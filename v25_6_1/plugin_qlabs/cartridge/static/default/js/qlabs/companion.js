var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _scopes, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client2, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i, _client3, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _j, _parseJSX, _parseExpression, _parseChainExpression, _parseMemberExpression, _parseName, _parseElement;
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var NodeType;
(function(NodeType2) {
  NodeType2[NodeType2["Document"] = 0] = "Document";
  NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
  NodeType2[NodeType2["Element"] = 2] = "Element";
  NodeType2[NodeType2["Text"] = 3] = "Text";
  NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
  NodeType2[NodeType2["Comment"] = 5] = "Comment";
})(NodeType || (NodeType = {}));
function isElement(n2) {
  return n2.nodeType === n2.ELEMENT_NODE;
}
function isShadowRoot(n2) {
  const host = n2 === null || n2 === void 0 ? void 0 : n2.host;
  return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n2);
}
function isNativeShadowDom(shadowRoot) {
  return Object.prototype.toString.call(shadowRoot) === "[object ShadowRoot]";
}
function fixBrowserCompatibilityIssuesInCSS(cssText) {
  if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
    cssText = cssText.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;");
  }
  return cssText;
}
function escapeImportStatement(rule) {
  const { cssText } = rule;
  if (cssText.split('"').length < 3)
    return cssText;
  const statement = ["@import", `url(${JSON.stringify(rule.href)})`];
  if (rule.layerName === "") {
    statement.push(`layer`);
  } else if (rule.layerName) {
    statement.push(`layer(${rule.layerName})`);
  }
  if (rule.supportsText) {
    statement.push(`supports(${rule.supportsText})`);
  }
  if (rule.media.length) {
    statement.push(rule.media.mediaText);
  }
  return statement.join(" ") + ";";
}
function stringifyStylesheet(s) {
  try {
    const rules = s.rules || s.cssRules;
    return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join("")) : null;
  } catch (error) {
    return null;
  }
}
function stringifyRule(rule) {
  let importStringified;
  if (isCSSImportRule(rule)) {
    try {
      importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);
    } catch (error) {
    }
  } else if (isCSSStyleRule(rule) && rule.selectorText.includes(":")) {
    return fixSafariColons(rule.cssText);
  }
  return importStringified || rule.cssText;
}
function fixSafariColons(cssStringified) {
  const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return cssStringified.replace(regex, "$1\\$2");
}
function isCSSImportRule(rule) {
  return "styleSheet" in rule;
}
function isCSSStyleRule(rule) {
  return "selectorText" in rule;
}
class Mirror {
  constructor() {
    this.idNodeMap = /* @__PURE__ */ new Map();
    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
  getId(n2) {
    var _a2;
    if (!n2)
      return -1;
    const id2 = (_a2 = this.getMeta(n2)) === null || _a2 === void 0 ? void 0 : _a2.id;
    return id2 !== null && id2 !== void 0 ? id2 : -1;
  }
  getNode(id2) {
    return this.idNodeMap.get(id2) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(n2) {
    return this.nodeMetaMap.get(n2) || null;
  }
  removeNodeFromMap(n2) {
    const id2 = this.getId(n2);
    this.idNodeMap.delete(id2);
    if (n2.childNodes) {
      n2.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));
    }
  }
  has(id2) {
    return this.idNodeMap.has(id2);
  }
  hasNode(node2) {
    return this.nodeMetaMap.has(node2);
  }
  add(n2, meta) {
    const id2 = meta.id;
    this.idNodeMap.set(id2, n2);
    this.nodeMetaMap.set(n2, meta);
  }
  replace(id2, n2) {
    const oldNode = this.getNode(id2);
    if (oldNode) {
      const meta = this.nodeMetaMap.get(oldNode);
      if (meta)
        this.nodeMetaMap.set(n2, meta);
    }
    this.idNodeMap.set(id2, n2);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map();
    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function createMirror() {
  return new Mirror();
}
function maskInputValue({ element: element2, maskInputOptions, tagName, type: type2, value, maskInputFn }) {
  let text2 = value || "";
  const actualType = type2 && toLowerCase(type2);
  if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {
    if (maskInputFn) {
      text2 = maskInputFn(text2, element2);
    } else {
      text2 = "*".repeat(text2.length);
    }
  }
  return text2;
}
function toLowerCase(str) {
  return str.toLowerCase();
}
const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
function is2DCanvasBlank(canvas) {
  const ctx = canvas.getContext("2d");
  if (!ctx)
    return true;
  const chunkSize = 50;
  for (let x2 = 0; x2 < canvas.width; x2 += chunkSize) {
    for (let y2 = 0; y2 < canvas.height; y2 += chunkSize) {
      const getImageData = ctx.getImageData;
      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
      const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x2, y2, Math.min(chunkSize, canvas.width - x2), Math.min(chunkSize, canvas.height - y2)).data.buffer);
      if (pixelBuffer.some((pixel) => pixel !== 0))
        return false;
    }
  }
  return true;
}
function getInputType(element2) {
  const type2 = element2.type;
  return element2.hasAttribute("data-rr-is-password") ? "password" : type2 ? toLowerCase(type2) : null;
}
function extractFileExtension(path2, baseURL) {
  var _a2;
  let url;
  try {
    url = new URL(path2, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);
  } catch (err) {
    return null;
  }
  const regex = /\.([0-9a-z]+)(?:$)/i;
  const match2 = url.pathname.match(regex);
  return (_a2 = match2 === null || match2 === void 0 ? void 0 : match2[1]) !== null && _a2 !== void 0 ? _a2 : null;
}
let _id = 1;
const tagNameRegex = new RegExp("[^a-z0-9-_:]");
const IGNORED_NODE = -2;
function genId() {
  return _id++;
}
function getValidTagName(element2) {
  if (element2 instanceof HTMLFormElement) {
    return "form";
  }
  const processedTagName = toLowerCase(element2.tagName);
  if (tagNameRegex.test(processedTagName)) {
    return "div";
  }
  return processedTagName;
}
function extractOrigin(url) {
  let origin = "";
  if (url.indexOf("//") > -1) {
    origin = url.split("/").slice(0, 3).join("/");
  } else {
    origin = url.split("/")[0];
  }
  origin = origin.split("?")[0];
  return origin;
}
let canvasService;
let canvasCtx;
const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
const URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
const URL_WWW_MATCH = /^www\..*/i;
const DATA_URI = /^(data:)([^,]*),(.*)/i;
function absoluteToStylesheet(cssText, href) {
  return (cssText || "").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {
    const filePath = path1 || path2 || path3;
    const maybeQuote = quote1 || quote2 || "";
    if (!filePath) {
      return origin;
    }
    if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
      return `url(${maybeQuote}${filePath}${maybeQuote})`;
    }
    if (DATA_URI.test(filePath)) {
      return `url(${maybeQuote}${filePath}${maybeQuote})`;
    }
    if (filePath[0] === "/") {
      return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
    }
    const stack = href.split("/");
    const parts = filePath.split("/");
    stack.pop();
    for (const part of parts) {
      if (part === ".") {
        continue;
      } else if (part === "..") {
        stack.pop();
      } else {
        stack.push(part);
      }
    }
    return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
  });
}
const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
const SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
function getAbsoluteSrcsetString(doc, attributeValue) {
  if (attributeValue.trim() === "") {
    return attributeValue;
  }
  let pos = 0;
  function collectCharacters(regEx) {
    let chars2;
    const match2 = regEx.exec(attributeValue.substring(pos));
    if (match2) {
      chars2 = match2[0];
      pos += chars2.length;
      return chars2;
    }
    return "";
  }
  const output = [];
  while (true) {
    collectCharacters(SRCSET_COMMAS_OR_SPACES);
    if (pos >= attributeValue.length) {
      break;
    }
    let url = collectCharacters(SRCSET_NOT_SPACES);
    if (url.slice(-1) === ",") {
      url = absoluteToDoc(doc, url.substring(0, url.length - 1));
      output.push(url);
    } else {
      let descriptorsStr = "";
      url = absoluteToDoc(doc, url);
      let inParens = false;
      while (true) {
        const c2 = attributeValue.charAt(pos);
        if (c2 === "") {
          output.push((url + descriptorsStr).trim());
          break;
        } else if (!inParens) {
          if (c2 === ",") {
            pos += 1;
            output.push((url + descriptorsStr).trim());
            break;
          } else if (c2 === "(") {
            inParens = true;
          }
        } else {
          if (c2 === ")") {
            inParens = false;
          }
        }
        descriptorsStr += c2;
        pos += 1;
      }
    }
  }
  return output.join(", ");
}
function absoluteToDoc(doc, attributeValue) {
  if (!attributeValue || attributeValue.trim() === "") {
    return attributeValue;
  }
  const a = doc.createElement("a");
  a.href = attributeValue;
  return a.href;
}
function isSVGElement$1(el2) {
  return Boolean(el2.tagName === "svg" || el2.ownerSVGElement);
}
function getHref() {
  const a = document.createElement("a");
  a.href = "";
  return a.href;
}
function transformAttribute(doc, tagName, name, value) {
  if (!value) {
    return value;
  }
  if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
    return absoluteToDoc(doc, value);
  } else if (name === "xlink:href" && value[0] !== "#") {
    return absoluteToDoc(doc, value);
  } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
    return absoluteToDoc(doc, value);
  } else if (name === "srcset") {
    return getAbsoluteSrcsetString(doc, value);
  } else if (name === "style") {
    return absoluteToStylesheet(value, getHref());
  } else if (tagName === "object" && name === "data") {
    return absoluteToDoc(doc, value);
  }
  return value;
}
function ignoreAttribute(tagName, name, _value) {
  return (tagName === "video" || tagName === "audio") && name === "autoplay";
}
function _isBlockedElement(element2, blockClass, blockSelector) {
  try {
    if (typeof blockClass === "string") {
      if (element2.classList.contains(blockClass)) {
        return true;
      }
    } else {
      for (let eIndex = element2.classList.length; eIndex--; ) {
        const className = element2.classList[eIndex];
        if (blockClass.test(className)) {
          return true;
        }
      }
    }
    if (blockSelector) {
      return element2.matches(blockSelector);
    }
  } catch (e2) {
  }
  return false;
}
function classMatchesRegex(node2, regex, checkAncestors) {
  if (!node2)
    return false;
  if (node2.nodeType !== node2.ELEMENT_NODE) {
    if (!checkAncestors)
      return false;
    return classMatchesRegex(node2.parentNode, regex, checkAncestors);
  }
  for (let eIndex = node2.classList.length; eIndex--; ) {
    const className = node2.classList[eIndex];
    if (regex.test(className)) {
      return true;
    }
  }
  if (!checkAncestors)
    return false;
  return classMatchesRegex(node2.parentNode, regex, checkAncestors);
}
function needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {
  try {
    const el2 = node2.nodeType === node2.ELEMENT_NODE ? node2 : node2.parentElement;
    if (el2 === null)
      return false;
    if (typeof maskTextClass === "string") {
      if (checkAncestors) {
        if (el2.closest(`.${maskTextClass}`))
          return true;
      } else {
        if (el2.classList.contains(maskTextClass))
          return true;
      }
    } else {
      if (classMatchesRegex(el2, maskTextClass, checkAncestors))
        return true;
    }
    if (maskTextSelector) {
      if (checkAncestors) {
        if (el2.closest(maskTextSelector))
          return true;
      } else {
        if (el2.matches(maskTextSelector))
          return true;
      }
    }
  } catch (e2) {
  }
  return false;
}
function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
  const win2 = iframeEl.contentWindow;
  if (!win2) {
    return;
  }
  let fired = false;
  let readyState;
  try {
    readyState = win2.document.readyState;
  } catch (error) {
    return;
  }
  if (readyState !== "complete") {
    const timer = setTimeout(() => {
      if (!fired) {
        listener();
        fired = true;
      }
    }, iframeLoadTimeout);
    iframeEl.addEventListener("load", () => {
      clearTimeout(timer);
      fired = true;
      listener();
    });
    return;
  }
  const blankUrl = "about:blank";
  if (win2.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
    setTimeout(listener, 0);
    return iframeEl.addEventListener("load", listener);
  }
  iframeEl.addEventListener("load", listener);
}
function onceStylesheetLoaded(link2, listener, styleSheetLoadTimeout) {
  let fired = false;
  let styleSheetLoaded;
  try {
    styleSheetLoaded = link2.sheet;
  } catch (error) {
    return;
  }
  if (styleSheetLoaded)
    return;
  const timer = setTimeout(() => {
    if (!fired) {
      listener();
      fired = true;
    }
  }, styleSheetLoadTimeout);
  link2.addEventListener("load", () => {
    clearTimeout(timer);
    fired = true;
    listener();
  });
}
function serializeNode(n2, options) {
  const { doc, mirror: mirror2, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;
  const rootId = getRootId(doc, mirror2);
  switch (n2.nodeType) {
    case n2.DOCUMENT_NODE:
      if (n2.compatMode !== "CSS1Compat") {
        return {
          type: NodeType.Document,
          childNodes: [],
          compatMode: n2.compatMode
        };
      } else {
        return {
          type: NodeType.Document,
          childNodes: []
        };
      }
    case n2.DOCUMENT_TYPE_NODE:
      return {
        type: NodeType.DocumentType,
        name: n2.name,
        publicId: n2.publicId,
        systemId: n2.systemId,
        rootId
      };
    case n2.ELEMENT_NODE:
      return serializeElementNode(n2, {
        doc,
        blockClass,
        blockSelector,
        inlineStylesheet,
        maskInputOptions,
        maskInputFn,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        keepIframeSrcFn,
        newlyAddedElement,
        rootId
      });
    case n2.TEXT_NODE:
      return serializeTextNode(n2, {
        needsMask,
        maskTextFn,
        rootId
      });
    case n2.CDATA_SECTION_NODE:
      return {
        type: NodeType.CDATA,
        textContent: "",
        rootId
      };
    case n2.COMMENT_NODE:
      return {
        type: NodeType.Comment,
        textContent: n2.textContent || "",
        rootId
      };
    default:
      return false;
  }
}
function getRootId(doc, mirror2) {
  if (!mirror2.hasNode(doc))
    return void 0;
  const docId = mirror2.getId(doc);
  return docId === 1 ? void 0 : docId;
}
function serializeTextNode(n2, options) {
  var _a2;
  const { needsMask, maskTextFn, rootId } = options;
  const parentTagName = n2.parentNode && n2.parentNode.tagName;
  let textContent = n2.textContent;
  const isStyle = parentTagName === "STYLE" ? true : void 0;
  const isScript = parentTagName === "SCRIPT" ? true : void 0;
  if (isStyle && textContent) {
    try {
      if (n2.nextSibling || n2.previousSibling) {
      } else if ((_a2 = n2.parentNode.sheet) === null || _a2 === void 0 ? void 0 : _a2.cssRules) {
        textContent = stringifyStylesheet(n2.parentNode.sheet);
      }
    } catch (err) {
      console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n2);
    }
    textContent = absoluteToStylesheet(textContent, getHref());
  }
  if (isScript) {
    textContent = "SCRIPT_PLACEHOLDER";
  }
  if (!isStyle && !isScript && textContent && needsMask) {
    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\S]/g, "*");
  }
  return {
    type: NodeType.Text,
    textContent: textContent || "",
    isStyle,
    rootId
  };
}
function serializeElementNode(n2, options) {
  const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId } = options;
  const needBlock = _isBlockedElement(n2, blockClass, blockSelector);
  const tagName = getValidTagName(n2);
  let attributes = {};
  const len = n2.attributes.length;
  for (let i2 = 0; i2 < len; i2++) {
    const attr = n2.attributes[i2];
    if (!ignoreAttribute(tagName, attr.name, attr.value)) {
      attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);
    }
  }
  if (tagName === "link" && inlineStylesheet) {
    const stylesheet = Array.from(doc.styleSheets).find((s) => {
      return s.href === n2.href;
    });
    let cssText = null;
    if (stylesheet) {
      cssText = stringifyStylesheet(stylesheet);
    }
    if (cssText) {
      delete attributes.rel;
      delete attributes.href;
      attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);
    }
  }
  if (tagName === "style" && n2.sheet && !(n2.innerText || n2.textContent || "").trim().length) {
    const cssText = stringifyStylesheet(n2.sheet);
    if (cssText) {
      attributes._cssText = absoluteToStylesheet(cssText, getHref());
    }
  }
  if (tagName === "input" || tagName === "textarea" || tagName === "select") {
    const value = n2.value;
    const checked = n2.checked;
    if (attributes.type !== "radio" && attributes.type !== "checkbox" && attributes.type !== "submit" && attributes.type !== "button" && value) {
      attributes.value = maskInputValue({
        element: n2,
        type: getInputType(n2),
        tagName,
        value,
        maskInputOptions,
        maskInputFn
      });
    } else if (checked) {
      attributes.checked = checked;
    }
  }
  if (tagName === "option") {
    if (n2.selected && !maskInputOptions["select"]) {
      attributes.selected = true;
    } else {
      delete attributes.selected;
    }
  }
  if (tagName === "canvas" && recordCanvas) {
    if (n2.__context === "2d") {
      if (!is2DCanvasBlank(n2)) {
        attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);
      }
    } else if (!("__context" in n2)) {
      const canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);
      const blankCanvas = document.createElement("canvas");
      blankCanvas.width = n2.width;
      blankCanvas.height = n2.height;
      const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);
      if (canvasDataURL !== blankCanvasDataURL) {
        attributes.rr_dataURL = canvasDataURL;
      }
    }
  }
  if (tagName === "img" && inlineImages) {
    if (!canvasService) {
      canvasService = doc.createElement("canvas");
      canvasCtx = canvasService.getContext("2d");
    }
    const image2 = n2;
    const oldValue = image2.crossOrigin;
    image2.crossOrigin = "anonymous";
    const recordInlineImage = () => {
      image2.removeEventListener("load", recordInlineImage);
      try {
        canvasService.width = image2.naturalWidth;
        canvasService.height = image2.naturalHeight;
        canvasCtx.drawImage(image2, 0, 0);
        attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);
      } catch (err) {
        console.warn(`Cannot inline img src=${image2.currentSrc}! Error: ${err}`);
      }
      oldValue ? attributes.crossOrigin = oldValue : image2.removeAttribute("crossorigin");
    };
    if (image2.complete && image2.naturalWidth !== 0)
      recordInlineImage();
    else
      image2.addEventListener("load", recordInlineImage);
  }
  if (tagName === "audio" || tagName === "video") {
    const mediaAttributes = attributes;
    mediaAttributes.rr_mediaState = n2.paused ? "paused" : "played";
    mediaAttributes.rr_mediaCurrentTime = n2.currentTime;
    mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;
    mediaAttributes.rr_mediaMuted = n2.muted;
    mediaAttributes.rr_mediaLoop = n2.loop;
    mediaAttributes.rr_mediaVolume = n2.volume;
  }
  if (!newlyAddedElement) {
    if (n2.scrollLeft) {
      attributes.rr_scrollLeft = n2.scrollLeft;
    }
    if (n2.scrollTop) {
      attributes.rr_scrollTop = n2.scrollTop;
    }
  }
  if (needBlock) {
    const { width, height } = n2.getBoundingClientRect();
    attributes = {
      class: attributes.class,
      rr_width: `${width}px`,
      rr_height: `${height}px`
    };
  }
  if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
    if (!n2.contentDocument) {
      attributes.rr_src = attributes.src;
    }
    delete attributes.src;
  }
  let isCustomElement;
  try {
    if (customElements.get(tagName))
      isCustomElement = true;
  } catch (e2) {
  }
  return {
    type: NodeType.Element,
    tagName,
    attributes,
    childNodes: [],
    isSVG: isSVGElement$1(n2) || void 0,
    needBlock,
    rootId,
    isCustom: isCustomElement
  };
}
function lowerIfExists(maybeAttr) {
  if (maybeAttr === void 0 || maybeAttr === null) {
    return "";
  } else {
    return maybeAttr.toLowerCase();
  }
}
function slimDOMExcluded(sn, slimDOMOptions) {
  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {
    return true;
  } else if (sn.type === NodeType.Element) {
    if (slimDOMOptions.script && (sn.tagName === "script" || sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {
      return true;
    } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
      return true;
    } else if (sn.tagName === "meta") {
      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
        return true;
      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
        return true;
      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
        return true;
      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
        return true;
      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
        return true;
      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
        return true;
      }
    }
  }
  return false;
}
function serializeNodeWithId(n2, options) {
  const { doc, mirror: mirror2, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5e3, onStylesheetLoad, stylesheetLoadTimeout = 5e3, keepIframeSrcFn = () => false, newlyAddedElement = false } = options;
  let { needsMask } = options;
  let { preserveWhiteSpace = true } = options;
  if (!needsMask && n2.childNodes) {
    const checkAncestors = needsMask === void 0;
    needsMask = needMaskingText(n2, maskTextClass, maskTextSelector, checkAncestors);
  }
  const _serializedNode = serializeNode(n2, {
    doc,
    mirror: mirror2,
    blockClass,
    blockSelector,
    needsMask,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    keepIframeSrcFn,
    newlyAddedElement
  });
  if (!_serializedNode) {
    console.warn(n2, "not serialized");
    return null;
  }
  let id2;
  if (mirror2.hasNode(n2)) {
    id2 = mirror2.getId(n2);
  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
    id2 = IGNORED_NODE;
  } else {
    id2 = genId();
  }
  const serializedNode = Object.assign(_serializedNode, { id: id2 });
  mirror2.add(n2, serializedNode);
  if (id2 === IGNORED_NODE) {
    return null;
  }
  if (onSerialize) {
    onSerialize(n2);
  }
  let recordChild = !skipChild;
  if (serializedNode.type === NodeType.Element) {
    recordChild = recordChild && !serializedNode.needBlock;
    delete serializedNode.needBlock;
    const shadowRoot = n2.shadowRoot;
    if (shadowRoot && isNativeShadowDom(shadowRoot))
      serializedNode.isShadowHost = true;
  }
  if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {
    if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType.Element && serializedNode.tagName === "head") {
      preserveWhiteSpace = false;
    }
    const bypassOptions = {
      doc,
      mirror: mirror2,
      blockClass,
      blockSelector,
      needsMask,
      maskTextClass,
      maskTextSelector,
      skipChild,
      inlineStylesheet,
      maskInputOptions,
      maskTextFn,
      maskInputFn,
      slimDOMOptions,
      dataURLOptions,
      inlineImages,
      recordCanvas,
      preserveWhiteSpace,
      onSerialize,
      onIframeLoad,
      iframeLoadTimeout,
      onStylesheetLoad,
      stylesheetLoadTimeout,
      keepIframeSrcFn
    };
    if (serializedNode.type === NodeType.Element && serializedNode.tagName === "textarea" && serializedNode.attributes.value !== void 0) ;
    else {
      for (const childN of Array.from(n2.childNodes)) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
    if (isElement(n2) && n2.shadowRoot) {
      for (const childN of Array.from(n2.shadowRoot.childNodes)) {
        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
        if (serializedChildNode) {
          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);
          serializedNode.childNodes.push(serializedChildNode);
        }
      }
    }
  }
  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {
    serializedNode.isShadow = true;
  }
  if (serializedNode.type === NodeType.Element && serializedNode.tagName === "iframe") {
    onceIframeLoaded(n2, () => {
      const iframeDoc = n2.contentDocument;
      if (iframeDoc && onIframeLoad) {
        const serializedIframeNode = serializeNodeWithId(iframeDoc, {
          doc: iframeDoc,
          mirror: mirror2,
          blockClass,
          blockSelector,
          needsMask,
          maskTextClass,
          maskTextSelector,
          skipChild: false,
          inlineStylesheet,
          maskInputOptions,
          maskTextFn,
          maskInputFn,
          slimDOMOptions,
          dataURLOptions,
          inlineImages,
          recordCanvas,
          preserveWhiteSpace,
          onSerialize,
          onIframeLoad,
          iframeLoadTimeout,
          onStylesheetLoad,
          stylesheetLoadTimeout,
          keepIframeSrcFn
        });
        if (serializedIframeNode) {
          onIframeLoad(n2, serializedIframeNode);
        }
      }
    }, iframeLoadTimeout);
  }
  if (serializedNode.type === NodeType.Element && serializedNode.tagName === "link" && typeof serializedNode.attributes.rel === "string" && (serializedNode.attributes.rel === "stylesheet" || serializedNode.attributes.rel === "preload" && typeof serializedNode.attributes.href === "string" && extractFileExtension(serializedNode.attributes.href) === "css")) {
    onceStylesheetLoaded(n2, () => {
      if (onStylesheetLoad) {
        const serializedLinkNode = serializeNodeWithId(n2, {
          doc,
          mirror: mirror2,
          blockClass,
          blockSelector,
          needsMask,
          maskTextClass,
          maskTextSelector,
          skipChild: false,
          inlineStylesheet,
          maskInputOptions,
          maskTextFn,
          maskInputFn,
          slimDOMOptions,
          dataURLOptions,
          inlineImages,
          recordCanvas,
          preserveWhiteSpace,
          onSerialize,
          onIframeLoad,
          iframeLoadTimeout,
          onStylesheetLoad,
          stylesheetLoadTimeout,
          keepIframeSrcFn
        });
        if (serializedLinkNode) {
          onStylesheetLoad(n2, serializedLinkNode);
        }
      }
    }, stylesheetLoadTimeout);
  }
  return serializedNode;
}
function snapshot(n2, options) {
  const { mirror: mirror2 = new Mirror(), blockClass = "rr-block", blockSelector = null, maskTextClass = "rr-mask", maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false } = options || {};
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : maskAllInputs === false ? {
    password: true
  } : maskAllInputs;
  const slimDOMOptions = slimDOM === true || slimDOM === "all" ? {
    script: true,
    comment: true,
    headFavicon: true,
    headWhitespace: true,
    headMetaDescKeywords: slimDOM === "all",
    headMetaSocial: true,
    headMetaRobots: true,
    headMetaHttpEquiv: true,
    headMetaAuthorship: true,
    headMetaVerification: true
  } : slimDOM === false ? {} : slimDOM;
  return serializeNodeWithId(n2, {
    doc: n2,
    mirror: mirror2,
    blockClass,
    blockSelector,
    maskTextClass,
    maskTextSelector,
    skipChild: false,
    inlineStylesheet,
    maskInputOptions,
    maskTextFn,
    maskInputFn,
    slimDOMOptions,
    dataURLOptions,
    inlineImages,
    recordCanvas,
    preserveWhiteSpace,
    onSerialize,
    onIframeLoad,
    iframeLoadTimeout,
    onStylesheetLoad,
    stylesheetLoadTimeout,
    keepIframeSrcFn,
    newlyAddedElement: false
  });
}
function on(type2, fn, target = document) {
  const options = { capture: true, passive: true };
  target.addEventListener(type2, fn, options);
  return () => target.removeEventListener(type2, fn, options);
}
const DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
let _mirror = {
  map: {},
  getId() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return -1;
  },
  getNode() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return null;
  },
  removeNodeFromMap() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  },
  has() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
    return false;
  },
  reset() {
    console.error(DEPARTED_MIRROR_ACCESS_WARNING);
  }
};
if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
  _mirror = new Proxy(_mirror, {
    get(target, prop, receiver) {
      if (prop === "map") {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
function throttle(func, wait2, options = {}) {
  let timeout = null;
  let previous2 = 0;
  return function(...args) {
    const now2 = Date.now();
    if (!previous2 && options.leading === false) {
      previous2 = now2;
    }
    const remaining = wait2 - (now2 - previous2);
    const context = this;
    if (remaining <= 0 || remaining > wait2) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous2 = now2;
      func.apply(context, args);
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous2 = options.leading === false ? 0 : Date.now();
        timeout = null;
        func.apply(context, args);
      }, remaining);
    }
  };
}
function hookSetter(target, key, d2, isRevoked, win2 = window) {
  const original = win2.Object.getOwnPropertyDescriptor(target, key);
  win2.Object.defineProperty(target, key, isRevoked ? d2 : {
    set(value) {
      setTimeout(() => {
        d2.set.call(this, value);
      }, 0);
      if (original && original.set) {
        original.set.call(this, value);
      }
    }
  });
  return () => hookSetter(target, key, original || {}, true);
}
function patch$1(source, name, replacement) {
  try {
    if (!(name in source)) {
      return () => {
      };
    }
    const original = source[name];
    const wrapped = replacement(original);
    if (typeof wrapped === "function") {
      wrapped.prototype = wrapped.prototype || {};
      Object.defineProperties(wrapped, {
        __rrweb_original__: {
          enumerable: false,
          value: original
        }
      });
    }
    source[name] = wrapped;
    return () => {
      source[name] = original;
    };
  } catch (_a2) {
    return () => {
    };
  }
}
let nowTimestamp = Date.now;
if (!/[1-9][0-9]{12}/.test(Date.now().toString())) {
  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();
}
function getWindowScroll(win2) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const doc = win2.document;
  return {
    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win2.pageXOffset !== void 0 ? win2.pageXOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) || ((_b2 = (_a2 = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a2 === void 0 ? void 0 : _a2.parentElement) === null || _b2 === void 0 ? void 0 : _b2.scrollLeft) || ((_c2 = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c2 === void 0 ? void 0 : _c2.scrollLeft) || 0,
    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win2.pageYOffset !== void 0 ? win2.pageYOffset : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) || ((_e2 = (_d2 = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d2 === void 0 ? void 0 : _d2.parentElement) === null || _e2 === void 0 ? void 0 : _e2.scrollTop) || ((_f2 = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f2 === void 0 ? void 0 : _f2.scrollTop) || 0
  };
}
function getWindowHeight() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function getWindowWidth() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function closestElementOfNode(node2) {
  if (!node2) {
    return null;
  }
  const el2 = node2.nodeType === node2.ELEMENT_NODE ? node2 : node2.parentElement;
  return el2;
}
function isBlocked(node2, blockClass, blockSelector, checkAncestors) {
  if (!node2) {
    return false;
  }
  const el2 = closestElementOfNode(node2);
  if (!el2) {
    return false;
  }
  try {
    if (typeof blockClass === "string") {
      if (el2.classList.contains(blockClass))
        return true;
      if (checkAncestors && el2.closest("." + blockClass) !== null)
        return true;
    } else {
      if (classMatchesRegex(el2, blockClass, checkAncestors))
        return true;
    }
  } catch (e2) {
  }
  if (blockSelector) {
    if (el2.matches(blockSelector))
      return true;
    if (checkAncestors && el2.closest(blockSelector) !== null)
      return true;
  }
  return false;
}
function isSerialized(n2, mirror2) {
  return mirror2.getId(n2) !== -1;
}
function isIgnored(n2, mirror2) {
  return mirror2.getId(n2) === IGNORED_NODE;
}
function isAncestorRemoved(target, mirror2) {
  if (isShadowRoot(target)) {
    return false;
  }
  const id2 = mirror2.getId(target);
  if (!mirror2.has(id2)) {
    return true;
  }
  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {
    return false;
  }
  if (!target.parentNode) {
    return true;
  }
  return isAncestorRemoved(target.parentNode, mirror2);
}
function legacy_isTouchEvent(event) {
  return Boolean(event.changedTouches);
}
function polyfill(win2 = window) {
  if ("NodeList" in win2 && !win2.NodeList.prototype.forEach) {
    win2.NodeList.prototype.forEach = Array.prototype.forEach;
  }
  if ("DOMTokenList" in win2 && !win2.DOMTokenList.prototype.forEach) {
    win2.DOMTokenList.prototype.forEach = Array.prototype.forEach;
  }
  if (!Node.prototype.contains) {
    Node.prototype.contains = (...args) => {
      let node2 = args[0];
      if (!(0 in args)) {
        throw new TypeError("1 argument is required");
      }
      do {
        if (this === node2) {
          return true;
        }
      } while (node2 = node2 && node2.parentNode);
      return false;
    };
  }
}
function isSerializedIframe(n2, mirror2) {
  return Boolean(n2.nodeName === "IFRAME" && mirror2.getMeta(n2));
}
function isSerializedStylesheet(n2, mirror2) {
  return Boolean(n2.nodeName === "LINK" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute("rel") === "stylesheet" && mirror2.getMeta(n2));
}
function hasShadowRoot(n2) {
  return Boolean(n2 === null || n2 === void 0 ? void 0 : n2.shadowRoot);
}
class StyleSheetMirror {
  constructor() {
    this.id = 1;
    this.styleIDMap = /* @__PURE__ */ new WeakMap();
    this.idStyleMap = /* @__PURE__ */ new Map();
  }
  getId(stylesheet) {
    var _a2;
    return (_a2 = this.styleIDMap.get(stylesheet)) !== null && _a2 !== void 0 ? _a2 : -1;
  }
  has(stylesheet) {
    return this.styleIDMap.has(stylesheet);
  }
  add(stylesheet, id2) {
    if (this.has(stylesheet))
      return this.getId(stylesheet);
    let newId;
    if (id2 === void 0) {
      newId = this.id++;
    } else
      newId = id2;
    this.styleIDMap.set(stylesheet, newId);
    this.idStyleMap.set(newId, stylesheet);
    return newId;
  }
  getStyle(id2) {
    return this.idStyleMap.get(id2) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap();
    this.idStyleMap = /* @__PURE__ */ new Map();
    this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function getShadowHost(n2) {
  var _a2, _b2;
  let shadowHost = null;
  if (((_b2 = (_a2 = n2.getRootNode) === null || _a2 === void 0 ? void 0 : _a2.call(n2)) === null || _b2 === void 0 ? void 0 : _b2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)
    shadowHost = n2.getRootNode().host;
  return shadowHost;
}
function getRootShadowHost(n2) {
  let rootShadowHost = n2;
  let shadowHost;
  while (shadowHost = getShadowHost(rootShadowHost))
    rootShadowHost = shadowHost;
  return rootShadowHost;
}
function shadowHostInDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc)
    return false;
  const shadowHost = getRootShadowHost(n2);
  return doc.contains(shadowHost);
}
function inDom(n2) {
  const doc = n2.ownerDocument;
  if (!doc)
    return false;
  return doc.contains(n2) || shadowHostInDom(n2);
}
var EventType$1 = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType$1 || {});
var IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource$1 || {});
var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
  MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
  MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
  MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
  MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
  MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
  MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
  MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
  MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
  MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
  MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
  MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
  return MouseInteractions2;
})(MouseInteractions || {});
var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
  PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
  PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
  PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
  return PointerTypes2;
})(PointerTypes || {});
var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
  CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
  CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
  CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
  return CanvasContext2;
})(CanvasContext || {});
function isNodeInLinkedList(n2) {
  return "__ln" in n2;
}
class DoubleLinkedList {
  constructor() {
    this.length = 0;
    this.head = null;
    this.tail = null;
  }
  get(position2) {
    if (position2 >= this.length) {
      throw new Error("Position outside of list range");
    }
    let current2 = this.head;
    for (let index2 = 0; index2 < position2; index2++) {
      current2 = (current2 === null || current2 === void 0 ? void 0 : current2.next) || null;
    }
    return current2;
  }
  addNode(n2) {
    const node2 = {
      value: n2,
      previous: null,
      next: null
    };
    n2.__ln = node2;
    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {
      const current2 = n2.previousSibling.__ln.next;
      node2.next = current2;
      node2.previous = n2.previousSibling.__ln;
      n2.previousSibling.__ln.next = node2;
      if (current2) {
        current2.previous = node2;
      }
    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {
      const current2 = n2.nextSibling.__ln.previous;
      node2.previous = current2;
      node2.next = n2.nextSibling.__ln;
      n2.nextSibling.__ln.previous = node2;
      if (current2) {
        current2.next = node2;
      }
    } else {
      if (this.head) {
        this.head.previous = node2;
      }
      node2.next = this.head;
      this.head = node2;
    }
    if (node2.next === null) {
      this.tail = node2;
    }
    this.length++;
  }
  removeNode(n2) {
    const current2 = n2.__ln;
    if (!this.head) {
      return;
    }
    if (!current2.previous) {
      this.head = current2.next;
      if (this.head) {
        this.head.previous = null;
      } else {
        this.tail = null;
      }
    } else {
      current2.previous.next = current2.next;
      if (current2.next) {
        current2.next.previous = current2.previous;
      } else {
        this.tail = current2.previous;
      }
    }
    if (n2.__ln) {
      delete n2.__ln;
    }
    this.length--;
  }
}
const moveKey = (id2, parentId) => `${id2}@${parentId}`;
class MutationBuffer {
  constructor() {
    this.frozen = false;
    this.locked = false;
    this.texts = [];
    this.attributes = [];
    this.attributeMap = /* @__PURE__ */ new WeakMap();
    this.removes = [];
    this.mapRemoves = [];
    this.movedMap = {};
    this.addedSet = /* @__PURE__ */ new Set();
    this.movedSet = /* @__PURE__ */ new Set();
    this.droppedSet = /* @__PURE__ */ new Set();
    this.processMutations = (mutations) => {
      mutations.forEach(this.processMutation);
      this.emit();
    };
    this.emit = () => {
      if (this.frozen || this.locked) {
        return;
      }
      const adds = [];
      const addedIds = /* @__PURE__ */ new Set();
      const addList = new DoubleLinkedList();
      const getNextId = (n2) => {
        let ns = n2;
        let nextId = IGNORED_NODE;
        while (nextId === IGNORED_NODE) {
          ns = ns && ns.nextSibling;
          nextId = ns && this.mirror.getId(ns);
        }
        return nextId;
      };
      const pushAdd = (n2) => {
        if (!n2.parentNode || !inDom(n2) || n2.parentNode.tagName === "TEXTAREA") {
          return;
        }
        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);
        const nextId = getNextId(n2);
        if (parentId === -1 || nextId === -1) {
          return addList.addNode(n2);
        }
        const sn = serializeNodeWithId(n2, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskTextClass: this.maskTextClass,
          maskTextSelector: this.maskTextSelector,
          skipChild: true,
          newlyAddedElement: true,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (currentN) => {
            if (isSerializedIframe(currentN, this.mirror)) {
              this.iframeManager.addIframe(currentN);
            }
            if (isSerializedStylesheet(currentN, this.mirror)) {
              this.stylesheetManager.trackLinkElement(currentN);
            }
            if (hasShadowRoot(n2)) {
              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);
            }
          },
          onIframeLoad: (iframe, childSn) => {
            this.iframeManager.attachIframe(iframe, childSn);
            this.shadowDomManager.observeAttachShadow(iframe);
          },
          onStylesheetLoad: (link2, childSn) => {
            this.stylesheetManager.attachLinkElement(link2, childSn);
          }
        });
        if (sn) {
          adds.push({
            parentId,
            nextId,
            node: sn
          });
          addedIds.add(sn.id);
        }
      };
      while (this.mapRemoves.length) {
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      }
      for (const n2 of this.movedSet) {
        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {
          continue;
        }
        pushAdd(n2);
      }
      for (const n2 of this.addedSet) {
        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {
          pushAdd(n2);
        } else if (isAncestorInSet(this.movedSet, n2)) {
          pushAdd(n2);
        } else {
          this.droppedSet.add(n2);
        }
      }
      let candidate = null;
      while (addList.length) {
        let node2 = null;
        if (candidate) {
          const parentId = this.mirror.getId(candidate.value.parentNode);
          const nextId = getNextId(candidate.value);
          if (parentId !== -1 && nextId !== -1) {
            node2 = candidate;
          }
        }
        if (!node2) {
          let tailNode = addList.tail;
          while (tailNode) {
            const _node = tailNode;
            tailNode = tailNode.previous;
            if (_node) {
              const parentId = this.mirror.getId(_node.value.parentNode);
              const nextId = getNextId(_node.value);
              if (nextId === -1)
                continue;
              else if (parentId !== -1) {
                node2 = _node;
                break;
              } else {
                const unhandledNode = _node.value;
                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const shadowHost = unhandledNode.parentNode.host;
                  const parentId2 = this.mirror.getId(shadowHost);
                  if (parentId2 !== -1) {
                    node2 = _node;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!node2) {
          while (addList.head) {
            addList.removeNode(addList.head.value);
          }
          break;
        }
        candidate = node2.previous;
        addList.removeNode(node2.value);
        pushAdd(node2.value);
      }
      const payload = {
        texts: this.texts.map((text2) => {
          const n2 = text2.node;
          if (n2.parentNode && n2.parentNode.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(n2.parentNode);
          }
          return {
            id: this.mirror.getId(n2),
            value: text2.value
          };
        }).filter((text2) => !addedIds.has(text2.id)).filter((text2) => this.mirror.has(text2.id)),
        attributes: this.attributes.map((attribute) => {
          const { attributes } = attribute;
          if (typeof attributes.style === "string") {
            const diffAsStr = JSON.stringify(attribute.styleDiff);
            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
            if (diffAsStr.length < attributes.style.length) {
              if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                attributes.style = attribute.styleDiff;
              }
            }
          }
          return {
            id: this.mirror.getId(attribute.node),
            attributes
          };
        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
        removes: this.removes,
        adds
      };
      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
        return;
      }
      this.texts = [];
      this.attributes = [];
      this.attributeMap = /* @__PURE__ */ new WeakMap();
      this.removes = [];
      this.addedSet = /* @__PURE__ */ new Set();
      this.movedSet = /* @__PURE__ */ new Set();
      this.droppedSet = /* @__PURE__ */ new Set();
      this.movedMap = {};
      this.mutationCb(payload);
    };
    this.genTextAreaValueMutation = (textarea) => {
      let item = this.attributeMap.get(textarea);
      if (!item) {
        item = {
          node: textarea,
          attributes: {},
          styleDiff: {},
          _unchangedStyles: {}
        };
        this.attributes.push(item);
        this.attributeMap.set(textarea, item);
      }
      item.attributes.value = Array.from(textarea.childNodes, (cn) => cn.textContent || "").join("");
    };
    this.processMutation = (m2) => {
      if (isIgnored(m2.target, this.mirror)) {
        return;
      }
      switch (m2.type) {
        case "characterData": {
          const value = m2.target.textContent;
          if (!isBlocked(m2.target, this.blockClass, this.blockSelector, false) && value !== m2.oldValue) {
            this.texts.push({
              value: needMaskingText(m2.target, this.maskTextClass, this.maskTextSelector, true) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m2.target)) : value.replace(/[\S]/g, "*") : value,
              node: m2.target
            });
          }
          break;
        }
        case "attributes": {
          const target = m2.target;
          let attributeName = m2.attributeName;
          let value = m2.target.getAttribute(attributeName);
          if (attributeName === "value") {
            const type2 = getInputType(target);
            value = maskInputValue({
              element: target,
              maskInputOptions: this.maskInputOptions,
              tagName: target.tagName,
              type: type2,
              value,
              maskInputFn: this.maskInputFn
            });
          }
          if (isBlocked(m2.target, this.blockClass, this.blockSelector, false) || value === m2.oldValue) {
            return;
          }
          let item = this.attributeMap.get(m2.target);
          if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
            if (!target.contentDocument) {
              attributeName = "rr_src";
            } else {
              return;
            }
          }
          if (!item) {
            item = {
              node: m2.target,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(item);
            this.attributeMap.set(m2.target, item);
          }
          if (attributeName === "type" && target.tagName === "INPUT" && (m2.oldValue || "").toLowerCase() === "password") {
            target.setAttribute("data-rr-is-password", "true");
          }
          if (!ignoreAttribute(target.tagName, attributeName)) {
            item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);
            if (attributeName === "style") {
              if (!this.unattachedDoc) {
                try {
                  this.unattachedDoc = document.implementation.createHTMLDocument();
                } catch (e2) {
                  this.unattachedDoc = this.doc;
                }
              }
              const old = this.unattachedDoc.createElement("span");
              if (m2.oldValue) {
                old.setAttribute("style", m2.oldValue);
              }
              for (const pname of Array.from(target.style)) {
                const newValue = target.style.getPropertyValue(pname);
                const newPriority = target.style.getPropertyPriority(pname);
                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                  if (newPriority === "") {
                    item.styleDiff[pname] = newValue;
                  } else {
                    item.styleDiff[pname] = [newValue, newPriority];
                  }
                } else {
                  item._unchangedStyles[pname] = [newValue, newPriority];
                }
              }
              for (const pname of Array.from(old.style)) {
                if (target.style.getPropertyValue(pname) === "") {
                  item.styleDiff[pname] = false;
                }
              }
            }
          }
          break;
        }
        case "childList": {
          if (isBlocked(m2.target, this.blockClass, this.blockSelector, true))
            return;
          if (m2.target.tagName === "TEXTAREA") {
            this.genTextAreaValueMutation(m2.target);
            return;
          }
          m2.addedNodes.forEach((n2) => this.genAdds(n2, m2.target));
          m2.removedNodes.forEach((n2) => {
            const nodeId = this.mirror.getId(n2);
            const parentId = isShadowRoot(m2.target) ? this.mirror.getId(m2.target.host) : this.mirror.getId(m2.target);
            if (isBlocked(m2.target, this.blockClass, this.blockSelector, false) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {
              return;
            }
            if (this.addedSet.has(n2)) {
              deepDelete(this.addedSet, n2);
              this.droppedSet.add(n2);
            } else if (this.addedSet.has(m2.target) && nodeId === -1) ;
            else if (isAncestorRemoved(m2.target, this.mirror)) ;
            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {
              deepDelete(this.movedSet, n2);
            } else {
              this.removes.push({
                parentId,
                id: nodeId,
                isShadow: isShadowRoot(m2.target) && isNativeShadowDom(m2.target) ? true : void 0
              });
            }
            this.mapRemoves.push(n2);
          });
          break;
        }
      }
    };
    this.genAdds = (n2, target) => {
      if (this.processedNodeManager.inOtherBuffer(n2, this))
        return;
      if (this.addedSet.has(n2) || this.movedSet.has(n2))
        return;
      if (this.mirror.hasNode(n2)) {
        if (isIgnored(n2, this.mirror)) {
          return;
        }
        this.movedSet.add(n2);
        let targetId = null;
        if (target && this.mirror.hasNode(target)) {
          targetId = this.mirror.getId(target);
        }
        if (targetId && targetId !== -1) {
          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;
        }
      } else {
        this.addedSet.add(n2);
        this.droppedSet.delete(n2);
      }
      if (!isBlocked(n2, this.blockClass, this.blockSelector, false)) {
        n2.childNodes.forEach((childN) => this.genAdds(childN));
        if (hasShadowRoot(n2)) {
          n2.shadowRoot.childNodes.forEach((childN) => {
            this.processedNodeManager.add(childN, this);
            this.genAdds(childN, n2);
          });
        }
      }
    };
  }
  init(options) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "maskTextClass",
      "maskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((key) => {
      this[key] = options[key];
    });
  }
  freeze() {
    this.frozen = true;
    this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = false;
    this.canvasManager.unfreeze();
    this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = true;
    this.canvasManager.lock();
  }
  unlock() {
    this.locked = false;
    this.canvasManager.unlock();
    this.emit();
  }
  reset() {
    this.shadowDomManager.reset();
    this.canvasManager.reset();
  }
}
function deepDelete(addsSet, n2) {
  addsSet.delete(n2);
  n2.childNodes.forEach((childN) => deepDelete(addsSet, childN));
}
function isParentRemoved(removes, n2, mirror2) {
  if (removes.length === 0)
    return false;
  return _isParentRemoved(removes, n2, mirror2);
}
function _isParentRemoved(removes, n2, mirror2) {
  const { parentNode } = n2;
  if (!parentNode) {
    return false;
  }
  const parentId = mirror2.getId(parentNode);
  if (removes.some((r2) => r2.id === parentId)) {
    return true;
  }
  return _isParentRemoved(removes, parentNode, mirror2);
}
function isAncestorInSet(set, n2) {
  if (set.size === 0)
    return false;
  return _isAncestorInSet(set, n2);
}
function _isAncestorInSet(set, n2) {
  const { parentNode } = n2;
  if (!parentNode) {
    return false;
  }
  if (set.has(parentNode)) {
    return true;
  }
  return _isAncestorInSet(set, parentNode);
}
let errorHandler;
function registerErrorHandler(handler) {
  errorHandler = handler;
}
function unregisterErrorHandler() {
  errorHandler = void 0;
}
const callbackWrapper = (cb2) => {
  if (!errorHandler) {
    return cb2;
  }
  const rrwebWrapped = (...rest) => {
    try {
      return cb2(...rest);
    } catch (error) {
      if (errorHandler && errorHandler(error) === true) {
        return;
      }
      throw error;
    }
  };
  return rrwebWrapped;
};
const mutationBuffers = [];
function getEventTarget(event) {
  try {
    if ("composedPath" in event) {
      const path2 = event.composedPath();
      if (path2.length) {
        return path2[0];
      }
    } else if ("path" in event && event.path.length) {
      return event.path[0];
    }
  } catch (_a2) {
  }
  return event && event.target;
}
function initMutationObserver(options, rootEl) {
  var _a2, _b2;
  const mutationBuffer = new MutationBuffer();
  mutationBuffers.push(mutationBuffer);
  mutationBuffer.init(options);
  let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;
  const angularZoneSymbol = (_b2 = (_a2 = window === null || window === void 0 ? void 0 : window.Zone) === null || _a2 === void 0 ? void 0 : _a2.__symbol__) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, "MutationObserver");
  if (angularZoneSymbol && window[angularZoneSymbol]) {
    mutationObserverCtor = window[angularZoneSymbol];
  }
  const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));
  observer.observe(rootEl, {
    attributes: true,
    attributeOldValue: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  });
  return observer;
}
function initMoveObserver({ mousemoveCb, sampling, doc, mirror: mirror2 }) {
  if (sampling.mousemove === false) {
    return () => {
    };
  }
  const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
  const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
  let positions = [];
  let timeBaseline;
  const wrappedCb = throttle(callbackWrapper((source) => {
    const totalOffset = Date.now() - timeBaseline;
    mousemoveCb(positions.map((p2) => {
      p2.timeOffset -= totalOffset;
      return p2;
    }), source);
    positions = [];
    timeBaseline = null;
  }), callbackThreshold);
  const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {
    const target = getEventTarget(evt);
    const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
    if (!timeBaseline) {
      timeBaseline = nowTimestamp();
    }
    positions.push({
      x: clientX,
      y: clientY,
      id: mirror2.getId(target),
      timeOffset: nowTimestamp() - timeBaseline
    });
    wrappedCb(typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource$1.Drag : evt instanceof MouseEvent ? IncrementalSource$1.MouseMove : IncrementalSource$1.TouchMove);
  }), threshold, {
    trailing: false
  }));
  const handlers2 = [
    on("mousemove", updatePosition, doc),
    on("touchmove", updatePosition, doc),
    on("drag", updatePosition, doc)
  ];
  return callbackWrapper(() => {
    handlers2.forEach((h2) => h2());
  });
}
function initMouseInteractionObserver({ mouseInteractionCb, doc, mirror: mirror2, blockClass, blockSelector, sampling }) {
  if (sampling.mouseInteraction === false) {
    return () => {
    };
  }
  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
  const handlers2 = [];
  let currentPointerType = null;
  const getHandler = (eventKey) => {
    return (event) => {
      const target = getEventTarget(event);
      if (isBlocked(target, blockClass, blockSelector, true)) {
        return;
      }
      let pointerType = null;
      let thisEventKey = eventKey;
      if ("pointerType" in event) {
        switch (event.pointerType) {
          case "mouse":
            pointerType = PointerTypes.Mouse;
            break;
          case "touch":
            pointerType = PointerTypes.Touch;
            break;
          case "pen":
            pointerType = PointerTypes.Pen;
            break;
        }
        if (pointerType === PointerTypes.Touch) {
          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
            thisEventKey = "TouchStart";
          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
            thisEventKey = "TouchEnd";
          }
        } else if (pointerType === PointerTypes.Pen) ;
      } else if (legacy_isTouchEvent(event)) {
        pointerType = PointerTypes.Touch;
      }
      if (pointerType !== null) {
        currentPointerType = pointerType;
        if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
          pointerType = null;
        }
      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
        pointerType = currentPointerType;
        currentPointerType = null;
      }
      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
      if (!e2) {
        return;
      }
      const id2 = mirror2.getId(target);
      const { clientX, clientY } = e2;
      callbackWrapper(mouseInteractionCb)(Object.assign({ type: MouseInteractions[thisEventKey], id: id2, x: clientX, y: clientY }, pointerType !== null && { pointerType }));
    };
  };
  Object.keys(MouseInteractions).filter((key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false).forEach((eventKey) => {
    let eventName = toLowerCase(eventKey);
    const handler = getHandler(eventKey);
    if (window.PointerEvent) {
      switch (MouseInteractions[eventKey]) {
        case MouseInteractions.MouseDown:
        case MouseInteractions.MouseUp:
          eventName = eventName.replace("mouse", "pointer");
          break;
        case MouseInteractions.TouchStart:
        case MouseInteractions.TouchEnd:
          return;
      }
    }
    handlers2.push(on(eventName, handler, doc));
  });
  return callbackWrapper(() => {
    handlers2.forEach((h2) => h2());
  });
}
function initScrollObserver({ scrollCb, doc, mirror: mirror2, blockClass, blockSelector, sampling }) {
  const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {
    const target = getEventTarget(evt);
    if (!target || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    const id2 = mirror2.getId(target);
    if (target === doc && doc.defaultView) {
      const scrollLeftTop = getWindowScroll(doc.defaultView);
      scrollCb({
        id: id2,
        x: scrollLeftTop.left,
        y: scrollLeftTop.top
      });
    } else {
      scrollCb({
        id: id2,
        x: target.scrollLeft,
        y: target.scrollTop
      });
    }
  }), sampling.scroll || 100));
  return on("scroll", updatePosition, doc);
}
function initViewportResizeObserver({ viewportResizeCb }, { win: win2 }) {
  let lastH = -1;
  let lastW = -1;
  const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {
    const height = getWindowHeight();
    const width = getWindowWidth();
    if (lastH !== height || lastW !== width) {
      viewportResizeCb({
        width: Number(width),
        height: Number(height)
      });
      lastH = height;
      lastW = width;
    }
  }), 200));
  return on("resize", updateDimension, win2);
}
const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
const lastInputValueMap = /* @__PURE__ */ new WeakMap();
function initInputObserver({ inputCb, doc, mirror: mirror2, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput }) {
  function eventHandler(event) {
    let target = getEventTarget(event);
    const userTriggered = event.isTrusted;
    const tagName = target && target.tagName;
    if (target && tagName === "OPTION") {
      target = target.parentElement;
    }
    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {
      return;
    }
    let text2 = target.value;
    let isChecked = false;
    const type2 = getInputType(target) || "";
    if (type2 === "radio" || type2 === "checkbox") {
      isChecked = target.checked;
    } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type2]) {
      text2 = maskInputValue({
        element: target,
        maskInputOptions,
        tagName,
        type: type2,
        value: text2,
        maskInputFn
      });
    }
    cbWithDedup(target, userTriggeredOnInput ? { text: text2, isChecked, userTriggered } : { text: text2, isChecked });
    const name = target.name;
    if (type2 === "radio" && name && isChecked) {
      doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el2) => {
        if (el2 !== target) {
          const text3 = el2.value;
          cbWithDedup(el2, userTriggeredOnInput ? { text: text3, isChecked: !isChecked, userTriggered: false } : { text: text3, isChecked: !isChecked });
        }
      });
    }
  }
  function cbWithDedup(target, v2) {
    const lastInputValue = lastInputValueMap.get(target);
    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {
      lastInputValueMap.set(target, v2);
      const id2 = mirror2.getId(target);
      callbackWrapper(inputCb)(Object.assign(Object.assign({}, v2), { id: id2 }));
    }
  }
  const events = sampling.input === "last" ? ["change"] : ["input", "change"];
  const handlers2 = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));
  const currentWindow = doc.defaultView;
  if (!currentWindow) {
    return () => {
      handlers2.forEach((h2) => h2());
    };
  }
  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, "value");
  const hookProperties = [
    [currentWindow.HTMLInputElement.prototype, "value"],
    [currentWindow.HTMLInputElement.prototype, "checked"],
    [currentWindow.HTMLSelectElement.prototype, "value"],
    [currentWindow.HTMLTextAreaElement.prototype, "value"],
    [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
    [currentWindow.HTMLOptionElement.prototype, "selected"]
  ];
  if (propertyDescriptor && propertyDescriptor.set) {
    handlers2.push(...hookProperties.map((p2) => hookSetter(p2[0], p2[1], {
      set() {
        callbackWrapper(eventHandler)({
          target: this,
          isTrusted: false
        });
      }
    }, false, currentWindow)));
  }
  return callbackWrapper(() => {
    handlers2.forEach((h2) => h2());
  });
}
function getNestedCSSRulePositions(rule) {
  const positions = [];
  function recurse(childRule, pos) {
    if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
      const rules = Array.from(childRule.parentRule.cssRules);
      const index2 = rules.indexOf(childRule);
      pos.unshift(index2);
    } else if (childRule.parentStyleSheet) {
      const rules = Array.from(childRule.parentStyleSheet.cssRules);
      const index2 = rules.indexOf(childRule);
      pos.unshift(index2);
    }
    return pos;
  }
  return recurse(rule, positions);
}
function getIdAndStyleId(sheet, mirror2, styleMirror) {
  let id2, styleId;
  if (!sheet)
    return {};
  if (sheet.ownerNode)
    id2 = mirror2.getId(sheet.ownerNode);
  else
    styleId = styleMirror.getId(sheet);
  return {
    styleId,
    id: id2
  };
}
function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win: win2 }) {
  if (!win2.CSSStyleSheet || !win2.CSSStyleSheet.prototype) {
    return () => {
    };
  }
  const insertRule = win2.CSSStyleSheet.prototype.insertRule;
  win2.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
    apply: callbackWrapper((target, thisArg, argumentsList) => {
      const [rule, index2] = argumentsList;
      const { id: id2, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
      if (id2 && id2 !== -1 || styleId && styleId !== -1) {
        styleSheetRuleCb({
          id: id2,
          styleId,
          adds: [{ rule, index: index2 }]
        });
      }
      return target.apply(thisArg, argumentsList);
    })
  });
  const deleteRule = win2.CSSStyleSheet.prototype.deleteRule;
  win2.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
    apply: callbackWrapper((target, thisArg, argumentsList) => {
      const [index2] = argumentsList;
      const { id: id2, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
      if (id2 && id2 !== -1 || styleId && styleId !== -1) {
        styleSheetRuleCb({
          id: id2,
          styleId,
          removes: [{ index: index2 }]
        });
      }
      return target.apply(thisArg, argumentsList);
    })
  });
  let replace2;
  if (win2.CSSStyleSheet.prototype.replace) {
    replace2 = win2.CSSStyleSheet.prototype.replace;
    win2.CSSStyleSheet.prototype.replace = new Proxy(replace2, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [text2] = argumentsList;
        const { id: id2, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
        if (id2 && id2 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id2,
            styleId,
            replace: text2
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
  }
  let replaceSync;
  if (win2.CSSStyleSheet.prototype.replaceSync) {
    replaceSync = win2.CSSStyleSheet.prototype.replaceSync;
    win2.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [text2] = argumentsList;
        const { id: id2, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);
        if (id2 && id2 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id2,
            styleId,
            replaceSync: text2
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
  }
  const supportedNestedCSSRuleTypes = {};
  if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
    supportedNestedCSSRuleTypes.CSSGroupingRule = win2.CSSGroupingRule;
  } else {
    if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
      supportedNestedCSSRuleTypes.CSSMediaRule = win2.CSSMediaRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
      supportedNestedCSSRuleTypes.CSSConditionRule = win2.CSSConditionRule;
    }
    if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
      supportedNestedCSSRuleTypes.CSSSupportsRule = win2.CSSSupportsRule;
    }
  }
  const unmodifiedFunctions = {};
  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type2]) => {
    unmodifiedFunctions[typeKey] = {
      insertRule: type2.prototype.insertRule,
      deleteRule: type2.prototype.deleteRule
    };
    type2.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [rule, index2] = argumentsList;
        const { id: id2, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
        if (id2 && id2 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id2,
            styleId,
            adds: [
              {
                rule,
                index: [
                  ...getNestedCSSRulePositions(thisArg),
                  index2 || 0
                ]
              }
            ]
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
    type2.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {
      apply: callbackWrapper((target, thisArg, argumentsList) => {
        const [index2] = argumentsList;
        const { id: id2, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
        if (id2 && id2 !== -1 || styleId && styleId !== -1) {
          styleSheetRuleCb({
            id: id2,
            styleId,
            removes: [
              { index: [...getNestedCSSRulePositions(thisArg), index2] }
            ]
          });
        }
        return target.apply(thisArg, argumentsList);
      })
    });
  });
  return callbackWrapper(() => {
    win2.CSSStyleSheet.prototype.insertRule = insertRule;
    win2.CSSStyleSheet.prototype.deleteRule = deleteRule;
    replace2 && (win2.CSSStyleSheet.prototype.replace = replace2);
    replaceSync && (win2.CSSStyleSheet.prototype.replaceSync = replaceSync);
    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type2]) => {
      type2.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
      type2.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
    });
  });
}
function initAdoptedStyleSheetObserver({ mirror: mirror2, stylesheetManager }, host) {
  var _a2, _b2, _c2;
  let hostId = null;
  if (host.nodeName === "#document")
    hostId = mirror2.getId(host);
  else
    hostId = mirror2.getId(host.host);
  const patchTarget = host.nodeName === "#document" ? (_a2 = host.defaultView) === null || _a2 === void 0 ? void 0 : _a2.Document : (_c2 = (_b2 = host.ownerDocument) === null || _b2 === void 0 ? void 0 : _b2.defaultView) === null || _c2 === void 0 ? void 0 : _c2.ShadowRoot;
  const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, "adoptedStyleSheets") : void 0;
  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
    return () => {
    };
  Object.defineProperty(host, "adoptedStyleSheets", {
    configurable: originalPropertyDescriptor.configurable,
    enumerable: originalPropertyDescriptor.enumerable,
    get() {
      var _a3;
      return (_a3 = originalPropertyDescriptor.get) === null || _a3 === void 0 ? void 0 : _a3.call(this);
    },
    set(sheets) {
      var _a3;
      const result = (_a3 = originalPropertyDescriptor.set) === null || _a3 === void 0 ? void 0 : _a3.call(this, sheets);
      if (hostId !== null && hostId !== -1) {
        try {
          stylesheetManager.adoptStyleSheets(sheets, hostId);
        } catch (e2) {
        }
      }
      return result;
    }
  });
  return callbackWrapper(() => {
    Object.defineProperty(host, "adoptedStyleSheets", {
      configurable: originalPropertyDescriptor.configurable,
      enumerable: originalPropertyDescriptor.enumerable,
      get: originalPropertyDescriptor.get,
      set: originalPropertyDescriptor.set
    });
  });
}
function initStyleDeclarationObserver({ styleDeclarationCb, mirror: mirror2, ignoreCSSAttributes, stylesheetManager }, { win: win2 }) {
  const setProperty3 = win2.CSSStyleDeclaration.prototype.setProperty;
  win2.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty3, {
    apply: callbackWrapper((target, thisArg, argumentsList) => {
      var _a2;
      const [property, value, priority] = argumentsList;
      if (ignoreCSSAttributes.has(property)) {
        return setProperty3.apply(thisArg, [property, value, priority]);
      }
      const { id: id2, styleId } = getIdAndStyleId((_a2 = thisArg.parentRule) === null || _a2 === void 0 ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
      if (id2 && id2 !== -1 || styleId && styleId !== -1) {
        styleDeclarationCb({
          id: id2,
          styleId,
          set: {
            property,
            value,
            priority
          },
          index: getNestedCSSRulePositions(thisArg.parentRule)
        });
      }
      return target.apply(thisArg, argumentsList);
    })
  });
  const removeProperty = win2.CSSStyleDeclaration.prototype.removeProperty;
  win2.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
    apply: callbackWrapper((target, thisArg, argumentsList) => {
      var _a2;
      const [property] = argumentsList;
      if (ignoreCSSAttributes.has(property)) {
        return removeProperty.apply(thisArg, [property]);
      }
      const { id: id2, styleId } = getIdAndStyleId((_a2 = thisArg.parentRule) === null || _a2 === void 0 ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror);
      if (id2 && id2 !== -1 || styleId && styleId !== -1) {
        styleDeclarationCb({
          id: id2,
          styleId,
          remove: {
            property
          },
          index: getNestedCSSRulePositions(thisArg.parentRule)
        });
      }
      return target.apply(thisArg, argumentsList);
    })
  });
  return callbackWrapper(() => {
    win2.CSSStyleDeclaration.prototype.setProperty = setProperty3;
    win2.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
  });
}
function initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, mirror: mirror2, sampling, doc }) {
  const handler = callbackWrapper((type2) => throttle(callbackWrapper((event) => {
    const target = getEventTarget(event);
    if (!target || isBlocked(target, blockClass, blockSelector, true)) {
      return;
    }
    const { currentTime, volume, muted, playbackRate, loop } = target;
    mediaInteractionCb({
      type: type2,
      id: mirror2.getId(target),
      currentTime,
      volume,
      muted,
      playbackRate,
      loop
    });
  }), sampling.media || 500));
  const handlers2 = [
    on("play", handler(0), doc),
    on("pause", handler(1), doc),
    on("seeked", handler(2), doc),
    on("volumechange", handler(3), doc),
    on("ratechange", handler(4), doc)
  ];
  return callbackWrapper(() => {
    handlers2.forEach((h2) => h2());
  });
}
function initFontObserver({ fontCb, doc }) {
  const win2 = doc.defaultView;
  if (!win2) {
    return () => {
    };
  }
  const handlers2 = [];
  const fontMap = /* @__PURE__ */ new WeakMap();
  const originalFontFace = win2.FontFace;
  win2.FontFace = function FontFace(family, source, descriptors2) {
    const fontFace = new originalFontFace(family, source, descriptors2);
    fontMap.set(fontFace, {
      family,
      buffer: typeof source !== "string",
      descriptors: descriptors2,
      fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
    });
    return fontFace;
  };
  const restoreHandler = patch$1(doc.fonts, "add", function(original) {
    return function(fontFace) {
      setTimeout(callbackWrapper(() => {
        const p2 = fontMap.get(fontFace);
        if (p2) {
          fontCb(p2);
          fontMap.delete(fontFace);
        }
      }), 0);
      return original.apply(this, [fontFace]);
    };
  });
  handlers2.push(() => {
    win2.FontFace = originalFontFace;
  });
  handlers2.push(restoreHandler);
  return callbackWrapper(() => {
    handlers2.forEach((h2) => h2());
  });
}
function initSelectionObserver(param) {
  const { doc, mirror: mirror2, blockClass, blockSelector, selectionCb } = param;
  let collapsed = true;
  const updateSelection = callbackWrapper(() => {
    const selection = doc.getSelection();
    if (!selection || collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed))
      return;
    collapsed = selection.isCollapsed || false;
    const ranges = [];
    const count = selection.rangeCount || 0;
    for (let i2 = 0; i2 < count; i2++) {
      const range = selection.getRangeAt(i2);
      const { startContainer, startOffset, endContainer, endOffset } = range;
      const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);
      if (blocked)
        continue;
      ranges.push({
        start: mirror2.getId(startContainer),
        startOffset,
        end: mirror2.getId(endContainer),
        endOffset
      });
    }
    selectionCb({ ranges });
  });
  updateSelection();
  return on("selectionchange", updateSelection);
}
function initCustomElementObserver({ doc, customElementCb }) {
  const win2 = doc.defaultView;
  if (!win2 || !win2.customElements)
    return () => {
    };
  const restoreHandler = patch$1(win2.customElements, "define", function(original) {
    return function(name, constructor, options) {
      try {
        customElementCb({
          define: {
            name
          }
        });
      } catch (e2) {
        console.warn(`Custom element callback failed for ${name}`);
      }
      return original.apply(this, [name, constructor, options]);
    };
  });
  return restoreHandler;
}
function mergeHooks(o, hooks) {
  const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb } = o;
  o.mutationCb = (...p2) => {
    if (hooks.mutation) {
      hooks.mutation(...p2);
    }
    mutationCb(...p2);
  };
  o.mousemoveCb = (...p2) => {
    if (hooks.mousemove) {
      hooks.mousemove(...p2);
    }
    mousemoveCb(...p2);
  };
  o.mouseInteractionCb = (...p2) => {
    if (hooks.mouseInteraction) {
      hooks.mouseInteraction(...p2);
    }
    mouseInteractionCb(...p2);
  };
  o.scrollCb = (...p2) => {
    if (hooks.scroll) {
      hooks.scroll(...p2);
    }
    scrollCb(...p2);
  };
  o.viewportResizeCb = (...p2) => {
    if (hooks.viewportResize) {
      hooks.viewportResize(...p2);
    }
    viewportResizeCb(...p2);
  };
  o.inputCb = (...p2) => {
    if (hooks.input) {
      hooks.input(...p2);
    }
    inputCb(...p2);
  };
  o.mediaInteractionCb = (...p2) => {
    if (hooks.mediaInteaction) {
      hooks.mediaInteaction(...p2);
    }
    mediaInteractionCb(...p2);
  };
  o.styleSheetRuleCb = (...p2) => {
    if (hooks.styleSheetRule) {
      hooks.styleSheetRule(...p2);
    }
    styleSheetRuleCb(...p2);
  };
  o.styleDeclarationCb = (...p2) => {
    if (hooks.styleDeclaration) {
      hooks.styleDeclaration(...p2);
    }
    styleDeclarationCb(...p2);
  };
  o.canvasMutationCb = (...p2) => {
    if (hooks.canvasMutation) {
      hooks.canvasMutation(...p2);
    }
    canvasMutationCb(...p2);
  };
  o.fontCb = (...p2) => {
    if (hooks.font) {
      hooks.font(...p2);
    }
    fontCb(...p2);
  };
  o.selectionCb = (...p2) => {
    if (hooks.selection) {
      hooks.selection(...p2);
    }
    selectionCb(...p2);
  };
  o.customElementCb = (...c2) => {
    if (hooks.customElement) {
      hooks.customElement(...c2);
    }
    customElementCb(...c2);
  };
}
function initObservers(o, hooks = {}) {
  const currentWindow = o.doc.defaultView;
  if (!currentWindow) {
    return () => {
    };
  }
  mergeHooks(o, hooks);
  let mutationObserver;
  if (o.recordDOM) {
    mutationObserver = initMutationObserver(o, o.doc);
  }
  const mousemoveHandler = initMoveObserver(o);
  const mouseInteractionHandler = initMouseInteractionObserver(o);
  const scrollHandler = initScrollObserver(o);
  const viewportResizeHandler = initViewportResizeObserver(o, {
    win: currentWindow
  });
  const inputHandler = initInputObserver(o);
  const mediaInteractionHandler = initMediaInteractionObserver(o);
  let styleSheetObserver = () => {
  };
  let adoptedStyleSheetObserver = () => {
  };
  let styleDeclarationObserver = () => {
  };
  let fontObserver = () => {
  };
  if (o.recordDOM) {
    styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });
    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);
    styleDeclarationObserver = initStyleDeclarationObserver(o, {
      win: currentWindow
    });
    if (o.collectFonts) {
      fontObserver = initFontObserver(o);
    }
  }
  const selectionObserver = initSelectionObserver(o);
  const customElementObserver = initCustomElementObserver(o);
  const pluginHandlers = [];
  for (const plugin of o.plugins) {
    pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));
  }
  return callbackWrapper(() => {
    mutationBuffers.forEach((b2) => b2.reset());
    mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();
    mousemoveHandler();
    mouseInteractionHandler();
    scrollHandler();
    viewportResizeHandler();
    inputHandler();
    mediaInteractionHandler();
    styleSheetObserver();
    adoptedStyleSheetObserver();
    styleDeclarationObserver();
    fontObserver();
    selectionObserver();
    customElementObserver();
    pluginHandlers.forEach((h2) => h2());
  });
}
function hasNestedCSSRule(prop) {
  return typeof window[prop] !== "undefined";
}
function canMonkeyPatchNestedCSSRule(prop) {
  return Boolean(typeof window[prop] !== "undefined" && window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype);
}
class CrossOriginIframeMirror {
  constructor(generateIdFn) {
    this.generateIdFn = generateIdFn;
    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
  }
  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
    let id2 = idToRemoteIdMap.get(remoteId);
    if (!id2) {
      id2 = this.generateIdFn();
      idToRemoteIdMap.set(remoteId, id2);
      remoteIdToIdMap.set(id2, remoteId);
    }
    return id2;
  }
  getIds(iframe, remoteId) {
    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return remoteId.map((id2) => this.getId(iframe, id2, idToRemoteIdMap, remoteIdToIdMap));
  }
  getRemoteId(iframe, id2, map) {
    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);
    if (typeof id2 !== "number")
      return id2;
    const remoteId = remoteIdToIdMap.get(id2);
    if (!remoteId)
      return -1;
    return remoteId;
  }
  getRemoteIds(iframe, ids) {
    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
    return ids.map((id2) => this.getRemoteId(iframe, id2, remoteIdToIdMap));
  }
  reset(iframe) {
    if (!iframe) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(iframe);
    this.iframeRemoteIdToIdMap.delete(iframe);
  }
  getIdToRemoteIdMap(iframe) {
    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
    if (!idToRemoteIdMap) {
      idToRemoteIdMap = /* @__PURE__ */ new Map();
      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
    }
    return idToRemoteIdMap;
  }
  getRemoteIdToIdMap(iframe) {
    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
    if (!remoteIdToIdMap) {
      remoteIdToIdMap = /* @__PURE__ */ new Map();
      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
    }
    return remoteIdToIdMap;
  }
}
class IframeManager {
  constructor(options) {
    this.iframes = /* @__PURE__ */ new WeakMap();
    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();
    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
    this.mutationCb = options.mutationCb;
    this.wrappedEmit = options.wrappedEmit;
    this.stylesheetManager = options.stylesheetManager;
    this.recordCrossOriginIframes = options.recordCrossOriginIframes;
    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));
    this.mirror = options.mirror;
    if (this.recordCrossOriginIframes) {
      window.addEventListener("message", this.handleMessage.bind(this));
    }
  }
  addIframe(iframeEl) {
    this.iframes.set(iframeEl, true);
    if (iframeEl.contentWindow)
      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
  }
  addLoadListener(cb2) {
    this.loadListener = cb2;
  }
  attachIframe(iframeEl, childSn) {
    var _a2;
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(iframeEl),
          nextId: null,
          node: childSn
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: true
    });
    (_a2 = this.loadListener) === null || _a2 === void 0 ? void 0 : _a2.call(this, iframeEl);
    if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
      this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));
  }
  handleMessage(message) {
    const crossOriginMessageEvent = message;
    if (crossOriginMessageEvent.data.type !== "rrweb" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
      return;
    const iframeSourceWindow = message.source;
    if (!iframeSourceWindow)
      return;
    const iframeEl = this.crossOriginIframeMap.get(message.source);
    if (!iframeEl)
      return;
    const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);
    if (transformedEvent)
      this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);
  }
  transformCrossOriginEvent(iframeEl, e2) {
    var _a2;
    switch (e2.type) {
      case EventType$1.FullSnapshot: {
        this.crossOriginIframeMirror.reset(iframeEl);
        this.crossOriginIframeStyleMirror.reset(iframeEl);
        this.replaceIdOnNode(e2.data.node, iframeEl);
        const rootId = e2.data.node.id;
        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
        this.patchRootIdOnNode(e2.data.node, rootId);
        return {
          timestamp: e2.timestamp,
          type: EventType$1.IncrementalSnapshot,
          data: {
            source: IncrementalSource$1.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(iframeEl),
                nextId: null,
                node: e2.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: true
          }
        };
      }
      case EventType$1.Meta:
      case EventType$1.Load:
      case EventType$1.DomContentLoaded: {
        return false;
      }
      case EventType$1.Plugin: {
        return e2;
      }
      case EventType$1.Custom: {
        this.replaceIds(e2.data.payload, iframeEl, ["id", "parentId", "previousId", "nextId"]);
        return e2;
      }
      case EventType$1.IncrementalSnapshot: {
        switch (e2.data.source) {
          case IncrementalSource$1.Mutation: {
            e2.data.adds.forEach((n2) => {
              this.replaceIds(n2, iframeEl, [
                "parentId",
                "nextId",
                "previousId"
              ]);
              this.replaceIdOnNode(n2.node, iframeEl);
              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
              rootId && this.patchRootIdOnNode(n2.node, rootId);
            });
            e2.data.removes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["parentId", "id"]);
            });
            e2.data.attributes.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            e2.data.texts.forEach((n2) => {
              this.replaceIds(n2, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource$1.Drag:
          case IncrementalSource$1.TouchMove:
          case IncrementalSource$1.MouseMove: {
            e2.data.positions.forEach((p2) => {
              this.replaceIds(p2, iframeEl, ["id"]);
            });
            return e2;
          }
          case IncrementalSource$1.ViewportResize: {
            return false;
          }
          case IncrementalSource$1.MediaInteraction:
          case IncrementalSource$1.MouseInteraction:
          case IncrementalSource$1.Scroll:
          case IncrementalSource$1.CanvasMutation:
          case IncrementalSource$1.Input: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            return e2;
          }
          case IncrementalSource$1.StyleSheetRule:
          case IncrementalSource$1.StyleDeclaration: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleId"]);
            return e2;
          }
          case IncrementalSource$1.Font: {
            return e2;
          }
          case IncrementalSource$1.Selection: {
            e2.data.ranges.forEach((range) => {
              this.replaceIds(range, iframeEl, ["start", "end"]);
            });
            return e2;
          }
          case IncrementalSource$1.AdoptedStyleSheet: {
            this.replaceIds(e2.data, iframeEl, ["id"]);
            this.replaceStyleIds(e2.data, iframeEl, ["styleIds"]);
            (_a2 = e2.data.styles) === null || _a2 === void 0 ? void 0 : _a2.forEach((style) => {
              this.replaceStyleIds(style, iframeEl, ["styleId"]);
            });
            return e2;
          }
        }
      }
    }
    return false;
  }
  replace(iframeMirror, obj, iframeEl, keys2) {
    for (const key of keys2) {
      if (!Array.isArray(obj[key]) && typeof obj[key] !== "number")
        continue;
      if (Array.isArray(obj[key])) {
        obj[key] = iframeMirror.getIds(iframeEl, obj[key]);
      } else {
        obj[key] = iframeMirror.getId(iframeEl, obj[key]);
      }
    }
    return obj;
  }
  replaceIds(obj, iframeEl, keys2) {
    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys2);
  }
  replaceStyleIds(obj, iframeEl, keys2) {
    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys2);
  }
  replaceIdOnNode(node2, iframeEl) {
    this.replaceIds(node2, iframeEl, ["id", "rootId"]);
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.replaceIdOnNode(child, iframeEl);
      });
    }
  }
  patchRootIdOnNode(node2, rootId) {
    if (node2.type !== NodeType.Document && !node2.rootId)
      node2.rootId = rootId;
    if ("childNodes" in node2) {
      node2.childNodes.forEach((child) => {
        this.patchRootIdOnNode(child, rootId);
      });
    }
  }
}
class ShadowDomManager {
  constructor(options) {
    this.shadowDoms = /* @__PURE__ */ new WeakSet();
    this.restoreHandlers = [];
    this.mutationCb = options.mutationCb;
    this.scrollCb = options.scrollCb;
    this.bypassOptions = options.bypassOptions;
    this.mirror = options.mirror;
    this.init();
  }
  init() {
    this.reset();
    this.patchAttachShadow(Element, document);
  }
  addShadowRoot(shadowRoot, doc) {
    if (!isNativeShadowDom(shadowRoot))
      return;
    if (this.shadowDoms.has(shadowRoot))
      return;
    this.shadowDoms.add(shadowRoot);
    const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), { doc, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), shadowRoot);
    this.restoreHandlers.push(() => observer.disconnect());
    this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: shadowRoot, mirror: this.mirror })));
    setTimeout(() => {
      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)
        this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));
      this.restoreHandlers.push(initAdoptedStyleSheetObserver({
        mirror: this.mirror,
        stylesheetManager: this.bypassOptions.stylesheetManager
      }, shadowRoot));
    }, 0);
  }
  observeAttachShadow(iframeElement) {
    if (!iframeElement.contentWindow || !iframeElement.contentDocument)
      return;
    this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);
  }
  patchAttachShadow(element2, doc) {
    const manager = this;
    this.restoreHandlers.push(patch$1(element2.prototype, "attachShadow", function(original) {
      return function(option) {
        const shadowRoot = original.call(this, option);
        if (this.shadowRoot && inDom(this))
          manager.addShadowRoot(this.shadowRoot, doc);
        return shadowRoot;
      };
    }));
  }
  reset() {
    this.restoreHandlers.forEach((handler) => {
      try {
        handler();
      } catch (e2) {
      }
    });
    this.restoreHandlers = [];
    this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t2[p2[i2]] = s[p2[i2]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup[chars.charCodeAt(i$1)] = i$1;
}
var encode$2 = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
  for (i2 = 0; i2 < len; i2 += 3) {
    base64 += chars[bytes[i2] >> 2];
    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
    base64 += chars[bytes[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
const canvasVarMap = /* @__PURE__ */ new Map();
function variableListFor(ctx, ctor) {
  let contextMap = canvasVarMap.get(ctx);
  if (!contextMap) {
    contextMap = /* @__PURE__ */ new Map();
    canvasVarMap.set(ctx, contextMap);
  }
  if (!contextMap.has(ctor)) {
    contextMap.set(ctor, []);
  }
  return contextMap.get(ctor);
}
const saveWebGLVar = (value, win2, ctx) => {
  if (!value || !(isInstanceOfWebGLObject(value, win2) || typeof value === "object"))
    return;
  const name = value.constructor.name;
  const list2 = variableListFor(ctx, name);
  let index2 = list2.indexOf(value);
  if (index2 === -1) {
    index2 = list2.length;
    list2.push(value);
  }
  return index2;
};
function serializeArg(value, win2, ctx) {
  if (value instanceof Array) {
    return value.map((arg) => serializeArg(arg, win2, ctx));
  } else if (value === null) {
    return value;
  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [Object.values(value)]
    };
  } else if (value instanceof ArrayBuffer) {
    const name = value.constructor.name;
    const base64 = encode$2(value);
    return {
      rr_type: name,
      base64
    };
  } else if (value instanceof DataView) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [
        serializeArg(value.buffer, win2, ctx),
        value.byteOffset,
        value.byteLength
      ]
    };
  } else if (value instanceof HTMLImageElement) {
    const name = value.constructor.name;
    const { src } = value;
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof HTMLCanvasElement) {
    const name = "HTMLImageElement";
    const src = value.toDataURL();
    return {
      rr_type: name,
      src
    };
  } else if (value instanceof ImageData) {
    const name = value.constructor.name;
    return {
      rr_type: name,
      args: [serializeArg(value.data, win2, ctx), value.width, value.height]
    };
  } else if (isInstanceOfWebGLObject(value, win2) || typeof value === "object") {
    const name = value.constructor.name;
    const index2 = saveWebGLVar(value, win2, ctx);
    return {
      rr_type: name,
      index: index2
    };
  }
  return value;
}
const serializeArgs = (args, win2, ctx) => {
  return args.map((arg) => serializeArg(arg, win2, ctx));
};
const isInstanceOfWebGLObject = (value, win2) => {
  const webGLConstructorNames = [
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLRenderbuffer",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLTexture",
    "WebGLUniformLocation",
    "WebGLVertexArrayObject",
    "WebGLVertexArrayObjectOES"
  ];
  const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win2[name] === "function");
  return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win2[name]));
};
function initCanvas2DMutationObserver(cb2, win2, blockClass, blockSelector) {
  const handlers2 = [];
  const props2D = Object.getOwnPropertyNames(win2.CanvasRenderingContext2D.prototype);
  for (const prop of props2D) {
    try {
      if (typeof win2.CanvasRenderingContext2D.prototype[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch$1(win2.CanvasRenderingContext2D.prototype, prop, function(original) {
        return function(...args) {
          if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {
            setTimeout(() => {
              const recordArgs = serializeArgs(args, win2, this);
              cb2(this.canvas, {
                type: CanvasContext["2D"],
                property: prop,
                args: recordArgs
              });
            }, 0);
          }
          return original.apply(this, args);
        };
      });
      handlers2.push(restoreHandler);
    } catch (_a2) {
      const hookHandler = hookSetter(win2.CanvasRenderingContext2D.prototype, prop, {
        set(v2) {
          cb2(this.canvas, {
            type: CanvasContext["2D"],
            property: prop,
            args: [v2],
            setter: true
          });
        }
      });
      handlers2.push(hookHandler);
    }
  }
  return () => {
    handlers2.forEach((h2) => h2());
  };
}
function getNormalizedContextName(contextType) {
  return contextType === "experimental-webgl" ? "webgl" : contextType;
}
function initCanvasContextObserver(win2, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {
  const handlers2 = [];
  try {
    const restoreHandler = patch$1(win2.HTMLCanvasElement.prototype, "getContext", function(original) {
      return function(contextType, ...args) {
        if (!isBlocked(this, blockClass, blockSelector, true)) {
          const ctxName = getNormalizedContextName(contextType);
          if (!("__context" in this))
            this.__context = ctxName;
          if (setPreserveDrawingBufferToTrue && ["webgl", "webgl2"].includes(ctxName)) {
            if (args[0] && typeof args[0] === "object") {
              const contextAttributes = args[0];
              if (!contextAttributes.preserveDrawingBuffer) {
                contextAttributes.preserveDrawingBuffer = true;
              }
            } else {
              args.splice(0, 1, {
                preserveDrawingBuffer: true
              });
            }
          }
        }
        return original.apply(this, [contextType, ...args]);
      };
    });
    handlers2.push(restoreHandler);
  } catch (_a2) {
    console.error("failed to patch HTMLCanvasElement.prototype.getContext");
  }
  return () => {
    handlers2.forEach((h2) => h2());
  };
}
function patchGLPrototype(prototype2, type2, cb2, blockClass, blockSelector, mirror2, win2) {
  const handlers2 = [];
  const props = Object.getOwnPropertyNames(prototype2);
  for (const prop of props) {
    if ([
      "isContextLost",
      "canvas",
      "drawingBufferWidth",
      "drawingBufferHeight"
    ].includes(prop)) {
      continue;
    }
    try {
      if (typeof prototype2[prop] !== "function") {
        continue;
      }
      const restoreHandler = patch$1(prototype2, prop, function(original) {
        return function(...args) {
          const result = original.apply(this, args);
          saveWebGLVar(result, win2, this);
          if ("tagName" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {
            const recordArgs = serializeArgs(args, win2, this);
            const mutation = {
              type: type2,
              property: prop,
              args: recordArgs
            };
            cb2(this.canvas, mutation);
          }
          return result;
        };
      });
      handlers2.push(restoreHandler);
    } catch (_a2) {
      const hookHandler = hookSetter(prototype2, prop, {
        set(v2) {
          cb2(this.canvas, {
            type: type2,
            property: prop,
            args: [v2],
            setter: true
          });
        }
      });
      handlers2.push(hookHandler);
    }
  }
  return handlers2;
}
function initCanvasWebGLMutationObserver(cb2, win2, blockClass, blockSelector, mirror2) {
  const handlers2 = [];
  handlers2.push(...patchGLPrototype(win2.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb2, blockClass, blockSelector, mirror2, win2));
  if (typeof win2.WebGL2RenderingContext !== "undefined") {
    handlers2.push(...patchGLPrototype(win2.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb2, blockClass, blockSelector, mirror2, win2));
  }
  return () => {
    handlers2.forEach((h2) => h2());
  };
}
function funcToSource(fn, sourcemapArg) {
  var source = fn.toString();
  var lines = source.split("\n");
  lines.pop();
  lines.shift();
  var blankPrefixLength = lines[0].search(/\S/);
  var regex = /(['"])__worker_loader_strict__(['"])/g;
  for (var i2 = 0, n2 = lines.length; i2 < n2; ++i2) {
    lines[i2] = lines[i2].substring(blankPrefixLength).replace(regex, "$1use strict$2") + "\n";
  }
  return lines;
}
function createURL(fn, sourcemapArg) {
  var lines = funcToSource(fn);
  var blob = new Blob(lines, { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createInlineWorkerFactory(fn, sourcemapArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(fn);
    return new Worker(url, options);
  };
}
var WorkerFactory = createInlineWorkerFactory(
  /* rollup-plugin-web-worker-loader */
  function() {
    (function() {
      "__worker_loader_strict__";
      /*! *****************************************************************************
          Copyright (c) Microsoft Corporation.
      
          Permission to use, copy, modify, and/or distribute this software for any
          purpose with or without fee is hereby granted.
      
          THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          PERFORMANCE OF THIS SOFTWARE.
          ***************************************************************************** */
      function __awaiter2(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, [])).next());
        });
      }
      var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i2 = 0; i2 < chars2.length; i2++) {
        lookup2[chars2.charCodeAt(i2)] = i2;
      }
      var encode2 = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer), i3, len = bytes.length, base64 = "";
        for (i3 = 0; i3 < len; i3 += 3) {
          base64 += chars2[bytes[i3] >> 2];
          base64 += chars2[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
          base64 += chars2[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
          base64 += chars2[bytes[i3 + 2] & 63];
        }
        if (len % 3 === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
        return base64;
      };
      const lastBlobMap = /* @__PURE__ */ new Map();
      const transparentBlobMap = /* @__PURE__ */ new Map();
      function getTransparentBlobFor(width, height, dataURLOptions) {
        return __awaiter2(this, void 0, void 0, function* () {
          const id2 = `${width}-${height}`;
          if ("OffscreenCanvas" in globalThis) {
            if (transparentBlobMap.has(id2))
              return transparentBlobMap.get(id2);
            const offscreen = new OffscreenCanvas(width, height);
            offscreen.getContext("2d");
            const blob = yield offscreen.convertToBlob(dataURLOptions);
            const arrayBuffer = yield blob.arrayBuffer();
            const base64 = encode2(arrayBuffer);
            transparentBlobMap.set(id2, base64);
            return base64;
          } else {
            return "";
          }
        });
      }
      const worker = self;
      worker.onmessage = function(e2) {
        return __awaiter2(this, void 0, void 0, function* () {
          if ("OffscreenCanvas" in globalThis) {
            const { id: id2, bitmap, width, height, dataURLOptions } = e2.data;
            const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);
            const offscreen = new OffscreenCanvas(width, height);
            const ctx = offscreen.getContext("2d");
            ctx.drawImage(bitmap, 0, 0);
            bitmap.close();
            const blob = yield offscreen.convertToBlob(dataURLOptions);
            const type2 = blob.type;
            const arrayBuffer = yield blob.arrayBuffer();
            const base64 = encode2(arrayBuffer);
            if (!lastBlobMap.has(id2) && (yield transparentBase64) === base64) {
              lastBlobMap.set(id2, base64);
              return worker.postMessage({ id: id2 });
            }
            if (lastBlobMap.get(id2) === base64)
              return worker.postMessage({ id: id2 });
            worker.postMessage({
              id: id2,
              type: type2,
              base64,
              width,
              height
            });
            lastBlobMap.set(id2, base64);
          } else {
            return worker.postMessage({ id: e2.data.id });
          }
        });
      };
    })();
  }
);
class CanvasManager {
  reset() {
    this.pendingCanvasMutations.clear();
    this.resetObservers && this.resetObservers();
  }
  freeze() {
    this.frozen = true;
  }
  unfreeze() {
    this.frozen = false;
  }
  lock() {
    this.locked = true;
  }
  unlock() {
    this.locked = false;
  }
  constructor(options) {
    this.pendingCanvasMutations = /* @__PURE__ */ new Map();
    this.rafStamps = { latestId: 0, invokeId: null };
    this.frozen = false;
    this.locked = false;
    this.processMutation = (target, mutation) => {
      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
      if (newFrame || !this.rafStamps.invokeId)
        this.rafStamps.invokeId = this.rafStamps.latestId;
      if (!this.pendingCanvasMutations.has(target)) {
        this.pendingCanvasMutations.set(target, []);
      }
      this.pendingCanvasMutations.get(target).push(mutation);
    };
    const { sampling = "all", win: win2, blockClass, blockSelector, recordCanvas, dataURLOptions } = options;
    this.mutationCb = options.mutationCb;
    this.mirror = options.mirror;
    if (recordCanvas && sampling === "all")
      this.initCanvasMutationObserver(win2, blockClass, blockSelector);
    if (recordCanvas && typeof sampling === "number")
      this.initCanvasFPSObserver(sampling, win2, blockClass, blockSelector, {
        dataURLOptions
      });
  }
  initCanvasFPSObserver(fps, win2, blockClass, blockSelector, options) {
    const canvasContextReset = initCanvasContextObserver(win2, blockClass, blockSelector, true);
    const snapshotInProgressMap = /* @__PURE__ */ new Map();
    const worker = new WorkerFactory();
    worker.onmessage = (e2) => {
      const { id: id2 } = e2.data;
      snapshotInProgressMap.set(id2, false);
      if (!("base64" in e2.data))
        return;
      const { base64, type: type2, width, height } = e2.data;
      this.mutationCb({
        id: id2,
        type: CanvasContext["2D"],
        commands: [
          {
            property: "clearRect",
            args: [0, 0, width, height]
          },
          {
            property: "drawImage",
            args: [
              {
                rr_type: "ImageBitmap",
                args: [
                  {
                    rr_type: "Blob",
                    data: [{ rr_type: "ArrayBuffer", base64 }],
                    type: type2
                  }
                ]
              },
              0,
              0
            ]
          }
        ]
      });
    };
    const timeBetweenSnapshots = 1e3 / fps;
    let lastSnapshotTime = 0;
    let rafId;
    const getCanvas = () => {
      const matchedCanvas = [];
      win2.document.querySelectorAll("canvas").forEach((canvas) => {
        if (!isBlocked(canvas, blockClass, blockSelector, true)) {
          matchedCanvas.push(canvas);
        }
      });
      return matchedCanvas;
    };
    const takeCanvasSnapshots = (timestamp) => {
      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {
        rafId = requestAnimationFrame(takeCanvasSnapshots);
        return;
      }
      lastSnapshotTime = timestamp;
      getCanvas().forEach((canvas) => __awaiter(this, void 0, void 0, function* () {
        var _a2;
        const id2 = this.mirror.getId(canvas);
        if (snapshotInProgressMap.get(id2))
          return;
        if (canvas.width === 0 || canvas.height === 0)
          return;
        snapshotInProgressMap.set(id2, true);
        if (["webgl", "webgl2"].includes(canvas.__context)) {
          const context = canvas.getContext(canvas.__context);
          if (((_a2 = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a2 === void 0 ? void 0 : _a2.preserveDrawingBuffer) === false) {
            context.clear(context.COLOR_BUFFER_BIT);
          }
        }
        const bitmap = yield createImageBitmap(canvas);
        worker.postMessage({
          id: id2,
          bitmap,
          width: canvas.width,
          height: canvas.height,
          dataURLOptions: options.dataURLOptions
        }, [bitmap]);
      }));
      rafId = requestAnimationFrame(takeCanvasSnapshots);
    };
    rafId = requestAnimationFrame(takeCanvasSnapshots);
    this.resetObservers = () => {
      canvasContextReset();
      cancelAnimationFrame(rafId);
    };
  }
  initCanvasMutationObserver(win2, blockClass, blockSelector) {
    this.startRAFTimestamping();
    this.startPendingCanvasMutationFlusher();
    const canvasContextReset = initCanvasContextObserver(win2, blockClass, blockSelector, false);
    const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win2, blockClass, blockSelector);
    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win2, blockClass, blockSelector, this.mirror);
    this.resetObservers = () => {
      canvasContextReset();
      canvas2DReset();
      canvasWebGL1and2Reset();
    };
  }
  startPendingCanvasMutationFlusher() {
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  startRAFTimestamping() {
    const setLatestRAFTimestamp = (timestamp) => {
      this.rafStamps.latestId = timestamp;
      requestAnimationFrame(setLatestRAFTimestamp);
    };
    requestAnimationFrame(setLatestRAFTimestamp);
  }
  flushPendingCanvasMutations() {
    this.pendingCanvasMutations.forEach((values, canvas) => {
      const id2 = this.mirror.getId(canvas);
      this.flushPendingCanvasMutationFor(canvas, id2);
    });
    requestAnimationFrame(() => this.flushPendingCanvasMutations());
  }
  flushPendingCanvasMutationFor(canvas, id2) {
    if (this.frozen || this.locked) {
      return;
    }
    const valuesWithType = this.pendingCanvasMutations.get(canvas);
    if (!valuesWithType || id2 === -1)
      return;
    const values = valuesWithType.map((value) => {
      const rest = __rest(value, ["type"]);
      return rest;
    });
    const { type: type2 } = valuesWithType[0];
    this.mutationCb({ id: id2, type: type2, commands: values });
    this.pendingCanvasMutations.delete(canvas);
  }
}
class StylesheetManager {
  constructor(options) {
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
    this.styleMirror = new StyleSheetMirror();
    this.mutationCb = options.mutationCb;
    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
  }
  attachLinkElement(linkEl, childSn) {
    if ("_cssText" in childSn.attributes)
      this.mutationCb({
        adds: [],
        removes: [],
        texts: [],
        attributes: [
          {
            id: childSn.id,
            attributes: childSn.attributes
          }
        ]
      });
    this.trackLinkElement(linkEl);
  }
  trackLinkElement(linkEl) {
    if (this.trackedLinkElements.has(linkEl))
      return;
    this.trackedLinkElements.add(linkEl);
    this.trackStylesheetInLinkElement(linkEl);
  }
  adoptStyleSheets(sheets, hostId) {
    if (sheets.length === 0)
      return;
    const adoptedStyleSheetData = {
      id: hostId,
      styleIds: []
    };
    const styles = [];
    for (const sheet of sheets) {
      let styleId;
      if (!this.styleMirror.has(sheet)) {
        styleId = this.styleMirror.add(sheet);
        styles.push({
          styleId,
          rules: Array.from(sheet.rules || CSSRule, (r2, index2) => ({
            rule: stringifyRule(r2),
            index: index2
          }))
        });
      } else
        styleId = this.styleMirror.getId(sheet);
      adoptedStyleSheetData.styleIds.push(styleId);
    }
    if (styles.length > 0)
      adoptedStyleSheetData.styles = styles;
    this.adoptedStyleSheetCb(adoptedStyleSheetData);
  }
  reset() {
    this.styleMirror.reset();
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  trackStylesheetInLinkElement(linkEl) {
  }
}
class ProcessedNodeManager {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new WeakMap();
    this.loop = true;
    this.periodicallyClear();
  }
  periodicallyClear() {
    requestAnimationFrame(() => {
      this.clear();
      if (this.loop)
        this.periodicallyClear();
    });
  }
  inOtherBuffer(node2, thisBuffer) {
    const buffers = this.nodeMap.get(node2);
    return buffers && Array.from(buffers).some((buffer2) => buffer2 !== thisBuffer);
  }
  add(node2, buffer2) {
    this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer2));
  }
  clear() {
    this.nodeMap = /* @__PURE__ */ new WeakMap();
  }
  destroy() {
    this.loop = false;
  }
}
function wrapEvent(e2) {
  return Object.assign(Object.assign({}, e2), { timestamp: nowTimestamp() });
}
let wrappedEmit;
let takeFullSnapshot;
let canvasManager;
let recording = false;
const mirror = createMirror();
function record(options = {}) {
  const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = "rr-block", blockSelector = null, ignoreClass = "rr-ignore", ignoreSelector = null, maskTextClass = "rr-mask", maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load", userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = /* @__PURE__ */ new Set([]), errorHandler: errorHandler2 } = options;
  registerErrorHandler(errorHandler2);
  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
  let passEmitsToParent = false;
  if (!inEmittingFrame) {
    try {
      if (window.parent.document) {
        passEmitsToParent = false;
      }
    } catch (e2) {
      passEmitsToParent = true;
    }
  }
  if (inEmittingFrame && !emit) {
    throw new Error("emit function is required");
  }
  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
    sampling.mousemove = mousemoveWait;
  }
  mirror.reset();
  const maskInputOptions = maskAllInputs === true ? {
    color: true,
    date: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
    textarea: true,
    select: true,
    password: true
  } : _maskInputOptions !== void 0 ? _maskInputOptions : { password: true };
  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
    script: true,
    comment: true,
    headFavicon: true,
    headWhitespace: true,
    headMetaSocial: true,
    headMetaRobots: true,
    headMetaHttpEquiv: true,
    headMetaVerification: true,
    headMetaAuthorship: _slimDOMOptions === "all",
    headMetaDescKeywords: _slimDOMOptions === "all"
  } : _slimDOMOptions ? _slimDOMOptions : {};
  polyfill();
  let lastFullSnapshotEvent;
  let incrementalSnapshotCount = 0;
  const eventProcessor = (e2) => {
    for (const plugin of plugins || []) {
      if (plugin.eventProcessor) {
        e2 = plugin.eventProcessor(e2);
      }
    }
    if (packFn && !passEmitsToParent) {
      e2 = packFn(e2);
    }
    return e2;
  };
  wrappedEmit = (e2, isCheckout) => {
    var _a2;
    if (((_a2 = mutationBuffers[0]) === null || _a2 === void 0 ? void 0 : _a2.isFrozen()) && e2.type !== EventType$1.FullSnapshot && !(e2.type === EventType$1.IncrementalSnapshot && e2.data.source === IncrementalSource$1.Mutation)) {
      mutationBuffers.forEach((buf) => buf.unfreeze());
    }
    if (inEmittingFrame) {
      emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e2), isCheckout);
    } else if (passEmitsToParent) {
      const message = {
        type: "rrweb",
        event: eventProcessor(e2),
        origin: window.location.origin,
        isCheckout
      };
      window.parent.postMessage(message, "*");
    }
    if (e2.type === EventType$1.FullSnapshot) {
      lastFullSnapshotEvent = e2;
      incrementalSnapshotCount = 0;
    } else if (e2.type === EventType$1.IncrementalSnapshot) {
      if (e2.data.source === IncrementalSource$1.Mutation && e2.data.isAttachIframe) {
        return;
      }
      incrementalSnapshotCount++;
      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
      const exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
      if (exceedCount || exceedTime) {
        takeFullSnapshot(true);
      }
    }
  };
  const wrappedMutationEmit = (m2) => {
    wrappedEmit(wrapEvent({
      type: EventType$1.IncrementalSnapshot,
      data: Object.assign({ source: IncrementalSource$1.Mutation }, m2)
    }));
  };
  const wrappedScrollEmit = (p2) => wrappedEmit(wrapEvent({
    type: EventType$1.IncrementalSnapshot,
    data: Object.assign({ source: IncrementalSource$1.Scroll }, p2)
  }));
  const wrappedCanvasMutationEmit = (p2) => wrappedEmit(wrapEvent({
    type: EventType$1.IncrementalSnapshot,
    data: Object.assign({ source: IncrementalSource$1.CanvasMutation }, p2)
  }));
  const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({
    type: EventType$1.IncrementalSnapshot,
    data: Object.assign({ source: IncrementalSource$1.AdoptedStyleSheet }, a)
  }));
  const stylesheetManager = new StylesheetManager({
    mutationCb: wrappedMutationEmit,
    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
  });
  const iframeManager = new IframeManager({
    mirror,
    mutationCb: wrappedMutationEmit,
    stylesheetManager,
    recordCrossOriginIframes,
    wrappedEmit
  });
  for (const plugin of plugins || []) {
    if (plugin.getMirror)
      plugin.getMirror({
        nodeMirror: mirror,
        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
      });
  }
  const processedNodeManager = new ProcessedNodeManager();
  canvasManager = new CanvasManager({
    recordCanvas,
    mutationCb: wrappedCanvasMutationEmit,
    win: window,
    blockClass,
    blockSelector,
    mirror,
    sampling: sampling.canvas,
    dataURLOptions
  });
  const shadowDomManager = new ShadowDomManager({
    mutationCb: wrappedMutationEmit,
    scrollCb: wrappedScrollEmit,
    bypassOptions: {
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskInputOptions,
      dataURLOptions,
      maskTextFn,
      maskInputFn,
      recordCanvas,
      inlineImages,
      sampling,
      slimDOMOptions,
      iframeManager,
      stylesheetManager,
      canvasManager,
      keepIframeSrcFn,
      processedNodeManager
    },
    mirror
  });
  takeFullSnapshot = (isCheckout = false) => {
    if (!recordDOM) {
      return;
    }
    wrappedEmit(wrapEvent({
      type: EventType$1.Meta,
      data: {
        href: window.location.href,
        width: getWindowWidth(),
        height: getWindowHeight()
      }
    }), isCheckout);
    stylesheetManager.reset();
    shadowDomManager.init();
    mutationBuffers.forEach((buf) => buf.lock());
    const node2 = snapshot(document, {
      mirror,
      blockClass,
      blockSelector,
      maskTextClass,
      maskTextSelector,
      inlineStylesheet,
      maskAllInputs: maskInputOptions,
      maskTextFn,
      slimDOM: slimDOMOptions,
      dataURLOptions,
      recordCanvas,
      inlineImages,
      onSerialize: (n2) => {
        if (isSerializedIframe(n2, mirror)) {
          iframeManager.addIframe(n2);
        }
        if (isSerializedStylesheet(n2, mirror)) {
          stylesheetManager.trackLinkElement(n2);
        }
        if (hasShadowRoot(n2)) {
          shadowDomManager.addShadowRoot(n2.shadowRoot, document);
        }
      },
      onIframeLoad: (iframe, childSn) => {
        iframeManager.attachIframe(iframe, childSn);
        shadowDomManager.observeAttachShadow(iframe);
      },
      onStylesheetLoad: (linkEl, childSn) => {
        stylesheetManager.attachLinkElement(linkEl, childSn);
      },
      keepIframeSrcFn
    });
    if (!node2) {
      return console.warn("Failed to snapshot the document");
    }
    wrappedEmit(wrapEvent({
      type: EventType$1.FullSnapshot,
      data: {
        node: node2,
        initialOffset: getWindowScroll(window)
      }
    }), isCheckout);
    mutationBuffers.forEach((buf) => buf.unlock());
    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
      stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));
  };
  try {
    const handlers2 = [];
    const observe = (doc) => {
      var _a2;
      return callbackWrapper(initObservers)({
        mutationCb: wrappedMutationEmit,
        mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: {
            source,
            positions
          }
        })),
        mouseInteractionCb: (d2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.MouseInteraction }, d2)
        })),
        scrollCb: wrappedScrollEmit,
        viewportResizeCb: (d2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.ViewportResize }, d2)
        })),
        inputCb: (v2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.Input }, v2)
        })),
        mediaInteractionCb: (p2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.MediaInteraction }, p2)
        })),
        styleSheetRuleCb: (r2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.StyleSheetRule }, r2)
        })),
        styleDeclarationCb: (r2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.StyleDeclaration }, r2)
        })),
        canvasMutationCb: wrappedCanvasMutationEmit,
        fontCb: (p2) => wrappedEmit(wrapEvent({
          type: EventType$1.IncrementalSnapshot,
          data: Object.assign({ source: IncrementalSource$1.Font }, p2)
        })),
        selectionCb: (p2) => {
          wrappedEmit(wrapEvent({
            type: EventType$1.IncrementalSnapshot,
            data: Object.assign({ source: IncrementalSource$1.Selection }, p2)
          }));
        },
        customElementCb: (c2) => {
          wrappedEmit(wrapEvent({
            type: EventType$1.IncrementalSnapshot,
            data: Object.assign({ source: IncrementalSource$1.CustomElement }, c2)
          }));
        },
        blockClass,
        ignoreClass,
        ignoreSelector,
        maskTextClass,
        maskTextSelector,
        maskInputOptions,
        inlineStylesheet,
        sampling,
        recordDOM,
        recordCanvas,
        inlineImages,
        userTriggeredOnInput,
        collectFonts,
        doc,
        maskInputFn,
        maskTextFn,
        keepIframeSrcFn,
        blockSelector,
        slimDOMOptions,
        dataURLOptions,
        mirror,
        iframeManager,
        stylesheetManager,
        shadowDomManager,
        processedNodeManager,
        canvasManager,
        ignoreCSSAttributes,
        plugins: ((_a2 = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p2) => p2.observer)) === null || _a2 === void 0 ? void 0 : _a2.map((p2) => ({
          observer: p2.observer,
          options: p2.options,
          callback: (payload) => wrappedEmit(wrapEvent({
            type: EventType$1.Plugin,
            data: {
              plugin: p2.name,
              payload
            }
          }))
        }))) || []
      }, hooks);
    };
    iframeManager.addLoadListener((iframeEl) => {
      try {
        handlers2.push(observe(iframeEl.contentDocument));
      } catch (error) {
        console.warn(error);
      }
    });
    const init = () => {
      takeFullSnapshot();
      handlers2.push(observe(document));
      recording = true;
    };
    if (document.readyState === "interactive" || document.readyState === "complete") {
      init();
    } else {
      handlers2.push(on("DOMContentLoaded", () => {
        wrappedEmit(wrapEvent({
          type: EventType$1.DomContentLoaded,
          data: {}
        }));
        if (recordAfter === "DOMContentLoaded")
          init();
      }));
      handlers2.push(on("load", () => {
        wrappedEmit(wrapEvent({
          type: EventType$1.Load,
          data: {}
        }));
        if (recordAfter === "load")
          init();
      }, window));
    }
    return () => {
      handlers2.forEach((h2) => h2());
      processedNodeManager.destroy();
      recording = false;
      unregisterErrorHandler();
    };
  } catch (error) {
    console.warn(error);
  }
}
record.addCustomEvent = (tag, payload) => {
  if (!recording) {
    throw new Error("please add custom event after start recording");
  }
  wrappedEmit(wrapEvent({
    type: EventType$1.Custom,
    data: {
      tag,
      payload
    }
  }));
};
record.freezePage = () => {
  mutationBuffers.forEach((buf) => buf.freeze());
};
record.takeFullSnapshot = (isCheckout) => {
  if (!recording) {
    throw new Error("please take full snapshot after start recording");
  }
  takeFullSnapshot(isCheckout);
};
record.mirror = mirror;
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
  EventType2[EventType2["Load"] = 1] = "Load";
  EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
  EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
  EventType2[EventType2["Meta"] = 4] = "Meta";
  EventType2[EventType2["Custom"] = 5] = "Custom";
  EventType2[EventType2["Plugin"] = 6] = "Plugin";
  return EventType2;
})(EventType || {});
var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
  IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
  IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
  IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
  IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
  IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
  IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
  IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
  IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
  IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
  IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
  IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
  IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
  IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
  IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
  IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
  IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
  IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
  return IncrementalSource2;
})(IncrementalSource || {});
var Config = {
  DEBUG: false,
  LIB_VERSION: "2.55.0"
};
var win;
if (typeof window === "undefined") {
  var loc = {
    hostname: ""
  };
  win = {
    navigator: { userAgent: "" },
    document: {
      location: loc,
      referrer: ""
    },
    screen: { width: 0, height: 0 },
    location: loc
  };
} else {
  win = window;
}
var MAX_RECORDING_MS = 24 * 60 * 60 * 1e3;
var ArrayProto = Array.prototype, FuncProto = Function.prototype, ObjProto = Object.prototype, slice$1 = ArrayProto.slice, toString$3 = ObjProto.toString, hasOwnProperty$3 = ObjProto.hasOwnProperty, windowConsole = win.console, navigator$1 = win.navigator, document$1$1 = win.document, windowOpera = win.opera, screen = win.screen, userAgent = navigator$1.userAgent;
var nativeBind = FuncProto.bind, nativeForEach = ArrayProto.forEach, nativeIndexOf = ArrayProto.indexOf, nativeMap = ArrayProto.map, nativeIsArray = Array.isArray, breaker = {};
var _ = {
  trim: function(str) {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
};
var console$1 = {
  /** @type {function(...*)} */
  log: function() {
    if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
      try {
        windowConsole.log.apply(windowConsole, arguments);
      } catch (err) {
        _.each(arguments, function(arg) {
          windowConsole.log(arg);
        });
      }
    }
  },
  /** @type {function(...*)} */
  warn: function() {
    if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
      var args = ["Mixpanel warning:"].concat(_.toArray(arguments));
      try {
        windowConsole.warn.apply(windowConsole, args);
      } catch (err) {
        _.each(args, function(arg) {
          windowConsole.warn(arg);
        });
      }
    }
  },
  /** @type {function(...*)} */
  error: function() {
    if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {
      var args = ["Mixpanel error:"].concat(_.toArray(arguments));
      try {
        windowConsole.error.apply(windowConsole, args);
      } catch (err) {
        _.each(args, function(arg) {
          windowConsole.error(arg);
        });
      }
    }
  },
  /** @type {function(...*)} */
  critical: function() {
    if (!_.isUndefined(windowConsole) && windowConsole) {
      var args = ["Mixpanel error:"].concat(_.toArray(arguments));
      try {
        windowConsole.error.apply(windowConsole, args);
      } catch (err) {
        _.each(args, function(arg) {
          windowConsole.error(arg);
        });
      }
    }
  }
};
var log_func_with_prefix = function(func, prefix2) {
  return function() {
    arguments[0] = "[" + prefix2 + "] " + arguments[0];
    return func.apply(console$1, arguments);
  };
};
var console_with_prefix = function(prefix2) {
  return {
    log: log_func_with_prefix(console$1.log, prefix2),
    error: log_func_with_prefix(console$1.error, prefix2),
    critical: log_func_with_prefix(console$1.critical, prefix2)
  };
};
_.bind = function(func, context) {
  var args, bound;
  if (nativeBind && func.bind === nativeBind) {
    return nativeBind.apply(func, slice$1.call(arguments, 1));
  }
  if (!_.isFunction(func)) {
    throw new TypeError();
  }
  args = slice$1.call(arguments, 2);
  bound = function() {
    if (!(this instanceof bound)) {
      return func.apply(context, args.concat(slice$1.call(arguments)));
    }
    var ctor = {};
    ctor.prototype = func.prototype;
    var self2 = new ctor();
    ctor.prototype = null;
    var result = func.apply(self2, args.concat(slice$1.call(arguments)));
    if (Object(result) === result) {
      return result;
    }
    return self2;
  };
  return bound;
};
_.each = function(obj, iterator, context) {
  if (obj === null || obj === void 0) {
    return;
  }
  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (i2 in obj && iterator.call(context, obj[i2], i2, obj) === breaker) {
        return;
      }
    }
  } else {
    for (var key in obj) {
      if (hasOwnProperty$3.call(obj, key)) {
        if (iterator.call(context, obj[key], key, obj) === breaker) {
          return;
        }
      }
    }
  }
};
_.extend = function(obj) {
  _.each(slice$1.call(arguments, 1), function(source) {
    for (var prop in source) {
      if (source[prop] !== void 0) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
};
_.isArray = nativeIsArray || function(obj) {
  return toString$3.call(obj) === "[object Array]";
};
_.isFunction = function(f2) {
  try {
    return /^\s*\bfunction\b/.test(f2);
  } catch (x2) {
    return false;
  }
};
_.isArguments = function(obj) {
  return !!(obj && hasOwnProperty$3.call(obj, "callee"));
};
_.toArray = function(iterable) {
  if (!iterable) {
    return [];
  }
  if (iterable.toArray) {
    return iterable.toArray();
  }
  if (_.isArray(iterable)) {
    return slice$1.call(iterable);
  }
  if (_.isArguments(iterable)) {
    return slice$1.call(iterable);
  }
  return _.values(iterable);
};
_.map = function(arr, callback, context) {
  if (nativeMap && arr.map === nativeMap) {
    return arr.map(callback, context);
  } else {
    var results = [];
    _.each(arr, function(item) {
      results.push(callback.call(context, item));
    });
    return results;
  }
};
_.keys = function(obj) {
  var results = [];
  if (obj === null) {
    return results;
  }
  _.each(obj, function(value, key) {
    results[results.length] = key;
  });
  return results;
};
_.values = function(obj) {
  var results = [];
  if (obj === null) {
    return results;
  }
  _.each(obj, function(value) {
    results[results.length] = value;
  });
  return results;
};
_.include = function(obj, target) {
  var found = false;
  if (obj === null) {
    return found;
  }
  if (nativeIndexOf && obj.indexOf === nativeIndexOf) {
    return obj.indexOf(target) != -1;
  }
  _.each(obj, function(value) {
    if (found || (found = value === target)) {
      return breaker;
    }
  });
  return found;
};
_.includes = function(str, needle) {
  return str.indexOf(needle) !== -1;
};
_.inherit = function(subclass, superclass) {
  subclass.prototype = new superclass();
  subclass.prototype.constructor = subclass;
  subclass.superclass = superclass.prototype;
  return subclass;
};
_.isObject = function(obj) {
  return obj === Object(obj) && !_.isArray(obj);
};
_.isEmptyObject = function(obj) {
  if (_.isObject(obj)) {
    for (var key in obj) {
      if (hasOwnProperty$3.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  return false;
};
_.isUndefined = function(obj) {
  return obj === void 0;
};
_.isString = function(obj) {
  return toString$3.call(obj) == "[object String]";
};
_.isDate = function(obj) {
  return toString$3.call(obj) == "[object Date]";
};
_.isNumber = function(obj) {
  return toString$3.call(obj) == "[object Number]";
};
_.isElement = function(obj) {
  return !!(obj && obj.nodeType === 1);
};
_.encodeDates = function(obj) {
  _.each(obj, function(v2, k2) {
    if (_.isDate(v2)) {
      obj[k2] = _.formatDate(v2);
    } else if (_.isObject(v2)) {
      obj[k2] = _.encodeDates(v2);
    }
  });
  return obj;
};
_.timestamp = function() {
  Date.now = Date.now || function() {
    return +/* @__PURE__ */ new Date();
  };
  return Date.now();
};
_.formatDate = function(d2) {
  function pad(n2) {
    return n2 < 10 ? "0" + n2 : n2;
  }
  return d2.getUTCFullYear() + "-" + pad(d2.getUTCMonth() + 1) + "-" + pad(d2.getUTCDate()) + "T" + pad(d2.getUTCHours()) + ":" + pad(d2.getUTCMinutes()) + ":" + pad(d2.getUTCSeconds());
};
_.strip_empty_properties = function(p2) {
  var ret = {};
  _.each(p2, function(v2, k2) {
    if (_.isString(v2) && v2.length > 0) {
      ret[k2] = v2;
    }
  });
  return ret;
};
_.truncate = function(obj, length2) {
  var ret;
  if (typeof obj === "string") {
    ret = obj.slice(0, length2);
  } else if (_.isArray(obj)) {
    ret = [];
    _.each(obj, function(val) {
      ret.push(_.truncate(val, length2));
    });
  } else if (_.isObject(obj)) {
    ret = {};
    _.each(obj, function(val, key) {
      ret[key] = _.truncate(val, length2);
    });
  } else {
    ret = obj;
  }
  return ret;
};
_.JSONEncode = /* @__PURE__ */ function() {
  return function(mixed_val) {
    var value = mixed_val;
    var quote = function(string2) {
      var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      };
      escapable.lastIndex = 0;
      return escapable.test(string2) ? '"' + string2.replace(escapable, function(a) {
        var c2 = meta[a];
        return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string2 + '"';
    };
    var str = function(key, holder) {
      var gap = "";
      var indent = "    ";
      var i2 = 0;
      var k2 = "";
      var v2 = "";
      var length2 = 0;
      var mind = gap;
      var partial = [];
      var value2 = holder[key];
      if (value2 && typeof value2 === "object" && typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key);
      }
      switch (typeof value2) {
        case "string":
          return quote(value2);
        case "number":
          return isFinite(value2) ? String(value2) : "null";
        case "boolean":
        case "null":
          return String(value2);
        case "object":
          if (!value2) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (toString$3.apply(value2) === "[object Array]") {
            length2 = value2.length;
            for (i2 = 0; i2 < length2; i2 += 1) {
              partial[i2] = str(i2, value2) || "null";
            }
            v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v2;
          }
          for (k2 in value2) {
            if (hasOwnProperty$3.call(value2, k2)) {
              v2 = str(k2, value2);
              if (v2) {
                partial.push(quote(k2) + (gap ? ": " : ":") + v2);
              }
            }
          }
          v2 = partial.length === 0 ? "{}" : gap ? "{" + partial.join(",") + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v2;
      }
    };
    return str("", {
      "": value
    });
  };
}();
_.JSONDecode = function() {
  var at2, ch2, escapee = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    "b": "\b",
    "f": "\f",
    "n": "\n",
    "r": "\r",
    "t": "	"
  }, text2, error = function(m2) {
    var e2 = new SyntaxError(m2);
    e2.at = at2;
    e2.text = text2;
    throw e2;
  }, next2 = function(c2) {
    if (c2 && c2 !== ch2) {
      error("Expected '" + c2 + "' instead of '" + ch2 + "'");
    }
    ch2 = text2.charAt(at2);
    at2 += 1;
    return ch2;
  }, number2 = function() {
    var number3, string3 = "";
    if (ch2 === "-") {
      string3 = "-";
      next2("-");
    }
    while (ch2 >= "0" && ch2 <= "9") {
      string3 += ch2;
      next2();
    }
    if (ch2 === ".") {
      string3 += ".";
      while (next2() && ch2 >= "0" && ch2 <= "9") {
        string3 += ch2;
      }
    }
    if (ch2 === "e" || ch2 === "E") {
      string3 += ch2;
      next2();
      if (ch2 === "-" || ch2 === "+") {
        string3 += ch2;
        next2();
      }
      while (ch2 >= "0" && ch2 <= "9") {
        string3 += ch2;
        next2();
      }
    }
    number3 = +string3;
    if (!isFinite(number3)) {
      error("Bad number");
    } else {
      return number3;
    }
  }, string2 = function() {
    var hex2, i2, string3 = "", uffff;
    if (ch2 === '"') {
      while (next2()) {
        if (ch2 === '"') {
          next2();
          return string3;
        }
        if (ch2 === "\\") {
          next2();
          if (ch2 === "u") {
            uffff = 0;
            for (i2 = 0; i2 < 4; i2 += 1) {
              hex2 = parseInt(next2(), 16);
              if (!isFinite(hex2)) {
                break;
              }
              uffff = uffff * 16 + hex2;
            }
            string3 += String.fromCharCode(uffff);
          } else if (typeof escapee[ch2] === "string") {
            string3 += escapee[ch2];
          } else {
            break;
          }
        } else {
          string3 += ch2;
        }
      }
    }
    error("Bad string");
  }, white = function() {
    while (ch2 && ch2 <= " ") {
      next2();
    }
  }, word = function() {
    switch (ch2) {
      case "t":
        next2("t");
        next2("r");
        next2("u");
        next2("e");
        return true;
      case "f":
        next2("f");
        next2("a");
        next2("l");
        next2("s");
        next2("e");
        return false;
      case "n":
        next2("n");
        next2("u");
        next2("l");
        next2("l");
        return null;
    }
    error('Unexpected "' + ch2 + '"');
  }, value, array = function() {
    var array2 = [];
    if (ch2 === "[") {
      next2("[");
      white();
      if (ch2 === "]") {
        next2("]");
        return array2;
      }
      while (ch2) {
        array2.push(value());
        white();
        if (ch2 === "]") {
          next2("]");
          return array2;
        }
        next2(",");
        white();
      }
    }
    error("Bad array");
  }, object = function() {
    var key, object2 = {};
    if (ch2 === "{") {
      next2("{");
      white();
      if (ch2 === "}") {
        next2("}");
        return object2;
      }
      while (ch2) {
        key = string2();
        white();
        next2(":");
        if (Object.hasOwnProperty.call(object2, key)) {
          error('Duplicate key "' + key + '"');
        }
        object2[key] = value();
        white();
        if (ch2 === "}") {
          next2("}");
          return object2;
        }
        next2(",");
        white();
      }
    }
    error("Bad object");
  };
  value = function() {
    white();
    switch (ch2) {
      case "{":
        return object();
      case "[":
        return array();
      case '"':
        return string2();
      case "-":
        return number2();
      default:
        return ch2 >= "0" && ch2 <= "9" ? number2() : word();
    }
  };
  return function(source) {
    var result;
    text2 = source;
    at2 = 0;
    ch2 = " ";
    result = value();
    white();
    if (ch2) {
      error("Syntax error");
    }
    return result;
  };
}();
_.base64Encode = function(data2) {
  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var o1, o2, o3, h1, h2, h3, h4, bits, i2 = 0, ac2 = 0, enc = "", tmp_arr = [];
  if (!data2) {
    return data2;
  }
  data2 = _.utf8Encode(data2);
  do {
    o1 = data2.charCodeAt(i2++);
    o2 = data2.charCodeAt(i2++);
    o3 = data2.charCodeAt(i2++);
    bits = o1 << 16 | o2 << 8 | o3;
    h1 = bits >> 18 & 63;
    h2 = bits >> 12 & 63;
    h3 = bits >> 6 & 63;
    h4 = bits & 63;
    tmp_arr[ac2++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  } while (i2 < data2.length);
  enc = tmp_arr.join("");
  switch (data2.length % 3) {
    case 1:
      enc = enc.slice(0, -2) + "==";
      break;
    case 2:
      enc = enc.slice(0, -1) + "=";
      break;
  }
  return enc;
};
_.utf8Encode = function(string2) {
  string2 = (string2 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  var utftext = "", start, end;
  var stringl = 0, n2;
  start = end = 0;
  stringl = string2.length;
  for (n2 = 0; n2 < stringl; n2++) {
    var c1 = string2.charCodeAt(n2);
    var enc = null;
    if (c1 < 128) {
      end++;
    } else if (c1 > 127 && c1 < 2048) {
      enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);
    } else {
      enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);
    }
    if (enc !== null) {
      if (end > start) {
        utftext += string2.substring(start, end);
      }
      utftext += enc;
      start = end = n2 + 1;
    }
  }
  if (end > start) {
    utftext += string2.substring(start, string2.length);
  }
  return utftext;
};
_.UUID = /* @__PURE__ */ function() {
  var T2 = function() {
    var time2 = 1 * /* @__PURE__ */ new Date();
    var ticks;
    if (win.performance && win.performance.now) {
      ticks = win.performance.now();
    } else {
      ticks = 0;
      while (time2 == 1 * /* @__PURE__ */ new Date()) {
        ticks++;
      }
    }
    return time2.toString(16) + Math.floor(ticks).toString(16);
  };
  var R2 = function() {
    return Math.random().toString(16).replace(".", "");
  };
  var UA = function() {
    var ua2 = userAgent, i2, ch2, buffer2 = [], ret = 0;
    function xor(result, byte_array) {
      var j, tmp = 0;
      for (j = 0; j < byte_array.length; j++) {
        tmp |= buffer2[j] << j * 8;
      }
      return result ^ tmp;
    }
    for (i2 = 0; i2 < ua2.length; i2++) {
      ch2 = ua2.charCodeAt(i2);
      buffer2.unshift(ch2 & 255);
      if (buffer2.length >= 4) {
        ret = xor(ret, buffer2);
        buffer2 = [];
      }
    }
    if (buffer2.length > 0) {
      ret = xor(ret, buffer2);
    }
    return ret.toString(16);
  };
  return function() {
    var se2 = (screen.height * screen.width).toString(16);
    return T2() + "-" + R2() + "-" + UA() + "-" + se2 + "-" + T2();
  };
}();
var BLOCKED_UA_STRS = [
  "ahrefsbot",
  "ahrefssiteaudit",
  "baiduspider",
  "bingbot",
  "bingpreview",
  "chrome-lighthouse",
  "facebookexternal",
  "petalbot",
  "pinterest",
  "screaming frog",
  "yahoo! slurp",
  "yandexbot",
  // a whole bunch of goog-specific crawlers
  // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers
  "adsbot-google",
  "apis-google",
  "duplexweb-google",
  "feedfetcher-google",
  "google favicon",
  "google web preview",
  "google-read-aloud",
  "googlebot",
  "googleweblight",
  "mediapartners-google",
  "storebot-google"
];
_.isBlockedUA = function(ua2) {
  var i2;
  ua2 = ua2.toLowerCase();
  for (i2 = 0; i2 < BLOCKED_UA_STRS.length; i2++) {
    if (ua2.indexOf(BLOCKED_UA_STRS[i2]) !== -1) {
      return true;
    }
  }
  return false;
};
_.HTTPBuildQuery = function(formdata, arg_separator) {
  var use_val, use_key, tmp_arr = [];
  if (_.isUndefined(arg_separator)) {
    arg_separator = "&";
  }
  _.each(formdata, function(val, key) {
    use_val = encodeURIComponent(val.toString());
    use_key = encodeURIComponent(key);
    tmp_arr[tmp_arr.length] = use_key + "=" + use_val;
  });
  return tmp_arr.join(arg_separator);
};
_.getQueryParam = function(url, param) {
  param = param.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
  var regexS = "[\\?&]" + param + "=([^&#]*)", regex = new RegExp(regexS), results = regex.exec(url);
  if (results === null || results && typeof results[1] !== "string" && results[1].length) {
    return "";
  } else {
    var result = results[1];
    try {
      result = decodeURIComponent(result);
    } catch (err) {
      console$1.error("Skipping decoding for malformed query param: " + result);
    }
    return result.replace(/\+/g, " ");
  }
};
_.cookie = {
  get: function(name) {
    var nameEQ = name + "=";
    var ca2 = document$1$1.cookie.split(";");
    for (var i2 = 0; i2 < ca2.length; i2++) {
      var c2 = ca2[i2];
      while (c2.charAt(0) == " ") {
        c2 = c2.substring(1, c2.length);
      }
      if (c2.indexOf(nameEQ) === 0) {
        return decodeURIComponent(c2.substring(nameEQ.length, c2.length));
      }
    }
    return null;
  },
  parse: function(name) {
    var cookie;
    try {
      cookie = _.JSONDecode(_.cookie.get(name)) || {};
    } catch (err) {
    }
    return cookie;
  },
  set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {
    var cdomain = "", expires = "", secure = "";
    if (domain_override) {
      cdomain = "; domain=" + domain_override;
    } else if (is_cross_subdomain) {
      var domain = extract_domain(document$1$1.location.hostname);
      cdomain = domain ? "; domain=." + domain : "";
    }
    if (seconds) {
      var date = /* @__PURE__ */ new Date();
      date.setTime(date.getTime() + seconds * 1e3);
      expires = "; expires=" + date.toGMTString();
    }
    if (is_cross_site) {
      is_secure = true;
      secure = "; SameSite=None";
    }
    if (is_secure) {
      secure += "; secure";
    }
    document$1$1.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/" + cdomain + secure;
  },
  set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {
    var cdomain = "", expires = "", secure = "";
    if (domain_override) {
      cdomain = "; domain=" + domain_override;
    } else if (is_cross_subdomain) {
      var domain = extract_domain(document$1$1.location.hostname);
      cdomain = domain ? "; domain=." + domain : "";
    }
    if (days) {
      var date = /* @__PURE__ */ new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
      expires = "; expires=" + date.toGMTString();
    }
    if (is_cross_site) {
      is_secure = true;
      secure = "; SameSite=None";
    }
    if (is_secure) {
      secure += "; secure";
    }
    var new_cookie_val = name + "=" + encodeURIComponent(value) + expires + "; path=/" + cdomain + secure;
    document$1$1.cookie = new_cookie_val;
    return new_cookie_val;
  },
  remove: function(name, is_cross_subdomain, domain_override) {
    _.cookie.set(name, "", -1, is_cross_subdomain, false, false, domain_override);
  }
};
var _localStorageSupported = null;
var localStorageSupported = function(storage, forceCheck) {
  if (_localStorageSupported !== null && !forceCheck) {
    return _localStorageSupported;
  }
  var supported = true;
  try {
    storage = storage || window.localStorage;
    var key = "__mplss_" + cheap_guid(8), val = "xyz";
    storage.setItem(key, val);
    if (storage.getItem(key) !== val) {
      supported = false;
    }
    storage.removeItem(key);
  } catch (err) {
    supported = false;
  }
  _localStorageSupported = supported;
  return supported;
};
_.localStorage = {
  is_supported: function(force_check) {
    var supported = localStorageSupported(null, force_check);
    if (!supported) {
      console$1.error("localStorage unsupported; falling back to cookie store");
    }
    return supported;
  },
  error: function(msg) {
    console$1.error("localStorage error: " + msg);
  },
  get: function(name) {
    try {
      return window.localStorage.getItem(name);
    } catch (err) {
      _.localStorage.error(err);
    }
    return null;
  },
  parse: function(name) {
    try {
      return _.JSONDecode(_.localStorage.get(name)) || {};
    } catch (err) {
    }
    return null;
  },
  set: function(name, value) {
    try {
      window.localStorage.setItem(name, value);
    } catch (err) {
      _.localStorage.error(err);
    }
  },
  remove: function(name) {
    try {
      window.localStorage.removeItem(name);
    } catch (err) {
      _.localStorage.error(err);
    }
  }
};
_.register_event = function() {
  var register_event = function(element2, type2, handler, oldSchool, useCapture) {
    if (!element2) {
      console$1.error("No valid element provided to register_event");
      return;
    }
    if (element2.addEventListener && !oldSchool) {
      element2.addEventListener(type2, handler, !!useCapture);
    } else {
      var ontype = "on" + type2;
      var old_handler = element2[ontype];
      element2[ontype] = makeHandler(element2, handler, old_handler);
    }
  };
  function makeHandler(element2, new_handler, old_handlers) {
    var handler = function(event) {
      event = event || fixEvent(window.event);
      if (!event) {
        return void 0;
      }
      var ret = true;
      var old_result, new_result;
      if (_.isFunction(old_handlers)) {
        old_result = old_handlers(event);
      }
      new_result = new_handler.call(element2, event);
      if (false === old_result || false === new_result) {
        ret = false;
      }
      return ret;
    };
    return handler;
  }
  function fixEvent(event) {
    if (event) {
      event.preventDefault = fixEvent.preventDefault;
      event.stopPropagation = fixEvent.stopPropagation;
    }
    return event;
  }
  fixEvent.preventDefault = function() {
    this.returnValue = false;
  };
  fixEvent.stopPropagation = function() {
    this.cancelBubble = true;
  };
  return register_event;
}();
var TOKEN_MATCH_REGEX = new RegExp('^(\\w*)\\[(\\w+)([=~\\|\\^\\$\\*]?)=?"?([^\\]"]*)"?\\]$');
_.dom_query = /* @__PURE__ */ function() {
  function getAllChildren(e2) {
    return e2.all ? e2.all : e2.getElementsByTagName("*");
  }
  var bad_whitespace = /[\t\r\n]/g;
  function hasClass(elem, selector) {
    var className = " " + selector + " ";
    return (" " + elem.className + " ").replace(bad_whitespace, " ").indexOf(className) >= 0;
  }
  function getElementsBySelector(selector) {
    if (!document$1$1.getElementsByTagName) {
      return [];
    }
    var tokens = selector.split(" ");
    var token2, bits, tagName, found, foundCount, i2, j, k2, elements, currentContextIndex;
    var currentContext = [document$1$1];
    for (i2 = 0; i2 < tokens.length; i2++) {
      token2 = tokens[i2].replace(/^\s+/, "").replace(/\s+$/, "");
      if (token2.indexOf("#") > -1) {
        bits = token2.split("#");
        tagName = bits[0];
        var id2 = bits[1];
        var element2 = document$1$1.getElementById(id2);
        if (!element2 || tagName && element2.nodeName.toLowerCase() != tagName) {
          return [];
        }
        currentContext = [element2];
        continue;
      }
      if (token2.indexOf(".") > -1) {
        bits = token2.split(".");
        tagName = bits[0];
        var className = bits[1];
        if (!tagName) {
          tagName = "*";
        }
        found = [];
        foundCount = 0;
        for (j = 0; j < currentContext.length; j++) {
          if (tagName == "*") {
            elements = getAllChildren(currentContext[j]);
          } else {
            elements = currentContext[j].getElementsByTagName(tagName);
          }
          for (k2 = 0; k2 < elements.length; k2++) {
            found[foundCount++] = elements[k2];
          }
        }
        currentContext = [];
        currentContextIndex = 0;
        for (j = 0; j < found.length; j++) {
          if (found[j].className && _.isString(found[j].className) && // some SVG elements have classNames which are not strings
          hasClass(found[j], className)) {
            currentContext[currentContextIndex++] = found[j];
          }
        }
        continue;
      }
      var token_match = token2.match(TOKEN_MATCH_REGEX);
      if (token_match) {
        tagName = token_match[1];
        var attrName = token_match[2];
        var attrOperator = token_match[3];
        var attrValue = token_match[4];
        if (!tagName) {
          tagName = "*";
        }
        found = [];
        foundCount = 0;
        for (j = 0; j < currentContext.length; j++) {
          if (tagName == "*") {
            elements = getAllChildren(currentContext[j]);
          } else {
            elements = currentContext[j].getElementsByTagName(tagName);
          }
          for (k2 = 0; k2 < elements.length; k2++) {
            found[foundCount++] = elements[k2];
          }
        }
        currentContext = [];
        currentContextIndex = 0;
        var checkFunction;
        switch (attrOperator) {
          case "=":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName) == attrValue;
            };
            break;
          case "~":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName).match(new RegExp("\\b" + attrValue + "\\b"));
            };
            break;
          case "|":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName).match(new RegExp("^" + attrValue + "-?"));
            };
            break;
          case "^":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName).indexOf(attrValue) === 0;
            };
            break;
          case "$":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName).lastIndexOf(attrValue) == e2.getAttribute(attrName).length - attrValue.length;
            };
            break;
          case "*":
            checkFunction = function(e2) {
              return e2.getAttribute(attrName).indexOf(attrValue) > -1;
            };
            break;
          default:
            checkFunction = function(e2) {
              return e2.getAttribute(attrName);
            };
        }
        currentContext = [];
        currentContextIndex = 0;
        for (j = 0; j < found.length; j++) {
          if (checkFunction(found[j])) {
            currentContext[currentContextIndex++] = found[j];
          }
        }
        continue;
      }
      tagName = token2;
      found = [];
      foundCount = 0;
      for (j = 0; j < currentContext.length; j++) {
        elements = currentContext[j].getElementsByTagName(tagName);
        for (k2 = 0; k2 < elements.length; k2++) {
          found[foundCount++] = elements[k2];
        }
      }
      currentContext = found;
    }
    return currentContext;
  }
  return function(query) {
    if (_.isElement(query)) {
      return [query];
    } else if (_.isObject(query) && !_.isUndefined(query.length)) {
      return query;
    } else {
      return getElementsBySelector.call(this, query);
    }
  };
}();
var CAMPAIGN_KEYWORDS = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term"];
var CLICK_IDS = ["dclid", "fbclid", "gclid", "ko_click_id", "li_fat_id", "msclkid", "ttclid", "twclid", "wbraid"];
_.info = {
  campaignParams: function(default_value) {
    var kw2 = "", params = {};
    _.each(CAMPAIGN_KEYWORDS, function(kwkey) {
      kw2 = _.getQueryParam(document$1$1.URL, kwkey);
      if (kw2.length) {
        params[kwkey] = kw2;
      } else if (default_value !== void 0) {
        params[kwkey] = default_value;
      }
    });
    return params;
  },
  clickParams: function() {
    var id2 = "", params = {};
    _.each(CLICK_IDS, function(idkey) {
      id2 = _.getQueryParam(document$1$1.URL, idkey);
      if (id2.length) {
        params[idkey] = id2;
      }
    });
    return params;
  },
  marketingParams: function() {
    return _.extend(_.info.campaignParams(), _.info.clickParams());
  },
  searchEngine: function(referrer) {
    if (referrer.search("https?://(.*)google.([^/?]*)") === 0) {
      return "google";
    } else if (referrer.search("https?://(.*)bing.com") === 0) {
      return "bing";
    } else if (referrer.search("https?://(.*)yahoo.com") === 0) {
      return "yahoo";
    } else if (referrer.search("https?://(.*)duckduckgo.com") === 0) {
      return "duckduckgo";
    } else {
      return null;
    }
  },
  searchInfo: function(referrer) {
    var search2 = _.info.searchEngine(referrer), param = search2 != "yahoo" ? "q" : "p", ret = {};
    if (search2 !== null) {
      ret["$search_engine"] = search2;
      var keyword = _.getQueryParam(referrer, param);
      if (keyword.length) {
        ret["mp_keyword"] = keyword;
      }
    }
    return ret;
  },
  /**
   * This function detects which browser is running this script.
   * The order of the checks are important since many user agents
   * include key words used in later checks.
   */
  browser: function(user_agent, vendor, opera) {
    vendor = vendor || "";
    if (opera || _.includes(user_agent, " OPR/")) {
      if (_.includes(user_agent, "Mini")) {
        return "Opera Mini";
      }
      return "Opera";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
      return "BlackBerry";
    } else if (_.includes(user_agent, "IEMobile") || _.includes(user_agent, "WPDesktop")) {
      return "Internet Explorer Mobile";
    } else if (_.includes(user_agent, "SamsungBrowser/")) {
      return "Samsung Internet";
    } else if (_.includes(user_agent, "Edge") || _.includes(user_agent, "Edg/")) {
      return "Microsoft Edge";
    } else if (_.includes(user_agent, "FBIOS")) {
      return "Facebook Mobile";
    } else if (_.includes(user_agent, "Chrome")) {
      return "Chrome";
    } else if (_.includes(user_agent, "CriOS")) {
      return "Chrome iOS";
    } else if (_.includes(user_agent, "UCWEB") || _.includes(user_agent, "UCBrowser")) {
      return "UC Browser";
    } else if (_.includes(user_agent, "FxiOS")) {
      return "Firefox iOS";
    } else if (_.includes(vendor, "Apple")) {
      if (_.includes(user_agent, "Mobile")) {
        return "Mobile Safari";
      }
      return "Safari";
    } else if (_.includes(user_agent, "Android")) {
      return "Android Mobile";
    } else if (_.includes(user_agent, "Konqueror")) {
      return "Konqueror";
    } else if (_.includes(user_agent, "Firefox")) {
      return "Firefox";
    } else if (_.includes(user_agent, "MSIE") || _.includes(user_agent, "Trident/")) {
      return "Internet Explorer";
    } else if (_.includes(user_agent, "Gecko")) {
      return "Mozilla";
    } else {
      return "";
    }
  },
  /**
   * This function detects which browser version is running this script,
   * parsing major and minor version (e.g., 42.1). User agent strings from:
   * http://www.useragentstring.com/pages/useragentstring.php
   */
  browserVersion: function(userAgent2, vendor, opera) {
    var browser = _.info.browser(userAgent2, vendor, opera);
    var versionRegexs = {
      "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
      "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
      "Chrome": /Chrome\/(\d+(\.\d+)?)/,
      "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
      "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
      "Safari": /Version\/(\d+(\.\d+)?)/,
      "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
      "Opera": /(Opera|OPR)\/(\d+(\.\d+)?)/,
      "Firefox": /Firefox\/(\d+(\.\d+)?)/,
      "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
      "Konqueror": /Konqueror:(\d+(\.\d+)?)/,
      "BlackBerry": /BlackBerry (\d+(\.\d+)?)/,
      "Android Mobile": /android\s(\d+(\.\d+)?)/,
      "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
      "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
      "Mozilla": /rv:(\d+(\.\d+)?)/
    };
    var regex = versionRegexs[browser];
    if (regex === void 0) {
      return null;
    }
    var matches = userAgent2.match(regex);
    if (!matches) {
      return null;
    }
    return parseFloat(matches[matches.length - 2]);
  },
  os: function() {
    var a = userAgent;
    if (/Windows/i.test(a)) {
      if (/Phone/.test(a) || /WPDesktop/.test(a)) {
        return "Windows Phone";
      }
      return "Windows";
    } else if (/(iPhone|iPad|iPod)/.test(a)) {
      return "iOS";
    } else if (/Android/.test(a)) {
      return "Android";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {
      return "BlackBerry";
    } else if (/Mac/i.test(a)) {
      return "Mac OS X";
    } else if (/Linux/.test(a)) {
      return "Linux";
    } else if (/CrOS/.test(a)) {
      return "Chrome OS";
    } else {
      return "";
    }
  },
  device: function(user_agent) {
    if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {
      return "Windows Phone";
    } else if (/iPad/.test(user_agent)) {
      return "iPad";
    } else if (/iPod/.test(user_agent)) {
      return "iPod Touch";
    } else if (/iPhone/.test(user_agent)) {
      return "iPhone";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
      return "BlackBerry";
    } else if (/Android/.test(user_agent)) {
      return "Android";
    } else {
      return "";
    }
  },
  referringDomain: function(referrer) {
    var split = referrer.split("/");
    if (split.length >= 3) {
      return split[2];
    }
    return "";
  },
  currentUrl: function() {
    return win.location.href;
  },
  properties: function(extra_props) {
    if (typeof extra_props !== "object") {
      extra_props = {};
    }
    return _.extend(_.strip_empty_properties({
      "$os": _.info.os(),
      "$browser": _.info.browser(userAgent, navigator$1.vendor, windowOpera),
      "$referrer": document$1$1.referrer,
      "$referring_domain": _.info.referringDomain(document$1$1.referrer),
      "$device": _.info.device(userAgent)
    }), {
      "$current_url": _.info.currentUrl(),
      "$browser_version": _.info.browserVersion(userAgent, navigator$1.vendor, windowOpera),
      "$screen_height": screen.height,
      "$screen_width": screen.width,
      "mp_lib": "web",
      "$lib_version": Config.LIB_VERSION,
      "$insert_id": cheap_guid(),
      "time": _.timestamp() / 1e3
      // epoch time in seconds
    }, _.strip_empty_properties(extra_props));
  },
  people_properties: function() {
    return _.extend(_.strip_empty_properties({
      "$os": _.info.os(),
      "$browser": _.info.browser(userAgent, navigator$1.vendor, windowOpera)
    }), {
      "$browser_version": _.info.browserVersion(userAgent, navigator$1.vendor, windowOpera)
    });
  },
  mpPageViewProperties: function() {
    return _.strip_empty_properties({
      "current_page_title": document$1$1.title,
      "current_domain": win.location.hostname,
      "current_url_path": win.location.pathname,
      "current_url_protocol": win.location.protocol,
      "current_url_search": win.location.search
    });
  }
};
var cheap_guid = function(maxlen) {
  var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);
  return maxlen ? guid.substring(0, maxlen) : guid;
};
var SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\.[a-z]+$/i;
var DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
var extract_domain = function(hostname) {
  var domain_regex = DOMAIN_MATCH_REGEX;
  var parts = hostname.split(".");
  var tld = parts[parts.length - 1];
  if (tld.length > 4 || tld === "com" || tld === "org") {
    domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;
  }
  var matches = hostname.match(domain_regex);
  return matches ? matches[0] : "";
};
var JSONStringify = null, JSONParse = null;
if (typeof JSON !== "undefined") {
  JSONStringify = JSON.stringify;
  JSONParse = JSON.parse;
}
JSONStringify = JSONStringify || _.JSONEncode;
JSONParse = JSONParse || _.JSONDecode;
_["toArray"] = _.toArray;
_["isObject"] = _.isObject;
_["JSONEncode"] = _.JSONEncode;
_["JSONDecode"] = _.JSONDecode;
_["isBlockedUA"] = _.isBlockedUA;
_["isEmptyObject"] = _.isEmptyObject;
_["info"] = _.info;
_["info"]["device"] = _.info.device;
_["info"]["browser"] = _.info.browser;
_["info"]["browserVersion"] = _.info.browserVersion;
_["info"]["properties"] = _.info.properties;
var GDPR_DEFAULT_PERSISTENCE_PREFIX = "__mp_opt_in_out_";
function optIn(token2, options) {
  _optInOut(true, token2, options);
}
function optOut(token2, options) {
  _optInOut(false, token2, options);
}
function hasOptedIn(token2, options) {
  return _getStorageValue(token2, options) === "1";
}
function hasOptedOut(token2, options) {
  if (_hasDoNotTrackFlagOn(options)) {
    console$1.warn('This browser has "Do Not Track" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the "Do Not Track" browser setting, initialize the Mixpanel instance with the config "ignore_dnt: true"');
    return true;
  }
  var optedOut = _getStorageValue(token2, options) === "0";
  if (optedOut) {
    console$1.warn("You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.");
  }
  return optedOut;
}
function addOptOutCheckMixpanelLib(method) {
  return _addOptOutCheck(method, function(name) {
    return this.get_config(name);
  });
}
function addOptOutCheckMixpanelPeople(method) {
  return _addOptOutCheck(method, function(name) {
    return this._get_config(name);
  });
}
function addOptOutCheckMixpanelGroup(method) {
  return _addOptOutCheck(method, function(name) {
    return this._get_config(name);
  });
}
function clearOptInOut(token2, options) {
  options = options || {};
  _getStorage(options).remove(
    _getStorageKey(token2, options),
    !!options.crossSubdomainCookie,
    options.cookieDomain
  );
}
function _getStorage(options) {
  options = options || {};
  return options.persistenceType === "localStorage" ? _.localStorage : _.cookie;
}
function _getStorageKey(token2, options) {
  options = options || {};
  return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token2;
}
function _getStorageValue(token2, options) {
  return _getStorage(options).get(_getStorageKey(token2, options));
}
function _hasDoNotTrackFlagOn(options) {
  if (options && options.ignoreDnt) {
    return false;
  }
  var win$1 = options && options.window || win;
  var nav = win$1["navigator"] || {};
  var hasDntOn = false;
  _.each([
    nav["doNotTrack"],
    // standard
    nav["msDoNotTrack"],
    win$1["doNotTrack"]
  ], function(dntValue) {
    if (_.includes([true, 1, "1", "yes"], dntValue)) {
      hasDntOn = true;
    }
  });
  return hasDntOn;
}
function _optInOut(optValue, token2, options) {
  if (!_.isString(token2) || !token2.length) {
    console$1.error("gdpr." + (optValue ? "optIn" : "optOut") + " called with an invalid token");
    return;
  }
  options = options || {};
  _getStorage(options).set(
    _getStorageKey(token2, options),
    optValue ? 1 : 0,
    _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,
    !!options.crossSubdomainCookie,
    !!options.secureCookie,
    !!options.crossSiteCookie,
    options.cookieDomain
  );
  if (options.track && optValue) {
    options.track(options.trackEventName || "$opt_in", options.trackProperties, {
      "send_immediately": true
    });
  }
}
function _addOptOutCheck(method, getConfigValue) {
  return function() {
    var optedOut = false;
    try {
      var token2 = getConfigValue.call(this, "token");
      var ignoreDnt = getConfigValue.call(this, "ignore_dnt");
      var persistenceType = getConfigValue.call(this, "opt_out_tracking_persistence_type");
      var persistencePrefix = getConfigValue.call(this, "opt_out_tracking_cookie_prefix");
      var win2 = getConfigValue.call(this, "window");
      if (token2) {
        optedOut = hasOptedOut(token2, {
          ignoreDnt,
          persistenceType,
          persistencePrefix,
          window: win2
        });
      }
    } catch (err) {
      console$1.error("Unexpected error when checking tracking opt-out status: " + err);
    }
    if (!optedOut) {
      return method.apply(this, arguments);
    }
    var callback = arguments[arguments.length - 1];
    if (typeof callback === "function") {
      callback(0);
    }
    return;
  };
}
var logger$3 = console_with_prefix("lock");
var SharedLock = function(key, options) {
  options = options || {};
  this.storageKey = key;
  this.storage = options.storage || window.localStorage;
  this.pollIntervalMS = options.pollIntervalMS || 100;
  this.timeoutMS = options.timeoutMS || 2e3;
};
SharedLock.prototype.withLock = function(lockedCB, errorCB, pid) {
  if (!pid && typeof errorCB !== "function") {
    pid = errorCB;
    errorCB = null;
  }
  var i2 = pid || (/* @__PURE__ */ new Date()).getTime() + "|" + Math.random();
  var startTime = (/* @__PURE__ */ new Date()).getTime();
  var key = this.storageKey;
  var pollIntervalMS = this.pollIntervalMS;
  var timeoutMS = this.timeoutMS;
  var storage = this.storage;
  var keyX = key + ":X";
  var keyY = key + ":Y";
  var keyZ = key + ":Z";
  var reportError2 = function(err) {
    errorCB && errorCB(err);
  };
  var delay2 = function(cb2) {
    if ((/* @__PURE__ */ new Date()).getTime() - startTime > timeoutMS) {
      logger$3.error("Timeout waiting for mutex on " + key + "; clearing lock. [" + i2 + "]");
      storage.removeItem(keyZ);
      storage.removeItem(keyY);
      loop();
      return;
    }
    setTimeout(function() {
      try {
        cb2();
      } catch (err) {
        reportError2(err);
      }
    }, pollIntervalMS * (Math.random() + 0.1));
  };
  var waitFor = function(predicate, cb2) {
    if (predicate()) {
      cb2();
    } else {
      delay2(function() {
        waitFor(predicate, cb2);
      });
    }
  };
  var getSetY = function() {
    var valY = storage.getItem(keyY);
    if (valY && valY !== i2) {
      return false;
    } else {
      storage.setItem(keyY, i2);
      if (storage.getItem(keyY) === i2) {
        return true;
      } else {
        if (!localStorageSupported(storage, true)) {
          throw new Error("localStorage support dropped while acquiring lock");
        }
        return false;
      }
    }
  };
  var loop = function() {
    storage.setItem(keyX, i2);
    waitFor(getSetY, function() {
      if (storage.getItem(keyX) === i2) {
        criticalSection();
        return;
      }
      delay2(function() {
        if (storage.getItem(keyY) !== i2) {
          loop();
          return;
        }
        waitFor(function() {
          return !storage.getItem(keyZ);
        }, criticalSection);
      });
    });
  };
  var criticalSection = function() {
    storage.setItem(keyZ, "1");
    try {
      lockedCB();
    } finally {
      storage.removeItem(keyZ);
      if (storage.getItem(keyY) === i2) {
        storage.removeItem(keyY);
      }
      if (storage.getItem(keyX) === i2) {
        storage.removeItem(keyX);
      }
    }
  };
  try {
    if (localStorageSupported(storage, true)) {
      loop();
    } else {
      throw new Error("localStorage support check failed");
    }
  } catch (err) {
    reportError2(err);
  }
};
var logger$2 = console_with_prefix("batch");
var RequestQueue = function(storageKey2, options) {
  options = options || {};
  this.storageKey = storageKey2;
  this.storage = options.storage || window.localStorage;
  this.reportError = options.errorReporter || _.bind(logger$2.error, logger$2);
  this.lock = new SharedLock(storageKey2, { storage: this.storage });
  this.usePersistence = options.usePersistence;
  this.pid = options.pid || null;
  this.memQueue = [];
};
RequestQueue.prototype.enqueue = function(item, flushInterval, cb2) {
  var queueEntry = {
    "id": cheap_guid(),
    "flushAfter": (/* @__PURE__ */ new Date()).getTime() + flushInterval * 2,
    "payload": item
  };
  if (!this.usePersistence) {
    this.memQueue.push(queueEntry);
    if (cb2) {
      cb2(true);
    }
  } else {
    this.lock.withLock(_.bind(function lockAcquired() {
      var succeeded;
      try {
        var storedQueue = this.readFromStorage();
        storedQueue.push(queueEntry);
        succeeded = this.saveToStorage(storedQueue);
        if (succeeded) {
          this.memQueue.push(queueEntry);
        }
      } catch (err) {
        this.reportError("Error enqueueing item", item);
        succeeded = false;
      }
      if (cb2) {
        cb2(succeeded);
      }
    }, this), _.bind(function lockFailure(err) {
      this.reportError("Error acquiring storage lock", err);
      if (cb2) {
        cb2(false);
      }
    }, this), this.pid);
  }
};
RequestQueue.prototype.fillBatch = function(batchSize) {
  var batch = this.memQueue.slice(0, batchSize);
  if (this.usePersistence && batch.length < batchSize) {
    var storedQueue = this.readFromStorage();
    if (storedQueue.length) {
      var idsInBatch = {};
      _.each(batch, function(item2) {
        idsInBatch[item2["id"]] = true;
      });
      for (var i2 = 0; i2 < storedQueue.length; i2++) {
        var item = storedQueue[i2];
        if ((/* @__PURE__ */ new Date()).getTime() > item["flushAfter"] && !idsInBatch[item["id"]]) {
          item.orphaned = true;
          batch.push(item);
          if (batch.length >= batchSize) {
            break;
          }
        }
      }
    }
  }
  return batch;
};
var filterOutIDsAndInvalid = function(items, idSet) {
  var filteredItems = [];
  _.each(items, function(item) {
    if (item["id"] && !idSet[item["id"]]) {
      filteredItems.push(item);
    }
  });
  return filteredItems;
};
RequestQueue.prototype.removeItemsByID = function(ids, cb2) {
  var idSet = {};
  _.each(ids, function(id2) {
    idSet[id2] = true;
  });
  this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);
  if (!this.usePersistence) {
    if (cb2) {
      cb2(true);
    }
  } else {
    var removeFromStorage = _.bind(function() {
      var succeeded;
      try {
        var storedQueue = this.readFromStorage();
        storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);
        succeeded = this.saveToStorage(storedQueue);
        if (succeeded) {
          storedQueue = this.readFromStorage();
          for (var i2 = 0; i2 < storedQueue.length; i2++) {
            var item = storedQueue[i2];
            if (item["id"] && !!idSet[item["id"]]) {
              this.reportError("Item not removed from storage");
              return false;
            }
          }
        }
      } catch (err) {
        this.reportError("Error removing items", ids);
        succeeded = false;
      }
      return succeeded;
    }, this);
    this.lock.withLock(function lockAcquired() {
      var succeeded = removeFromStorage();
      if (cb2) {
        cb2(succeeded);
      }
    }, _.bind(function lockFailure(err) {
      var succeeded = false;
      this.reportError("Error acquiring storage lock", err);
      if (!localStorageSupported(this.storage, true)) {
        succeeded = removeFromStorage();
        if (!succeeded) {
          try {
            this.storage.removeItem(this.storageKey);
          } catch (err2) {
            this.reportError("Error clearing queue", err2);
          }
        }
      }
      if (cb2) {
        cb2(succeeded);
      }
    }, this), this.pid);
  }
};
var updatePayloads = function(existingItems, itemsToUpdate) {
  var newItems = [];
  _.each(existingItems, function(item) {
    var id2 = item["id"];
    if (id2 in itemsToUpdate) {
      var newPayload = itemsToUpdate[id2];
      if (newPayload !== null) {
        item["payload"] = newPayload;
        newItems.push(item);
      }
    } else {
      newItems.push(item);
    }
  });
  return newItems;
};
RequestQueue.prototype.updatePayloads = function(itemsToUpdate, cb2) {
  this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);
  if (!this.usePersistence) {
    if (cb2) {
      cb2(true);
    }
  } else {
    this.lock.withLock(_.bind(function lockAcquired() {
      var succeeded;
      try {
        var storedQueue = this.readFromStorage();
        storedQueue = updatePayloads(storedQueue, itemsToUpdate);
        succeeded = this.saveToStorage(storedQueue);
      } catch (err) {
        this.reportError("Error updating items", itemsToUpdate);
        succeeded = false;
      }
      if (cb2) {
        cb2(succeeded);
      }
    }, this), _.bind(function lockFailure(err) {
      this.reportError("Error acquiring storage lock", err);
      if (cb2) {
        cb2(false);
      }
    }, this), this.pid);
  }
};
RequestQueue.prototype.readFromStorage = function() {
  var storageEntry;
  try {
    storageEntry = this.storage.getItem(this.storageKey);
    if (storageEntry) {
      storageEntry = JSONParse(storageEntry);
      if (!_.isArray(storageEntry)) {
        this.reportError("Invalid storage entry:", storageEntry);
        storageEntry = null;
      }
    }
  } catch (err) {
    this.reportError("Error retrieving queue", err);
    storageEntry = null;
  }
  return storageEntry || [];
};
RequestQueue.prototype.saveToStorage = function(queue) {
  try {
    this.storage.setItem(this.storageKey, JSONStringify(queue));
    return true;
  } catch (err) {
    this.reportError("Error saving queue", err);
    return false;
  }
};
RequestQueue.prototype.clear = function() {
  this.memQueue = [];
  if (this.usePersistence) {
    this.storage.removeItem(this.storageKey);
  }
};
var MAX_RETRY_INTERVAL_MS = 10 * 60 * 1e3;
var logger$1 = console_with_prefix("batch");
var RequestBatcher = function(storageKey2, options) {
  this.errorReporter = options.errorReporter;
  this.queue = new RequestQueue(storageKey2, {
    errorReporter: _.bind(this.reportError, this),
    storage: options.storage,
    usePersistence: options.usePersistence
  });
  this.libConfig = options.libConfig;
  this.sendRequest = options.sendRequestFunc;
  this.beforeSendHook = options.beforeSendHook;
  this.stopAllBatching = options.stopAllBatchingFunc;
  this.batchSize = this.libConfig["batch_size"];
  this.flushInterval = this.libConfig["batch_flush_interval_ms"];
  this.stopped = !this.libConfig["batch_autostart"];
  this.consecutiveRemovalFailures = 0;
  this.itemIdsSentSuccessfully = {};
  this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;
};
RequestBatcher.prototype.enqueue = function(item, cb2) {
  this.queue.enqueue(item, this.flushInterval, cb2);
};
RequestBatcher.prototype.start = function() {
  this.stopped = false;
  this.consecutiveRemovalFailures = 0;
  this.flush();
};
RequestBatcher.prototype.stop = function() {
  this.stopped = true;
  if (this.timeoutID) {
    clearTimeout(this.timeoutID);
    this.timeoutID = null;
  }
};
RequestBatcher.prototype.clear = function() {
  this.queue.clear();
};
RequestBatcher.prototype.resetBatchSize = function() {
  this.batchSize = this.libConfig["batch_size"];
};
RequestBatcher.prototype.resetFlush = function() {
  this.scheduleFlush(this.libConfig["batch_flush_interval_ms"]);
};
RequestBatcher.prototype.scheduleFlush = function(flushMS) {
  this.flushInterval = flushMS;
  if (!this.stopped) {
    this.timeoutID = setTimeout(_.bind(function() {
      if (!this.stopped) {
        this.flush();
      }
    }, this), this.flushInterval);
  }
};
RequestBatcher.prototype.flush = function(options) {
  try {
    if (this.requestInProgress) {
      logger$1.log("Flush: Request already in progress");
      return;
    }
    options = options || {};
    var timeoutMS = this.libConfig["batch_request_timeout_ms"];
    var startTime = (/* @__PURE__ */ new Date()).getTime();
    var currentBatchSize = this.batchSize;
    var batch = this.queue.fillBatch(currentBatchSize);
    var attemptSecondaryFlush = batch.length === currentBatchSize;
    var dataForRequest = [];
    var transformedItems = {};
    _.each(batch, function(item) {
      var payload = item["payload"];
      if (this.beforeSendHook && !item.orphaned) {
        payload = this.beforeSendHook(payload);
      }
      if (payload) {
        if (payload["event"] && payload["properties"]) {
          payload["properties"] = _.extend(
            {},
            payload["properties"],
            { "mp_sent_by_lib_version": Config.LIB_VERSION }
          );
        }
        var addPayload = true;
        var itemId = item["id"];
        if (itemId) {
          if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {
            this.reportError("[dupe] item ID sent too many times, not sending", {
              item,
              batchSize: batch.length,
              timesSent: this.itemIdsSentSuccessfully[itemId]
            });
            addPayload = false;
          }
        } else {
          this.reportError("[dupe] found item with no ID", { item });
        }
        if (addPayload) {
          dataForRequest.push(payload);
        }
      }
      transformedItems[item["id"]] = payload;
    }, this);
    if (dataForRequest.length < 1) {
      this.resetFlush();
      return;
    }
    this.requestInProgress = true;
    var batchSendCallback = _.bind(function(res) {
      this.requestInProgress = false;
      try {
        var removeItemsFromQueue = false;
        if (options.unloading) {
          this.queue.updatePayloads(transformedItems);
        } else if (_.isObject(res) && res.error === "timeout" && (/* @__PURE__ */ new Date()).getTime() - startTime >= timeoutMS) {
          this.reportError("Network timeout; retrying");
          this.flush();
        } else if (_.isObject(res) && (res.httpStatusCode >= 500 || res.httpStatusCode === 429 || res.error === "timeout")) {
          var retryMS = this.flushInterval * 2;
          if (res.retryAfter) {
            retryMS = parseInt(res.retryAfter, 10) * 1e3 || retryMS;
          }
          retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);
          this.reportError("Error; retry in " + retryMS + " ms");
          this.scheduleFlush(retryMS);
        } else if (_.isObject(res) && res.httpStatusCode === 413) {
          if (batch.length > 1) {
            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));
            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);
            this.reportError("413 response; reducing batch size to " + this.batchSize);
            this.resetFlush();
          } else {
            this.reportError("Single-event request too large; dropping", batch);
            this.resetBatchSize();
            removeItemsFromQueue = true;
          }
        } else {
          removeItemsFromQueue = true;
        }
        if (removeItemsFromQueue) {
          this.queue.removeItemsByID(
            _.map(batch, function(item) {
              return item["id"];
            }),
            _.bind(function(succeeded) {
              if (succeeded) {
                this.consecutiveRemovalFailures = 0;
                if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {
                  this.resetFlush();
                } else {
                  this.flush();
                }
              } else {
                this.reportError("Failed to remove items from queue");
                if (++this.consecutiveRemovalFailures > 5) {
                  this.reportError("Too many queue failures; disabling batching system.");
                  this.stopAllBatching();
                } else {
                  this.resetFlush();
                }
              }
            }, this)
          );
          _.each(batch, _.bind(function(item) {
            var itemId = item["id"];
            if (itemId) {
              this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;
              this.itemIdsSentSuccessfully[itemId]++;
              if (this.itemIdsSentSuccessfully[itemId] > 5) {
                this.reportError("[dupe] item ID sent too many times", {
                  item,
                  batchSize: batch.length,
                  timesSent: this.itemIdsSentSuccessfully[itemId]
                });
              }
            } else {
              this.reportError("[dupe] found item with no ID while removing", { item });
            }
          }, this));
        }
      } catch (err) {
        this.reportError("Error handling API response", err);
        this.resetFlush();
      }
    }, this);
    var requestOptions = {
      method: "POST",
      verbose: true,
      ignore_json_errors: true,
      // eslint-disable-line camelcase
      timeout_ms: timeoutMS
      // eslint-disable-line camelcase
    };
    if (options.unloading) {
      requestOptions.transport = "sendBeacon";
    }
    logger$1.log("MIXPANEL REQUEST:", dataForRequest);
    this.sendRequest(dataForRequest, requestOptions, batchSendCallback);
  } catch (err) {
    this.reportError("Error flushing request queue", err);
    this.resetFlush();
  }
};
RequestBatcher.prototype.reportError = function(msg, err) {
  logger$1.error.apply(logger$1.error, arguments);
  if (this.errorReporter) {
    try {
      if (!(err instanceof Error)) {
        err = new Error(msg);
      }
      this.errorReporter(msg, err);
    } catch (err2) {
      logger$1.error(err2);
    }
  }
};
var logger = console_with_prefix("recorder");
var CompressionStream = win["CompressionStream"];
var RECORDER_BATCHER_LIB_CONFIG = {
  "batch_size": 1e3,
  "batch_flush_interval_ms": 10 * 1e3,
  "batch_request_timeout_ms": 90 * 1e3,
  "batch_autostart": true
};
var ACTIVE_SOURCES = /* @__PURE__ */ new Set([
  IncrementalSource.MouseMove,
  IncrementalSource.MouseInteraction,
  IncrementalSource.Scroll,
  IncrementalSource.ViewportResize,
  IncrementalSource.Input,
  IncrementalSource.TouchMove,
  IncrementalSource.MediaInteraction,
  IncrementalSource.Drag,
  IncrementalSource.Selection
]);
function isUserEvent(ev) {
  return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);
}
var MixpanelRecorder = function(mixpanelInstance) {
  this._mixpanel = mixpanelInstance;
  this._stopRecording = null;
  this.recEvents = [];
  this.seqNo = 0;
  this.replayId = null;
  this.replayStartTime = null;
  this.sendBatchId = null;
  this.idleTimeoutId = null;
  this.maxTimeoutId = null;
  this.recordMaxMs = MAX_RECORDING_MS;
  this._initBatcher();
};
MixpanelRecorder.prototype._initBatcher = function() {
  this.batcher = new RequestBatcher("__mprec", {
    libConfig: RECORDER_BATCHER_LIB_CONFIG,
    sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),
    errorReporter: _.bind(this.reportError, this),
    flushOnlyOnInterval: true,
    usePersistence: false
  });
};
MixpanelRecorder.prototype.get_config = function(configVar) {
  return this._mixpanel.get_config(configVar);
};
MixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {
  if (this._stopRecording !== null) {
    logger.log("Recording already in progress, skipping startRecording.");
    return;
  }
  this.recordMaxMs = this.get_config("record_max_ms");
  if (this.recordMaxMs > MAX_RECORDING_MS) {
    this.recordMaxMs = MAX_RECORDING_MS;
    logger.critical("record_max_ms cannot be greater than " + MAX_RECORDING_MS + "ms. Capping value.");
  }
  this.recEvents = [];
  this.seqNo = 0;
  this.replayStartTime = null;
  this.replayId = _.UUID();
  if (shouldStopBatcher) {
    this.batcher.stop();
  } else {
    this.batcher.start();
  }
  var resetIdleTimeout = _.bind(function() {
    clearTimeout(this.idleTimeoutId);
    this.idleTimeoutId = setTimeout(_.bind(function() {
      logger.log("Idle timeout reached, restarting recording.");
      this.resetRecording();
    }, this), this.get_config("record_idle_timeout_ms"));
  }, this);
  this._stopRecording = record({
    "emit": _.bind(function(ev) {
      this.batcher.enqueue(ev);
      if (isUserEvent(ev)) {
        if (this.batcher.stopped) {
          this.batcher.start();
        }
        resetIdleTimeout();
      }
    }, this),
    "blockClass": this.get_config("record_block_class"),
    "blockSelector": this.get_config("record_block_selector"),
    "collectFonts": this.get_config("record_collect_fonts"),
    "inlineImages": this.get_config("record_inline_images"),
    "maskAllInputs": true,
    "maskTextClass": this.get_config("record_mask_text_class"),
    "maskTextSelector": this.get_config("record_mask_text_selector")
  });
  resetIdleTimeout();
  this.maxTimeoutId = setTimeout(_.bind(this.resetRecording, this), this.recordMaxMs);
};
MixpanelRecorder.prototype.resetRecording = function() {
  this.stopRecording();
  this.startRecording(true);
};
MixpanelRecorder.prototype.stopRecording = function() {
  if (this._stopRecording !== null) {
    this._stopRecording();
    this._stopRecording = null;
  }
  if (this.batcher.stopped) {
    this.batcher.clear();
  } else {
    this.batcher.flush();
    this.batcher.stop();
  }
  this.replayId = null;
  clearTimeout(this.idleTimeoutId);
  clearTimeout(this.maxTimeoutId);
};
MixpanelRecorder.prototype.flushEventsWithOptOut = function(data2, options, cb2) {
  this._flushEvents(data2, options, cb2, _.bind(this._onOptOut, this));
};
MixpanelRecorder.prototype._onOptOut = function(code2) {
  if (code2 === 0) {
    this.recEvents = [];
    this.stopRecording();
  }
};
MixpanelRecorder.prototype._sendRequest = function(reqParams, reqBody, callback) {
  var onSuccess = _.bind(function(response, responseBody) {
    if (response.status === 200) {
      this.seqNo++;
    }
    callback({
      status: 0,
      httpStatusCode: response.status,
      responseBody,
      retryAfter: response.headers.get("Retry-After")
    });
  }, this);
  win["fetch"](this.get_config("api_host") + "/" + this.get_config("api_routes")["record"] + "?" + new URLSearchParams(reqParams), {
    "method": "POST",
    "headers": {
      "Authorization": "Basic " + btoa(this.get_config("token") + ":"),
      "Content-Type": "application/octet-stream"
    },
    "body": reqBody
  }).then(function(response) {
    response.json().then(function(responseBody) {
      onSuccess(response, responseBody);
    }).catch(function(error) {
      callback({ error });
    });
  }).catch(function(error) {
    callback({ error });
  });
};
MixpanelRecorder.prototype._flushEvents = addOptOutCheckMixpanelLib(function(data2, options, callback) {
  const numEvents = data2.length;
  if (numEvents > 0) {
    var batchStartTime = data2[0].timestamp;
    if (this.seqNo === 0) {
      this.replayStartTime = batchStartTime;
    }
    var replayLengthMs = data2[numEvents - 1].timestamp - this.replayStartTime;
    var reqParams = {
      "distinct_id": String(this._mixpanel.get_distinct_id()),
      "seq": this.seqNo,
      "batch_start_time": batchStartTime / 1e3,
      "replay_id": this.replayId,
      "replay_length_ms": replayLengthMs,
      "replay_start_time": this.replayStartTime / 1e3
    };
    var eventsJson = _.JSONEncode(data2);
    var deviceId = this._mixpanel.get_property("$device_id");
    if (deviceId) {
      reqParams["$device_id"] = deviceId;
    }
    var userId = this._mixpanel.get_property("$user_id");
    if (userId) {
      reqParams["$user_id"] = userId;
    }
    if (CompressionStream) {
      var jsonStream = new Blob([eventsJson], { type: "application/json" }).stream();
      var gzipStream = jsonStream.pipeThrough(new CompressionStream("gzip"));
      new Response(gzipStream).blob().then(_.bind(function(compressedBlob) {
        reqParams["format"] = "gzip";
        this._sendRequest(reqParams, compressedBlob, callback);
      }, this));
    } else {
      reqParams["format"] = "body";
      this._sendRequest(reqParams, eventsJson, callback);
    }
  }
});
MixpanelRecorder.prototype.reportError = function(msg, err) {
  logger.error.apply(logger.error, arguments);
  try {
    if (!err && !(msg instanceof Error)) {
      msg = new Error(msg);
    }
    this.get_config("error_reporter")(msg, err);
  } catch (err2) {
    logger.error(err2);
  }
};
win["__mp_recorder"] = MixpanelRecorder;
var DomTracker = function() {
};
DomTracker.prototype.create_properties = function() {
};
DomTracker.prototype.event_handler = function() {
};
DomTracker.prototype.after_track_handler = function() {
};
DomTracker.prototype.init = function(mixpanel_instance) {
  this.mp = mixpanel_instance;
  return this;
};
DomTracker.prototype.track = function(query, event_name, properties, user_callback) {
  var that = this;
  var elements = _.dom_query(query);
  if (elements.length === 0) {
    console$1.error("The DOM query (" + query + ") returned 0 elements");
    return;
  }
  _.each(elements, function(element2) {
    _.register_event(element2, this.override_event, function(e2) {
      var options = {};
      var props = that.create_properties(properties, this);
      var timeout = that.mp.get_config("track_links_timeout");
      that.event_handler(e2, this, options);
      window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);
      that.mp.track(event_name, props, that.track_callback(user_callback, props, options));
    });
  }, this);
  return true;
};
DomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {
  timeout_occured = timeout_occured || false;
  var that = this;
  return function() {
    if (options.callback_fired) {
      return;
    }
    options.callback_fired = true;
    if (user_callback && user_callback(timeout_occured, props) === false) {
      return;
    }
    that.after_track_handler(props, options, timeout_occured);
  };
};
DomTracker.prototype.create_properties = function(properties, element2) {
  var props;
  if (typeof properties === "function") {
    props = properties(element2);
  } else {
    props = _.extend({}, properties);
  }
  return props;
};
var LinkTracker = function() {
  this.override_event = "click";
};
_.inherit(LinkTracker, DomTracker);
LinkTracker.prototype.create_properties = function(properties, element2) {
  var props = LinkTracker.superclass.create_properties.apply(this, arguments);
  if (element2.href) {
    props["url"] = element2.href;
  }
  return props;
};
LinkTracker.prototype.event_handler = function(evt, element2, options) {
  options.new_tab = evt.which === 2 || evt.metaKey || evt.ctrlKey || element2.target === "_blank";
  options.href = element2.href;
  if (!options.new_tab) {
    evt.preventDefault();
  }
};
LinkTracker.prototype.after_track_handler = function(props, options) {
  if (options.new_tab) {
    return;
  }
  setTimeout(function() {
    window.location = options.href;
  }, 0);
};
var FormTracker = function() {
  this.override_event = "submit";
};
_.inherit(FormTracker, DomTracker);
FormTracker.prototype.event_handler = function(evt, element2, options) {
  options.element = element2;
  evt.preventDefault();
};
FormTracker.prototype.after_track_handler = function(props, options) {
  setTimeout(function() {
    options.element.submit();
  }, 0);
};
var SET_ACTION = "$set";
var SET_ONCE_ACTION = "$set_once";
var UNSET_ACTION = "$unset";
var ADD_ACTION = "$add";
var APPEND_ACTION = "$append";
var UNION_ACTION = "$union";
var REMOVE_ACTION = "$remove";
var DELETE_ACTION = "$delete";
var apiActions = {
  set_action: function(prop, to) {
    var data2 = {};
    var $set = {};
    if (_.isObject(prop)) {
      _.each(prop, function(v2, k2) {
        if (!this._is_reserved_property(k2)) {
          $set[k2] = v2;
        }
      }, this);
    } else {
      $set[prop] = to;
    }
    data2[SET_ACTION] = $set;
    return data2;
  },
  unset_action: function(prop) {
    var data2 = {};
    var $unset = [];
    if (!_.isArray(prop)) {
      prop = [prop];
    }
    _.each(prop, function(k2) {
      if (!this._is_reserved_property(k2)) {
        $unset.push(k2);
      }
    }, this);
    data2[UNSET_ACTION] = $unset;
    return data2;
  },
  set_once_action: function(prop, to) {
    var data2 = {};
    var $set_once = {};
    if (_.isObject(prop)) {
      _.each(prop, function(v2, k2) {
        if (!this._is_reserved_property(k2)) {
          $set_once[k2] = v2;
        }
      }, this);
    } else {
      $set_once[prop] = to;
    }
    data2[SET_ONCE_ACTION] = $set_once;
    return data2;
  },
  union_action: function(list_name, values) {
    var data2 = {};
    var $union = {};
    if (_.isObject(list_name)) {
      _.each(list_name, function(v2, k2) {
        if (!this._is_reserved_property(k2)) {
          $union[k2] = _.isArray(v2) ? v2 : [v2];
        }
      }, this);
    } else {
      $union[list_name] = _.isArray(values) ? values : [values];
    }
    data2[UNION_ACTION] = $union;
    return data2;
  },
  append_action: function(list_name, value) {
    var data2 = {};
    var $append = {};
    if (_.isObject(list_name)) {
      _.each(list_name, function(v2, k2) {
        if (!this._is_reserved_property(k2)) {
          $append[k2] = v2;
        }
      }, this);
    } else {
      $append[list_name] = value;
    }
    data2[APPEND_ACTION] = $append;
    return data2;
  },
  remove_action: function(list_name, value) {
    var data2 = {};
    var $remove = {};
    if (_.isObject(list_name)) {
      _.each(list_name, function(v2, k2) {
        if (!this._is_reserved_property(k2)) {
          $remove[k2] = v2;
        }
      }, this);
    } else {
      $remove[list_name] = value;
    }
    data2[REMOVE_ACTION] = $remove;
    return data2;
  },
  delete_action: function() {
    var data2 = {};
    data2[DELETE_ACTION] = "";
    return data2;
  }
};
var MixpanelGroup = function() {
};
_.extend(MixpanelGroup.prototype, apiActions);
MixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {
  this._mixpanel = mixpanel_instance;
  this._group_key = group_key;
  this._group_id = group_id;
};
MixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {
  var data2 = this.set_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {
  var data2 = this.set_once_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {
  var data2 = this.unset_action(prop);
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {
  if (_.isObject(list_name)) {
    callback = values;
  }
  var data2 = this.union_action(list_name, values);
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype["delete"] = addOptOutCheckMixpanelGroup(function(callback) {
  var data2 = this.delete_action();
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {
  var data2 = this.remove_action(list_name, value);
  return this._send_request(data2, callback);
});
MixpanelGroup.prototype._send_request = function(data2, callback) {
  data2["$group_key"] = this._group_key;
  data2["$group_id"] = this._group_id;
  data2["$token"] = this._get_config("token");
  var date_encoded_data = _.encodeDates(data2);
  return this._mixpanel._track_or_batch({
    type: "groups",
    data: date_encoded_data,
    endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes")["groups"],
    batcher: this._mixpanel.request_batchers.groups
  }, callback);
};
MixpanelGroup.prototype._is_reserved_property = function(prop) {
  return prop === "$group_key" || prop === "$group_id";
};
MixpanelGroup.prototype._get_config = function(conf) {
  return this._mixpanel.get_config(conf);
};
MixpanelGroup.prototype.toString = function() {
  return this._mixpanel.toString() + ".group." + this._group_key + "." + this._group_id;
};
MixpanelGroup.prototype["remove"] = MixpanelGroup.prototype.remove;
MixpanelGroup.prototype["set"] = MixpanelGroup.prototype.set;
MixpanelGroup.prototype["set_once"] = MixpanelGroup.prototype.set_once;
MixpanelGroup.prototype["union"] = MixpanelGroup.prototype.union;
MixpanelGroup.prototype["unset"] = MixpanelGroup.prototype.unset;
MixpanelGroup.prototype["toString"] = MixpanelGroup.prototype.toString;
var MixpanelPeople = function() {
};
_.extend(MixpanelPeople.prototype, apiActions);
MixpanelPeople.prototype._init = function(mixpanel_instance) {
  this._mixpanel = mixpanel_instance;
};
MixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {
  var data2 = this.set_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  if (this._get_config("save_referrer")) {
    this._mixpanel["persistence"].update_referrer_info(document.referrer);
  }
  data2[SET_ACTION] = _.extend(
    {},
    _.info.people_properties(),
    data2[SET_ACTION]
  );
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {
  var data2 = this.set_once_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {
  var data2 = this.unset_action(prop);
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {
  var data2 = {};
  var $add = {};
  if (_.isObject(prop)) {
    _.each(prop, function(v2, k2) {
      if (!this._is_reserved_property(k2)) {
        if (isNaN(parseFloat(v2))) {
          console$1.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
          return;
        } else {
          $add[k2] = v2;
        }
      }
    }, this);
    callback = by;
  } else {
    if (_.isUndefined(by)) {
      by = 1;
    }
    $add[prop] = by;
  }
  data2[ADD_ACTION] = $add;
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {
  if (_.isObject(list_name)) {
    callback = value;
  }
  var data2 = this.append_action(list_name, value);
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {
  if (_.isObject(list_name)) {
    callback = value;
  }
  var data2 = this.remove_action(list_name, value);
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {
  if (_.isObject(list_name)) {
    callback = values;
  }
  var data2 = this.union_action(list_name, values);
  return this._send_request(data2, callback);
});
MixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {
  if (!_.isNumber(amount)) {
    amount = parseFloat(amount);
    if (isNaN(amount)) {
      console$1.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
      return;
    }
  }
  return this.append("$transactions", _.extend({
    "$amount": amount
  }, properties), callback);
});
MixpanelPeople.prototype.clear_charges = function(callback) {
  return this.set("$transactions", [], callback);
};
MixpanelPeople.prototype.delete_user = function() {
  if (!this._identify_called()) {
    console$1.error("mixpanel.people.delete_user() requires you to call identify() first");
    return;
  }
  var data2 = { "$delete": this._mixpanel.get_distinct_id() };
  return this._send_request(data2);
};
MixpanelPeople.prototype.toString = function() {
  return this._mixpanel.toString() + ".people";
};
MixpanelPeople.prototype._send_request = function(data2, callback) {
  data2["$token"] = this._get_config("token");
  data2["$distinct_id"] = this._mixpanel.get_distinct_id();
  var device_id = this._mixpanel.get_property("$device_id");
  var user_id = this._mixpanel.get_property("$user_id");
  var had_persisted_distinct_id = this._mixpanel.get_property("$had_persisted_distinct_id");
  if (device_id) {
    data2["$device_id"] = device_id;
  }
  if (user_id) {
    data2["$user_id"] = user_id;
  }
  if (had_persisted_distinct_id) {
    data2["$had_persisted_distinct_id"] = had_persisted_distinct_id;
  }
  var date_encoded_data = _.encodeDates(data2);
  if (!this._identify_called()) {
    this._enqueue(data2);
    if (!_.isUndefined(callback)) {
      if (this._get_config("verbose")) {
        callback({ status: -1, error: null });
      } else {
        callback(-1);
      }
    }
    return _.truncate(date_encoded_data, 255);
  }
  return this._mixpanel._track_or_batch({
    type: "people",
    data: date_encoded_data,
    endpoint: this._get_config("api_host") + "/" + this._get_config("api_routes")["engage"],
    batcher: this._mixpanel.request_batchers.people
  }, callback);
};
MixpanelPeople.prototype._get_config = function(conf_var) {
  return this._mixpanel.get_config(conf_var);
};
MixpanelPeople.prototype._identify_called = function() {
  return this._mixpanel._flags.identify_called === true;
};
MixpanelPeople.prototype._enqueue = function(data2) {
  if (SET_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(SET_ACTION, data2);
  } else if (SET_ONCE_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(SET_ONCE_ACTION, data2);
  } else if (UNSET_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(UNSET_ACTION, data2);
  } else if (ADD_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(ADD_ACTION, data2);
  } else if (APPEND_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(APPEND_ACTION, data2);
  } else if (REMOVE_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(REMOVE_ACTION, data2);
  } else if (UNION_ACTION in data2) {
    this._mixpanel["persistence"]._add_to_people_queue(UNION_ACTION, data2);
  } else {
    console$1.error("Invalid call to _enqueue():", data2);
  }
};
MixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {
  var _this = this;
  var queued_data = _.extend({}, this._mixpanel["persistence"].load_queue(action));
  var action_params = queued_data;
  if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {
    _this._mixpanel["persistence"]._pop_from_people_queue(action, queued_data);
    _this._mixpanel["persistence"].save();
    if (queue_to_params_fn) {
      action_params = queue_to_params_fn(queued_data);
    }
    action_method.call(_this, action_params, function(response, data2) {
      if (response === 0) {
        _this._mixpanel["persistence"]._add_to_people_queue(action, queued_data);
      }
      if (!_.isUndefined(callback)) {
        callback(response, data2);
      }
    });
  }
};
MixpanelPeople.prototype._flush = function(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {
  var _this = this;
  this._flush_one_queue(SET_ACTION, this.set, _set_callback);
  this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);
  this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) {
    return _.keys(queue);
  });
  this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);
  this._flush_one_queue(UNION_ACTION, this.union, _union_callback);
  var $append_queue = this._mixpanel["persistence"].load_queue(APPEND_ACTION);
  if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {
    var $append_item;
    var append_callback = function(response, data2) {
      if (response === 0) {
        _this._mixpanel["persistence"]._add_to_people_queue(APPEND_ACTION, $append_item);
      }
      if (!_.isUndefined(_append_callback)) {
        _append_callback(response, data2);
      }
    };
    for (var i2 = $append_queue.length - 1; i2 >= 0; i2--) {
      $append_queue = this._mixpanel["persistence"].load_queue(APPEND_ACTION);
      $append_item = $append_queue.pop();
      _this._mixpanel["persistence"].save();
      if (!_.isEmptyObject($append_item)) {
        _this.append($append_item, append_callback);
      }
    }
  }
  var $remove_queue = this._mixpanel["persistence"].load_queue(REMOVE_ACTION);
  if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {
    var $remove_item;
    var remove_callback = function(response, data2) {
      if (response === 0) {
        _this._mixpanel["persistence"]._add_to_people_queue(REMOVE_ACTION, $remove_item);
      }
      if (!_.isUndefined(_remove_callback)) {
        _remove_callback(response, data2);
      }
    };
    for (var j = $remove_queue.length - 1; j >= 0; j--) {
      $remove_queue = this._mixpanel["persistence"].load_queue(REMOVE_ACTION);
      $remove_item = $remove_queue.pop();
      _this._mixpanel["persistence"].save();
      if (!_.isEmptyObject($remove_item)) {
        _this.remove($remove_item, remove_callback);
      }
    }
  }
};
MixpanelPeople.prototype._is_reserved_property = function(prop) {
  return prop === "$distinct_id" || prop === "$token" || prop === "$device_id" || prop === "$user_id" || prop === "$had_persisted_distinct_id";
};
MixpanelPeople.prototype["set"] = MixpanelPeople.prototype.set;
MixpanelPeople.prototype["set_once"] = MixpanelPeople.prototype.set_once;
MixpanelPeople.prototype["unset"] = MixpanelPeople.prototype.unset;
MixpanelPeople.prototype["increment"] = MixpanelPeople.prototype.increment;
MixpanelPeople.prototype["append"] = MixpanelPeople.prototype.append;
MixpanelPeople.prototype["remove"] = MixpanelPeople.prototype.remove;
MixpanelPeople.prototype["union"] = MixpanelPeople.prototype.union;
MixpanelPeople.prototype["track_charge"] = MixpanelPeople.prototype.track_charge;
MixpanelPeople.prototype["clear_charges"] = MixpanelPeople.prototype.clear_charges;
MixpanelPeople.prototype["delete_user"] = MixpanelPeople.prototype.delete_user;
MixpanelPeople.prototype["toString"] = MixpanelPeople.prototype.toString;
var SET_QUEUE_KEY = "__mps";
var SET_ONCE_QUEUE_KEY = "__mpso";
var UNSET_QUEUE_KEY = "__mpus";
var ADD_QUEUE_KEY = "__mpa";
var APPEND_QUEUE_KEY = "__mpap";
var REMOVE_QUEUE_KEY = "__mpr";
var UNION_QUEUE_KEY = "__mpu";
var PEOPLE_DISTINCT_ID_KEY = "$people_distinct_id";
var ALIAS_ID_KEY = "__alias";
var EVENT_TIMERS_KEY = "__timers";
var RESERVED_PROPERTIES = [
  SET_QUEUE_KEY,
  SET_ONCE_QUEUE_KEY,
  UNSET_QUEUE_KEY,
  ADD_QUEUE_KEY,
  APPEND_QUEUE_KEY,
  REMOVE_QUEUE_KEY,
  UNION_QUEUE_KEY,
  PEOPLE_DISTINCT_ID_KEY,
  ALIAS_ID_KEY,
  EVENT_TIMERS_KEY
];
var MixpanelPersistence = function(config) {
  this["props"] = {};
  this.campaign_params_saved = false;
  if (config["persistence_name"]) {
    this.name = "mp_" + config["persistence_name"];
  } else {
    this.name = "mp_" + config["token"] + "_mixpanel";
  }
  var storage_type = config["persistence"];
  if (storage_type !== "cookie" && storage_type !== "localStorage") {
    console$1.critical("Unknown persistence type " + storage_type + "; falling back to cookie");
    storage_type = config["persistence"] = "cookie";
  }
  if (storage_type === "localStorage" && _.localStorage.is_supported()) {
    this.storage = _.localStorage;
  } else {
    this.storage = _.cookie;
  }
  this.load();
  this.update_config(config);
  this.upgrade();
  this.save();
};
MixpanelPersistence.prototype.properties = function() {
  var p2 = {};
  this.load();
  _.each(this["props"], function(v2, k2) {
    if (!_.include(RESERVED_PROPERTIES, k2)) {
      p2[k2] = v2;
    }
  });
  return p2;
};
MixpanelPersistence.prototype.load = function() {
  if (this.disabled) {
    return;
  }
  var entry = this.storage.parse(this.name);
  if (entry) {
    this["props"] = _.extend({}, entry);
  }
};
MixpanelPersistence.prototype.upgrade = function() {
  var old_cookie, old_localstorage;
  if (this.storage === _.localStorage) {
    old_cookie = _.cookie.parse(this.name);
    _.cookie.remove(this.name);
    _.cookie.remove(this.name, true);
    if (old_cookie) {
      this.register_once(old_cookie);
    }
  } else if (this.storage === _.cookie) {
    old_localstorage = _.localStorage.parse(this.name);
    _.localStorage.remove(this.name);
    if (old_localstorage) {
      this.register_once(old_localstorage);
    }
  }
};
MixpanelPersistence.prototype.save = function() {
  if (this.disabled) {
    return;
  }
  this.storage.set(
    this.name,
    _.JSONEncode(this["props"]),
    this.expire_days,
    this.cross_subdomain,
    this.secure,
    this.cross_site,
    this.cookie_domain
  );
};
MixpanelPersistence.prototype.load_prop = function(key) {
  this.load();
  return this["props"][key];
};
MixpanelPersistence.prototype.remove = function() {
  this.storage.remove(this.name, false, this.cookie_domain);
  this.storage.remove(this.name, true, this.cookie_domain);
};
MixpanelPersistence.prototype.clear = function() {
  this.remove();
  this["props"] = {};
};
MixpanelPersistence.prototype.register_once = function(props, default_value, days) {
  if (_.isObject(props)) {
    if (typeof default_value === "undefined") {
      default_value = "None";
    }
    this.expire_days = typeof days === "undefined" ? this.default_expiry : days;
    this.load();
    _.each(props, function(val, prop) {
      if (!this["props"].hasOwnProperty(prop) || this["props"][prop] === default_value) {
        this["props"][prop] = val;
      }
    }, this);
    this.save();
    return true;
  }
  return false;
};
MixpanelPersistence.prototype.register = function(props, days) {
  if (_.isObject(props)) {
    this.expire_days = typeof days === "undefined" ? this.default_expiry : days;
    this.load();
    _.extend(this["props"], props);
    this.save();
    return true;
  }
  return false;
};
MixpanelPersistence.prototype.unregister = function(prop) {
  this.load();
  if (prop in this["props"]) {
    delete this["props"][prop];
    this.save();
  }
};
MixpanelPersistence.prototype.update_search_keyword = function(referrer) {
  this.register(_.info.searchInfo(referrer));
};
MixpanelPersistence.prototype.update_referrer_info = function(referrer) {
  this.register_once({
    "$initial_referrer": referrer || "$direct",
    "$initial_referring_domain": _.info.referringDomain(referrer) || "$direct"
  }, "");
};
MixpanelPersistence.prototype.get_referrer_info = function() {
  return _.strip_empty_properties({
    "$initial_referrer": this["props"]["$initial_referrer"],
    "$initial_referring_domain": this["props"]["$initial_referring_domain"]
  });
};
MixpanelPersistence.prototype.update_config = function(config) {
  this.default_expiry = this.expire_days = config["cookie_expiration"];
  this.set_disabled(config["disable_persistence"]);
  this.set_cookie_domain(config["cookie_domain"]);
  this.set_cross_site(config["cross_site_cookie"]);
  this.set_cross_subdomain(config["cross_subdomain_cookie"]);
  this.set_secure(config["secure_cookie"]);
};
MixpanelPersistence.prototype.set_disabled = function(disabled) {
  this.disabled = disabled;
  if (this.disabled) {
    this.remove();
  } else {
    this.save();
  }
};
MixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {
  if (cookie_domain !== this.cookie_domain) {
    this.remove();
    this.cookie_domain = cookie_domain;
    this.save();
  }
};
MixpanelPersistence.prototype.set_cross_site = function(cross_site) {
  if (cross_site !== this.cross_site) {
    this.cross_site = cross_site;
    this.remove();
    this.save();
  }
};
MixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {
  if (cross_subdomain !== this.cross_subdomain) {
    this.cross_subdomain = cross_subdomain;
    this.remove();
    this.save();
  }
};
MixpanelPersistence.prototype.get_cross_subdomain = function() {
  return this.cross_subdomain;
};
MixpanelPersistence.prototype.set_secure = function(secure) {
  if (secure !== this.secure) {
    this.secure = secure ? true : false;
    this.remove();
    this.save();
  }
};
MixpanelPersistence.prototype._add_to_people_queue = function(queue, data2) {
  var q_key = this._get_queue_key(queue), q_data = data2[queue], set_q = this._get_or_create_queue(SET_ACTION), set_once_q = this._get_or_create_queue(SET_ONCE_ACTION), unset_q = this._get_or_create_queue(UNSET_ACTION), add_q = this._get_or_create_queue(ADD_ACTION), union_q = this._get_or_create_queue(UNION_ACTION), remove_q = this._get_or_create_queue(REMOVE_ACTION, []), append_q = this._get_or_create_queue(APPEND_ACTION, []);
  if (q_key === SET_QUEUE_KEY) {
    _.extend(set_q, q_data);
    this._pop_from_people_queue(ADD_ACTION, q_data);
    this._pop_from_people_queue(UNION_ACTION, q_data);
    this._pop_from_people_queue(UNSET_ACTION, q_data);
  } else if (q_key === SET_ONCE_QUEUE_KEY) {
    _.each(q_data, function(v2, k2) {
      if (!(k2 in set_once_q)) {
        set_once_q[k2] = v2;
      }
    });
    this._pop_from_people_queue(UNSET_ACTION, q_data);
  } else if (q_key === UNSET_QUEUE_KEY) {
    _.each(q_data, function(prop) {
      _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {
        if (prop in enqueued_obj) {
          delete enqueued_obj[prop];
        }
      });
      _.each(append_q, function(append_obj) {
        if (prop in append_obj) {
          delete append_obj[prop];
        }
      });
      unset_q[prop] = true;
    });
  } else if (q_key === ADD_QUEUE_KEY) {
    _.each(q_data, function(v2, k2) {
      if (k2 in set_q) {
        set_q[k2] += v2;
      } else {
        if (!(k2 in add_q)) {
          add_q[k2] = 0;
        }
        add_q[k2] += v2;
      }
    }, this);
    this._pop_from_people_queue(UNSET_ACTION, q_data);
  } else if (q_key === UNION_QUEUE_KEY) {
    _.each(q_data, function(v2, k2) {
      if (_.isArray(v2)) {
        if (!(k2 in union_q)) {
          union_q[k2] = [];
        }
        union_q[k2] = union_q[k2].concat(v2);
      }
    });
    this._pop_from_people_queue(UNSET_ACTION, q_data);
  } else if (q_key === REMOVE_QUEUE_KEY) {
    remove_q.push(q_data);
    this._pop_from_people_queue(APPEND_ACTION, q_data);
  } else if (q_key === APPEND_QUEUE_KEY) {
    append_q.push(q_data);
    this._pop_from_people_queue(UNSET_ACTION, q_data);
  }
  console$1.log("MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):");
  console$1.log(data2);
  this.save();
};
MixpanelPersistence.prototype._pop_from_people_queue = function(queue, data2) {
  var q2 = this["props"][this._get_queue_key(queue)];
  if (!_.isUndefined(q2)) {
    _.each(data2, function(v2, k2) {
      if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {
        _.each(q2, function(queued_action) {
          if (queued_action[k2] === v2) {
            delete queued_action[k2];
          }
        });
      } else {
        delete q2[k2];
      }
    }, this);
  }
};
MixpanelPersistence.prototype.load_queue = function(queue) {
  return this.load_prop(this._get_queue_key(queue));
};
MixpanelPersistence.prototype._get_queue_key = function(queue) {
  if (queue === SET_ACTION) {
    return SET_QUEUE_KEY;
  } else if (queue === SET_ONCE_ACTION) {
    return SET_ONCE_QUEUE_KEY;
  } else if (queue === UNSET_ACTION) {
    return UNSET_QUEUE_KEY;
  } else if (queue === ADD_ACTION) {
    return ADD_QUEUE_KEY;
  } else if (queue === APPEND_ACTION) {
    return APPEND_QUEUE_KEY;
  } else if (queue === REMOVE_ACTION) {
    return REMOVE_QUEUE_KEY;
  } else if (queue === UNION_ACTION) {
    return UNION_QUEUE_KEY;
  } else {
    console$1.error("Invalid queue:", queue);
  }
};
MixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {
  var key = this._get_queue_key(queue);
  default_val = _.isUndefined(default_val) ? {} : default_val;
  return this["props"][key] || (this["props"][key] = default_val);
};
MixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {
  var timers = this.load_prop(EVENT_TIMERS_KEY) || {};
  timers[event_name] = timestamp;
  this["props"][EVENT_TIMERS_KEY] = timers;
  this.save();
};
MixpanelPersistence.prototype.remove_event_timer = function(event_name) {
  var timers = this.load_prop(EVENT_TIMERS_KEY) || {};
  var timestamp = timers[event_name];
  if (!_.isUndefined(timestamp)) {
    delete this["props"][EVENT_TIMERS_KEY][event_name];
    this.save();
  }
  return timestamp;
};
var init_type;
var load_extra_bundle = function(src, _onload) {
  throw new Error(src + " not available in this build.");
};
var mixpanel_master;
var INIT_MODULE = 0;
var INIT_SNIPPET = 1;
var IDENTITY_FUNC = function(x2) {
  return x2;
};
var NOOP_FUNC = function() {
};
var PRIMARY_INSTANCE_NAME = "mixpanel";
var PAYLOAD_TYPE_BASE64 = "base64";
var PAYLOAD_TYPE_JSON = "json";
var DEVICE_ID_PREFIX = "$device:";
var USE_XHR = win.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
var ENQUEUE_REQUESTS = !USE_XHR && userAgent.indexOf("MSIE") === -1 && userAgent.indexOf("Mozilla") === -1;
var sendBeacon = null;
if (navigator$1["sendBeacon"]) {
  sendBeacon = function() {
    return navigator$1["sendBeacon"].apply(navigator$1, arguments);
  };
}
var DEFAULT_API_ROUTES = {
  "track": "track/",
  "engage": "engage/",
  "groups": "groups/",
  "record": "record/"
};
var DEFAULT_CONFIG = {
  "api_host": "https://api-js.mixpanel.com",
  "api_routes": DEFAULT_API_ROUTES,
  "api_method": "POST",
  "api_transport": "XHR",
  "api_payload_format": PAYLOAD_TYPE_BASE64,
  "app_host": "https://mixpanel.com",
  "cdn": "https://cdn.mxpnl.com",
  "cross_site_cookie": false,
  "cross_subdomain_cookie": true,
  "error_reporter": NOOP_FUNC,
  "persistence": "cookie",
  "persistence_name": "",
  "cookie_domain": "",
  "cookie_name": "",
  "loaded": NOOP_FUNC,
  "mp_loader": null,
  "track_marketing": true,
  "track_pageview": false,
  "skip_first_touch_marketing": false,
  "store_google": true,
  "stop_utm_persistence": false,
  "save_referrer": true,
  "test": false,
  "verbose": false,
  "img": false,
  "debug": false,
  "track_links_timeout": 300,
  "cookie_expiration": 365,
  "upgrade": false,
  "disable_persistence": false,
  "disable_cookie": false,
  "secure_cookie": false,
  "ip": true,
  "opt_out_tracking_by_default": false,
  "opt_out_persistence_by_default": false,
  "opt_out_tracking_persistence_type": "localStorage",
  "opt_out_tracking_cookie_prefix": null,
  "property_blacklist": [],
  "xhr_headers": {},
  // { header: value, header2: value }
  "ignore_dnt": false,
  "batch_requests": true,
  "batch_size": 50,
  "batch_flush_interval_ms": 5e3,
  "batch_request_timeout_ms": 9e4,
  "batch_autostart": true,
  "hooks": {},
  "record_block_class": new RegExp("^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$"),
  "record_block_selector": "img, video",
  "record_collect_fonts": false,
  "record_idle_timeout_ms": 30 * 60 * 1e3,
  // 30 minutes
  "record_inline_images": false,
  "record_mask_text_class": new RegExp("^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$"),
  "record_mask_text_selector": "*",
  "record_max_ms": MAX_RECORDING_MS,
  "record_sessions_percent": 0,
  "recorder_src": "https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js"
};
var DOM_LOADED = false;
var MixpanelLib = function() {
};
var create_mplib = function(token2, config, name) {
  var instance, target = name === PRIMARY_INSTANCE_NAME ? mixpanel_master : mixpanel_master[name];
  if (target && init_type === INIT_MODULE) {
    instance = target;
  } else {
    if (target && !_.isArray(target)) {
      console$1.error("You have already initialized " + name);
      return;
    }
    instance = new MixpanelLib();
  }
  instance._cached_groups = {};
  instance._init(token2, config, name);
  instance["people"] = new MixpanelPeople();
  instance["people"]._init(instance);
  if (!instance.get_config("skip_first_touch_marketing")) {
    var utm_params = _.info.campaignParams(null);
    var initial_utm_params = {};
    var has_utm = false;
    _.each(utm_params, function(utm_value, utm_key) {
      initial_utm_params["initial_" + utm_key] = utm_value;
      if (utm_value) {
        has_utm = true;
      }
    });
    if (has_utm) {
      instance["people"].set_once(initial_utm_params);
    }
  }
  Config.DEBUG = Config.DEBUG || instance.get_config("debug");
  if (!_.isUndefined(target) && _.isArray(target)) {
    instance._execute_array.call(instance["people"], target["people"]);
    instance._execute_array(target);
  }
  return instance;
};
MixpanelLib.prototype.init = function(token2, config, name) {
  if (_.isUndefined(name)) {
    this.report_error("You must name your new library: init(token, config, name)");
    return;
  }
  if (name === PRIMARY_INSTANCE_NAME) {
    this.report_error("You must initialize the main mixpanel object right after you include the Mixpanel js snippet");
    return;
  }
  var instance = create_mplib(token2, config, name);
  mixpanel_master[name] = instance;
  instance._loaded();
  return instance;
};
MixpanelLib.prototype._init = function(token2, config, name) {
  config = config || {};
  this["__loaded"] = true;
  this["config"] = {};
  var variable_features = {};
  if (!("api_payload_format" in config)) {
    var api_host = config["api_host"] || DEFAULT_CONFIG["api_host"];
    if (api_host.match(/\.mixpanel\.com/)) {
      variable_features["api_payload_format"] = PAYLOAD_TYPE_JSON;
    }
  }
  this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {
    "name": name,
    "token": token2,
    "callback_fn": (name === PRIMARY_INSTANCE_NAME ? name : PRIMARY_INSTANCE_NAME + "." + name) + "._jsc"
  }));
  this["_jsc"] = NOOP_FUNC;
  this.__dom_loaded_queue = [];
  this.__request_queue = [];
  this.__disabled_events = [];
  this._flags = {
    "disable_all_events": false,
    "identify_called": false
  };
  this.request_batchers = {};
  this._batch_requests = this.get_config("batch_requests");
  if (this._batch_requests) {
    if (!_.localStorage.is_supported(true) || !USE_XHR) {
      this._batch_requests = false;
      console$1.log("Turning off Mixpanel request-queueing; needs XHR and localStorage support");
      _.each(this.get_batcher_configs(), function(batcher_config) {
        console$1.log("Clearing batch queue " + batcher_config.queue_key);
        _.localStorage.remove(batcher_config.queue_key);
      });
    } else {
      this.init_batchers();
      if (sendBeacon && win.addEventListener) {
        var flush_on_unload = _.bind(function() {
          if (!this.request_batchers.events.stopped) {
            this.request_batchers.events.flush({ unloading: true });
          }
        }, this);
        win.addEventListener("pagehide", function(ev) {
          if (ev["persisted"]) {
            flush_on_unload();
          }
        });
        win.addEventListener("visibilitychange", function() {
          if (document$1$1["visibilityState"] === "hidden") {
            flush_on_unload();
          }
        });
      }
    }
  }
  this["persistence"] = this["cookie"] = new MixpanelPersistence(this["config"]);
  this.unpersisted_superprops = {};
  this._gdpr_init();
  var uuid = _.UUID();
  if (!this.get_distinct_id()) {
    this.register_once({
      "distinct_id": DEVICE_ID_PREFIX + uuid,
      "$device_id": uuid
    }, "");
  }
  var track_pageview_option = this.get_config("track_pageview");
  if (track_pageview_option) {
    this._init_url_change_tracking(track_pageview_option);
  }
  if (this.get_config("record_sessions_percent") > 0 && Math.random() * 100 <= this.get_config("record_sessions_percent")) {
    this.start_session_recording();
  }
};
MixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function() {
  if (!win["MutationObserver"]) {
    console$1.critical("Browser does not support MutationObserver; skipping session recording");
    return;
  }
  var handleLoadedRecorder = _.bind(function() {
    this._recorder = this._recorder || new win["__mp_recorder"](this);
    this._recorder["startRecording"]();
  }, this);
  if (_.isUndefined(win["__mp_recorder"])) {
    load_extra_bundle(this.get_config("recorder_src"), handleLoadedRecorder);
  } else {
    handleLoadedRecorder();
  }
});
MixpanelLib.prototype.stop_session_recording = function() {
  if (this._recorder) {
    this._recorder["stopRecording"]();
  } else {
    console$1.critical("Session recorder module not loaded");
  }
};
MixpanelLib.prototype.get_session_recording_properties = function() {
  var props = {};
  if (this._recorder) {
    var replay_id = this._recorder["replayId"];
    if (replay_id) {
      props["$mp_replay_id"] = replay_id;
    }
  }
  return props;
};
MixpanelLib.prototype._loaded = function() {
  this.get_config("loaded")(this);
  this._set_default_superprops();
  this["people"].set_once(this["persistence"].get_referrer_info());
  if (this.get_config("store_google") && this.get_config("stop_utm_persistence")) {
    var utm_params = _.info.campaignParams(null);
    _.each(utm_params, (function(_utm_value, utm_key) {
      this.unregister(utm_key);
    }).bind(this));
  }
};
MixpanelLib.prototype._set_default_superprops = function() {
  this["persistence"].update_search_keyword(document$1$1.referrer);
  if (this.get_config("store_google") && !this.get_config("stop_utm_persistence")) {
    this.register(_.info.campaignParams());
  }
  if (this.get_config("save_referrer")) {
    this["persistence"].update_referrer_info(document$1$1.referrer);
  }
};
MixpanelLib.prototype._dom_loaded = function() {
  _.each(this.__dom_loaded_queue, function(item) {
    this._track_dom.apply(this, item);
  }, this);
  if (!this.has_opted_out_tracking()) {
    _.each(this.__request_queue, function(item) {
      this._send_request.apply(this, item);
    }, this);
  }
  delete this.__dom_loaded_queue;
  delete this.__request_queue;
};
MixpanelLib.prototype._track_dom = function(DomClass, args) {
  if (this.get_config("img")) {
    this.report_error("You can't use DOM tracking functions with img = true.");
    return false;
  }
  if (!DOM_LOADED) {
    this.__dom_loaded_queue.push([DomClass, args]);
    return false;
  }
  var dt = new DomClass().init(this);
  return dt.track.apply(dt, args);
};
MixpanelLib.prototype._init_url_change_tracking = function(track_pageview_option) {
  var previous_tracked_url = "";
  var tracked = this.track_pageview();
  if (tracked) {
    previous_tracked_url = _.info.currentUrl();
  }
  if (_.include(["full-url", "url-with-path-and-query-string", "url-with-path"], track_pageview_option)) {
    win.addEventListener("popstate", function() {
      win.dispatchEvent(new Event("mp_locationchange"));
    });
    win.addEventListener("hashchange", function() {
      win.dispatchEvent(new Event("mp_locationchange"));
    });
    var nativePushState = win.history.pushState;
    if (typeof nativePushState === "function") {
      win.history.pushState = function(state, unused, url) {
        nativePushState.call(win.history, state, unused, url);
        win.dispatchEvent(new Event("mp_locationchange"));
      };
    }
    var nativeReplaceState = win.history.replaceState;
    if (typeof nativeReplaceState === "function") {
      win.history.replaceState = function(state, unused, url) {
        nativeReplaceState.call(win.history, state, unused, url);
        win.dispatchEvent(new Event("mp_locationchange"));
      };
    }
    win.addEventListener("mp_locationchange", (function() {
      var current_url = _.info.currentUrl();
      var should_track = false;
      if (track_pageview_option === "full-url") {
        should_track = current_url !== previous_tracked_url;
      } else if (track_pageview_option === "url-with-path-and-query-string") {
        should_track = current_url.split("#")[0] !== previous_tracked_url.split("#")[0];
      } else if (track_pageview_option === "url-with-path") {
        should_track = current_url.split("#")[0].split("?")[0] !== previous_tracked_url.split("#")[0].split("?")[0];
      }
      if (should_track) {
        var tracked2 = this.track_pageview();
        if (tracked2) {
          previous_tracked_url = current_url;
        }
      }
    }).bind(this));
  }
};
MixpanelLib.prototype._prepare_callback = function(callback, data2) {
  if (_.isUndefined(callback)) {
    return null;
  }
  if (USE_XHR) {
    var callback_function = function(response) {
      callback(response, data2);
    };
    return callback_function;
  } else {
    var jsc = this["_jsc"];
    var randomized_cb = "" + Math.floor(Math.random() * 1e8);
    var callback_string = this.get_config("callback_fn") + "[" + randomized_cb + "]";
    jsc[randomized_cb] = function(response) {
      delete jsc[randomized_cb];
      callback(response, data2);
    };
    return callback_string;
  }
};
MixpanelLib.prototype._send_request = function(url, data2, options, callback) {
  var succeeded = true;
  if (ENQUEUE_REQUESTS) {
    this.__request_queue.push(arguments);
    return succeeded;
  }
  var DEFAULT_OPTIONS = {
    method: this.get_config("api_method"),
    transport: this.get_config("api_transport"),
    verbose: this.get_config("verbose")
  };
  var body_data = null;
  if (!callback && (_.isFunction(options) || typeof options === "string")) {
    callback = options;
    options = null;
  }
  options = _.extend(DEFAULT_OPTIONS, options || {});
  if (!USE_XHR) {
    options.method = "GET";
  }
  var use_post = options.method === "POST";
  var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === "sendbeacon";
  var verbose_mode = options.verbose;
  if (data2["verbose"]) {
    verbose_mode = true;
  }
  if (this.get_config("test")) {
    data2["test"] = 1;
  }
  if (verbose_mode) {
    data2["verbose"] = 1;
  }
  if (this.get_config("img")) {
    data2["img"] = 1;
  }
  if (!USE_XHR) {
    if (callback) {
      data2["callback"] = callback;
    } else if (verbose_mode || this.get_config("test")) {
      data2["callback"] = "(function(){})";
    }
  }
  data2["ip"] = this.get_config("ip") ? 1 : 0;
  data2["_"] = (/* @__PURE__ */ new Date()).getTime().toString();
  if (use_post) {
    body_data = "data=" + encodeURIComponent(data2["data"]);
    delete data2["data"];
  }
  url += "?" + _.HTTPBuildQuery(data2);
  var lib = this;
  if ("img" in data2) {
    var img = document$1$1.createElement("img");
    img.src = url;
    document$1$1.body.appendChild(img);
  } else if (use_sendBeacon) {
    try {
      succeeded = sendBeacon(url, body_data);
    } catch (e2) {
      lib.report_error(e2);
      succeeded = false;
    }
    try {
      if (callback) {
        callback(succeeded ? 1 : 0);
      }
    } catch (e2) {
      lib.report_error(e2);
    }
  } else if (USE_XHR) {
    try {
      var req = new XMLHttpRequest();
      req.open(options.method, url, true);
      var headers = this.get_config("xhr_headers");
      if (use_post) {
        headers["Content-Type"] = "application/x-www-form-urlencoded";
      }
      _.each(headers, function(headerValue, headerName) {
        req.setRequestHeader(headerName, headerValue);
      });
      if (options.timeout_ms && typeof req.timeout !== "undefined") {
        req.timeout = options.timeout_ms;
        var start_time = (/* @__PURE__ */ new Date()).getTime();
      }
      req.withCredentials = true;
      req.onreadystatechange = function() {
        if (req.readyState === 4) {
          if (req.status === 200) {
            if (callback) {
              if (verbose_mode) {
                var response;
                try {
                  response = _.JSONDecode(req.responseText);
                } catch (e2) {
                  lib.report_error(e2);
                  if (options.ignore_json_errors) {
                    response = req.responseText;
                  } else {
                    return;
                  }
                }
                callback(response);
              } else {
                callback(Number(req.responseText));
              }
            }
          } else {
            var error;
            if (req.timeout && !req.status && (/* @__PURE__ */ new Date()).getTime() - start_time >= req.timeout) {
              error = "timeout";
            } else {
              error = "Bad HTTP status: " + req.status + " " + req.statusText;
            }
            lib.report_error(error);
            if (callback) {
              if (verbose_mode) {
                var response_headers = req["responseHeaders"] || {};
                callback({ status: 0, httpStatusCode: req["status"], error, retryAfter: response_headers["Retry-After"] });
              } else {
                callback(0);
              }
            }
          }
        }
      };
      req.send(body_data);
    } catch (e2) {
      lib.report_error(e2);
      succeeded = false;
    }
  } else {
    var script = document$1$1.createElement("script");
    script.type = "text/javascript";
    script.async = true;
    script.defer = true;
    script.src = url;
    var s = document$1$1.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(script, s);
  }
  return succeeded;
};
MixpanelLib.prototype._execute_array = function(array) {
  var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];
  _.each(array, function(item) {
    if (item) {
      fn_name = item[0];
      if (_.isArray(fn_name)) {
        tracking_calls.push(item);
      } else if (typeof item === "function") {
        item.call(this);
      } else if (_.isArray(item) && fn_name === "alias") {
        alias_calls.push(item);
      } else if (_.isArray(item) && fn_name.indexOf("track") !== -1 && typeof this[fn_name] === "function") {
        tracking_calls.push(item);
      } else {
        other_calls.push(item);
      }
    }
  }, this);
  var execute = function(calls, context) {
    _.each(calls, function(item) {
      if (_.isArray(item[0])) {
        var caller = context;
        _.each(item, function(call) {
          caller = caller[call[0]].apply(caller, call.slice(1));
        });
      } else {
        this[item[0]].apply(this, item.slice(1));
      }
    }, context);
  };
  execute(alias_calls, this);
  execute(other_calls, this);
  execute(tracking_calls, this);
};
MixpanelLib.prototype.are_batchers_initialized = function() {
  return !!this.request_batchers.events;
};
MixpanelLib.prototype.get_batcher_configs = function() {
  var queue_prefix = "__mpq_" + this.get_config("token");
  var api_routes = this.get_config("api_routes");
  this._batcher_configs = this._batcher_configs || {
    events: { type: "events", endpoint: "/" + api_routes["track"], queue_key: queue_prefix + "_ev" },
    people: { type: "people", endpoint: "/" + api_routes["engage"], queue_key: queue_prefix + "_pp" },
    groups: { type: "groups", endpoint: "/" + api_routes["groups"], queue_key: queue_prefix + "_gr" }
  };
  return this._batcher_configs;
};
MixpanelLib.prototype.init_batchers = function() {
  if (!this.are_batchers_initialized()) {
    var batcher_for = _.bind(function(attrs) {
      return new RequestBatcher(
        attrs.queue_key,
        {
          libConfig: this["config"],
          errorReporter: this.get_config("error_reporter"),
          sendRequestFunc: _.bind(function(data2, options, cb2) {
            this._send_request(
              this.get_config("api_host") + attrs.endpoint,
              this._encode_data_for_request(data2),
              options,
              this._prepare_callback(cb2, data2)
            );
          }, this),
          beforeSendHook: _.bind(function(item) {
            return this._run_hook("before_send_" + attrs.type, item);
          }, this),
          stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),
          usePersistence: true
        }
      );
    }, this);
    var batcher_configs = this.get_batcher_configs();
    this.request_batchers = {
      events: batcher_for(batcher_configs.events),
      people: batcher_for(batcher_configs.people),
      groups: batcher_for(batcher_configs.groups)
    };
  }
  if (this.get_config("batch_autostart")) {
    this.start_batch_senders();
  }
};
MixpanelLib.prototype.start_batch_senders = function() {
  this._batchers_were_started = true;
  if (this.are_batchers_initialized()) {
    this._batch_requests = true;
    _.each(this.request_batchers, function(batcher) {
      batcher.start();
    });
  }
};
MixpanelLib.prototype.stop_batch_senders = function() {
  this._batch_requests = false;
  _.each(this.request_batchers, function(batcher) {
    batcher.stop();
    batcher.clear();
  });
};
MixpanelLib.prototype.push = function(item) {
  this._execute_array([item]);
};
MixpanelLib.prototype.disable = function(events) {
  if (typeof events === "undefined") {
    this._flags.disable_all_events = true;
  } else {
    this.__disabled_events = this.__disabled_events.concat(events);
  }
};
MixpanelLib.prototype._encode_data_for_request = function(data2) {
  var encoded_data = _.JSONEncode(data2);
  if (this.get_config("api_payload_format") === PAYLOAD_TYPE_BASE64) {
    encoded_data = _.base64Encode(encoded_data);
  }
  return { "data": encoded_data };
};
MixpanelLib.prototype._track_or_batch = function(options, callback) {
  var truncated_data = _.truncate(options.data, 255);
  var endpoint = options.endpoint;
  var batcher = options.batcher;
  var should_send_immediately = options.should_send_immediately;
  var send_request_options = options.send_request_options || {};
  callback = callback || NOOP_FUNC;
  var request_enqueued_or_initiated = true;
  var send_request_immediately = _.bind(function() {
    if (!send_request_options.skip_hooks) {
      truncated_data = this._run_hook("before_send_" + options.type, truncated_data);
    }
    if (truncated_data) {
      console$1.log("MIXPANEL REQUEST:");
      console$1.log(truncated_data);
      return this._send_request(
        endpoint,
        this._encode_data_for_request(truncated_data),
        send_request_options,
        this._prepare_callback(callback, truncated_data)
      );
    } else {
      return null;
    }
  }, this);
  if (this._batch_requests && !should_send_immediately) {
    batcher.enqueue(truncated_data, function(succeeded) {
      if (succeeded) {
        callback(1, truncated_data);
      } else {
        send_request_immediately();
      }
    });
  } else {
    request_enqueued_or_initiated = send_request_immediately();
  }
  return request_enqueued_or_initiated && truncated_data;
};
MixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {
  if (!callback && typeof options === "function") {
    callback = options;
    options = null;
  }
  options = options || {};
  var transport = options["transport"];
  if (transport) {
    options.transport = transport;
  }
  var should_send_immediately = options["send_immediately"];
  if (typeof callback !== "function") {
    callback = NOOP_FUNC;
  }
  if (_.isUndefined(event_name)) {
    this.report_error("No event name provided to mixpanel.track");
    return;
  }
  if (this._event_is_disabled(event_name)) {
    callback(0);
    return;
  }
  properties = _.extend({}, properties);
  properties["token"] = this.get_config("token");
  var start_timestamp = this["persistence"].remove_event_timer(event_name);
  if (!_.isUndefined(start_timestamp)) {
    var duration_in_ms = (/* @__PURE__ */ new Date()).getTime() - start_timestamp;
    properties["$duration"] = parseFloat((duration_in_ms / 1e3).toFixed(3));
  }
  this._set_default_superprops();
  var marketing_properties = this.get_config("track_marketing") ? _.info.marketingParams() : {};
  properties = _.extend(
    {},
    _.info.properties({ "mp_loader": this.get_config("mp_loader") }),
    marketing_properties,
    this["persistence"].properties(),
    this.unpersisted_superprops,
    this.get_session_recording_properties(),
    properties
  );
  var property_blacklist = this.get_config("property_blacklist");
  if (_.isArray(property_blacklist)) {
    _.each(property_blacklist, function(blacklisted_prop) {
      delete properties[blacklisted_prop];
    });
  } else {
    this.report_error("Invalid value for property_blacklist config: " + property_blacklist);
  }
  var data2 = {
    "event": event_name,
    "properties": properties
  };
  var ret = this._track_or_batch({
    type: "events",
    data: data2,
    endpoint: this.get_config("api_host") + "/" + this.get_config("api_routes")["track"],
    batcher: this.request_batchers.events,
    should_send_immediately,
    send_request_options: options
  }, callback);
  return ret;
});
MixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {
  if (!_.isArray(group_ids)) {
    group_ids = [group_ids];
  }
  var prop = {};
  prop[group_key] = group_ids;
  this.register(prop);
  return this["people"].set(group_key, group_ids, callback);
});
MixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {
  var old_values = this.get_property(group_key);
  var prop = {};
  if (old_values === void 0) {
    prop[group_key] = [group_id];
    this.register(prop);
  } else {
    if (old_values.indexOf(group_id) === -1) {
      old_values.push(group_id);
      prop[group_key] = old_values;
      this.register(prop);
    }
  }
  return this["people"].union(group_key, group_id, callback);
});
MixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {
  var old_value = this.get_property(group_key);
  if (old_value !== void 0) {
    var idx = old_value.indexOf(group_id);
    if (idx > -1) {
      old_value.splice(idx, 1);
      this.register({ group_key: old_value });
    }
    if (old_value.length === 0) {
      this.unregister(group_key);
    }
  }
  return this["people"].remove(group_key, group_id, callback);
});
MixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {
  var tracking_props = _.extend({}, properties || {});
  _.each(groups, function(v2, k2) {
    if (v2 !== null && v2 !== void 0) {
      tracking_props[k2] = v2;
    }
  });
  return this.track(event_name, tracking_props, callback);
});
MixpanelLib.prototype._create_map_key = function(group_key, group_id) {
  return group_key + "_" + JSON.stringify(group_id);
};
MixpanelLib.prototype._remove_group_from_cache = function(group_key, group_id) {
  delete this._cached_groups[this._create_map_key(group_key, group_id)];
};
MixpanelLib.prototype.get_group = function(group_key, group_id) {
  var map_key = this._create_map_key(group_key, group_id);
  var group = this._cached_groups[map_key];
  if (group === void 0 || group._group_key !== group_key || group._group_id !== group_id) {
    group = new MixpanelGroup();
    group._init(this, group_key, group_id);
    this._cached_groups[map_key] = group;
  }
  return group;
};
MixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {
  if (typeof properties !== "object") {
    properties = {};
  }
  options = options || {};
  var event_name = options["event_name"] || "$mp_web_page_view";
  var default_page_properties = _.extend(
    _.info.mpPageViewProperties(),
    _.info.campaignParams(),
    _.info.clickParams()
  );
  var event_properties = _.extend(
    {},
    default_page_properties,
    properties
  );
  return this.track(event_name, event_properties);
});
MixpanelLib.prototype.track_links = function() {
  return this._track_dom.call(this, LinkTracker, arguments);
};
MixpanelLib.prototype.track_forms = function() {
  return this._track_dom.call(this, FormTracker, arguments);
};
MixpanelLib.prototype.time_event = function(event_name) {
  if (_.isUndefined(event_name)) {
    this.report_error("No event name provided to mixpanel.time_event");
    return;
  }
  if (this._event_is_disabled(event_name)) {
    return;
  }
  this["persistence"].set_event_timer(event_name, (/* @__PURE__ */ new Date()).getTime());
};
var REGISTER_DEFAULTS = {
  "persistent": true
};
var options_for_register = function(days_or_options) {
  var options;
  if (_.isObject(days_or_options)) {
    options = days_or_options;
  } else if (!_.isUndefined(days_or_options)) {
    options = { "days": days_or_options };
  } else {
    options = {};
  }
  return _.extend({}, REGISTER_DEFAULTS, options);
};
MixpanelLib.prototype.register = function(props, days_or_options) {
  var options = options_for_register(days_or_options);
  if (options["persistent"]) {
    this["persistence"].register(props, options["days"]);
  } else {
    _.extend(this.unpersisted_superprops, props);
  }
};
MixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {
  var options = options_for_register(days_or_options);
  if (options["persistent"]) {
    this["persistence"].register_once(props, default_value, options["days"]);
  } else {
    if (typeof default_value === "undefined") {
      default_value = "None";
    }
    _.each(props, function(val, prop) {
      if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {
        this.unpersisted_superprops[prop] = val;
      }
    }, this);
  }
};
MixpanelLib.prototype.unregister = function(property, options) {
  options = options_for_register(options);
  if (options["persistent"]) {
    this["persistence"].unregister(property);
  } else {
    delete this.unpersisted_superprops[property];
  }
};
MixpanelLib.prototype._register_single = function(prop, value) {
  var props = {};
  props[prop] = value;
  this.register(props);
};
MixpanelLib.prototype.identify = function(new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback) {
  var previous_distinct_id = this.get_distinct_id();
  if (new_distinct_id && previous_distinct_id !== new_distinct_id) {
    if (typeof new_distinct_id === "string" && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {
      this.report_error("distinct_id cannot have $device: prefix");
      return -1;
    }
    this.register({ "$user_id": new_distinct_id });
  }
  if (!this.get_property("$device_id")) {
    var device_id = previous_distinct_id;
    this.register_once({
      "$had_persisted_distinct_id": true,
      "$device_id": device_id
    }, "");
  }
  if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {
    this.unregister(ALIAS_ID_KEY);
    this.register({ "distinct_id": new_distinct_id });
  }
  this._flags.identify_called = true;
  this["people"]._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);
  if (new_distinct_id !== previous_distinct_id) {
    this.track("$identify", {
      "distinct_id": new_distinct_id,
      "$anon_distinct_id": previous_distinct_id
    }, { skip_hooks: true });
  }
};
MixpanelLib.prototype.reset = function() {
  this["persistence"].clear();
  this._flags.identify_called = false;
  var uuid = _.UUID();
  this.register_once({
    "distinct_id": DEVICE_ID_PREFIX + uuid,
    "$device_id": uuid
  }, "");
};
MixpanelLib.prototype.get_distinct_id = function() {
  return this.get_property("distinct_id");
};
MixpanelLib.prototype.alias = function(alias, original) {
  if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {
    this.report_error("Attempting to create alias for existing People user - aborting.");
    return -2;
  }
  var _this = this;
  if (_.isUndefined(original)) {
    original = this.get_distinct_id();
  }
  if (alias !== original) {
    this._register_single(ALIAS_ID_KEY, alias);
    return this.track("$create_alias", {
      "alias": alias,
      "distinct_id": original
    }, {
      skip_hooks: true
    }, function() {
      _this.identify(alias);
    });
  } else {
    this.report_error("alias matches current distinct_id - skipping api call.");
    this.identify(alias);
    return -1;
  }
};
MixpanelLib.prototype.name_tag = function(name_tag) {
  this._register_single("mp_name_tag", name_tag);
};
MixpanelLib.prototype.set_config = function(config) {
  if (_.isObject(config)) {
    _.extend(this["config"], config);
    var new_batch_size = config["batch_size"];
    if (new_batch_size) {
      _.each(this.request_batchers, function(batcher) {
        batcher.resetBatchSize();
      });
    }
    if (!this.get_config("persistence_name")) {
      this["config"]["persistence_name"] = this["config"]["cookie_name"];
    }
    if (!this.get_config("disable_persistence")) {
      this["config"]["disable_persistence"] = this["config"]["disable_cookie"];
    }
    if (this["persistence"]) {
      this["persistence"].update_config(this["config"]);
    }
    Config.DEBUG = Config.DEBUG || this.get_config("debug");
  }
};
MixpanelLib.prototype.get_config = function(prop_name) {
  return this["config"][prop_name];
};
MixpanelLib.prototype._run_hook = function(hook_name) {
  var ret = (this["config"]["hooks"][hook_name] || IDENTITY_FUNC).apply(this, slice$1.call(arguments, 1));
  if (typeof ret === "undefined") {
    this.report_error(hook_name + " hook did not return a value");
    ret = null;
  }
  return ret;
};
MixpanelLib.prototype.get_property = function(property_name) {
  return this["persistence"].load_prop([property_name]);
};
MixpanelLib.prototype.toString = function() {
  var name = this.get_config("name");
  if (name !== PRIMARY_INSTANCE_NAME) {
    name = PRIMARY_INSTANCE_NAME + "." + name;
  }
  return name;
};
MixpanelLib.prototype._event_is_disabled = function(event_name) {
  return _.isBlockedUA(userAgent) || this._flags.disable_all_events || _.include(this.__disabled_events, event_name);
};
MixpanelLib.prototype._gdpr_init = function() {
  var is_localStorage_requested = this.get_config("opt_out_tracking_persistence_type") === "localStorage";
  if (is_localStorage_requested && _.localStorage.is_supported()) {
    if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({ "persistence_type": "cookie" })) {
      this.opt_in_tracking({ "enable_persistence": false });
    }
    if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({ "persistence_type": "cookie" })) {
      this.opt_out_tracking({ "clear_persistence": false });
    }
    this.clear_opt_in_out_tracking({
      "persistence_type": "cookie",
      "enable_persistence": false
    });
  }
  if (this.has_opted_out_tracking()) {
    this._gdpr_update_persistence({ "clear_persistence": true });
  } else if (!this.has_opted_in_tracking() && (this.get_config("opt_out_tracking_by_default") || _.cookie.get("mp_optout"))) {
    _.cookie.remove("mp_optout");
    this.opt_out_tracking({
      "clear_persistence": this.get_config("opt_out_persistence_by_default")
    });
  }
};
MixpanelLib.prototype._gdpr_update_persistence = function(options) {
  var disabled;
  if (options && options["clear_persistence"]) {
    disabled = true;
  } else if (options && options["enable_persistence"]) {
    disabled = false;
  } else {
    return;
  }
  if (!this.get_config("disable_persistence") && this["persistence"].disabled !== disabled) {
    this["persistence"].set_disabled(disabled);
  }
  if (disabled) {
    this.stop_batch_senders();
  } else {
    if (this._batchers_were_started) {
      this.start_batch_senders();
    }
  }
};
MixpanelLib.prototype._gdpr_call_func = function(func, options) {
  options = _.extend({
    "track": _.bind(this.track, this),
    "persistence_type": this.get_config("opt_out_tracking_persistence_type"),
    "cookie_prefix": this.get_config("opt_out_tracking_cookie_prefix"),
    "cookie_expiration": this.get_config("cookie_expiration"),
    "cross_site_cookie": this.get_config("cross_site_cookie"),
    "cross_subdomain_cookie": this.get_config("cross_subdomain_cookie"),
    "cookie_domain": this.get_config("cookie_domain"),
    "secure_cookie": this.get_config("secure_cookie"),
    "ignore_dnt": this.get_config("ignore_dnt")
  }, options);
  if (!_.localStorage.is_supported()) {
    options["persistence_type"] = "cookie";
  }
  return func(this.get_config("token"), {
    track: options["track"],
    trackEventName: options["track_event_name"],
    trackProperties: options["track_properties"],
    persistenceType: options["persistence_type"],
    persistencePrefix: options["cookie_prefix"],
    cookieDomain: options["cookie_domain"],
    cookieExpiration: options["cookie_expiration"],
    crossSiteCookie: options["cross_site_cookie"],
    crossSubdomainCookie: options["cross_subdomain_cookie"],
    secureCookie: options["secure_cookie"],
    ignoreDnt: options["ignore_dnt"]
  });
};
MixpanelLib.prototype.opt_in_tracking = function(options) {
  options = _.extend({
    "enable_persistence": true
  }, options);
  this._gdpr_call_func(optIn, options);
  this._gdpr_update_persistence(options);
};
MixpanelLib.prototype.opt_out_tracking = function(options) {
  options = _.extend({
    "clear_persistence": true,
    "delete_user": true
  }, options);
  if (options["delete_user"] && this["people"] && this["people"]._identify_called()) {
    this["people"].delete_user();
    this["people"].clear_charges();
  }
  this._gdpr_call_func(optOut, options);
  this._gdpr_update_persistence(options);
};
MixpanelLib.prototype.has_opted_in_tracking = function(options) {
  return this._gdpr_call_func(hasOptedIn, options);
};
MixpanelLib.prototype.has_opted_out_tracking = function(options) {
  return this._gdpr_call_func(hasOptedOut, options);
};
MixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {
  options = _.extend({
    "enable_persistence": true
  }, options);
  this._gdpr_call_func(clearOptInOut, options);
  this._gdpr_update_persistence(options);
};
MixpanelLib.prototype.report_error = function(msg, err) {
  console$1.error.apply(console$1.error, arguments);
  try {
    if (!err && !(msg instanceof Error)) {
      msg = new Error(msg);
    }
    this.get_config("error_reporter")(msg, err);
  } catch (err2) {
    console$1.error(err2);
  }
};
MixpanelLib.prototype["init"] = MixpanelLib.prototype.init;
MixpanelLib.prototype["reset"] = MixpanelLib.prototype.reset;
MixpanelLib.prototype["disable"] = MixpanelLib.prototype.disable;
MixpanelLib.prototype["time_event"] = MixpanelLib.prototype.time_event;
MixpanelLib.prototype["track"] = MixpanelLib.prototype.track;
MixpanelLib.prototype["track_links"] = MixpanelLib.prototype.track_links;
MixpanelLib.prototype["track_forms"] = MixpanelLib.prototype.track_forms;
MixpanelLib.prototype["track_pageview"] = MixpanelLib.prototype.track_pageview;
MixpanelLib.prototype["register"] = MixpanelLib.prototype.register;
MixpanelLib.prototype["register_once"] = MixpanelLib.prototype.register_once;
MixpanelLib.prototype["unregister"] = MixpanelLib.prototype.unregister;
MixpanelLib.prototype["identify"] = MixpanelLib.prototype.identify;
MixpanelLib.prototype["alias"] = MixpanelLib.prototype.alias;
MixpanelLib.prototype["name_tag"] = MixpanelLib.prototype.name_tag;
MixpanelLib.prototype["set_config"] = MixpanelLib.prototype.set_config;
MixpanelLib.prototype["get_config"] = MixpanelLib.prototype.get_config;
MixpanelLib.prototype["get_property"] = MixpanelLib.prototype.get_property;
MixpanelLib.prototype["get_distinct_id"] = MixpanelLib.prototype.get_distinct_id;
MixpanelLib.prototype["toString"] = MixpanelLib.prototype.toString;
MixpanelLib.prototype["opt_out_tracking"] = MixpanelLib.prototype.opt_out_tracking;
MixpanelLib.prototype["opt_in_tracking"] = MixpanelLib.prototype.opt_in_tracking;
MixpanelLib.prototype["has_opted_out_tracking"] = MixpanelLib.prototype.has_opted_out_tracking;
MixpanelLib.prototype["has_opted_in_tracking"] = MixpanelLib.prototype.has_opted_in_tracking;
MixpanelLib.prototype["clear_opt_in_out_tracking"] = MixpanelLib.prototype.clear_opt_in_out_tracking;
MixpanelLib.prototype["get_group"] = MixpanelLib.prototype.get_group;
MixpanelLib.prototype["set_group"] = MixpanelLib.prototype.set_group;
MixpanelLib.prototype["add_group"] = MixpanelLib.prototype.add_group;
MixpanelLib.prototype["remove_group"] = MixpanelLib.prototype.remove_group;
MixpanelLib.prototype["track_with_groups"] = MixpanelLib.prototype.track_with_groups;
MixpanelLib.prototype["start_batch_senders"] = MixpanelLib.prototype.start_batch_senders;
MixpanelLib.prototype["stop_batch_senders"] = MixpanelLib.prototype.stop_batch_senders;
MixpanelLib.prototype["start_session_recording"] = MixpanelLib.prototype.start_session_recording;
MixpanelLib.prototype["stop_session_recording"] = MixpanelLib.prototype.stop_session_recording;
MixpanelLib.prototype["get_session_recording_properties"] = MixpanelLib.prototype.get_session_recording_properties;
MixpanelLib.prototype["DEFAULT_API_ROUTES"] = DEFAULT_API_ROUTES;
MixpanelPersistence.prototype["properties"] = MixpanelPersistence.prototype.properties;
MixpanelPersistence.prototype["update_search_keyword"] = MixpanelPersistence.prototype.update_search_keyword;
MixpanelPersistence.prototype["update_referrer_info"] = MixpanelPersistence.prototype.update_referrer_info;
MixpanelPersistence.prototype["get_cross_subdomain"] = MixpanelPersistence.prototype.get_cross_subdomain;
MixpanelPersistence.prototype["clear"] = MixpanelPersistence.prototype.clear;
var instances = {};
var extend_mp = function() {
  _.each(instances, function(instance, name) {
    if (name !== PRIMARY_INSTANCE_NAME) {
      mixpanel_master[name] = instance;
    }
  });
  mixpanel_master["_"] = _;
};
var override_mp_init_func = function() {
  mixpanel_master["init"] = function(token2, config, name) {
    if (name) {
      if (!mixpanel_master[name]) {
        mixpanel_master[name] = instances[name] = create_mplib(token2, config, name);
        mixpanel_master[name]._loaded();
      }
      return mixpanel_master[name];
    } else {
      var instance = mixpanel_master;
      if (instances[PRIMARY_INSTANCE_NAME]) {
        instance = instances[PRIMARY_INSTANCE_NAME];
      } else if (token2) {
        instance = create_mplib(token2, config, PRIMARY_INSTANCE_NAME);
        instance._loaded();
        instances[PRIMARY_INSTANCE_NAME] = instance;
      }
      mixpanel_master = instance;
      if (init_type === INIT_SNIPPET) {
        win[PRIMARY_INSTANCE_NAME] = mixpanel_master;
      }
      extend_mp();
    }
  };
};
var add_dom_loaded_handler = function() {
  function dom_loaded_handler() {
    if (dom_loaded_handler.done) {
      return;
    }
    dom_loaded_handler.done = true;
    DOM_LOADED = true;
    ENQUEUE_REQUESTS = false;
    _.each(instances, function(inst) {
      inst._dom_loaded();
    });
  }
  function do_scroll_check() {
    try {
      document$1$1.documentElement.doScroll("left");
    } catch (e2) {
      setTimeout(do_scroll_check, 1);
      return;
    }
    dom_loaded_handler();
  }
  if (document$1$1.addEventListener) {
    if (document$1$1.readyState === "complete") {
      dom_loaded_handler();
    } else {
      document$1$1.addEventListener("DOMContentLoaded", dom_loaded_handler, false);
    }
  } else if (document$1$1.attachEvent) {
    document$1$1.attachEvent("onreadystatechange", dom_loaded_handler);
    var toplevel = false;
    try {
      toplevel = win.frameElement === null;
    } catch (e2) {
    }
    if (document$1$1.documentElement.doScroll && toplevel) {
      do_scroll_check();
    }
  }
  _.register_event(win, "load", dom_loaded_handler, true);
};
function init_as_module(bundle_loader) {
  load_extra_bundle = bundle_loader;
  init_type = INIT_MODULE;
  mixpanel_master = new MixpanelLib();
  override_mp_init_func();
  mixpanel_master["init"]();
  add_dom_loaded_handler();
  return mixpanel_master;
}
function loadNoop(_src, onload) {
  onload();
}
var mixpanel = init_as_module(loadNoop);
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$4() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type: type2 = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type2 !== "all") {
    const isActive = query.isActive();
    if (type2 === "active" && !isActive) {
      return false;
    }
    if (type2 === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_2, val) => isPlainObject$3(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (a && b2 && typeof a === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialMatchKey(a[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a, b2) {
  if (a === b2) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b2);
  if (array || isPlainObject$3(a) && isPlainObject$3(b2)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array ? i2 : bItems[i2];
      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b2[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(a[key], b2[key]);
        if (copy2[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy2;
  }
  return b2;
}
function shallowEqualObjects(a, b2) {
  if (!b2 || Object.keys(a).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$3(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep$1(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data2, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data2);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data2);
  }
  return data2;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data2) {
    Object.assign(thenable, data2);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config.abort) == null ? void 0 : _a2.call(config);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config.onSuccess) == null ? void 0 : _a2.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config.onError) == null ? void 0 : _a2.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a2 = config.onPause) == null ? void 0 : _a2.call(config);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config.onContinue) == null ? void 0 : _a2.call(config);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config.onFail) == null ? void 0 : _a2.call(config, failureCount, error);
      sleep$1(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query$1 = (_d = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _client);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config.defaultOptions);
    this.setOptions(config.options);
    this.observers = [];
    __privateSet(this, _client, config.client);
    __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a2;
    return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data2 = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data: data2,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data2;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$4).catch(noop$4) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        client: __privateGet(this, _client),
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      client: __privateGet(this, _client),
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = (error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data2) => {
        var _a3, _b3, _c3, _d2;
        if (data2 === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data2);
        } catch (error) {
          onError(error);
          return;
        }
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data2, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data2,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _client = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data2, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data2 === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data2 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data2 !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data: data2,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query$1({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config.mutationId;
    __privateSet(this, _mutationCache, config.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config.state || getDefaultState();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data2 = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data2,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data2, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data2,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data2, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data: data2 });
      return data2;
    } catch (error) {
      try {
        await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s = this.options).onSettled) == null ? void 0 : _t.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _scopes);
    __privateAdd(this, _mutationId);
    this.config = config;
    __privateSet(this, _mutations, /* @__PURE__ */ new Set());
    __privateSet(this, _scopes, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, 0);
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    __privateGet(this, _mutations).add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = __privateGet(this, _scopes).get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        __privateGet(this, _scopes).set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (__privateGet(this, _mutations).delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index2 = scopedMutations.indexOf(mutation);
            if (index2 !== -1) {
              scopedMutations.splice(index2, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            __privateGet(this, _scopes).delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
      const firstPendingMutation = mutationsWithSameScope == null ? void 0 : mutationsWithSameScope.find(
        (m2) => m2.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = (_a2 = __privateGet(this, _scopes).get(scope)) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
      return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      __privateGet(this, _mutations).forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      __privateGet(this, _mutations).clear();
      __privateGet(this, _scopes).clear();
    });
  }
  getAll() {
    return Array.from(__privateGet(this, _mutations));
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$4))
      )
    );
  }
}, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a2;
  return (_a2 = mutation.options.scope) == null ? void 0 : _a2.id;
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a2, _b2, _c2, _d2, _e2;
      const options = context.options;
      const direction = (_c2 = (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
      const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
      const oldPageParams = ((_e2 = context.state.data) == null ? void 0 : _e2.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data2, param, previous2) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data2.pages.length) {
            return Promise.resolve(data2);
          }
          const queryFnContext = {
            client: context.client,
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous2 ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous2 ? addToStart : addToEnd;
          return {
            pages: addTo(data2.pages, page, maxPages),
            pageParams: addTo(data2.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous2 = direction === "backward";
          const pageParamFn = previous2 ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous2);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a3, _b3;
          return (_b3 = (_a3 = context.options).persister) == null ? void 0 : _b3.call(
            _a3,
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return pages.length > 0 ? (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
var QueryClient = (_h = class {
  constructor(config = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data2 = state.data;
      return [queryKey, data2];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data2 = functionalUpdate(updater, prevData);
    if (data2 === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data2, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(
      options.queryHash
    )) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$4).catch(noop$4);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if ((filters == null ? void 0 : filters.refetchType) === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$4);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$4);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$4).catch(noop$4);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$4).catch(noop$4);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults2 = [...__privateGet(this, _queryDefaults).values()];
    const result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults2.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var QueryObserver = (_i = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _currentThenable);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client2, client);
    __privateSet(this, _selectError, null);
    __privateSet(this, _currentThenable, pendingThenable());
    if (!this.options.experimental_prefetchInRender) {
      __privateGet(this, _currentThenable).reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client2).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client2).defaultQueryOptions(options);
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a2;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data2;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data2 = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data2 = options.select(newState.data);
          data2 = replaceData(prevResult == null ? void 0 : prevResult.data, data2, options);
          __privateSet(this, _selectResult, data2);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data2 = newState.data;
    }
    if (options.placeholderData !== void 0 && data2 === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data2 = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data2 = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data2 !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data: data2,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: __privateGet(this, _currentThenable)
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = __privateGet(this, _currentThenable);
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client2 = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop$4);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time2 = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time2 + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client2).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _i);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var MutationObserver = (_j = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client3);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client3, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a2;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client3).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client3).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a2;
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a2;
    __privateSet(this, _mutateOptions, options);
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client3).getMutationCache().build(__privateGet(this, _client3), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client3 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a2;
  const state = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e2 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e2, action.error, variables, context);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _j);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$5 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$3 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a && a.defaultProps) for (d2 in g2 = a.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$4, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a, b2) {
  return { $$typeof: l$4, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$4;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
function R$1(a, b2, e2, d2, c2) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h2 = false;
  if (null === a) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$4:
        case n$5:
          h2 = true;
      }
  }
  if (h2) return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
    return a2;
  })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a)) for (var g2 = 0; g2 < a.length; g2++) {
    k2 = a[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$1(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a), "function" === typeof f2) for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b2, e2) {
  if (null == a) return a;
  var d2 = [], c2 = 0;
  R$1(a, d2, "", "", function(a2) {
    return b2.call(e2, a2, c2++);
  });
  return d2;
}
function T$1(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
  S$1(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$1(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$3;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$5;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a.type && a.type.defaultProps) var g2 = a.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$4, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$3, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$4, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b2 = M$1.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$4, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b2) {
  return U$1.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$1.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$1.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$1.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$1.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$1.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$1.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$1.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$3 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$4 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q$4(c2, a, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a) m$4.call(a, b2) && !p$5.hasOwnProperty(b2) && (d2[b2] = a[b2]);
  if (c2 && c2.defaultProps) for (b2 in a = c2.defaultProps, a) void 0 === d2[b2] && (d2[b2] = a[b2]);
  return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$3;
reactJsxRuntime_production_min.jsx = q$4;
reactJsxRuntime_production_min.jsxs = q$4;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client = reactExports.useContext(QueryClientContext);
  if (queryClient2) {
    return queryClient2;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  reactExports.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop$3() {
}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};
var ensureSuspenseTimers = (defaultedOptions) => {
  const originalStaleTime = defaultedOptions.staleTime;
  if (defaultedOptions.suspense) {
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient2) {
  var _a2, _b2, _c2, _d2, _e2;
  const client = useQueryClient(queryClient2);
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b2 = (_a2 = client.getDefaultOptions().queries) == null ? void 0 : _a2._experimental_beforeQuery) == null ? void 0 : _b2.call(
    _a2,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = reactExports.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop$3;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  (_d2 = (_c2 = client.getDefaultOptions().queries) == null ? void 0 : _c2._experimental_afterQuery) == null ? void 0 : _d2.call(
    _c2,
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (_e2 = client.getQueryCache().get(defaultedOptions.queryHash)) == null ? void 0 : _e2.promise
    );
    promise == null ? void 0 : promise.catch(noop$3).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver, queryClient2);
}
function useMutation(options, queryClient2) {
  const client = useQueryClient(queryClient2);
  const [observer] = reactExports.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate2 = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$3);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate: mutate2, mutateAsync: result.mutate };
}
function uuid4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r2 = Math.random() * 16 | 0, v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
}
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString$2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$2 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$2(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim$2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject$2(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend$2 = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray$2(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$2 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit2 = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray$2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit2(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit2(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils$1 = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer: isBuffer$2,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject$2,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$2,
  trim: trim$2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$2,
  hasOwnProp: hasOwnProperty$2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError$1(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index2) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el2, key) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData$1(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data2);
    if (isObjectPayload && utils$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1.isArrayBuffer(data2) || utils$1.isBuffer(data2) || utils$1.isStream(data2) || utils$1.isFile(data2) || utils$1.isBlob(data2)) {
      return data2;
    }
    if (utils$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data2 && utils$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value)) return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data2 = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data2 = fn.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path2) && cookie.push("path=" + path2);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type2, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters2[i2];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a, b2, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION$1 = "1.6.7";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners) return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError$1(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all$2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var OpenAIModel = /* @__PURE__ */ ((OpenAIModel2) => {
  OpenAIModel2["GPT_3_5_TURBO"] = "gpt-3.5-turbo";
  OpenAIModel2["GPT_3_5_TURBO_16K"] = "gpt-3.5-turbo-16k";
  OpenAIModel2["GPT_4"] = "gpt-4";
  OpenAIModel2["GPT_4_32K"] = "gpt-4-32k";
  return OpenAIModel2;
})(OpenAIModel || {});
const CONFIG = {
  publicPath: window._clientSettings.publicPath,
  staticAssets: window._clientSettings.staticAssets,
  dataStoreEndpoint: window._clientSettings.dataStoreEndpoint,
  mrtEndpoint: window._clientSettings.mrtEndpoint,
  aiEndpoint: window._clientSettings.aiEndpoint,
  userVerificationUrl: window._clientSettings.userVerificationUrl,
  egptEndpoint: window._clientSettings.egptEndpoint,
  egptSystemEndpoint: window._clientSettings.egptSystemEndpoint,
  componentInfoEndpoint: window._clientSettings.componentInfoEndpoint,
  miscEndpoint: window._clientSettings.miscEndpoint,
  agentApiEndpoint: window._clientSettings.agentApiEndpoint,
  clientId: window._clientSettings.clientId,
  username: window._clientSettings.username,
  hostname: new URL(document.baseURI).hostname,
  currentLocale: window._clientSettings.currentLocale,
  allowedSiteLocales: window._clientSettings.allowedSiteLocales,
  isGenerativeAvailable: window._clientSettings.isGenerativeAvailable,
  currentSite: window._clientSettings.currentSite,
  siteIds: window._clientSettings.siteIds,
  appSettingsOverride: window._clientSettings.appSettingsOverride,
  composableConfiguration: window._clientSettings.composableConfiguration,
  scapiShortCode: window._clientSettings.scapiShortCode,
  scapiOrgId: window._clientSettings.scapiOrgId
};
const APP_SETTINGS = {
  OCAPI_VERSION: "v23_2",
  // MODEL COSTS c per 1k tokens
  MODEL_COSTS: {
    [OpenAIModel.GPT_3_5_TURBO]: {},
    [OpenAIModel.GPT_3_5_TURBO_16K]: {},
    [OpenAIModel.GPT_4]: {},
    [OpenAIModel.GPT_4_32K]: {}
  },
  ...CONFIG.appSettingsOverride
};
async function getBMAuthGrant$1() {
  const response = await fetch(`https://${CONFIG.hostname}/dw/oauth2/access_token`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: `grant_type=urn%3Ademandware%3Aparams%3Aoauth%3Agrant-type%3Aclient-id%3Adwsid%3Adwsecuretoken&client_id=${CONFIG.clientId}`,
    includeCredentials: true
  });
  const data2 = await response.json();
  return data2;
}
const __vite_import_meta_env__$1 = {};
const createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api2 = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState2(setState, getState, api2);
  return api2;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$2 = reactExports;
function h$3(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var k$2 = "function" === typeof Object.is ? Object.is : h$3, l$2 = e$2.useState, m$3 = e$2.useEffect, n$3 = e$2.useLayoutEffect, p$4 = e$2.useDebugValue;
function q$3(a, b2) {
  var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$2(c2) && g2({ inst: c2 });
  }, [a, d2, b2]);
  m$3(function() {
    r$2(c2) && g2({ inst: c2 });
    return a(function() {
      r$2(c2) && g2({ inst: c2 });
    });
  }, [a]);
  p$4(d2);
  return d2;
}
function r$2(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var d2 = b2();
    return !k$2(a, d2);
  } catch (f2) {
    return true;
  }
}
function t$3(a, b2) {
  return b2();
}
var u$2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$3 : q$3;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$2.useSyncExternalStore ? e$2.useSyncExternalStore : u$2;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$2 = reactExports, n$2 = shimExports;
function p$3(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var q$2 = "function" === typeof Object.is ? Object.is : p$3, r$1 = n$2.useSyncExternalStore, t$2 = h$2.useRef, u$1 = h$2.useEffect, v$3 = h$2.useMemo, w$1 = h$2.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e2, l2, g2) {
  var c2 = t$2(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else f2 = c2.current;
  c2 = v$3(function() {
    function a2(a3) {
      if (!c3) {
        c3 = true;
        d3 = a3;
        a3 = l2(a3);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a3)) return k2 = b3;
        }
        return k2 = a3;
      }
      b3 = k2;
      if (q$2(d3, a3)) return b3;
      var e3 = l2(a3);
      if (void 0 !== g2 && g2(b3, e3)) return b3;
      d3 = a3;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a2(b2());
    }, null === m2 ? void 0 : function() {
      return a2(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$1(a, c2[0], c2[1]);
  u$1(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$1(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
const __vite_import_meta_env__ = {};
const { useDebugValue } = React;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api2, selector = identity, equalityFn) {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice2 = useSyncExternalStoreWithSelector(
    api2.subscribe,
    api2.getState,
    api2.getServerState || api2.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState2) => {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && typeof createState2 !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api2 = typeof createState2 === "function" ? createStore(createState2) : createState2;
  const useBoundStore = (selector, equalityFn) => useStore(api2, selector, equalityFn);
  Object.assign(useBoundStore, api2);
  return useBoundStore;
};
const create$5 = (createState2) => createState2 ? createImpl(createState2) : createImpl;
const useGlobalState = create$5((set) => ({
  globalError: [],
  currentLocale: CONFIG.currentLocale || "default",
  setError: (err) => set(({
    globalError
  }) => ({
    globalError: [...globalError, err]
  })),
  clearErrors: () => set(() => ({
    globalError: []
  })),
  setCurrentLocale: (locale) => set(() => ({
    currentLocale: locale
  }))
}));
const api$1 = axios.create({
  baseURL: `/s/-/dw/data/${APP_SETTINGS.OCAPI_VERSION ?? "v23_2"}/`
});
var accessToken = null;
var accessTokenExpiration = null;
api$1.interceptors.request.use(async (config) => {
  if (!accessToken || !accessTokenExpiration || accessTokenExpiration < Date.now()) {
    var grant = await getBMAuthGrant$1();
    accessToken = grant.access_token;
    accessTokenExpiration = Date.now() + (grant.expires_in - 5) * 1e3;
  }
  config.headers.Authorization = `Bearer ${accessToken}`;
  return config;
});
api$1.interceptors.response.use(null, (error) => {
  var _a2, _b2, _c2;
  if (error.response) {
    console.error(error.response.data);
  }
  if (error.response && error.response.status !== 404 && // special case see below
  !((_c2 = (_b2 = (_a2 = error.response) == null ? void 0 : _a2.data) == null ? void 0 : _b2.fault) == null ? void 0 : _c2.type) === "UnknownPropertyException") {
    useGlobalState.getState().setError("API Error: Refresh the page");
  }
  throw error;
});
var failedAuths = 0;
api$1.interceptors.response.use(null, async (error) => {
  var _a2;
  if (((_a2 = error == null ? void 0 : error.response) == null ? void 0 : _a2.status) === 401 && failedAuths < 3) {
    failedAuths++;
    var grant = await getBMAuthGrant$1();
    accessToken = grant.access_token;
    accessTokenExpiration = Date.now() + (grant.expires_in - 5) * 1e3;
    return api$1.request(error.config);
  }
  throw error;
});
const CUSTOM_OBJ_TYPE = "QLabsDataStore";
function customObjToDataStoreObject(obj) {
  var _a2;
  return {
    typeId: obj.c_typeId,
    creationDate: obj.creation_date,
    lastModified: obj.last_modified,
    resourceState: obj._resource_state,
    attrs: ((_a2 = obj.c_attrs) == null ? void 0 : _a2.reduce((attrs, attr) => {
      const [key, value] = attr.split("=");
      attrs[key] = value;
      return attrs;
    }, {})) ?? {},
    data: {
      __id: obj.key_value_string,
      __typeId: obj.c_typeId,
      ...JSON.parse(obj.c_data)
    },
    id: obj.key_value_string
  };
}
const SYSTEM_FIELD_MAP = {
  creationDate: "creation_date",
  lastModified: "last_modified"
};
const SYSTEM_FIELDS = ["creation_date", "last_modified"];
async function searchObjects(typeId, {
  attrs = {},
  attributeOperator = "AND",
  start = 0,
  count = 100,
  sort = []
} = {}) {
  var _a2;
  var queryRequirements = [{
    term_query: {
      fields: ["c_typeId"],
      operator: "is",
      values: [typeId]
    }
  }];
  if (attrs) {
    const attrQueries = Object.entries(attrs).map(([key, value]) => ({
      term_query: {
        fields: ["c_attrs"],
        operator: "is",
        values: [`${key}=${value}`]
      }
    }));
    queryRequirements.push({
      bool_query: {
        [attributeOperator === "AND" ? "must" : "should"]: attrQueries
      }
    });
  }
  var _sorts;
  if (sort.length > 0) {
    _sorts = sort.map((sort2) => {
      const field = SYSTEM_FIELD_MAP[sort2.field] || sort2.field;
      return {
        field: SYSTEM_FIELDS.includes(field) ? field : `c_${field}`,
        sort_order: sort2.sortOrder
      };
    });
  }
  const response = await api$1.post(`custom_objects_search/${CUSTOM_OBJ_TYPE}`, {
    query: {
      bool_query: {
        must: queryRequirements
      }
    },
    select: "(**)",
    start,
    count,
    sorts: _sorts
  });
  return {
    count: response.data.count,
    start: response.data.start,
    total: response.data.total,
    data: ((_a2 = response.data.hits) == null ? void 0 : _a2.map(customObjToDataStoreObject)) || []
  };
}
async function getObject(id2) {
  const response = await api$1.post(`custom_objects_search/${CUSTOM_OBJ_TYPE}`, {
    query: {
      term_query: {
        fields: ["key_value_string"],
        operator: "is",
        values: [id2]
      }
    },
    select: "(**)"
  });
  if (!response.data.hits || response.data.hits.length === 0) {
    throw new Error(`No object found for id ${id2}`);
  }
  return customObjToDataStoreObject(response.data.hits[0]);
}
async function postObject(typeId, data2, attrs) {
  var newId = uuid4().replace(/-/g, "");
  var serializedData = JSON.stringify(data2, null, 2);
  const response = await api$1.put(`custom_objects/${CUSTOM_OBJ_TYPE}/${newId}`, {
    _resource_state: "not_exists",
    c_typeId: typeId,
    c_data: serializedData,
    c_attrs: Object.entries(attrs || {}).map(([key, value]) => `${key}=${value}`)
  });
  return customObjToDataStoreObject(response.data);
}
async function putObject(obj, attrs) {
  var _data = Object.entries(obj.data).reduce((acc, [key, value]) => {
    if (key !== "__id" && key !== "__typeId") {
      acc[key] = value;
    }
    return acc;
  }, {});
  var serializedData = JSON.stringify(_data, null, 2);
  const response = await api$1.put(`custom_objects/${CUSTOM_OBJ_TYPE}/${obj.id}`, {
    _resource_state: obj.resourceState,
    c_typeId: obj.typeId,
    c_data: serializedData,
    c_attrs: Object.entries(attrs || {}).map(([key, value]) => `${key}=${value}`)
  });
  return customObjToDataStoreObject(response.data);
}
async function patchObject(obj, attrs) {
  const existing = await api$1.get(`custom_objects/${CUSTOM_OBJ_TYPE}/${obj.id}`);
  const existingData = JSON.parse(existing.data.c_data);
  var serializedData;
  {
    serializedData = JSON.stringify({
      ...existingData,
      ...obj.data
    }, null, 2);
  }
  const response = await api$1.put(`custom_objects/${CUSTOM_OBJ_TYPE}/${obj.id}`, {
    _resource_state: obj.resourceState,
    c_typeId: obj.typeId,
    c_data: serializedData,
    c_attrs: Object.entries(attrs || {}).map(([key, value]) => `${key}=${value}`)
  });
  return customObjToDataStoreObject(response.data);
}
async function deleteObject(obj) {
  await api$1.delete(`custom_objects/${CUSTOM_OBJ_TYPE}/${obj.id}`);
}
if (typeof window !== "undefined") {
  window.qlabsDataStore = {
    searchObjects,
    getObject,
    postObject,
    putObject,
    patchObject,
    deleteObject
  };
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$2 = 0;
var character = 0;
var characters = "";
function node$1(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$2 > 0 ? charat(characters, --position$2) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$2 < length ? charat(characters, position$2++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$2);
}
function caret() {
  return position$2;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$2 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim$1(slice(position$2 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace$1(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$2;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$2;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$2 - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position$2);
}
function compile(value) {
  return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$2(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous2 = character2, character2 = next()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference = ruleset(characters2, root2, parent, index2, offset2, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$2(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$2(value, reference, reference, rule && append2(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset2, rules, points, type2, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset2 === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify$2(element2, index2, children, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element2, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element2, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element2) {
    if (!element2.root) {
      if (element2 = element2.return)
        callback(element2);
    }
  };
}
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$2);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$2 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value = element2.value, parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element2.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element2.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value = element2.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2["return"]) switch (element2.type) {
      case DECLARATION:
        element2["return"] = prefix(element2.value, element2.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element2, {
          value: replace(element2.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element2.length) return combine(element2.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element2, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element2, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element2, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element2, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$2 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c$1:
        switch (a = a.type, a) {
          case l$1:
          case m$2:
          case e$1:
          case g$1:
          case f$1:
          case p$2:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k$1:
              case n$1:
              case t$1:
              case r:
              case h$1:
                return a;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a) {
  return z$1(a) === m$2;
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$2;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$1;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$2;
reactIs_production_min$1.isAsyncMode = function(a) {
  return A$1(a) || z$1(a) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a) {
  return z$1(a) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a) {
  return z$1(a) === h$1;
};
reactIs_production_min$1.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c$1;
};
reactIs_production_min$1.isForwardRef = function(a) {
  return z$1(a) === n$1;
};
reactIs_production_min$1.isFragment = function(a) {
  return z$1(a) === e$1;
};
reactIs_production_min$1.isLazy = function(a) {
  return z$1(a) === t$1;
};
reactIs_production_min$1.isMemo = function(a) {
  return z$1(a) === r;
};
reactIs_production_min$1.isPortal = function(a) {
  return z$1(a) === d$1;
};
reactIs_production_min$1.isProfiler = function(a) {
  return z$1(a) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a) {
  return z$1(a) === f$1;
};
reactIs_production_min$1.isSuspense = function(a) {
  return z$1(a) === p$2;
};
reactIs_production_min$1.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$2 || a === g$1 || a === f$1 || a === p$2 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$2);
};
reactIs_production_min$1.typeOf = z$1;
{
  reactIs$2.exports = reactIs_production_min$1;
}
var reactIsExports$1 = reactIs$2.exports;
var reactIs$1 = reactIsExports$1;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current2 = serialized;
    do {
      cache.insert(serialized === current2 ? "." + className : "", current2, cache.sheet, true);
      current2 = current2.next;
    } while (current2 !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  {
    return interpolation;
  }
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && registered == null) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var hasOwn$2 = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwn$2.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwn$2.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref2;
  newProps.className = className;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var Fragment = jsxRuntimeExports.Fragment;
function jsx(type2, props, key) {
  if (!hasOwn$2.call(props, "css")) {
    return jsxRuntimeExports.jsx(type2, props, key);
  }
  return jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(type2, props), key);
}
function jsxs(type2, props, key) {
  if (!hasOwn$2.call(props, "css")) {
    return jsxRuntimeExports.jsxs(type2, props, key);
  }
  return jsxRuntimeExports.jsxs(Emotion$1, createEmotionProps(type2, props), key);
}
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c2 = a.length;
    a.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a[d2];
      if (0 < g2(e2, b2)) a[d2] = b2, a[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b2 = a[0], c2 = a.pop();
    if (c2 !== b2) {
      a[0] = c2;
      a: for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a[d2] = x2, a[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a, b2) {
    var c2 = a.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a);
    }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++) da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$1(a, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new v$1(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z[b2] = new v$1(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new v$1(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new v$1(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new v$1(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new v$1(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z[b2] = new v$1(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c2, d2) {
  var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a.render;
      a = a.displayName;
      a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
    case Ha:
      b2 = a._payload;
      a = a._init;
      try {
        return Qa(a(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b2 = a._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c2 = b2.checked;
  return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a.value || a.value != c2) a.value = "" + c2;
  } else a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function cb(a, b2, c2) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a) null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++) e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
  return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a._wrapperState = { initialValue: Sa(c2) };
}
function ib(a, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b2.firstChild; ) a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a.setProperty(c2, e2) : a[c2] = e2;
  }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-")) return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p$1(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2) for (a = 0; a < b2.length; a++) Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c2) {
  if (Ib) return a(b2, c2);
  Ib = true;
  try {
    return Gb(a, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c2 = a.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d2;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c2 = a;
  if (a.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p$1(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2) throw Error(p$1(188));
    return b2 !== a ? null : a;
  }
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$1(190));
  }
  if (3 !== c2.tag) throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2) return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c2 = a.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a.entangledLanes;
  if (0 !== b2) for (a = a.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
  return d2;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a);
  return b2;
}
function Ac(a, b2, c2) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c2;
}
function Bc(a, b2) {
  var c2 = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d2 = a.eventTimes;
  for (a = a.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a, b2) {
  var c2 = a.entangledLanes |= b2;
  for (a = a.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c2, d2, e2, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d2;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c2) {
      c2 = a.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c2) {
  Xc(a) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a, b2, c2, d2);
    if (null === e2) hd(a, b2, d2, id$2, c2), Sc(a, d2);
    else if (Uc(e2, a, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c2, d2);
        null === f2 && hd(a, b2, d2, id$2, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a, b2, d2, null, c2);
  }
}
var id$2 = null;
function Yc(a, b2, c2, d2) {
  id$2 = null;
  a = xb(d2);
  a = Wc(a);
  if (null !== a) if (b2 = Vb(a), null === b2) a = null;
  else if (c2 = b2.tag, 13 === c2) {
    a = Wb(b2);
    if (null !== a) return a;
    a = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a = null;
  } else b2 !== a && (a = null);
  id$2 = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++) ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a) a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b2) {
  switch (a) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b2.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b2) {
  if (ie) return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
}
function ne(a, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b2 = ue(a);
  if (Wa(b2)) return a;
}
function ve(a, b2) {
  if ("change" === a) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a, xb(a));
    Jb(re, b2);
  }
}
function Ce(a, b2, c2) {
  "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b2) {
  if ("click" === a) return te(b2);
}
function Fe(a, b2) {
  if ("input" === a || "change" === a) return te(b2);
}
function Ge(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b2) {
  if (He(a, b2)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b2) {
  var c2 = Je(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2) return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a = b2.contentWindow;
    else break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe(a) {
  var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; ) 1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b2 = We[a], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a] = b2[c2];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = c2;
  Ub(d2, b2, void 0, a);
  a.currentTarget = null;
}
function se(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a.length; c2++) {
    var d2 = a[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a + "__bubble";
  c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
}
function qf(a, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
}
function hd(a, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a, h3, d3);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c2) : ke(a, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a, b2, c2) {
  return { instance: a, listener: b2, currentTarget: c2 };
}
function oe(a, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d2;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c2) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c2) throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c2 = a.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2) return b2;
  for (var c2 = a.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a = Mf(a); null !== a; ) {
        if (c2 = a[Of]) return c2;
        a = Mf(a);
      }
      return b2;
    }
    a = c2;
    c2 = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b2, c2) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a, b2, c2) {
  var d2 = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$1(108, Ra(a) || "Unknown", e2));
  return A({}, c2, d2);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b2, c2) {
  var d2 = a.stateNode;
  if (!d2) throw Error(p$1(169));
  c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a < c2.length; a++) {
        var d2 = c2[a];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d2 = rg;
  a = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a, b2)) {
        if (Dg(a)) throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a)) throw Hg(), Error(p$1(418));
    for (; b2; ) Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2) {
  if (a && a.defaultProps) {
    b2 = A({}, b2);
    a = a.defaultProps;
    for (var c2 in a) void 0 === b2[c2] && (b2[c2] = a[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b2 = Mg.current;
  E(Mg);
  a._currentValue = b2;
}
function Sg(a, b2, c2) {
  for (; null !== a; ) {
    var d2 = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a === c2) break;
    a = a.return;
  }
}
function Tg(a, b2) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b2 = a._currentValue;
  if (Pg !== a) if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
    if (null === Ng) throw Error(p$1(308));
    Og = a;
    Ng.dependencies = { lanes: 0, firstContext: a };
  } else Og = Og.next = a;
  return b2;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a, d2);
}
function Zg(a, b2) {
  a.lanes |= b2;
  var c2 = a.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a;
  for (a = a.return; null !== a; ) a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b2, c2) {
  var d2 = a.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a, c2);
}
function eh(a, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
function fh(a, b2) {
  var c2 = a.updateQueue, d2 = a.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a.updateQueue = c2;
    return;
  }
  a = c2.lastBaseUpdate;
  null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a, b2, c2, d2) {
  var e2 = a.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function ih(a, b2, c2) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a) for (b2 = 0; b2 < a.length; b2++) {
    var d2 = a[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$1(191, e2));
      e2.call(d2);
    }
  }
}
var jh = new aa.Component().refs;
function kh(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
  a.memoizedState = c2;
  0 === a.lanes && (a.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternals;
  var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a, e2, d2);
  null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
} };
function oh(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a.stateNode = b2;
  b2._reactInternals = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = jh;
  ah(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$1(147, a));
      var e2 = d2, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a) throw Error(p$1(284));
    if (!c2._owner) throw Error(p$1(290, a));
  }
  return a;
}
function th(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function uh(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function vh$1(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = wh(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a2, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = sh(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function l2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
        case wa:
          return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a2, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
      th(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a2,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      th(a2, c3);
    }
    return null;
  }
  function y2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
        case wa:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a2, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a2, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a2, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a2, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a2, l3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                }
                c2(a2, l3);
                break;
              } else b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a2, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a2;
                a2 = d3;
                break a;
              } else {
                c2(a2, d3);
                break;
              }
              else b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a2, d3, f3, h3);
      if (Ka(f3)) return t2(a2, d3, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh) throw Error(p$1(174));
  return a;
}
function Ih(a, b2) {
  G(Gh, b2);
  G(Fh, a);
  G(Eh, Dh);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(Eh);
  G(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a.type);
  b2 !== c2 && (G(Fh, a), G(Eh, c2));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$1(321));
}
function Wh(a, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++) if (!He(a[c2], b2[c2])) return false;
  return true;
}
function Xh(a, b2, c2, d2, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2) throw Error(p$1(301));
      f2 += 1;
      P = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b2) throw Error(p$1(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = O.next;
  var b2 = null === P ? N.memoizedState : P.next;
  if (null !== b2) P = b2, O = a;
  else {
    if (null === a) throw Error(p$1(310));
    O = a;
    a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function fi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a = c2.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2) throw Error(p$1(311));
  c2.lastRenderedReducer = a;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a, b2) {
  var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a), [a]);
  if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R) throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a, b2, c2) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c2 };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
}
function mi(a, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a);
}
function ki(a, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a);
  });
}
function oi(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c2 = b2();
    return !He(a, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a) {
  var b2 = Zg(a, 1);
  null !== b2 && mh(b2, a, 1, -1);
}
function qi(a) {
  var b2 = ci();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b2.memoizedState, a];
}
function li(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b2, c2, d2) {
  var e2 = ci();
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a, b2) {
  return ti(8390656, 8, a, b2);
}
function ji(a, b2) {
  return ui(2048, 8, a, b2);
}
function wi(a, b2) {
  return ui(4, 2, a, b2);
}
function xi(a, b2) {
  return ui(4, 4, a, b2);
}
function yi(a, b2) {
  if ("function" === typeof b2) return a = a(), b2(a), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a = a(), b2.current = a, function() {
    b2.current = null;
  };
}
function zi(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b2, a), c2);
}
function Ai() {
}
function Bi(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}
function Ci(a, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1])) return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}
function Di(a, b2, c2) {
  if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
  return b2;
}
function Ei(a, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b2();
  } finally {
    C = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b2, c2) {
  var d2 = lh(a);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a)) Ii(b2, c2);
  else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a, b2, c2) {
  var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a)) Ii(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = Yg(a, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a) {
  var b2 = a.alternate;
  return a === N || null !== b2 && b2 === N;
}
function Ii(a, b2) {
  Th = Sh = true;
  var c2 = a.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a.pending = b2;
}
function Ji(a, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
  ci().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a),
    c2
  );
}, useLayoutEffect: function(a, b2) {
  return ti(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ti(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d2.queue = a;
  a = a.dispatch = Gi.bind(null, N, a);
  return [d2.memoizedState, a];
}, useRef: function(a) {
  var b2 = ci();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b2 = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c2) {
  var d2 = N, e2 = ci();
  if (I) {
    if (void 0 === c2) throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R) throw Error(p$1(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a
  ), [a]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a = ci(), b2 = R.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b2 = di();
    return Di(b2, O.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b2 = di().memoizedState;
    return [a, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b2 = di();
  return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b2 = di().memoizedState;
  return [a, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Li(a, b2, c2) {
  return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a, b2);
  };
  return c2;
}
function Ri(a, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a, b2, c2) {
  var d2 = a.pingCache;
  if (null === d2) {
    d2 = a.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
}
function Vi(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag) b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b2, c2, d2, e2) {
  if (0 === (a.mode & 1)) return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b2, c2, d2) {
  b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
}
function Zi(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a && !Ug) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, d2, e2);
  return b2.child;
}
function aj(a, b2, c2, d2, e2) {
  if (null === a) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
    a = yh(c2.type, null, d2, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a.ref === b2.ref) return $i(a, b2, e2);
  }
  b2.flags |= 1;
  a = wh(f2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function cj(a, b2, c2, d2, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d2) && a.ref === b2.ref) if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2)) 0 !== (a.flags & 131072) && (Ug = true);
    else return b2.lanes = a.lanes, $i(a, b2, e2);
  }
  return dj(a, b2, c2, d2, e2);
}
function ej(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(fj, gj);
    gj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
  Yi(a, b2, e2, c2);
  return b2.child;
}
function hj(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a && !Ug) return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, c2, e2);
  return b2.child;
}
function ij(a, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode) jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a, b2, c2, d2, f2, e2);
}
function kj(a, b2, c2, d2, e2, f2) {
  hj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), $i(a, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  Ih(a, b2.containerInfo);
}
function mj(a, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState) e2 |= 1;
  G(M, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return sj(a, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a.child;
  a = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function tj(a, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a.child, null, c2);
  a = rj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function sj(a, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return tj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Li(f2, d2, void 0);
    return tj(a, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
    }
    uj();
    d2 = Li(Error(p$1(421)));
    return tj(a, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a, b2, c2) {
  a.lanes |= b2;
  var d2 = a.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a.return, b2, c2);
}
function xj(a, b2, c2, d2, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a, b2, d2.children, c2);
  d2 = M.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b2.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && wj(a, c2, b2);
      else if (19 === a.tag) wj(a, c2, b2);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b2) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b2) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d2 &= 1;
  }
  G(M, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      xj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a = e2.alternate;
        if (null !== a && null === Mh(a)) {
          b2.child = e2;
          break;
        }
        a = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a;
      }
      xj(b2, true, c2, null, f2);
      break;
    case "together":
      xj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function jj(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a, b2, c2) {
  null !== a && (b2.dependencies = a.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a && b2.child !== a.child) throw Error(p$1(153));
  if (null !== b2.child) {
    a = b2.child;
    c2 = wh(a, a.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; ) a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(M, M.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return pj(a, b2, c2);
        G(M, M.current & 1);
        a = $i(a, b2, c2);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d2) return yj(a, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a, b2, c2);
  }
  return $i(a, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b2, c2, d2) {
  var e2 = a.memoizedProps;
  if (e2 !== d2) {
    a = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a, e2);
        d2 = Ya(a, d2);
        f2 = [];
        break;
      case "select":
        e2 = A({}, e2, { value: void 0 });
        d2 = A({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d2 = gb(a, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Dj = function(a, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a, b2) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b2 = a.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
  }
}
function S(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else for (e2 = a.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d2;
  a.childLanes = c2;
  return b2;
}
function Fj(a, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a || null === a.child) Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a && null != b2.stateNode) Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$1(166));
          S(b2);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
          a[Of] = b2;
          a[Pf] = d2;
          Aj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a);
                e2 = d2;
                break;
              case "source":
                D("error", a);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e2 = d2;
                break;
              case "details":
                D("toggle", a);
                e2 = d2;
                break;
              case "input":
                Za(a, d2);
                e2 = Ya(a, d2);
                D("invalid", a);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A({}, d2, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d2);
                e2 = gb(a, d2);
                D("invalid", a);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a);
                db(a, d2, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode) Dj(a, b2, a.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$1(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(M);
      d2 = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$1(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(M);
      f2 = b2.memoizedState;
      if (null === f2) return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Ej(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b2.child; null !== a; ) {
          g2 = Mh(a);
          if (null !== g2) {
            b2.flags |= 128;
            Ej(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
            G(M, M.current & 1 | 2);
            return b2.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a = Mh(g2), null !== a) {
          if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
        } else 2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Jj(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate) throw Error(p$1(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a, b2) {
  var c2 = a.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a, b2, d2);
  }
  else c2.current = null;
}
function Nj(a, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a, b2, d2);
  }
}
var Oj = false;
function Pj(a, b2) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c2 = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; ) if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a) a.return = b2, V = a;
  else for (; null !== V; ) {
    b2 = V;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$1(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a = b2.sibling;
    if (null !== a) {
      a.return = b2.return;
      V = a;
      break;
    }
    V = b2.return;
  }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a) === a) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c2 = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c2;
        break;
      default:
        a = c2;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Tj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Tj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Uj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Wj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b2, c2), a = a.sibling; null !== a; ) Wj(a, b2, c2), a = a.sibling;
}
function Xj(a, b2, c2) {
  var d2 = a.tag;
  if (5 === d2 || 6 === d2) a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
  else if (4 !== d2 && (a = a.child, null !== a)) for (Xj(a, b2, c2), a = a.sibling; null !== a; ) Xj(a, b2, c2), a = a.sibling;
}
var X = null, Yj = false;
function Zj(a, b2, c2) {
  for (c2 = c2.child; null !== c2; ) ak(a, b2, c2), c2 = c2.sibling;
}
function ak(a, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a, b2, c2);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a, b2, c2);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Zj(a, b2, c2);
      break;
    case 21:
      Zj(a, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
      break;
    default:
      Zj(a, b2, c2);
  }
}
function bk(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c2 = a.stateNode;
    null === c2 && (c2 = a.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X = h2.stateNode;
            Yj = false;
            break a;
          case 3:
            X = h2.stateNode.containerInfo;
            Yj = true;
            break a;
          case 4:
            X = h2.stateNode.containerInfo;
            Yj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X) throw Error(p$1(160));
      ak(f2, g2, e2);
      X = null;
      Yj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) ek(b2, a), b2 = b2.sibling;
}
function ek(a, b2) {
  var c2 = a.alternate, d2 = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a);
      fk(a);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      dk(b2, a);
      fk(a);
      if (d2 & 4) {
        if (null === a.stateNode) throw Error(p$1(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a);
      fk(a);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      dk(b2, a);
      fk(a);
      break;
    case 13:
      dk(b2, a);
      fk(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
      fk(a);
      if (d2 & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Qj(4, r2, r2.return);
                break;
              case 1:
                Mj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Mj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  hk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      dk(b2, a);
      fk(a);
      d2 & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function ik(a, b2, c2) {
  V = a;
  jk(a);
}
function jk(a, b2, c2) {
  for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
        for (; null !== f2; ) V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U = l2;
      }
      lk(a);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U || Rj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && ih(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              ih(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$1(163));
        }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok$1 = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b2, c2, d2) {
  if (50 < zk) throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a, c2, d2);
  if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b2) {
  var c2 = a.callbackNode;
  wc(a, b2);
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c2;
  }
}
function Hk(a, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6)) throw Error(p$1(327));
  var c2 = a.callbackNode;
  if (Ik() && a.callbackNode !== c2) return null;
  var d2 = uc(a, a === R ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2) b2 = Jk(a, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a || Z !== b2) vk = null, Hj = B() + 500, Lk(a, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
    if (1 === b2) throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
    if (6 === b2) Dk(a, d2);
    else {
      e2 = a.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2)) throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
      a.finishedWork = e2;
      a.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a, 0)) break;
            e2 = a.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c2 ? Hk.bind(null, a) : null;
}
function Ok(a, b2) {
  var c2 = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
  a = Jk(a, b2);
  2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a) {
  if (0 !== (K & 6)) throw Error(p$1(327));
  Ik();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1)) return Ek(a, B()), null;
  var c2 = Jk(a, b2);
  if (0 !== a.tag && 2 === c2) {
    var d2 = xc(a);
    0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
  }
  if (1 === c2) throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
  if (6 === c2) throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a(b2);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a) return a();
  } finally {
    C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c2 = a.timeoutHandle;
  -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        Jh();
        E(Wf);
        E(H);
        Oh();
        break;
      case 5:
        Lh(d2);
        break;
      case 4:
        Jh();
        break;
      case 13:
        E(M);
        break;
      case 19:
        E(M);
        break;
      case 10:
        Rg(d2.type._context);
        break;
      case 22:
      case 23:
        Ij();
    }
    c2 = c2.return;
  }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b2;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++) if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    Wg = null;
  }
  return a;
}
function Nk(a, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok$1.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R !== a || Z !== b2) vk = null, Lk(a, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y) throw Error(p$1(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; ) Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); ) Vk(Y);
}
function Vk(a) {
  var b2 = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Tk(a) : Y = b2;
  ok$1.current = null;
}
function Tk(a) {
  var b2 = a;
  do {
    var c2 = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Qk(a, b2, c2) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b2, c2, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6)) throw Error(p$1(327));
  c2 = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c2) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c2 === a.current) throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a, f2);
  a === R && (Y = R = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok$1.current = null;
    Pj(a, c2);
    ek(c2, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c2;
    ik(c2);
    dc();
    K = h2;
    C = g2;
    pk.transition = f2;
  } else a.current = c2;
  wk && (wk = false, xk = a, yk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a, B());
  if (null !== b2) for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi) throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b2 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk) var d2 = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6)) throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Tj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Qj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V = x2;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
          else b: for (g2 = w2; null !== V; ) {
            h2 = V;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Rj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V = F2;
              break b;
            }
            V = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a, b2, 1);
  a = dh(a, b2, 1);
  b2 = L();
  null !== a && (Ac(a, 1, b2), Ek(a, b2));
}
function W(a, b2, c2) {
  if (3 === a.tag) Yk(a, a, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Yk(b2, a, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
        a = Ki(c2, a);
        a = Ri(b2, a, 1);
        b2 = dh(b2, a, 1);
        a = L();
        null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ui(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a.pingedLanes |= a.suspendedLanes & c2;
  R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
  Ek(a, b2);
}
function Zk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a = Zg(a, b2);
  null !== a && (Ac(a, b2, c2), Ek(a, c2));
}
function vj(a) {
  var b2 = a.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a, c2);
}
function ck(a, b2) {
  var c2 = 0;
  switch (a.tag) {
    case 13:
      var d2 = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a, c2);
}
var Wk;
Wk = function(a, b2, c2) {
  if (null !== a) if (a.memoizedProps !== b2.pendingProps || Wf.current) Ug = true;
  else {
    if (0 === (a.lanes & c2) && 0 === (b2.flags & 128)) return Ug = false, zj(a, b2, c2);
    Ug = 0 !== (a.flags & 131072) ? true : false;
  }
  else Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a, b2);
        a = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a = Lg(d2, a);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a) throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ki(Error(p$1(423)), b2);
          b2 = mj(a, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ki(Error(p$1(424)), b2);
          b2 = mj(a, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a, b2, c2);
            break a;
          }
          Yi(a, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return pj(a, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
    case 7:
      return Yi(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = $i(a, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = ch(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                Sg(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$1(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            Sg(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Yi(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
    case 15:
      return cj(a, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
    case 19:
      return yj(a, b2, c2);
    case 22:
      return ej(a, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Gk(a, b2) {
  return ac(a, b2);
}
function al(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c2, d2) {
  return new al(a, b2, c2, d2);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a) return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function wh(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a.flags & 14680064;
  c2.childLanes = a.childLanes;
  c2.lanes = a.lanes;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function yh(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a) bj(a) && (g2 = 1);
  else if ("string" === typeof a) g2 = 5;
  else a: switch (a) {
    case ya:
      return Ah(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return qj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$1(130, null == a ? a : typeof a, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a, b2, c2, d2) {
  a = Bg(7, a, d2, b2);
  a.lanes = c2;
  return a;
}
function qj(a, b2, c2, d2) {
  a = Bg(22, a, d2, b2);
  a.elementType = Ia;
  a.lanes = c2;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b2, c2) {
  a = Bg(6, a, null, b2);
  a.lanes = c2;
  return a;
}
function zh(a, b2, c2) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function bl(a, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = new bl(a, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
function el(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p$1(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c2 = a.type;
    if (Zf(c2)) return bg(a, c2, b2);
  }
  return b2;
}
function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
  a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
  a.context = el(null);
  c2 = a.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d2);
  Ek(a, d2);
  return a;
}
function gl(a, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a = dh(e2, b2, g2);
  null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
  return g2;
}
function hl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c2 = a.retryLane;
    a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a, b2) {
  il(a, b2);
  (a = a.alternate) && il(a, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$1(409));
  gl(a, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a);
    0 === c2 && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a2 = hl(g2);
        f2.call(a2);
      };
    }
    var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g2;
  }
  for (; e2 = a.lastChild; ) a.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = hl(g2);
        h2.call(a2);
      };
    }
    gl(b2, g2, a, e2);
  } else g2 = rl(c2, b2, a, e2, d2);
  return hl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a, 1, c3);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = Zg(a, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a, 134217728, c2);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = lh(a), c2 = Zg(a, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a, b2, d2);
    }
    jl(a, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b2) {
  var c2 = C;
  try {
    return C = a, b2();
  } finally {
    C = c2;
  }
};
yb = function(a, b2, c2) {
  switch (b2) {
    case "input":
      bb(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber) try {
    kc = wl.inject(vl), lc = wl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2)) throw Error(p$1(200));
  return dl(a, b2, null, c2);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!ol(a)) throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render) throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b2, c2) {
  if (!pl(b2)) throw Error(p$1(200));
  return sl(null, a, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a, b2, c2) {
  if (!ol(a)) throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d2) for (a = 0; a < d2.length; a++) c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new nl(b2);
};
reactDom_production_min.render = function(a, b2, c2) {
  if (!pl(b2)) throw Error(p$1(200));
  return sl(null, a, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a)) throw Error(p$1(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
  if (!pl(c2)) throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p$1(38));
  return sl(a, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
const EmbeddedMessaging = ({
  agent,
  siteId
}) => {
  const orgId = agent.orgId;
  const esDeveloperName = agent.esDeveloperName;
  const deploymentUrl = agent.deploymentUrl;
  const messagingUrl = agent.messagingUrl;
  const [userJWT, setUserJWT] = reactExports.useState();
  const [visiblePrechatFields, setVisiblePrechatFields] = reactExports.useState({});
  const [prechatFieldsReady, setPrechatFieldsReady] = reactExports.useState(!agent.deployStorefront);
  reactExports.useEffect(() => {
    async function initVerification() {
      const userVerificationUrl = window.__qlabsConfig.userVerificationUrl;
      var resp = await fetch(userVerificationUrl, {
        method: "GET",
        credentials: "include"
      });
      var data2 = await resp.json();
      var userJwt = data2.jwt;
      setUserJWT(userJwt);
    }
    if (agent.userVerification) {
      initVerification();
    }
  }, [agent]);
  reactExports.useEffect(() => {
    async function fetchPrechatFields() {
      try {
        const params = new URLSearchParams();
        params.append("visible", "true");
        const miawFieldsUrl = `${window.__qlabsConfig.miawPrechatFieldsUrl}?${params.toString()}`;
        const resp = await fetch(miawFieldsUrl, {
          method: "GET"
        });
        if (resp.ok) {
          const data2 = await resp.json();
          if (data2.visiblePrechatFields) {
            setVisiblePrechatFields(data2.visiblePrechatFields);
          }
        }
        setPrechatFieldsReady(true);
      } catch (error) {
        console.error("Error fetching MIAW fields:", error);
        setPrechatFieldsReady(true);
      }
    }
    if (agent.deployStorefront) {
      fetchPrechatFields();
    }
  }, [agent]);
  reactExports.useEffect(() => {
    if (agent.userVerification && !userJWT || !prechatFieldsReady) {
      return;
    }
    const loadBootstrapScript = () => {
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.src = `${deploymentUrl}/assets/js/bootstrap.js`;
      script.onload = initEmbeddedMessaging;
      document.body.appendChild(script);
    };
    window.addEventListener("onEmbeddedMessagingReady", () => {
      var _a2, _b2, _c2, _d2;
      const previousSiteId = window.localStorage.getItem("qlabs-site-id");
      if (previousSiteId && previousSiteId !== siteId) {
        console.log(`[QLABS] siteId changed from ${previousSiteId} to ${siteId}`);
        window.localStorage.setItem("qlabs-site-id", siteId);
        if (agent.deployBM) {
          console.log(`[QLABS] clearing session due to siteId change`);
          embeddedservice_bootstrap.userVerificationAPI.clearSession();
        }
      }
      if (userJWT) {
        embeddedservice_bootstrap.userVerificationAPI.setIdentityToken({
          identityTokenType: "JWT",
          identityToken: userJWT
        });
      }
      const hiddenFields = JSON.parse(agent.prechatFields || "{}");
      if (siteId) {
        hiddenFields.siteId = siteId;
      }
      hiddenFields.scapiShortCode = // @ts-ignore
      (_b2 = (_a2 = window == null ? void 0 : window.__qlabsConfig) == null ? void 0 : _a2.clientSettings) == null ? void 0 : _b2.scapiShortCode;
      hiddenFields.scapiOrgId = // @ts-ignore
      (_d2 = (_c2 = window == null ? void 0 : window.__qlabsConfig) == null ? void 0 : _c2.clientSettings) == null ? void 0 : _d2.scapiOrgId;
      embeddedservice_bootstrap.prechatAPI.setHiddenPrechatFields(hiddenFields);
      embeddedservice_bootstrap.prechatAPI.setVisiblePrechatFields(visiblePrechatFields);
    });
    const initEmbeddedMessaging = () => {
      try {
        if (window.embeddedservice_bootstrap) {
          window.embeddedservice_bootstrap.settings.language = "en_US";
          window.embeddedservice_bootstrap.settings.disableStreamingResponses = true;
          window.embeddedservice_bootstrap.init(orgId, esDeveloperName, deploymentUrl, {
            scrt2URL: messagingUrl
          });
        }
      } catch (err) {
        console.error("Error loading Embedded Messaging: ", err);
      }
    };
    loadBootstrapScript();
    return () => {
      const scripts = document.getElementsByTagName("script");
      for (const script of scripts) {
        if (script.src.includes(`${deploymentUrl}/assets/js/bootstrap.js`)) {
          script.remove();
        }
      }
    };
  }, [agent, userJWT, siteId, visiblePrechatFields, prechatFieldsReady]);
  return null;
};
function renderAgent(agent, siteId) {
  const container = document.createElement("div");
  container.id = "root";
  document.body.appendChild(container);
  const root2 = createRoot(container);
  root2.render(/* @__PURE__ */ jsx(EmbeddedMessaging, { agent, siteId }));
}
class ParseError extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
}
function noop$1(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop$1, onError = noop$1, onRetry = noop$1, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id2, data2 = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line2 of complete)
      parseLine(line2);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line2) {
    if (line2 === "") {
      dispatchEvent();
      return;
    }
    if (line2.startsWith(":")) {
      onComment && onComment(line2.slice(line2.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line2.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line2.slice(0, fieldSeparatorIndex), offset2 = line2[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line2.slice(fieldSeparatorIndex + offset2);
      processField(field, value, line2);
      return;
    }
    processField(line2, "", line2);
  }
  function processField(field, value, line2) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data2 = `${data2}${value}
`;
        break;
      case "id":
        id2 = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line: line2
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}` : field}"`,
            { type: "unknown-field", field, value, line: line2 }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data2.length > 0 && onEvent({
      id: id2,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data2.endsWith(`
`) ? data2.slice(0, -1) : data2
    }), id2 = void 0, data2 = "", eventType = "";
  }
  function reset2(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id2 = void 0, data2 = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset: reset2 };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line2 = chunk.slice(searchIndex, lineEnd);
      lines.push(line2), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
function extractJson(message) {
  let jsonData = void 0;
  if (typeof message === "object") {
    return Object.assign({}, message);
  }
  if (message && typeof message === "string") {
    try {
      jsonData = JSON.parse(message);
    } catch (e2) {
    }
  }
  if (message && typeof message === "string") {
    const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)```/g;
    let match2;
    const matches = [];
    while ((match2 = codeBlockRegex.exec(message)) !== null) {
      const codeContent = match2[1].trim();
      try {
        const parsedJson = JSON.parse(codeContent);
        matches.push(parsedJson);
      } catch (e2) {
      }
    }
    if (matches.length > 0) {
      if (!jsonData) {
        jsonData = matches.length === 1 ? matches[0] : {};
      }
      if (matches.length > 1) {
        for (const obj of matches) {
          jsonData = {
            ...jsonData,
            ...obj
          };
        }
      }
    }
  }
  return jsonData;
}
const wait = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
const randomUUID = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r2 = Math.random() * 16 | 0, v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
};
const api = axios.create({
  baseURL: CONFIG.agentApiEndpoint
});
api.interceptors.request.use((config) => {
  const originalUri = config.url;
  config.headers["x-original-method"] = config.method;
  config.headers["x-endpoint"] = originalUri;
  config.method = "post";
  config.url = "";
  return config;
});
api.interceptors.response.use(null, (error) => {
  if (error.response) {
    console.error(error.response.data);
  }
  throw error;
});
var RequestMessageType = /* @__PURE__ */ ((RequestMessageType2) => {
  RequestMessageType2["Text"] = "Text";
  RequestMessageType2["Reply"] = "Reply";
  RequestMessageType2["Cancel"] = "Cancel";
  RequestMessageType2["TransferFailed"] = "TransferFailed";
  RequestMessageType2["TransferSucceeded"] = "TransferSucceeded";
  RequestMessageType2["PlanTemplate"] = "PlanTemplate";
  return RequestMessageType2;
})(RequestMessageType || {});
var ResponseMessageType = /* @__PURE__ */ ((ResponseMessageType2) => {
  ResponseMessageType2["Inform"] = "Inform";
  ResponseMessageType2["SessionEnded"] = "SessionEnded";
  ResponseMessageType2["TextChunk"] = "TextChunk";
  ResponseMessageType2["ValidationFailureChunk"] = "ValidationFailureChunk";
  ResponseMessageType2["ProgressIndicator"] = "ProgressIndicator";
  ResponseMessageType2["Inquire"] = "Inquire";
  ResponseMessageType2["Confirm"] = "Confirm";
  ResponseMessageType2["Failure"] = "Failure";
  ResponseMessageType2["Escalate"] = "Escalate";
  ResponseMessageType2["EndOfTurn"] = "EndOfTurn";
  ResponseMessageType2["Error"] = "Error";
  return ResponseMessageType2;
})(ResponseMessageType || {});
async function agentApiCreateSession(agent, {
  variables = []
} = {}) {
  const uuid = randomUUID();
  console.debug("Creating Agent API session with uuid", uuid);
  const resp = await api.post(`/einstein/ai-agent/v1/agents/${agent.agentId}/sessions`, {
    externalSessionKey: uuid,
    instanceConfig: {
      endpoint: agent.endpoint
    },
    tz: "America/Los_Angeles",
    variables,
    featureSupport: "Streaming",
    streamingCapabilities: {
      chunkTypes: []
    },
    bypassUser: true
  }, {
    headers: {
      // this is the custom object ID not the SFDC ID
      "x-agent-id": agent.__id
    }
  });
  return {
    ...resp.data
  };
}
async function agentApiEndSession(agent, sessionId) {
  console.debug("Deleting Agent API session with uuid", sessionId);
  await api.delete(`/einstein/ai-agent/v1/sessions/${sessionId}`, {
    headers: {
      // this is the custom object ID not the SFDC ID
      "x-agent-id": agent.__id
    }
  });
}
async function* agentApiSendMessageStream(agent, sessionId, message, {
  variables = []
} = {}) {
  const controller = new AbortController();
  const stream = new ReadableStream({
    async start(streamController) {
      try {
        const response = await fetch(CONFIG.agentApiEndpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "text/event-stream",
            "x-agent-id": agent.__id,
            "x-original-method": "POST",
            "x-endpoint": `/einstein/ai-agent/v1/sessions/${sessionId}/messages/stream`
          },
          body: JSON.stringify({
            message,
            variables
          }),
          signal: controller.signal,
          credentials: "include"
        });
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`SSE stream API error: ${response.status} ${response.statusText}`, errorText);
          streamController.error(new Error(`API request failed with status ${response.status}: ${errorText}`));
          return;
        }
        if (!response.body) {
          streamController.error(new Error("Response body is null for SSE stream"));
          return;
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        const parser = createParser({
          onEvent: (event) => {
            if (event.data) {
              try {
                const parsedData = JSON.parse(event.data);
                const message2 = parsedData.message;
                if (message2 && message2.type) {
                  const messageType = message2.type;
                  streamController.enqueue(message2);
                  if (messageType === "EndOfTurn" || messageType === "SessionEnded") {
                    streamController.close();
                    reader.cancel().catch(() => {
                    });
                  }
                } else {
                  console.warn("Received SSE data event without a valid 'type' property:", parsedData);
                  streamController.error(new Error("Invalid message structure from stream: missing type"));
                  reader.cancel().catch(() => {
                  });
                }
              } catch (e2) {
                console.error("Failed to parse SSE data JSON or handle event:", e2);
                streamController.error(new Error(`SSE data parsing error: ${e2.message}`));
                reader.cancel().catch(() => {
                });
              }
            }
          }
        });
        (async () => {
          try {
            while (true) {
              const {
                done,
                value
              } = await reader.read();
              if (done) {
                parser.feed("");
                try {
                  streamController.close();
                } catch (e2) {
                }
                break;
              }
              const chunk = decoder.decode(value, {
                stream: true
              });
              parser.feed(chunk);
            }
          } catch (error) {
            if (error instanceof DOMException && error.name === "AbortError") {
              console.debug("SSE Read loop aborted (likely intentional).");
            } else {
              console.error("Error in SSE read loop:", error);
              try {
                streamController.error(error);
              } catch (e2) {
              }
            }
          }
        })();
        controller.signal.addEventListener("abort", () => {
          reader.cancel().catch(() => {
          });
          try {
            streamController.close();
          } catch (e2) {
          }
        });
      } catch (error) {
        console.error("agentApiSendMessageStream setup failed:", error);
        streamController.error(error);
      }
    },
    cancel(reason) {
      console.debug("SSE Stream consumption cancelled by consumer:", reason);
      if (!controller.signal.aborted) {
        controller.abort();
      }
    }
  });
  for await (const message2 of stream) {
    yield message2;
  }
}
function isPromise(obj) {
  return obj && typeof obj.then === "function";
}
Promise.resolve(false);
Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time2, resolveWith) {
  if (!time2) time2 = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time2);
  });
}
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
var additional = 0;
function microSeconds$4() {
  var ms = (/* @__PURE__ */ new Date()).getTime();
  if (ms === lastMs) {
    additional++;
    return ms * 1e3 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1e3;
  }
}
var microSeconds$3 = microSeconds$4;
var type$3 = "native";
function create$4(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close$3(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage$3(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage$3(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed$3() {
  if (typeof window === "undefined") {
    return false;
  }
  if (typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime$3() {
  return 150;
}
var NativeMethod = {
  create: create$4,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$3,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
var ObliviousSet = (
  /** @class */
  function() {
    function ObliviousSet2(ttl) {
      this.ttl = ttl;
      this.map = /* @__PURE__ */ new Map();
      this._to = false;
    }
    ObliviousSet2.prototype.has = function(value) {
      return this.map.has(value);
    };
    ObliviousSet2.prototype.add = function(value) {
      var _this = this;
      this.map.set(value, now$1());
      if (!this._to) {
        this._to = true;
        setTimeout(function() {
          _this._to = false;
          removeTooOldValues(_this);
        }, 0);
      }
    };
    ObliviousSet2.prototype.clear = function() {
      this.map.clear();
    };
    return ObliviousSet2;
  }()
);
function removeTooOldValues(obliviousSet) {
  var olderThen = now$1() - obliviousSet.ttl;
  var iterator = obliviousSet.map[Symbol.iterator]();
  while (true) {
    var next2 = iterator.next().value;
    if (!next2) {
      return;
    }
    var value = next2[0];
    var time2 = next2[1];
    if (time2 < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
  if (!options.idb) options.idb = {};
  if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage) options.localstorage = {};
  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods) options.methods = originalOptions.methods;
  if (!options.node) options.node = {};
  if (!options.node.ttl) options.node.ttl = 1e3 * 60 * 2;
  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === "undefined") options.node.useFastPath = true;
  return options;
}
var microSeconds$2 = microSeconds$4;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
var type$2 = "idb";
function getIdb() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db2 = ev.target.result;
    db2.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage(db2, readerUuid, messageJson) {
  var time2 = (/* @__PURE__ */ new Date()).getTime();
  var writeObject = {
    uuid: readerUuid,
    time: time2,
    data: messageJson
  };
  var tx = db2.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getMessagesHigherThan(db2, lastCursorId) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e2) {
        res(e2.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e2) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        if (cursor2.value.id < lastCursorId + 1) {
          cursor2["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor2.value);
          cursor2["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id2) {
    var deleteRequest = objectStore["delete"](id2);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db2, ttl) {
  var olderThen = (/* @__PURE__ */ new Date()).getTime() - ttl;
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        var msgObk = cursor2.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor2["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create$3(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then(function(db2) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db2
    };
    db2.onclose = function() {
      state.closed = true;
      if (options.idb.onclose) options.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed) return;
  readNewMessages(state).then(function() {
    return sleep(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid) return false;
  if (state.eMIs.has(msgObj.id)) return false;
  if (msgObj.data.time < state.messagesCallbackTime) return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed) return PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close$2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage$2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage$2(channelState, fn, time2) {
  channelState.messagesCallbackTime = time2;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed$2() {
  return !!getIdb();
}
function averageResponseTime$2(options) {
  return options.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$3,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$2,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
};
var microSeconds$1 = microSeconds$4;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$1 = "localstorage";
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined") return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e2) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage$1(channelState, messageJson) {
  return new Promise(function(res) {
    sleep().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: randomToken(),
        time: (/* @__PURE__ */ new Date()).getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create$2(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed$1()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback) return;
    if (msgObj.uuid === uuid) return;
    if (!msgObj.token || eMIs.has(msgObj.token)) return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close$1(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage$1(channelState, fn, time2) {
  channelState.messagesCallbackTime = time2;
  channelState.messagesCallback = fn;
}
function canBeUsed$1() {
  var ls = getLocalStorage();
  if (!ls) return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e2) {
    return false;
  }
  return true;
}
function averageResponseTime$1() {
  var defaultTime = 120;
  var userAgent2 = navigator.userAgent.toLowerCase();
  if (userAgent2.includes("safari") && !userAgent2.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create$2,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$1,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
};
var microSeconds = microSeconds$4;
var type = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create$1(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
function postMessage(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function(channel) {
        return channel.name === channelState.name;
      }).filter(function(channel) {
        return channel !== channelState;
      }).filter(function(channel) {
        return !!channel.messagesCallback;
      }).forEach(function(channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  return true;
}
function averageResponseTime() {
  return 5;
}
var SimulateMethod = {
  create: create$1,
  close,
  onMessage,
  postMessage,
  canBeUsed,
  type,
  averageResponseTime,
  microSeconds
};
var METHODS = [
  NativeMethod,
  // fastest
  IndexedDBMethod,
  LocalstorageMethod
];
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return SimulateMethod;
    }
    var ret = chooseMethods.find(function(m2) {
      return m2.type === options.type;
    });
    if (!ret) throw new Error("method-type " + options.type + " not found");
    else return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m2) {
      return m2.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m2) {
    return m2.type;
  })));
  else return useMethod;
}
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel$1 = function BroadcastChannel2(name, options) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  this.options = fillOptionsWithDefaults(options);
  this.method = chooseMethod(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
BroadcastChannel$1._pubkey = true;
BroadcastChannel$1.prototype = {
  postMessage: function postMessage2(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn) {
    var time2 = this.method.microSeconds();
    var listenObj = {
      time: time2,
      fn
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn && typeof fn === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener(type2, fn) {
    var time2 = this.method.microSeconds();
    var listenObj = {
      time: time2,
      fn
    };
    _addListenerObject(this, type2, listenObj);
  },
  removeEventListener: function removeEventListener(type2, fn) {
    var obj = this._addEL[type2].find(function(obj2) {
      return obj2.fn === fn;
    });
    _removeListenerObject(this, type2, obj);
  },
  close: function close2() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel, type2, msg) {
  var time2 = broadcastChannel.method.microSeconds();
  var msgObj = {
    time: time2,
    type: type2,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s) {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0) return true;
  if (channel._addEL.internal.length > 0) return true;
  return false;
}
function _addListenerObject(channel, type2, obj) {
  channel._addEL[type2].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type2, obj) {
  channel._addEL[type2] = channel._addEL[type2].filter(function(o) {
    return o !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        var hundredMsInMicro = 100 * 1e3;
        var minMessageTime = listenerObject.time - hundredMsInMicro;
        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time2 = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time2);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time2);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time2 = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time2);
  }
}
function broadcastQueryClient({
  queryClient: queryClient2,
  broadcastChannel = "tanstack-query",
  options
}) {
  let transaction = false;
  const tx = (cb2) => {
    transaction = true;
    cb2();
    transaction = false;
  };
  const channel = new BroadcastChannel$1(broadcastChannel, {
    webWorkerSupport: false,
    ...options
  });
  const queryCache = queryClient2.getQueryCache();
  queryClient2.getQueryCache().subscribe((queryEvent) => {
    if (transaction) {
      return;
    }
    const {
      query: {
        queryHash,
        queryKey,
        state
      }
    } = queryEvent;
    if (queryEvent.type === "updated" && queryEvent.action.type === "success") {
      channel.postMessage({
        type: "updated",
        queryHash,
        queryKey,
        state
      });
    }
    if (queryEvent.type === "removed") {
      channel.postMessage({
        type: "removed",
        queryHash,
        queryKey
      });
    }
  });
  channel.onmessage = (action) => {
    if (!(action != null && action.type)) {
      return;
    }
    tx(() => {
      const {
        type: type2,
        queryHash,
        queryKey,
        state
      } = action;
      if (type2 === "updated") {
        const query = queryCache.get(queryHash);
        if (query) {
          query.setState(state);
          return;
        }
        queryCache.build(queryClient2, {
          queryKey,
          queryHash
        }, state);
      } else if (type2 === "removed") {
        const query = queryCache.get(queryHash);
        if (query) {
          queryCache.remove(query);
        }
      }
    });
  };
}
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      refetchOnWindowFocus: false,
      staleTime: 10 * (60 * 1e3)
      // 10 minutes
    }
  }
});
broadcastQueryClient({
  /* @ts-ignore */
  queryClient,
  broadcastChannel: "q-labs-companion"
});
let subscribers = [];
let nextSubscriptionId = 0;
let isInitialized = false;
const eventHistoryQueryKey = ["qlabsEvents", "history"];
function initializeEventManager() {
  if (isInitialized) {
    console.warn("EventManager: Already initialized");
    return;
  }
  isInitialized = true;
  if (!queryClient.getQueryData(eventHistoryQueryKey)) {
    queryClient.setQueryData(eventHistoryQueryKey, () => []);
  }
  window._qlabsEvents = Array.isArray(window._qlabsEvents) ? window._qlabsEvents : [];
  const bufferedEvents = [...window._qlabsEvents];
  window._qlabsEvents.length = 0;
  bufferedEvents.forEach((args) => {
    if (Array.isArray(args)) {
      qlabsEmit(args[0], args[1], args[2]);
    } else if (typeof args === "string") {
      qlabsEmit(args);
    }
  });
  window._qlabsEvents.push = (args) => {
    if (Array.isArray(args)) {
      qlabsEmit(args[0], args[1], args[2]);
    } else if (typeof args === "string") {
      qlabsEmit(args);
    }
    const history = queryClient.getQueryData(eventHistoryQueryKey) || [];
    return history.length;
  };
  window._qlabsSubscribers = window._qlabsSubscribers || [];
  window._qlabsSubscribers.forEach((sub) => {
    qlabsSubscribe(sub[0], sub[1], sub[2]);
  });
  window._qlabsSubscribers.length = 0;
  window._qlabsSubscribers.push = (sub) => {
    qlabsSubscribe(sub[0], sub[1], sub[2]);
    return subscribers.length;
  };
  window.qlabsEmit = qlabsEmit;
  window.qlabsSubscribe = qlabsSubscribe;
}
function matchesContext(subContext, emitContext) {
  if (!subContext || Object.keys(subContext).length === 0) {
    return true;
  }
  if (!emitContext) {
    return true;
  }
  return Object.entries(subContext).every(([key, value]) => !emitContext.hasOwnProperty(key) || emitContext[key] === value);
}
function qlabsSubscribe(name, callback, context) {
  const id2 = nextSubscriptionId++;
  const subscription = {
    id: id2,
    name,
    callback,
    context
  };
  subscribers.push(subscription);
  const history = queryClient.getQueryData(eventHistoryQueryKey) || [];
  history.forEach((event) => {
    if (event.name.startsWith(name) && matchesContext(context, event.context)) {
      callback == null ? void 0 : callback(event.payload, event.context);
    }
  });
  return () => {
    subscribers = subscribers.filter((sub) => sub.id !== id2);
  };
}
function qlabsEmit(name, payload, context) {
  if (!isInitialized) {
    window._qlabsEvents = Array.isArray(window._qlabsEvents) ? window._qlabsEvents : [];
    window._qlabsEvents.push([name, payload, context]);
    return;
  }
  const eventRecord = {
    name,
    payload,
    context,
    timestamp: Date.now()
  };
  queryClient.setQueryData(eventHistoryQueryKey, (oldHistory = []) => {
    return [...oldHistory, eventRecord];
  });
  subscribers.forEach((sub) => {
    if (name.startsWith(sub.name) && matchesContext(sub.context, context)) {
      sub == null ? void 0 : sub.callback(payload, context);
    }
  });
}
function isAsyncGeneratorFunction(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  return Object.prototype.toString.call(fn) === "[object AsyncGeneratorFunction]";
}
const SITE_ID$4 = CONFIG.currentSite;
const AgentContext = React.createContext({
  agent: null,
  runtimeContext: {},
  setRuntimeContext: () => {
  }
});
const AgentProvider = AgentContext.Provider;
const LOCAL_STORAGE_PREFIX = "agent-session-" + SITE_ID$4;
const SESSION_COOKIE_NAME = "agent-session-active-" + SITE_ID$4;
function setSessionCookie(agentName, sessionKey) {
  const agentNameWithoutSpaces = agentName.replace(/\s+/g, "_");
  const sessionKeyWithoutSpaces = sessionKey.replace(/\s+/g, "_");
  document.cookie = `${SESSION_COOKIE_NAME}${agentNameWithoutSpaces}${sessionKeyWithoutSpaces}=true; path=/; SameSite=Strict`;
}
function hasSessionCookie(agentName, sessionKey) {
  const agentNameWithoutSpaces = agentName.replace(/\s+/g, "_");
  const sessionKeyWithoutSpaces = sessionKey ? sessionKey.replace(/\s+/g, "_") : "";
  return document.cookie.split(";").some((cookie) => cookie.trim().startsWith(`${SESSION_COOKIE_NAME}${agentNameWithoutSpaces}${sessionKeyWithoutSpaces}=`));
}
const getLocalStorageKey = (agentName, sessionKey) => `${LOCAL_STORAGE_PREFIX}-${agentName}${sessionKey ? "-" + sessionKey : ""}`;
function saveSessionState(agentName, sessionKey, state) {
  try {
    setSessionCookie(agentName, sessionKey);
    const existingState = loadSessionState(agentName, sessionKey);
    if (existingState) {
      state = {
        ...existingState,
        ...state
      };
    }
    localStorage.setItem(getLocalStorageKey(agentName, sessionKey), JSON.stringify(state));
  } catch (e2) {
    console.error("Failed to save session state to localStorage:", e2);
  }
}
function loadSessionState(agentName, sessionKey) {
  try {
    if (!hasSessionCookie(agentName, sessionKey)) {
      return null;
    }
    const savedState = localStorage.getItem(getLocalStorageKey(agentName, sessionKey));
    if (savedState) {
      return JSON.parse(savedState);
    }
  } catch (e2) {
    console.error("Failed to load session state from localStorage:", e2);
  }
  return null;
}
function clearSessionState(agentName, sessionKey) {
  try {
    localStorage.removeItem(getLocalStorageKey(agentName, sessionKey));
  } catch (e2) {
    console.error("Failed to clear session state from localStorage:", e2);
  }
}
function getMockResponse(agent, context) {
  const func = new Function("agent", "context", "wait", "return " + agent.mockResponse);
  return func(agent, context, wait);
}
function useAgentAPI({
  agent: _agent,
  enabled = true,
  sessionKey: _sessionKey,
  messagePrefix: _messagePrefix,
  messageSuffix: _messageSuffix
} = {}) {
  const {
    runtimeContext,
    agent: _contextAgent,
    sessionKey: _contextSessionKey,
    messagePrefix: _contextMessagePrefix,
    messageSuffix: _contextMessageSuffix
  } = reactExports.useContext(AgentContext);
  const agent = _agent || _contextAgent;
  const sessionKey = _sessionKey || _contextSessionKey || "default";
  const queryClient2 = useQueryClient();
  const messagePrefix = _messagePrefix || _contextMessagePrefix || "";
  const messageSuffix = _messageSuffix || _contextMessageSuffix || "";
  const getRuntimeVariables = () => {
    if (!runtimeContext) return [];
    return Object.entries(runtimeContext).map(([key, value]) => ({
      name: key,
      type: "Text",
      value
    }));
  };
  const {
    data: data2,
    isLoading,
    isFetching,
    isError,
    error
  } = useQuery({
    queryKey: ["agentSession", agent == null ? void 0 : agent.name, sessionKey],
    queryFn: async () => {
      const savedState = loadSessionState(agent.name, sessionKey);
      if (savedState) {
        return savedState;
      }
      const variables = getRuntimeVariables();
      if (agent.enableMocking) {
        const uuid = randomUUID();
        const mockResponses = getMockResponse(agent, runtimeContext);
        const firstResponse = mockResponses[0];
        await wait(1e3);
        console.group(`Agent ${agent.name} agentApiCreateSession`);
        console.log("Using mock response for agent");
        console.dir(agent);
        console.dir(firstResponse);
        if (variables) {
          console.log("With Variables");
          console.dir(variables);
        }
        console.groupEnd();
        var resp = {
          sessionId: uuid,
          messages: [firstResponse]
        };
      } else {
        resp = await agentApiCreateSession(agent, {
          variables
        });
      }
      const _messages = resp.messages.map((message) => {
        return {
          MESSAGE_TYPE: "AGENT",
          ...message
        };
      });
      const initialState = {
        sessionId: resp.sessionId,
        messages: _messages,
        active: true,
        sequenceId: 1,
        data: null,
        lastStructuredMessage: null
      };
      saveSessionState(agent.name, sessionKey, initialState);
      return initialState;
    },
    enabled: !!agent && enabled
  });
  const sendMessageMutation = useMutation({
    mutationFn: async (text2) => {
      const currentState = data2;
      if (!agent || !(currentState == null ? void 0 : currentState.sessionId)) {
        throw new Error("Session not initialized");
      }
      const sequenceId = currentState.sequenceId;
      const message = {
        type: RequestMessageType.Text,
        text: messagePrefix + text2 + messageSuffix,
        sequenceId
      };
      const userMessage = {
        MESSAGE_TYPE: "USER",
        ...message,
        text: text2
      };
      queryClient2.setQueryData(["agentSession", agent.name, sessionKey], (old) => ({
        ...old,
        messages: [...old.messages, userMessage],
        sequenceId: sequenceId + 1,
        loading: true
      }));
      const variables = getRuntimeVariables();
      let streamFullyProcessed = false;
      const processResponseMessage = (apiMsg) => {
        const agentApiMsg = {
          MESSAGE_TYPE: "AGENT",
          id: apiMsg.id,
          type: apiMsg.type,
          // Spread common fields, then specific ones for type safety if using discriminated union properly
          ...apiMsg.type === ResponseMessageType.Inform && {
            message: apiMsg.message,
            feedbackId: apiMsg.feedbackId,
            planId: apiMsg.planId,
            isContentSafe: apiMsg.isContentSafe,
            result: apiMsg.result,
            citedReferences: apiMsg.citedReferences
          },
          ...apiMsg.type === ResponseMessageType.SessionEnded && {
            reason: apiMsg.reason,
            feedbackId: apiMsg.feedbackId
          },
          ...apiMsg.type === ResponseMessageType.ProgressIndicator && {
            message: apiMsg.message,
            indicatorType: apiMsg.indicatorType
          },
          // Add other types if they have unique fields to display
          json: apiMsg.type === ResponseMessageType.Inform ? extractJson(apiMsg.message) : void 0
        };
        queryClient2.setQueryData(["agentSession", agent.name, sessionKey], (old) => {
          if (!old) return old;
          const newMessages = [...old.messages, agentApiMsg];
          let updatedData = old.data;
          let updatedLastStructured = old.lastStructuredMessage;
          if (agentApiMsg.json) {
            updatedData = {
              ...old.data || {},
              ...agentApiMsg.json
            };
            updatedLastStructured = agentApiMsg.json;
          }
          const isSessionEndingMessage = apiMsg.type === ResponseMessageType.SessionEnded;
          const isTurnEndingMessage = apiMsg.type === ResponseMessageType.EndOfTurn || isSessionEndingMessage;
          if (isTurnEndingMessage) streamFullyProcessed = true;
          const newState = {
            ...old,
            messages: newMessages,
            data: updatedData,
            lastStructuredMessage: updatedLastStructured,
            loading: !isTurnEndingMessage,
            // Set loading false only if stream ends this turn
            active: old.active && !isSessionEndingMessage
          };
          saveSessionState(agent.name, sessionKey, newState);
          return newState;
        });
      };
      if (agent.enableMocking) {
        const mockResponses = getMockResponse(agent, runtimeContext);
        if (mockResponses.length < message.sequenceId + 1) {
          var response = mockResponses[mockResponses.length - 1];
        } else {
          response = mockResponses[message.sequenceId];
        }
        console.group(`Agent ${agent.name} agentApiSendMessage`);
        console.log("Using mock response for agent");
        console.dir(agent);
        if (variables) {
          console.log("With Variables");
          console.dir(variables);
        }
        if (isAsyncGeneratorFunction(response)) {
          const _response = response;
          for await (const apiMessage of _response(message)) {
            processResponseMessage(apiMessage);
            console.dir(apiMessage);
          }
          console.groupEnd();
        } else {
          if (typeof response === "function") {
            response = response(message);
          }
          console.dir(response);
          console.groupEnd();
          await wait(3e3);
          processResponseMessage(response);
        }
        if (!streamFullyProcessed) {
          processResponseMessage({
            type: ResponseMessageType.EndOfTurn,
            id: randomUUID()
          });
        }
      } else {
        const stream = agentApiSendMessageStream(agent, currentState.sessionId, message, {
          variables
        });
        for await (const apiMessage of stream) {
          processResponseMessage(apiMessage);
          if (streamFullyProcessed) break;
        }
        if (!streamFullyProcessed) {
          queryClient2.setQueryData(["agentSession", agent.name, sessionKey], (old) => {
            if (!old || !old.loading) return old;
            console.warn("Stream processing finished without an explicit EndOfTurn or SessionEnded message.");
            const newState = {
              ...old,
              loading: false
            };
            saveSessionState(agent.name, sessionKey, newState);
            return newState;
          });
        }
      }
    },
    onSuccess: () => {
      qlabsEmit("agent:messageSequenceComplete", {}, {
        agentName: agent == null ? void 0 : agent.name,
        sessionKey
      });
    },
    onError: (error2) => {
      console.error("Failed to send message:", error2);
    }
  });
  const resetStructuredData = reactExports.useCallback(() => {
    queryClient2.setQueryData(["agentSession", agent.name, sessionKey], (old) => ({
      ...old,
      data: null,
      lastStructuredMessage: null
    }));
  }, [agent.name, sessionKey, queryClient2]);
  const resetSession = reactExports.useCallback(() => {
    queryClient2.setQueryData(["agentSession", agent.name, sessionKey], null);
    if ((data2 == null ? void 0 : data2.sessionId) && !agent.enableMocking) {
      try {
        agentApiEndSession(agent, (data2 == null ? void 0 : data2.sessionId) || "");
      } catch (e2) {
        console.error("Failed to end session:", e2);
      }
    }
    clearSessionState(agent.name, sessionKey);
    queryClient2.invalidateQueries({
      queryKey: ["agentSession", agent.name, sessionKey]
    });
  }, [agent.name, sessionKey, queryClient2]);
  const sendMessage = reactExports.useCallback((text2) => {
    if (!agent) {
      console.error("Agent not initialized");
    } else if (!(data2 == null ? void 0 : data2.active)) {
      console.error("Agent Session not active; cannot send messages");
    } else {
      sendMessageMutation.mutate(text2);
    }
  }, [sendMessageMutation]);
  const subscribe = reactExports.useCallback((eventName, callback) => qlabsSubscribe(eventName, callback, {
    agentName: agent.name,
    sessionKey
  }), [agent == null ? void 0 : agent.name, sessionKey]);
  const emit = reactExports.useCallback((eventName, payload) => qlabsEmit(eventName, payload, {
    agentName: agent.name,
    sessionKey
  }), [agent == null ? void 0 : agent.name, sessionKey]);
  reactExports.useEffect(() => {
    const unsub = subscribe("agent:resetSession", () => {
      resetSession();
    });
    return () => {
      unsub();
    };
  }, [subscribe, resetSession]);
  reactExports.useEffect(() => {
    qlabsEmit("agent:sessionState", data2 ?? {}, {
      agentName: agent == null ? void 0 : agent.name,
      sessionKey
    });
  }, [data2, qlabsEmit]);
  return {
    messages: (data2 == null ? void 0 : data2.messages) || [],
    sessionId: data2 == null ? void 0 : data2.sessionId,
    isLoading: isLoading || isFetching || sendMessageMutation.isPending || (data2 == null ? void 0 : data2.loading),
    isError: isError || sendMessageMutation.isError,
    error: error || sendMessageMutation.error,
    sendMessage,
    isActive: !!(data2 == null ? void 0 : data2.sessionId) && !isLoading && !sendMessageMutation.isPending && !!(data2 == null ? void 0 : data2.active),
    data: (data2 == null ? void 0 : data2.data) || null,
    lastStructuredMessage: (data2 == null ? void 0 : data2.lastStructuredMessage) || null,
    resetStructuredData,
    resetSession,
    subscribe,
    emit
  };
}
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp2 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = __defProp2(target, "default", { value: mod, enumerable: true });
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp2(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb2, mod) => () => (mod || cb2((mod = { exports: {} }).exports, mod), mod.exports);
var require_xhtml = __commonJS((exports, module) => {
  module.exports = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "",
    iexcl: "",
    cent: "",
    pound: "",
    curren: "",
    yen: "",
    brvbar: "",
    sect: "",
    uml: "",
    copy: "",
    ordf: "",
    laquo: "",
    not: "",
    shy: "",
    reg: "",
    macr: "",
    deg: "",
    plusmn: "",
    sup2: "",
    sup3: "",
    acute: "",
    micro: "",
    para: "",
    middot: "",
    cedil: "",
    sup1: "",
    ordm: "",
    raquo: "",
    frac14: "",
    frac12: "",
    frac34: "",
    iquest: "",
    Agrave: "",
    Aacute: "",
    Acirc: "",
    Atilde: "",
    Auml: "",
    Aring: "",
    AElig: "",
    Ccedil: "",
    Egrave: "",
    Eacute: "",
    Ecirc: "",
    Euml: "",
    Igrave: "",
    Iacute: "",
    Icirc: "",
    Iuml: "",
    ETH: "",
    Ntilde: "",
    Ograve: "",
    Oacute: "",
    Ocirc: "",
    Otilde: "",
    Ouml: "",
    times: "",
    Oslash: "",
    Ugrave: "",
    Uacute: "",
    Ucirc: "",
    Uuml: "",
    Yacute: "",
    THORN: "",
    szlig: "",
    agrave: "",
    aacute: "",
    acirc: "",
    atilde: "",
    auml: "",
    aring: "",
    aelig: "",
    ccedil: "",
    egrave: "",
    eacute: "",
    ecirc: "",
    euml: "",
    igrave: "",
    iacute: "",
    icirc: "",
    iuml: "",
    eth: "",
    ntilde: "",
    ograve: "",
    oacute: "",
    ocirc: "",
    otilde: "",
    ouml: "",
    divide: "",
    oslash: "",
    ugrave: "",
    uacute: "",
    ucirc: "",
    uuml: "",
    yacute: "",
    thorn: "",
    yuml: "",
    OElig: "",
    oelig: "",
    Scaron: "",
    scaron: "",
    Yuml: "",
    fnof: "",
    circ: "",
    tilde: "",
    Alpha: "",
    Beta: "",
    Gamma: "",
    Delta: "",
    Epsilon: "",
    Zeta: "",
    Eta: "",
    Theta: "",
    Iota: "",
    Kappa: "",
    Lambda: "",
    Mu: "",
    Nu: "",
    Xi: "",
    Omicron: "",
    Pi: "",
    Rho: "",
    Sigma: "",
    Tau: "",
    Upsilon: "",
    Phi: "",
    Chi: "",
    Psi: "",
    Omega: "",
    alpha: "",
    beta: "",
    gamma: "",
    delta: "",
    epsilon: "",
    zeta: "",
    eta: "",
    theta: "",
    iota: "",
    kappa: "",
    lambda: "",
    mu: "",
    nu: "",
    xi: "",
    omicron: "",
    pi: "",
    rho: "",
    sigmaf: "",
    sigma: "",
    tau: "",
    upsilon: "",
    phi: "",
    chi: "",
    psi: "",
    omega: "",
    thetasym: "",
    upsih: "",
    piv: "",
    ensp: "",
    emsp: "",
    thinsp: "",
    zwnj: "",
    zwj: "",
    lrm: "",
    rlm: "",
    ndash: "",
    mdash: "",
    lsquo: "",
    rsquo: "",
    sbquo: "",
    ldquo: "",
    rdquo: "",
    bdquo: "",
    dagger: "",
    Dagger: "",
    bull: "",
    hellip: "",
    permil: "",
    prime: "",
    Prime: "",
    lsaquo: "",
    rsaquo: "",
    oline: "",
    frasl: "",
    euro: "",
    image: "",
    weierp: "",
    real: "",
    trade: "",
    alefsym: "",
    larr: "",
    uarr: "",
    rarr: "",
    darr: "",
    harr: "",
    crarr: "",
    lArr: "",
    uArr: "",
    rArr: "",
    dArr: "",
    hArr: "",
    forall: "",
    part: "",
    exist: "",
    empty: "",
    nabla: "",
    isin: "",
    notin: "",
    ni: "",
    prod: "",
    sum: "",
    minus: "",
    lowast: "",
    radic: "",
    prop: "",
    infin: "",
    ang: "",
    and: "",
    or: "",
    cap: "",
    cup: "",
    int: "",
    there4: "",
    sim: "",
    cong: "",
    asymp: "",
    ne: "",
    equiv: "",
    le: "",
    ge: "",
    sub: "",
    sup: "",
    nsub: "",
    sube: "",
    supe: "",
    oplus: "",
    otimes: "",
    perp: "",
    sdot: "",
    lceil: "",
    rceil: "",
    lfloor: "",
    rfloor: "",
    lang: "",
    rang: "",
    loz: "",
    spades: "",
    clubs: "",
    hearts: "",
    diams: ""
  };
});
var require_acorn = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
  })(exports, function(exports2) {
    var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var nonASCIIidentifierChars2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
    var nonASCIIidentifierStartChars2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
    var reservedWords2 = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$12 = {
      5: ecma5AndLessKeywords2,
      "5module": ecma5AndLessKeywords2 + " export import",
      6: ecma5AndLessKeywords2 + " const class extends export import super"
    };
    var keywordRelationalOperator2 = /^in(stanceof)?$/;
    var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
    var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
    function isInAstralSet2(code2, set) {
      var pos = 65536;
      for (var i22 = 0; i22 < set.length; i22 += 2) {
        pos += set[i22];
        if (pos > code2) {
          return false;
        }
        pos += set[i22 + 1];
        if (pos >= code2) {
          return true;
        }
      }
      return false;
    }
    function isIdentifierStart2(code2, astral) {
      if (code2 < 65) {
        return code2 === 36;
      }
      if (code2 < 91) {
        return true;
      }
      if (code2 < 97) {
        return code2 === 95;
      }
      if (code2 < 123) {
        return true;
      }
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code2));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet2(code2, astralIdentifierStartCodes2);
    }
    function isIdentifierChar2(code2, astral) {
      if (code2 < 48) {
        return code2 === 36;
      }
      if (code2 < 58) {
        return true;
      }
      if (code2 < 65) {
        return false;
      }
      if (code2 < 91) {
        return true;
      }
      if (code2 < 97) {
        return code2 === 95;
      }
      if (code2 < 123) {
        return true;
      }
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code2));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet2(code2, astralIdentifierStartCodes2) || isInAstralSet2(code2, astralIdentifierCodes2);
    }
    var TokenType3 = function TokenType4(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    function binop2(name, prec) {
      return new TokenType3(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
    var keywords2 = {};
    function kw2(name, options) {
      if (options === void 0)
        options = {};
      options.keyword = name;
      return keywords2[name] = new TokenType3(name, options);
    }
    var types$12 = {
      num: new TokenType3("num", startsExpr2),
      regexp: new TokenType3("regexp", startsExpr2),
      string: new TokenType3("string", startsExpr2),
      name: new TokenType3("name", startsExpr2),
      privateId: new TokenType3("privateId", startsExpr2),
      eof: new TokenType3("eof"),
      bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType3("]"),
      braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType3("}"),
      parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType3(")"),
      comma: new TokenType3(",", beforeExpr2),
      semi: new TokenType3(";", beforeExpr2),
      colon: new TokenType3(":", beforeExpr2),
      dot: new TokenType3("."),
      question: new TokenType3("?", beforeExpr2),
      questionDot: new TokenType3("?."),
      arrow: new TokenType3("=>", beforeExpr2),
      template: new TokenType3("template"),
      invalidTemplate: new TokenType3("invalidTemplate"),
      ellipsis: new TokenType3("...", beforeExpr2),
      backQuote: new TokenType3("`", startsExpr2),
      dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop2("||", 1),
      logicalAND: binop2("&&", 2),
      bitwiseOR: binop2("|", 3),
      bitwiseXOR: binop2("^", 4),
      bitwiseAND: binop2("&", 5),
      equality: binop2("==/!=/===/!==", 6),
      relational: binop2("</>/<=/>=", 7),
      bitShift: binop2("<</>>/>>>", 8),
      plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop2("%", 10),
      star: binop2("*", 10),
      slash: binop2("/", 10),
      starstar: new TokenType3("**", { beforeExpr: true }),
      coalesce: binop2("??", 1),
      _break: kw2("break"),
      _case: kw2("case", beforeExpr2),
      _catch: kw2("catch"),
      _continue: kw2("continue"),
      _debugger: kw2("debugger"),
      _default: kw2("default", beforeExpr2),
      _do: kw2("do", { isLoop: true, beforeExpr: true }),
      _else: kw2("else", beforeExpr2),
      _finally: kw2("finally"),
      _for: kw2("for", { isLoop: true }),
      _function: kw2("function", startsExpr2),
      _if: kw2("if"),
      _return: kw2("return", beforeExpr2),
      _switch: kw2("switch"),
      _throw: kw2("throw", beforeExpr2),
      _try: kw2("try"),
      _var: kw2("var"),
      _const: kw2("const"),
      _while: kw2("while", { isLoop: true }),
      _with: kw2("with"),
      _new: kw2("new", { beforeExpr: true, startsExpr: true }),
      _this: kw2("this", startsExpr2),
      _super: kw2("super", startsExpr2),
      _class: kw2("class", startsExpr2),
      _extends: kw2("extends", beforeExpr2),
      _export: kw2("export"),
      _import: kw2("import", startsExpr2),
      _null: kw2("null", startsExpr2),
      _true: kw2("true", startsExpr2),
      _false: kw2("false", startsExpr2),
      _in: kw2("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG2 = new RegExp(lineBreak2.source, "g");
    function isNewLine2(code2) {
      return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
    }
    function nextLineBreak2(code2, from2, end) {
      if (end === void 0)
        end = code2.length;
      for (var i22 = from2; i22 < end; i22++) {
        var next2 = code2.charCodeAt(i22);
        if (isNewLine2(next2)) {
          return i22 < end - 1 && next2 === 13 && code2.charCodeAt(i22 + 1) === 10 ? i22 + 2 : i22 + 1;
        }
      }
      return -1;
    }
    var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref2 = Object.prototype;
    var hasOwnProperty2 = ref2.hasOwnProperty;
    var toString22 = ref2.toString;
    var hasOwn2 = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty2.call(obj, propName);
    };
    var isArray22 = Array.isArray || function(obj) {
      return toString22.call(obj) === "[object Array]";
    };
    var regexpCache2 = /* @__PURE__ */ Object.create(null);
    function wordsRegexp2(words) {
      return regexpCache2[words] || (regexpCache2[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
    }
    function codePointToString2(code2) {
      if (code2 <= 65535) {
        return String.fromCharCode(code2);
      }
      code2 -= 65536;
      return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
    }
    var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    var Position3 = function Position4(line2, col) {
      this.line = line2;
      this.column = col;
    };
    Position3.prototype.offset = function offset2(n2) {
      return new Position3(this.line, this.column + n2);
    };
    var SourceLocation3 = function SourceLocation4(p2, start, end) {
      this.start = start;
      this.end = end;
      if (p2.sourceFile !== null) {
        this.source = p2.sourceFile;
      }
    };
    function getLineInfo2(input, offset2) {
      for (var line2 = 1, cur = 0; ; ) {
        var nextBreak = nextLineBreak2(input, cur, offset2);
        if (nextBreak < 0) {
          return new Position3(line2, offset2 - cur);
        }
        ++line2;
        cur = nextBreak;
      }
    }
    var defaultOptions2 = {
      ecmaVersion: null,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: null,
      allowSuperOutsideMethod: null,
      allowHashBang: false,
      checkPrivateFields: true,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    var warnedAboutEcmaVersion2 = false;
    function getOptions2(opts) {
      var options = {};
      for (var opt in defaultOptions2) {
        options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
      }
      if (options.ecmaVersion === "latest") {
        options.ecmaVersion = 1e8;
      } else if (options.ecmaVersion == null) {
        if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
          warnedAboutEcmaVersion2 = true;
          console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`);
        }
        options.ecmaVersion = 11;
      } else if (options.ecmaVersion >= 2015) {
        options.ecmaVersion -= 2009;
      }
      if (options.allowReserved == null) {
        options.allowReserved = options.ecmaVersion < 5;
      }
      if (!opts || opts.allowHashBang == null) {
        options.allowHashBang = options.ecmaVersion >= 14;
      }
      if (isArray22(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function(token2) {
          return tokens.push(token2);
        };
      }
      if (isArray22(options.onComment)) {
        options.onComment = pushComment2(options, options.onComment);
      }
      return options;
    }
    function pushComment2(options, array) {
      return function(block, text2, start, end, startLoc, endLoc) {
        var comment2 = {
          type: block ? "Block" : "Line",
          value: text2,
          start,
          end
        };
        if (options.locations) {
          comment2.loc = new SourceLocation3(this, startLoc, endLoc);
        }
        if (options.ranges) {
          comment2.range = [start, end];
        }
        array.push(comment2);
      };
    }
    var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
    function functionFlags2(async, generator) {
      return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
    }
    var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
    var Parser3 = function Parser4(options, input, startPos) {
      this.options = options = getOptions2(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
        if (options.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp2(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
      this.reservedWordsStrict = wordsRegexp2(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf(`
`, startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$12.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP2);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser3.prototype.parse = function parse4() {
      var node2 = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node2);
    };
    prototypeAccessors2.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
    };
    prototypeAccessors2.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors2.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors2.canAwait.get = function() {
      for (var i22 = this.scopeStack.length - 1; i22 >= 0; i22--) {
        var scope = this.scopeStack[i22];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION2) {
          return (scope.flags & SCOPE_ASYNC2) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors2.allowSuper.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors2.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
    };
    prototypeAccessors2.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors2.allowNewDotTarget.get = function() {
      var ref3 = this.currentThisScope();
      var flags = ref3.flags;
      var inClassFieldInit = ref3.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
    };
    prototypeAccessors2.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
    };
    Parser3.extend = function extend4() {
      var plugins = [], len = arguments.length;
      while (len--)
        plugins[len] = arguments[len];
      var cls = this;
      for (var i22 = 0; i22 < plugins.length; i22++) {
        cls = plugins[i22](cls);
      }
      return cls;
    };
    Parser3.parse = function parse4(input, options) {
      return new this(options, input).parse();
    };
    Parser3.parseExpressionAt = function parseExpressionAt3(input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser3.tokenizer = function tokenizer3(input, options) {
      return new this(options, input);
    };
    Object.defineProperties(Parser3.prototype, prototypeAccessors2);
    var pp$92 = Parser3.prototype;
    var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
    pp$92.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) {
        return false;
      }
      for (; ; ) {
        skipWhiteSpace2.lastIndex = start;
        start += skipWhiteSpace2.exec(this.input)[0].length;
        var match2 = literal2.exec(this.input.slice(start));
        if (!match2) {
          return false;
        }
        if ((match2[1] || match2[2]) === "use strict") {
          skipWhiteSpace2.lastIndex = start + match2[0].length;
          var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next2 = this.input.charAt(end);
          return next2 === ";" || next2 === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match2[0].length;
        skipWhiteSpace2.lastIndex = start;
        start += skipWhiteSpace2.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$92.eat = function(type2) {
      if (this.type === type2) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$92.isContextual = function(name) {
      return this.type === types$12.name && this.value === name && !this.containsEsc;
    };
    pp$92.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$92.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp$92.canInsertSemicolon = function() {
      return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$92.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$92.semicolon = function() {
      if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$92.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$92.expect = function(type2) {
      this.eat(type2) || this.unexpected();
    };
    pp$92.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    var DestructuringErrors3 = function DestructuringErrors4() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
      }
    };
    pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$92.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$92.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$82 = Parser3.prototype;
    pp$82.parseTopLevel = function(node2) {
      var exports3 = /* @__PURE__ */ Object.create(null);
      if (!node2.body) {
        node2.body = [];
      }
      while (this.type !== types$12.eof) {
        var stmt = this.parseStatement(null, true, exports3);
        node2.body.push(stmt);
      }
      if (this.inModule) {
        for (var i22 = 0, list22 = Object.keys(this.undefinedExports); i22 < list22.length; i22 += 1) {
          var name = list22[i22];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node2.body);
      this.next();
      node2.sourceType = this.options.sourceType;
      return this.finishNode(node2, "Program");
    };
    var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
    pp$82.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace2.lastIndex = this.pos;
      var skip = skipWhiteSpace2.exec(this.input);
      var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
      if (nextCh === 91 || nextCh === 92) {
        return true;
      }
      if (context) {
        return false;
      }
      if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (isIdentifierStart2(nextCh, true)) {
        var pos = next2 + 1;
        while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next2, pos);
        if (!keywordRelationalOperator2.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$82.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace2.lastIndex = this.pos;
      var skip = skipWhiteSpace2.exec(this.input);
      var next2 = this.pos + skip[0].length, after;
      return !lineBreak2.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
    };
    pp$82.parseStatement = function(context, topLevel, exports3) {
      var starttype = this.type, node2 = this.startNode(), kind;
      if (this.isLet(context)) {
        starttype = types$12._var;
        kind = "let";
      }
      switch (starttype) {
        case types$12._break:
        case types$12._continue:
          return this.parseBreakContinueStatement(node2, starttype.keyword);
        case types$12._debugger:
          return this.parseDebuggerStatement(node2);
        case types$12._do:
          return this.parseDoStatement(node2);
        case types$12._for:
          return this.parseForStatement(node2);
        case types$12._function:
          if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node2, false, !context);
        case types$12._class:
          if (context) {
            this.unexpected();
          }
          return this.parseClass(node2, true);
        case types$12._if:
          return this.parseIfStatement(node2);
        case types$12._return:
          return this.parseReturnStatement(node2);
        case types$12._switch:
          return this.parseSwitchStatement(node2);
        case types$12._throw:
          return this.parseThrowStatement(node2);
        case types$12._try:
          return this.parseTryStatement(node2);
        case types$12._const:
        case types$12._var:
          kind = kind || this.value;
          if (context && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node2, kind);
        case types$12._while:
          return this.parseWhileStatement(node2);
        case types$12._with:
          return this.parseWithStatement(node2);
        case types$12.braceL:
          return this.parseBlock(true, node2);
        case types$12.semi:
          return this.parseEmptyStatement(node2);
        case types$12._export:
        case types$12._import:
          if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
            skipWhiteSpace2.lastIndex = this.pos;
            var skip = skipWhiteSpace2.exec(this.input);
            var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node2, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$12._import ? this.parseImport(node2) : this.parseExport(node2, exports3);
        default:
          if (this.isAsyncFunction()) {
            if (context) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !context);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
      }
    };
    pp$82.parseBreakContinueStatement = function(node2, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$12.semi) || this.insertSemicolon()) {
        node2.label = null;
      } else if (this.type !== types$12.name) {
        this.unexpected();
      } else {
        node2.label = this.parseIdent();
        this.semicolon();
      }
      var i22 = 0;
      for (; i22 < this.labels.length; ++i22) {
        var lab = this.labels[i22];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node2.label && isBreak) {
            break;
          }
        }
      }
      if (i22 === this.labels.length) {
        this.raise(node2.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$82.parseDebuggerStatement = function(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    };
    pp$82.parseDoStatement = function(node2) {
      this.next();
      this.labels.push(loopLabel2);
      node2.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$12._while);
      node2.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$12.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "DoWhileStatement");
    };
    pp$82.parseForStatement = function(node2) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel2);
      this.enterScope(0);
      this.expect(types$12.parenL);
      if (this.type === types$12.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      var isLet = this.isLet();
      if (this.type === types$12._var || this.type === types$12._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$12._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var containsEsc = this.containsEsc;
      var refDestructuringErrors = new DestructuringErrors3();
      var initPos = this.start;
      var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
      if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (awaitAt > -1) {
          if (this.type === types$12._in) {
            this.unexpected(awaitAt);
          }
          node2.await = true;
        } else if (isForOf && this.options.ecmaVersion >= 8) {
          if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
            this.unexpected();
          } else if (this.options.ecmaVersion >= 9) {
            node2.await = false;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLValPattern(init);
        return this.parseForIn(node2, init);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init);
    };
    pp$82.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node2, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
    };
    pp$82.parseIfStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      node2.consequent = this.parseStatement("if");
      node2.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
      return this.finishNode(node2, "IfStatement");
    };
    pp$82.parseReturnStatement = function(node2) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$12.semi) || this.insertSemicolon()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    };
    pp$82.parseSwitchStatement = function(node2) {
      this.next();
      node2.discriminant = this.parseParenExpression();
      node2.cases = [];
      this.expect(types$12.braceL);
      this.labels.push(switchLabel2);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$12.braceR; ) {
        if (this.type === types$12._case || this.type === types$12._default) {
          var isCase = this.type === types$12._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node2.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$12.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    };
    pp$82.parseThrowStatement = function(node2) {
      this.next();
      if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    };
    var empty$12 = [];
    pp$82.parseCatchClauseParam = function() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
      this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
      this.expect(types$12.parenR);
      return param;
    };
    pp$82.parseTryStatement = function(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.type === types$12._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$12.parenL)) {
          clause.param = this.parseCatchClauseParam();
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(node2.start, "Missing catch or finally clause");
      }
      return this.finishNode(node2, "TryStatement");
    };
    pp$82.parseVarStatement = function(node2, kind, allowMissingInitializer) {
      this.next();
      this.parseVar(node2, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    };
    pp$82.parseWhileStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      this.labels.push(loopLabel2);
      node2.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    };
    pp$82.parseWithStatement = function(node2) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node2.object = this.parseParenExpression();
      node2.body = this.parseStatement("with");
      return this.finishNode(node2, "WithStatement");
    };
    pp$82.parseEmptyStatement = function(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    };
    pp$82.parseLabeledStatement = function(node2, maybeName, expr, context) {
      for (var i$1 = 0, list22 = this.labels; i$1 < list22.length; i$1 += 1) {
        var label = list22[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
      for (var i22 = this.labels.length - 1; i22 >= 0; i22--) {
        var label$1 = this.labels[i22];
        if (label$1.statementStart === node2.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    };
    pp$82.parseExpressionStatement = function(node2, expr) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    };
    pp$82.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node2 === void 0)
        node2 = this.startNode();
      node2.body = [];
      this.expect(types$12.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$12.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node2, "BlockStatement");
    };
    pp$82.parseFor = function(node2, init) {
      node2.init = init;
      this.expect(types$12.semi);
      node2.test = this.type === types$12.semi ? null : this.parseExpression();
      this.expect(types$12.semi);
      node2.update = this.type === types$12.parenR ? null : this.parseExpression();
      this.expect(types$12.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, "ForStatement");
    };
    pp$82.parseForIn = function(node2, init) {
      var isForIn = this.type === types$12._in;
      this.next();
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
      }
      node2.left = init;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$12.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$82.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
      node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$12.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$12.comma)) {
          break;
        }
      }
      return node2;
    };
    pp$82.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
    };
    var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
    pp$82.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
          this.unexpected();
        }
        node2.generator = this.eat(types$12.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT2) {
        node2.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
        if (node2.id && !(statement & FUNC_HANGING_STATEMENT2)) {
          this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags2(node2.async, node2.generator));
      if (!(statement & FUNC_STATEMENT2)) {
        node2.id = this.type === types$12.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node2);
      this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$82.parseFunctionParams = function(node2) {
      this.expect(types$12.parenL);
      node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$82.parseClass = function(node2, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node2, isStatement);
      this.parseClassSuper(node2);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$12.braceL);
      while (this.type !== types$12.braceR) {
        var element2 = this.parseClassElement(node2.superClass !== null);
        if (element2) {
          classBody.body.push(element2);
          if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
            if (hadConstructor) {
              this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
            this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node2.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$82.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$12.semi)) {
        return null;
      }
      var ecmaVersion22 = this.options.ecmaVersion;
      var node2 = this.startNode();
      var keyName = "";
      var isGenerator2 = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion22 >= 13 && this.eat(types$12.braceL)) {
          this.parseClassStaticBlock(node2);
          return node2;
        }
        if (this.isClassElementNameStart() || this.type === types$12.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node2.static = isStatic;
      if (!keyName && ecmaVersion22 >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion22 >= 9 || !isAsync) && this.eat(types$12.star)) {
        isGenerator2 = true;
      }
      if (!keyName && !isAsync && !isGenerator2) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node2.computed = false;
        node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node2.key.name = keyName;
        this.finishNode(node2.key, "Identifier");
      } else {
        this.parseClassElementName(node2);
      }
      if (ecmaVersion22 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator2 || isAsync) {
        var isConstructor = !node2.static && checkKeyName2(node2, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node2.key.start, "Constructor can't have get/set modifier");
        }
        node2.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node2, isGenerator2, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node2);
      }
      return node2;
    };
    pp$82.isClassElementNameStart = function() {
      return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
    };
    pp$82.parseClassElementName = function(element2) {
      if (this.type === types$12.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element2.computed = false;
        element2.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element2);
      }
    };
    pp$82.parseClassMethod = function(method, isGenerator2, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator2) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName2(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value = method.value = this.parseMethod(isGenerator2, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value.params.length !== 0) {
        this.raiseRecoverable(value.start, "getter should have no params");
      }
      if (method.kind === "set" && value.params.length !== 1) {
        this.raiseRecoverable(value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value.params[0].type === "RestElement") {
        this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$82.parseClassField = function(field) {
      if (checkKeyName2(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName2(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$12.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$82.parseClassStaticBlock = function(node2) {
      node2.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
      while (this.type !== types$12.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node2, "StaticBlock");
    };
    pp$82.parseClassId = function(node2, isStatement) {
      if (this.type === types$12.name) {
        node2.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node2.id, BIND_LEXICAL2, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node2.id = null;
      }
    };
    pp$82.parseClassSuper = function(node2) {
      node2.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$82.enterClassBody = function() {
      var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element2);
      return element2.declared;
    };
    pp$82.exitClassBody = function() {
      var ref3 = this.privateNameStack.pop();
      var declared = ref3.declared;
      var used = ref3.used;
      if (!this.options.checkPrivateFields) {
        return;
      }
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i22 = 0; i22 < used.length; ++i22) {
        var id2 = used[i22];
        if (!hasOwn2(declared, id2.name)) {
          if (parent) {
            parent.used.push(id2);
          } else {
            this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    function isPrivateNameConflicted2(privateNameMap, element2) {
      var name = element2.key.name;
      var curr = privateNameMap[name];
      var next2 = "true";
      if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
        next2 = (element2.static ? "s" : "i") + element2.kind;
      }
      if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
        privateNameMap[name] = "true";
        return false;
      } else if (!curr) {
        privateNameMap[name] = next2;
        return false;
      } else {
        return true;
      }
    }
    function checkKeyName2(node2, name) {
      var computed = node2.computed;
      var key = node2.key;
      return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
    }
    pp$82.parseExportAllDeclaration = function(node2, exports3) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node2.exported = this.parseModuleExportName();
          this.checkExport(exports3, node2.exported, this.lastTokStart);
        } else {
          node2.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types$12.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node2, "ExportAllDeclaration");
    };
    pp$82.parseExport = function(node2, exports3) {
      this.next();
      if (this.eat(types$12.star)) {
        return this.parseExportAllDeclaration(node2, exports3);
      }
      if (this.eat(types$12._default)) {
        this.checkExport(exports3, "default", this.lastTokStart);
        node2.declaration = this.parseExportDefaultDeclaration();
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node2.declaration = this.parseExportDeclaration(node2);
        if (node2.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports3, node2.declaration.declarations);
        } else {
          this.checkExport(exports3, node2.declaration.id, node2.declaration.id.start);
        }
        node2.specifiers = [];
        node2.source = null;
      } else {
        node2.declaration = null;
        node2.specifiers = this.parseExportSpecifiers(exports3);
        if (this.eatContextual("from")) {
          if (this.type !== types$12.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
        } else {
          for (var i22 = 0, list22 = node2.specifiers; i22 < list22.length; i22 += 1) {
            var spec = list22[i22];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    };
    pp$82.parseExportDeclaration = function(node2) {
      return this.parseStatement(null);
    };
    pp$82.parseExportDefaultDeclaration = function() {
      var isAsync;
      if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) {
          this.next();
        }
        return this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
      } else if (this.type === types$12._class) {
        var cNode = this.startNode();
        return this.parseClass(cNode, "nullableID");
      } else {
        var declaration2 = this.parseMaybeAssign();
        this.semicolon();
        return declaration2;
      }
    };
    pp$82.checkExport = function(exports3, name, pos) {
      if (!exports3) {
        return;
      }
      if (typeof name !== "string") {
        name = name.type === "Identifier" ? name.name : name.value;
      }
      if (hasOwn2(exports3, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports3[name] = true;
    };
    pp$82.checkPatternExport = function(exports3, pat) {
      var type2 = pat.type;
      if (type2 === "Identifier") {
        this.checkExport(exports3, pat, pat.start);
      } else if (type2 === "ObjectPattern") {
        for (var i22 = 0, list22 = pat.properties; i22 < list22.length; i22 += 1) {
          var prop = list22[i22];
          this.checkPatternExport(exports3, prop);
        }
      } else if (type2 === "ArrayPattern") {
        for (var i$1 = 0, list$12 = pat.elements; i$1 < list$12.length; i$1 += 1) {
          var elt = list$12[i$1];
          if (elt) {
            this.checkPatternExport(exports3, elt);
          }
        }
      } else if (type2 === "Property") {
        this.checkPatternExport(exports3, pat.value);
      } else if (type2 === "AssignmentPattern") {
        this.checkPatternExport(exports3, pat.left);
      } else if (type2 === "RestElement") {
        this.checkPatternExport(exports3, pat.argument);
      }
    };
    pp$82.checkVariableExport = function(exports3, decls) {
      if (!exports3) {
        return;
      }
      for (var i22 = 0, list22 = decls; i22 < list22.length; i22 += 1) {
        var decl = list22[i22];
        this.checkPatternExport(exports3, decl.id);
      }
    };
    pp$82.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$82.parseExportSpecifier = function(exports3) {
      var node2 = this.startNode();
      node2.local = this.parseModuleExportName();
      node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
      this.checkExport(exports3, node2.exported, node2.exported.start);
      return this.finishNode(node2, "ExportSpecifier");
    };
    pp$82.parseExportSpecifiers = function(exports3) {
      var nodes = [], first = true;
      this.expect(types$12.braceL);
      while (!this.eat(types$12.braceR)) {
        if (!first) {
          this.expect(types$12.comma);
          if (this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        nodes.push(this.parseExportSpecifier(exports3));
      }
      return nodes;
    };
    pp$82.parseImport = function(node2) {
      this.next();
      if (this.type === types$12.string) {
        node2.specifiers = empty$12;
        node2.source = this.parseExprAtom();
      } else {
        node2.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node2.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    };
    pp$82.parseImportSpecifier = function() {
      var node2 = this.startNode();
      node2.imported = this.parseModuleExportName();
      if (this.eatContextual("as")) {
        node2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node2.imported);
        node2.local = node2.imported;
      }
      this.checkLValSimple(node2.local, BIND_LEXICAL2);
      return this.finishNode(node2, "ImportSpecifier");
    };
    pp$82.parseImportDefaultSpecifier = function() {
      var node2 = this.startNode();
      node2.local = this.parseIdent();
      this.checkLValSimple(node2.local, BIND_LEXICAL2);
      return this.finishNode(node2, "ImportDefaultSpecifier");
    };
    pp$82.parseImportNamespaceSpecifier = function() {
      var node2 = this.startNode();
      this.next();
      this.expectContextual("as");
      node2.local = this.parseIdent();
      this.checkLValSimple(node2.local, BIND_LEXICAL2);
      return this.finishNode(node2, "ImportNamespaceSpecifier");
    };
    pp$82.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types$12.name) {
        nodes.push(this.parseImportDefaultSpecifier());
        if (!this.eat(types$12.comma)) {
          return nodes;
        }
      }
      if (this.type === types$12.star) {
        nodes.push(this.parseImportNamespaceSpecifier());
        return nodes;
      }
      this.expect(types$12.braceL);
      while (!this.eat(types$12.braceR)) {
        if (!first) {
          this.expect(types$12.comma);
          if (this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        nodes.push(this.parseImportSpecifier());
      }
      return nodes;
    };
    pp$82.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate2.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$82.adaptDirectivePrologue = function(statements) {
      for (var i22 = 0; i22 < statements.length && this.isDirectiveCandidate(statements[i22]); ++i22) {
        statements[i22].directive = statements[i22].expression.raw.slice(1, -1);
      }
    };
    pp$82.isDirectiveCandidate = function(statement) {
      return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$72 = Parser3.prototype;
    pp$72.toAssignable = function(node2, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node2) {
        switch (node2.type) {
          case "Identifier":
            if (this.inAsync && node2.name === "await") {
              this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i22 = 0, list22 = node2.properties; i22 < list22.length; i22 += 1) {
              var prop = list22[i22];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node2.kind !== "init") {
              this.raise(node2.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node2.value, isBinding);
            break;
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node2.elements, isBinding);
            break;
          case "SpreadElement":
            node2.type = "RestElement";
            this.toAssignable(node2.argument, isBinding);
            if (node2.argument.type === "AssignmentPattern") {
              this.raise(node2.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node2.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node2;
    };
    pp$72.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i22 = 0; i22 < end; i22++) {
        var elt = exprList[i22];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$72.parseSpread = function(refDestructuringErrors) {
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node2, "SpreadElement");
    };
    pp$72.parseRestBinding = function() {
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
        this.unexpected();
      }
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    };
    pp$72.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$12.bracketL:
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(types$12.bracketR, true, true);
            return this.finishNode(node2, "ArrayPattern");
          case types$12.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$72.parseBindingList = function(close3, allowEmpty, allowTrailingComma, allowModifiers) {
      var elts = [], first = true;
      while (!this.eat(close3)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$12.comma);
        }
        if (allowEmpty && this.type === types$12.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close3)) {
          break;
        } else if (this.type === types$12.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$12.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close3);
          break;
        } else {
          elts.push(this.parseAssignableListItem(allowModifiers));
        }
      }
      return elts;
    };
    pp$72.parseAssignableListItem = function(allowModifiers) {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      return elem;
    };
    pp$72.parseBindingListItem = function(param) {
      return param;
    };
    pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
        return left;
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.right = this.parseMaybeAssign();
      return this.finishNode(node2, "AssignmentPattern");
    };
    pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      var isBind = bindingType !== BIND_NONE2;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn2(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE2) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i22 = 0, list22 = expr.properties; i22 < list22.length; i22 += 1) {
            var prop = list22[i22];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$12 = expr.elements; i$1 < list$12.length; i$1 += 1) {
            var elem = list$12[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE2;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    var TokContext3 = function TokContext4(token2, isExpr, preserveSpace, override, generator) {
      this.token = token2;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    var types2 = {
      b_stat: new TokContext3("{", false),
      b_expr: new TokContext3("{", true),
      b_tmpl: new TokContext3("${", false),
      p_stat: new TokContext3("(", false),
      p_expr: new TokContext3("(", true),
      q_tmpl: new TokContext3("`", true, true, function(p2) {
        return p2.tryReadTemplateToken();
      }),
      f_stat: new TokContext3("function", false),
      f_expr: new TokContext3("function", true),
      f_expr_gen: new TokContext3("function", true, false, null, true),
      f_gen: new TokContext3("function", false, false, null, true)
    };
    var pp$62 = Parser3.prototype;
    pp$62.initialContext = function() {
      return [types2.b_stat];
    };
    pp$62.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$62.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types2.f_expr || parent === types2.f_stat) {
        return true;
      }
      if (prevType === types$12.colon && (parent === types2.b_stat || parent === types2.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
        return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
        return true;
      }
      if (prevType === types$12.braceL) {
        return parent === types2.b_stat;
      }
      if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$62.inGeneratorContext = function() {
      for (var i22 = this.context.length - 1; i22 >= 1; i22--) {
        var context = this.context[i22];
        if (context.token === "function") {
          return context.generator;
        }
      }
      return false;
    };
    pp$62.updateContext = function(prevType) {
      var update, type2 = this.type;
      if (type2.keyword && prevType === types$12.dot) {
        this.exprAllowed = false;
      } else if (update = type2.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type2.beforeExpr;
      }
    };
    pp$62.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types2.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types$12.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr);
      this.exprAllowed = true;
    };
    types$12.dollarBraceL.updateContext = function() {
      this.context.push(types2.b_tmpl);
      this.exprAllowed = true;
    };
    types$12.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
      this.context.push(statementParens ? types2.p_stat : types2.p_expr);
      this.exprAllowed = true;
    };
    types$12.incDec.updateContext = function() {
    };
    types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types2.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types2.b_stat)) {
        this.context.push(types2.f_expr);
      } else {
        this.context.push(types2.f_stat);
      }
      this.exprAllowed = false;
    };
    types$12.colon.updateContext = function() {
      if (this.curContext().token === "function") {
        this.context.pop();
      }
      this.exprAllowed = true;
    };
    types$12.backQuote.updateContext = function() {
      if (this.curContext() === types2.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types2.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$12.star.updateContext = function(prevType) {
      if (prevType === types$12._function) {
        var index2 = this.context.length - 1;
        if (this.context[index2] === types2.f_expr) {
          this.context[index2] = types2.f_expr_gen;
        } else {
          this.context[index2] = types2.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$12.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var pp$52 = Parser3.prototype;
    pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$52.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$12.comma) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.expressions = [expr];
        while (this.eat(types$12.comma)) {
          node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    };
    pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors3();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$12.parenL || this.type === types$12.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.value;
        if (this.type === types$12.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$12.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node2.left = left;
        this.next();
        node2.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node2, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$12.question)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssign();
        this.expect(types$12.colon);
        node2.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    };
    pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$12._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
          var coalesce = this.type === types$12.coalesce;
          if (coalesce) {
            prec = types$12.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.operator = op;
      node2.right = right;
      return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node2 = this.startNode(), update = this.type === types$12.incDec;
        node2.operator = this.value;
        node2.prefix = true;
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node2.argument);
        } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess2(node2.argument)) {
          this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
        } else if (node2.operator === "delete" && isPrivateFieldAccess2(node2.argument)) {
          this.raiseRecoverable(node2.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$12.privateId) {
        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$12._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$12 = this.startNodeAt(startPos, startLoc);
          node$12.operator = this.value;
          node$12.prefix = false;
          node$12.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$12, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$12.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    function isLocalVariableAccess2(node2) {
      return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess2(node2.expression);
    }
    function isPrivateFieldAccess2(node2) {
      return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess2(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess2(node2.expression);
    }
    pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result;
    };
    pp$52.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
      var optionalChained = false;
      while (true) {
        var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element2.optional) {
          optionalChained = true;
        }
        if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element2;
            element2 = this.finishNode(chainNode, "ChainExpression");
          }
          return element2;
        }
        base2 = element2;
      }
    };
    pp$52.shouldParseAsyncArrow = function() {
      return !this.canInsertSemicolon() && this.eat(types$12.arrow);
    };
    pp$52.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    };
    pp$52.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$12.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$12.bracketL);
      if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.object = base2;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(types$12.bracketR);
        } else if (this.type === types$12.privateId && base2.type !== "Super") {
          node2.property = this.parsePrivateIdent();
        } else {
          node2.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node2.computed = !!computed;
        if (optionalSupported) {
          node2.optional = optional;
        }
        base2 = this.finishNode(node2, "MemberExpression");
      } else if (!noCalls && this.eat(types$12.parenL)) {
        var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.callee = base2;
        node$12.arguments = exprList;
        if (optionalSupported) {
          node$12.optional = optional;
        }
        base2 = this.finishNode(node$12, "CallExpression");
      } else if (this.type === types$12.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base2;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base2 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base2;
    };
    pp$52.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
      if (this.type === types$12.slash) {
        this.readRegexp();
      }
      var node2, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$12._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node2 = this.startNode();
          this.next();
          if (this.type === types$12.parenL && !this.allowDirectSuper) {
            this.raise(node2.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
            this.unexpected();
          }
          return this.finishNode(node2, "Super");
        case types$12._this:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case types$12.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id2 = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
            this.overrideContext(types2.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$12.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id2 = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
            }
          }
          return id2;
        case types$12.regexp:
          var value = this.value;
          node2 = this.parseLiteral(value.value);
          node2.regex = { pattern: value.pattern, flags: value.flags };
          return node2;
        case types$12.num:
        case types$12.string:
          return this.parseLiteral(this.value);
        case types$12._null:
        case types$12._true:
        case types$12._false:
          node2 = this.startNode();
          node2.value = this.type === types$12._null ? null : this.type === types$12._true;
          node2.raw = this.type.keyword;
          this.next();
          return this.finishNode(node2, "Literal");
        case types$12.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$12.bracketL:
          node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node2, "ArrayExpression");
        case types$12.braceL:
          this.overrideContext(types2.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$12._function:
          node2 = this.startNode();
          this.next();
          return this.parseFunction(node2, 0);
        case types$12._class:
          return this.parseClass(this.startNode(), false);
        case types$12._new:
          return this.parseNew();
        case types$12.backQuote:
          return this.parseTemplate();
        case types$12._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport(forNew);
          } else {
            return this.unexpected();
          }
        default:
          return this.parseExprAtomDefault();
      }
    };
    pp$52.parseExprAtomDefault = function() {
      this.unexpected();
    };
    pp$52.parseExprImport = function(forNew) {
      var node2 = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      this.next();
      if (this.type === types$12.parenL && !forNew) {
        return this.parseDynamicImport(node2);
      } else if (this.type === types$12.dot) {
        var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
        meta.name = "import";
        node2.meta = this.finishNode(meta, "Identifier");
        return this.parseImportMeta(node2);
      } else {
        this.unexpected();
      }
    };
    pp$52.parseDynamicImport = function(node2) {
      this.next();
      node2.source = this.parseMaybeAssign();
      if (!this.eat(types$12.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node2, "ImportExpression");
    };
    pp$52.parseImportMeta = function(node2) {
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "meta") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node2, "MetaProperty");
    };
    pp$52.parseLiteral = function(value) {
      var node2 = this.startNode();
      node2.value = value;
      node2.raw = this.input.slice(this.start, this.end);
      if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
        node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node2, "Literal");
    };
    pp$52.parseParenExpression = function() {
      this.expect(types$12.parenL);
      var val = this.parseExpression();
      this.expect(types$12.parenR);
      return val;
    };
    pp$52.shouldParseArrow = function(exprList) {
      return !this.canInsertSemicolon();
    };
    pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$12.parenR) {
          first ? first = false : this.expect(types$12.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$12.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$12.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$12.parenR);
        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$12.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$52.parseParenItem = function(item) {
      return item;
    };
    pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    var empty2 = [];
    pp$52.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion >= 6 && this.type === types$12.dot) {
        var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
        meta.name = "new";
        node2.meta = this.finishNode(meta, "Identifier");
        this.next();
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "target") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node2, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc;
      node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
      if (this.eat(types$12.parenL)) {
        node2.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node2.arguments = empty2;
      }
      return this.finishNode(node2, "NewExpression");
    };
    pp$52.parseTemplateElement = function(ref3) {
      var isTagged = ref3.isTagged;
      var elem = this.startNode();
      if (this.type === types$12.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value.replace(/\r\n?/g, `
`),
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$12.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$52.parseTemplate = function(ref3) {
      if (ref3 === void 0)
        ref3 = {};
      var isTagged = ref3.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node2 = this.startNode();
      this.next();
      node2.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node2.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$12.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$12.dollarBraceL);
        node2.expressions.push(this.parseExpression());
        this.expect(types$12.braceR);
        node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node2, "TemplateLiteral");
    };
    pp$52.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$52.parseObj = function(isPattern, refDestructuringErrors) {
      var node2 = this.startNode(), first = true, propHash = {};
      node2.properties = [];
      this.next();
      while (!this.eat(types$12.braceR)) {
        if (!first) {
          this.expect(types$12.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node2.properties.push(prop);
      }
      return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator2, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$12.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator2 = this.eat(types$12.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator2 && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator2 = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator2, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$52.parseGetterSetter = function(prop) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get") {
          this.raiseRecoverable(start, "getter should have no params");
        } else {
          this.raiseRecoverable(start, "setter should have exactly one param");
        }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
          this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        }
      }
    };
    pp$52.parsePropertyValue = function(prop, isPattern, isGenerator2, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator2 || isAsync) && this.type === types$12.colon) {
        this.unexpected();
      }
      if (this.eat(types$12.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator2, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
        if (isGenerator2 || isAsync) {
          this.unexpected();
        }
        this.parseGetterSetter(prop);
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator2 || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$12.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$52.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$12.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$12.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$52.initFunction = function(node2) {
      node2.id = null;
      if (this.options.ecmaVersion >= 6) {
        node2.generator = node2.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = false;
      }
    };
    pp$52.parseMethod = function(isGenerator2, isAsync, allowDirectSuper) {
      var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 6) {
        node2.generator = isGenerator2;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags2(isAsync, node2.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
      this.expect(types$12.parenL);
      node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node2, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "FunctionExpression");
    };
    pp$52.parseArrowExpression = function(node2, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node2.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node2, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "ArrowFunctionExpression");
    };
    pp$52.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$12.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node2.body = this.parseMaybeAssign(forInit);
        node2.expression = true;
        this.checkParams(node2, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
        if (this.strict && node2.id) {
          this.checkLValSimple(node2.id, BIND_OUTSIDE2);
        }
        node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node2.expression = false;
        this.adaptDirectivePrologue(node2.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$52.isSimpleParamList = function(params) {
      for (var i22 = 0, list22 = params; i22 < list22.length; i22 += 1) {
        var param = list22[i22];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$52.checkParams = function(node2, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i22 = 0, list22 = node2.params; i22 < list22.length; i22 += 1) {
        var param = list22[i22];
        this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
      }
    };
    pp$52.parseExprList = function(close3, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close3)) {
        if (!first) {
          this.expect(types$12.comma);
          if (allowTrailingComma && this.afterTrailingComma(close3)) {
            break;
          }
        } else {
          first = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$12.comma) {
          elt = null;
        } else if (this.type === types$12.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$52.checkUnreserved = function(ref3) {
      var start = ref3.start;
      var end = ref3.end;
      var name = ref3.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
        this.raise(start, "Cannot use " + name + " in class static initialization block");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re2.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$52.parseIdent = function(liberal) {
      var node2 = this.parseIdentNode();
      this.next(!!liberal);
      this.finishNode(node2, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node2);
        if (node2.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node2.start;
        }
      }
      return node2;
    };
    pp$52.parseIdentNode = function() {
      var node2 = this.startNode();
      if (this.type === types$12.name) {
        node2.name = this.value;
      } else if (this.type.keyword) {
        node2.name = this.type.keyword;
        if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
        this.type = types$12.name;
      } else {
        this.unexpected();
      }
      return node2;
    };
    pp$52.parsePrivateIdent = function() {
      var node2 = this.startNode();
      if (this.type === types$12.privateId) {
        node2.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node2, "PrivateIdentifier");
      if (this.options.checkPrivateFields) {
        if (this.privateNameStack.length === 0) {
          this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
        }
      }
      return node2;
    };
    pp$52.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
        node2.delegate = false;
        node2.argument = null;
      } else {
        node2.delegate = this.eat(types$12.star);
        node2.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node2, "YieldExpression");
    };
    pp$52.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node2, "AwaitExpression");
    };
    var pp$42 = Parser3.prototype;
    pp$42.raise = function(pos, message) {
      var loc = getLineInfo2(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$42.raiseRecoverable = pp$42.raise;
    pp$42.curPosition = function() {
      if (this.options.locations) {
        return new Position3(this.curLine, this.pos - this.lineStart);
      }
    };
    var pp$32 = Parser3.prototype;
    var Scope3 = function Scope4(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$32.enterScope = function(flags) {
      this.scopeStack.push(new Scope3(flags));
    };
    pp$32.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$32.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
    };
    pp$32.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL2) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP2) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH2) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION2) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i22 = this.scopeStack.length - 1; i22 >= 0; --i22) {
          var scope$3 = this.scopeStack[i22];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR2) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$32.checkLocalExport = function(id2) {
      if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
        this.undefinedExports[id2.name] = id2;
      }
    };
    pp$32.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$32.currentVarScope = function() {
      for (var i22 = this.scopeStack.length - 1; ; i22--) {
        var scope = this.scopeStack[i22];
        if (scope.flags & SCOPE_VAR2) {
          return scope;
        }
      }
    };
    pp$32.currentThisScope = function() {
      for (var i22 = this.scopeStack.length - 1; ; i22--) {
        var scope = this.scopeStack[i22];
        if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
          return scope;
        }
      }
    };
    var Node3 = function Node4(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation3(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    var pp$22 = Parser3.prototype;
    pp$22.startNode = function() {
      return new Node3(this, this.start, this.startLoc);
    };
    pp$22.startNodeAt = function(pos, loc) {
      return new Node3(this, pos, loc);
    };
    function finishNodeAt2(node2, type2, pos, loc) {
      node2.type = type2;
      node2.end = pos;
      if (this.options.locations) {
        node2.loc.end = loc;
      }
      if (this.options.ranges) {
        node2.range[1] = pos;
      }
      return node2;
    }
    pp$22.finishNode = function(node2, type2) {
      return finishNodeAt2.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$22.finishNodeAt = function(node2, type2, pos, loc) {
      return finishNodeAt2.call(this, node2, type2, pos, loc);
    };
    pp$22.copyNode = function(node2) {
      var newNode = new Node3(this, node2.start, this.startLoc);
      for (var prop in node2) {
        newNode[prop] = node2[prop];
      }
      return newNode;
    };
    var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
    var ecma11BinaryProperties2 = ecma10BinaryProperties2;
    var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties2 = ecma12BinaryProperties2;
    var ecma14BinaryProperties2 = ecma13BinaryProperties2;
    var unicodeBinaryProperties2 = {
      9: ecma9BinaryProperties2,
      10: ecma10BinaryProperties2,
      11: ecma11BinaryProperties2,
      12: ecma12BinaryProperties2,
      13: ecma13BinaryProperties2,
      14: ecma14BinaryProperties2
    };
    var ecma14BinaryPropertiesOfStrings2 = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
    var unicodeBinaryPropertiesOfStrings2 = {
      9: "",
      10: "",
      11: "",
      12: "",
      13: "",
      14: ecma14BinaryPropertiesOfStrings2
    };
    var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var ecma14ScriptValues2 = ecma13ScriptValues2 + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
    var unicodeScriptValues2 = {
      9: ecma9ScriptValues2,
      10: ecma10ScriptValues2,
      11: ecma11ScriptValues2,
      12: ecma12ScriptValues2,
      13: ecma13ScriptValues2,
      14: ecma14ScriptValues2
    };
    var data2 = {};
    function buildUnicodeData2(ecmaVersion22) {
      var d2 = data2[ecmaVersion22] = {
        binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion22] + " " + unicodeGeneralCategoryValues2),
        binaryOfStrings: wordsRegexp2(unicodeBinaryPropertiesOfStrings2[ecmaVersion22]),
        nonBinary: {
          General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
          Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion22])
        }
      };
      d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
      d2.nonBinary.gc = d2.nonBinary.General_Category;
      d2.nonBinary.sc = d2.nonBinary.Script;
      d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
    }
    for (var i2 = 0, list2 = [9, 10, 11, 12, 13, 14]; i2 < list2.length; i2 += 1) {
      var ecmaVersion2 = list2[i2];
      buildUnicodeData2(ecmaVersion2);
    }
    var pp$12 = Parser3.prototype;
    var BranchID3 = function BranchID4(parent, base2) {
      this.parent = parent;
      this.base = base2 || this;
    };
    BranchID3.prototype.separatedFrom = function separatedFrom2(alt) {
      for (var self2 = this; self2; self2 = self2.parent) {
        for (var other = alt; other; other = other.parent) {
          if (self2.base === other.base && self2 !== other) {
            return true;
          }
        }
      }
      return false;
    };
    BranchID3.prototype.sibling = function sibling2() {
      return new BranchID3(this.parent, this.base);
    };
    var RegExpValidationState3 = function RegExpValidationState4(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
      this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchV = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = /* @__PURE__ */ Object.create(null);
      this.backReferenceNames = [];
      this.branchID = null;
    };
    RegExpValidationState3.prototype.reset = function reset2(start, pattern, flags) {
      var unicodeSets = flags.indexOf("v") !== -1;
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
        this.switchU = true;
        this.switchV = true;
        this.switchN = true;
      } else {
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchV = false;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      }
    };
    RegExpValidationState3.prototype.raise = function raise2(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState3.prototype.at = function at2(i22, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l2 = s.length;
      if (i22 >= l2) {
        return -1;
      }
      var c2 = s.charCodeAt(i22);
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i22 + 1 >= l2) {
        return c2;
      }
      var next2 = s.charCodeAt(i22 + 1);
      return next2 >= 56320 && next2 <= 57343 ? (c2 << 10) + next2 - 56613888 : c2;
    };
    RegExpValidationState3.prototype.nextIndex = function nextIndex2(i22, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s = this.source;
      var l2 = s.length;
      if (i22 >= l2) {
        return l2;
      }
      var c2 = s.charCodeAt(i22), next2;
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i22 + 1 >= l2 || (next2 = s.charCodeAt(i22 + 1)) < 56320 || next2 > 57343) {
        return i22 + 1;
      }
      return i22 + 2;
    };
    RegExpValidationState3.prototype.current = function current2(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState3.prototype.advance = function advance2(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState3.prototype.eat = function eat2(ch2, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch2) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    RegExpValidationState3.prototype.eatChars = function eatChars2(chs, forceU) {
      if (forceU === void 0)
        forceU = false;
      var pos = this.pos;
      for (var i22 = 0, list22 = chs; i22 < list22.length; i22 += 1) {
        var ch2 = list22[i22];
        var current2 = this.at(pos, forceU);
        if (current2 === -1 || current2 !== ch2) {
          return false;
        }
        pos = this.nextIndex(pos, forceU);
      }
      this.pos = pos;
      return true;
    };
    pp$12.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      var u2 = false;
      var v2 = false;
      for (var i22 = 0; i22 < flags.length; i22++) {
        var flag = flags.charAt(i22);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i22 + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
        if (flag === "u") {
          u2 = true;
        }
        if (flag === "v") {
          v2 = true;
        }
      }
      if (this.options.ecmaVersion >= 15 && u2 && v2) {
        this.raise(state.start, "Invalid regular expression flag");
      }
    };
    function hasProp2(obj) {
      for (var _2 in obj) {
        return true;
      }
      return false;
    }
    pp$12.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp2(state.groupNames)) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$12.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames = /* @__PURE__ */ Object.create(null);
      state.backReferenceNames.length = 0;
      state.branchID = null;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i22 = 0, list22 = state.backReferenceNames; i22 < list22.length; i22 += 1) {
        var name = list22[i22];
        if (!state.groupNames[name]) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$12.regexp_disjunction = function(state) {
      var trackDisjunction = this.options.ecmaVersion >= 16;
      if (trackDisjunction) {
        state.branchID = new BranchID3(state.branchID, null);
      }
      this.regexp_alternative(state);
      while (state.eat(124)) {
        if (trackDisjunction) {
          state.branchID = state.branchID.sibling();
        }
        this.regexp_alternative(state);
      }
      if (trackDisjunction) {
        state.branchID = state.branchID.parent;
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$12.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$12.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$12.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$12.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$12.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$12.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$12.regexp_eatSyntaxCharacter = function(state) {
      var ch2 = state.current();
      if (isSyntaxCharacter2(ch2)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    function isSyntaxCharacter2(ch2) {
      return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
    }
    pp$12.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch2 = 0;
      while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter2(ch2)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$12.regexp_eatExtendedPatternCharacter = function(state) {
      var ch2 = state.current();
      if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (!this.regexp_eatGroupName(state)) {
          state.raise("Invalid group");
        }
        var trackDisjunction = this.options.ecmaVersion >= 16;
        var known = state.groupNames[state.lastStringValue];
        if (known) {
          if (trackDisjunction) {
            for (var i22 = 0, list22 = known; i22 < list22.length; i22 += 1) {
              var altID = list22[i22];
              if (!altID.separatedFrom(state.branchID)) {
                state.raise("Duplicate capture group name");
              }
            }
          } else {
            state.raise("Duplicate capture group name");
          }
        }
        if (trackDisjunction) {
          (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
        } else {
          state.groupNames[state.lastStringValue] = true;
        }
      }
    };
    pp$12.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$12.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString2(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString2(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$12.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierStart2(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierStart2(ch2) {
      return isIdentifierStart2(ch2, true) || ch2 === 36 || ch2 === 95;
    }
    pp$12.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierPart2(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierPart2(ch2) {
      return isIdentifierChar2(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
    }
    pp$12.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$12.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n2 = state.lastIntValue;
        if (state.switchU) {
          if (n2 > state.maxBackReference) {
            state.maxBackReference = n2;
          }
          return true;
        }
        if (n2 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$12.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$12.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatControlEscape = function(state) {
      var ch2 = state.current();
      if (ch2 === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch2 === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch2 === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch2 === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch2 === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatControlLetter = function(state) {
      var ch2 = state.current();
      if (isControlLetter2(ch2)) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    function isControlLetter2(ch2) {
      return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
    }
    pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode2(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    function isValidUnicode2(ch2) {
      return ch2 >= 0 && ch2 <= 1114111;
    }
    pp$12.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch2 = state.current();
      if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch2 = state.current();
      if (ch2 >= 49 && ch2 <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
          state.advance();
        } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
        return true;
      }
      return false;
    };
    var CharSetNone2 = 0;
    var CharSetOk2 = 1;
    var CharSetString2 = 2;
    pp$12.regexp_eatCharacterClassEscape = function(state) {
      var ch2 = state.current();
      if (isCharacterClassEscape2(ch2)) {
        state.lastIntValue = -1;
        state.advance();
        return CharSetOk2;
      }
      var negate = false;
      if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch2 === 80) || ch2 === 112)) {
        state.lastIntValue = -1;
        state.advance();
        var result;
        if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
          if (negate && result === CharSetString2) {
            state.raise("Invalid property name");
          }
          return result;
        }
        state.raise("Invalid property name");
      }
      return CharSetNone2;
    };
    function isCharacterClassEscape2(ch2) {
      return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
    }
    pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return CharSetOk2;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      }
      return CharSetNone2;
    };
    pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn2(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (state.unicodeProperties.binary.test(nameOrValue)) {
        return CharSetOk2;
      }
      if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
        return CharSetString2;
      }
      state.raise("Invalid property name");
    };
    pp$12.regexp_eatUnicodePropertyName = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter2(ch2 = state.current())) {
        state.lastStringValue += codePointToString2(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter2(ch2) {
      return isControlLetter2(ch2) || ch2 === 95;
    }
    pp$12.regexp_eatUnicodePropertyValue = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter2(ch2 = state.current())) {
        state.lastStringValue += codePointToString2(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter2(ch2) {
      return isUnicodePropertyNameCharacter2(ch2) || isDecimalDigit2(ch2);
    }
    pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$12.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        var negate = state.eat(94);
        var result = this.regexp_classContents(state);
        if (!state.eat(93)) {
          state.raise("Unterminated character class");
        }
        if (negate && result === CharSetString2) {
          state.raise("Negated character class may contain strings");
        }
        return true;
      }
      return false;
    };
    pp$12.regexp_classContents = function(state) {
      if (state.current() === 93) {
        return CharSetOk2;
      }
      if (state.switchV) {
        return this.regexp_classSetExpression(state);
      }
      this.regexp_nonEmptyClassRanges(state);
      return CharSetOk2;
    };
    pp$12.regexp_nonEmptyClassRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$12.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit2(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch2 = state.current();
      if (ch2 !== 93) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$12.regexp_classSetExpression = function(state) {
      var result = CharSetOk2, subResult;
      if (this.regexp_eatClassSetRange(state))
        ;
      else if (subResult = this.regexp_eatClassSetOperand(state)) {
        if (subResult === CharSetString2) {
          result = CharSetString2;
        }
        var start = state.pos;
        while (state.eatChars([38, 38])) {
          if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
            if (subResult !== CharSetString2) {
              result = CharSetOk2;
            }
            continue;
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) {
          return result;
        }
        while (state.eatChars([45, 45])) {
          if (this.regexp_eatClassSetOperand(state)) {
            continue;
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) {
          return result;
        }
      } else {
        state.raise("Invalid character in character class");
      }
      for (; ; ) {
        if (this.regexp_eatClassSetRange(state)) {
          continue;
        }
        subResult = this.regexp_eatClassSetOperand(state);
        if (!subResult) {
          return result;
        }
        if (subResult === CharSetString2) {
          result = CharSetString2;
        }
      }
    };
    pp$12.regexp_eatClassSetRange = function(state) {
      var start = state.pos;
      if (this.regexp_eatClassSetCharacter(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
          var right = state.lastIntValue;
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatClassSetOperand = function(state) {
      if (this.regexp_eatClassSetCharacter(state)) {
        return CharSetOk2;
      }
      return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
    };
    pp$12.regexp_eatNestedClass = function(state) {
      var start = state.pos;
      if (state.eat(91)) {
        var negate = state.eat(94);
        var result = this.regexp_classContents(state);
        if (state.eat(93)) {
          if (negate && result === CharSetString2) {
            state.raise("Negated character class may contain strings");
          }
          return result;
        }
        state.pos = start;
      }
      if (state.eat(92)) {
        var result$1 = this.regexp_eatCharacterClassEscape(state);
        if (result$1) {
          return result$1;
        }
        state.pos = start;
      }
      return null;
    };
    pp$12.regexp_eatClassStringDisjunction = function(state) {
      var start = state.pos;
      if (state.eatChars([92, 113])) {
        if (state.eat(123)) {
          var result = this.regexp_classStringDisjunctionContents(state);
          if (state.eat(125)) {
            return result;
          }
        } else {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return null;
    };
    pp$12.regexp_classStringDisjunctionContents = function(state) {
      var result = this.regexp_classString(state);
      while (state.eat(124)) {
        if (this.regexp_classString(state) === CharSetString2) {
          result = CharSetString2;
        }
      }
      return result;
    };
    pp$12.regexp_classString = function(state) {
      var count = 0;
      while (this.regexp_eatClassSetCharacter(state)) {
        count++;
      }
      return count === 1 ? CharSetOk2 : CharSetString2;
    };
    pp$12.regexp_eatClassSetCharacter = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
          return true;
        }
        if (state.eat(98)) {
          state.lastIntValue = 8;
          return true;
        }
        state.pos = start;
        return false;
      }
      var ch2 = state.current();
      if (ch2 < 0 || ch2 === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter2(ch2)) {
        return false;
      }
      if (isClassSetSyntaxCharacter2(ch2)) {
        return false;
      }
      state.advance();
      state.lastIntValue = ch2;
      return true;
    };
    function isClassSetReservedDoublePunctuatorCharacter2(ch2) {
      return ch2 === 33 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || ch2 === 46 || ch2 >= 58 && ch2 <= 64 || ch2 === 94 || ch2 === 96 || ch2 === 126;
    }
    function isClassSetSyntaxCharacter2(ch2) {
      return ch2 === 40 || ch2 === 41 || ch2 === 45 || ch2 === 47 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
    }
    pp$12.regexp_eatClassSetReservedPunctuator = function(state) {
      var ch2 = state.current();
      if (isClassSetReservedPunctuator2(ch2)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    function isClassSetReservedPunctuator2(ch2) {
      return ch2 === 33 || ch2 === 35 || ch2 === 37 || ch2 === 38 || ch2 === 44 || ch2 === 45 || ch2 >= 58 && ch2 <= 62 || ch2 === 64 || ch2 === 96 || ch2 === 126;
    }
    pp$12.regexp_eatClassControlLetter = function(state) {
      var ch2 = state.current();
      if (isDecimalDigit2(ch2) || ch2 === 95) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$12.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$12.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit2(ch2 = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    function isDecimalDigit2(ch2) {
      return ch2 >= 48 && ch2 <= 57;
    }
    pp$12.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isHexDigit2(ch2 = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch2);
        state.advance();
      }
      return state.pos !== start;
    };
    function isHexDigit2(ch2) {
      return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
    }
    function hexToInt2(ch2) {
      if (ch2 >= 65 && ch2 <= 70) {
        return 10 + (ch2 - 65);
      }
      if (ch2 >= 97 && ch2 <= 102) {
        return 10 + (ch2 - 97);
      }
      return ch2 - 48;
    }
    pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$12.regexp_eatOctalDigit = function(state) {
      var ch2 = state.current();
      if (isOctalDigit2(ch2)) {
        state.lastIntValue = ch2 - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    function isOctalDigit2(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    pp$12.regexp_eatFixedHexDigits = function(state, length2) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i22 = 0; i22 < length2; ++i22) {
        var ch2 = state.current();
        if (!isHexDigit2(ch2)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch2);
        state.advance();
      }
      return true;
    };
    var Token3 = function Token4(p2) {
      this.type = p2.type;
      this.value = p2.value;
      this.start = p2.start;
      this.end = p2.end;
      if (p2.options.locations) {
        this.loc = new SourceLocation3(p2, p2.startLoc, p2.endLoc);
      }
      if (p2.options.ranges) {
        this.range = [p2.start, p2.end];
      }
    };
    var pp2 = Parser3.prototype;
    pp2.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token3(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp2.getToken = function() {
      this.next();
      return new Token3(this);
    };
    if (typeof Symbol !== "undefined") {
      pp2[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token2 = this$1$1.getToken();
            return {
              done: token2.type === types$12.eof,
              value: token2
            };
          }
        };
      };
    }
    pp2.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$12.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp2.readToken = function(code2) {
      if (isIdentifierStart2(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code2);
    };
    pp2.fullCharCodeAtPos = function() {
      var code2 = this.input.charCodeAt(this.pos);
      if (code2 <= 55295 || code2 >= 56320) {
        return code2;
      }
      var next2 = this.input.charCodeAt(this.pos + 1);
      return next2 <= 56319 || next2 >= 57344 ? code2 : (code2 << 10) + next2 - 56613888;
    };
    pp2.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp2.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch2 = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine2(ch2)) {
        ch2 = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp2.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch2 = this.input.charCodeAt(this.pos);
          switch (ch2) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch2))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp2.finishToken = function(type2, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type2;
      this.value = val;
      this.updateContext(prevType);
    };
    pp2.readToken_dot = function() {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 >= 48 && next2 <= 57) {
        return this.readNumber(true);
      }
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
        this.pos += 3;
        return this.finishToken(types$12.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$12.dot);
      }
    };
    pp2.readToken_slash = function() {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next2 === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.slash, 1);
    };
    pp2.readToken_mult_modulo_exp = function(code2) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code2 === 42 ? types$12.star : types$12.modulo;
      if (this.options.ecmaVersion >= 7 && code2 === 42 && next2 === 42) {
        ++size;
        tokentype = types$12.starstar;
        next2 = this.input.charCodeAt(this.pos + 2);
      }
      if (next2 === 61) {
        return this.finishOp(types$12.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp2.readToken_pipe_amp = function(code2) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === code2) {
        if (this.options.ecmaVersion >= 12) {
          var next22 = this.input.charCodeAt(this.pos + 2);
          if (next22 === 61) {
            return this.finishOp(types$12.assign, 3);
          }
        }
        return this.finishOp(code2 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
      }
      if (next2 === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(code2 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
    };
    pp2.readToken_caret = function() {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.bitwiseXOR, 1);
    };
    pp2.readToken_plus_min = function(code2) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === code2) {
        if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$12.incDec, 2);
      }
      if (next2 === 61) {
        return this.finishOp(types$12.assign, 2);
      }
      return this.finishOp(types$12.plusMin, 1);
    };
    pp2.readToken_lt_gt = function(code2) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next2 === code2) {
        size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$12.assign, size + 1);
        }
        return this.finishOp(types$12.bitShift, size);
      }
      if (next2 === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next2 === 61) {
        size = 2;
      }
      return this.finishOp(types$12.relational, size);
    };
    pp2.readToken_eq_excl = function(code2) {
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 61) {
        return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code2 === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$12.arrow);
      }
      return this.finishOp(code2 === 61 ? types$12.eq : types$12.prefix, 1);
    };
    pp2.readToken_question = function() {
      var ecmaVersion22 = this.options.ecmaVersion;
      if (ecmaVersion22 >= 11) {
        var next2 = this.input.charCodeAt(this.pos + 1);
        if (next2 === 46) {
          var next22 = this.input.charCodeAt(this.pos + 2);
          if (next22 < 48 || next22 > 57) {
            return this.finishOp(types$12.questionDot, 2);
          }
        }
        if (next2 === 63) {
          if (ecmaVersion22 >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(types$12.coalesce, 2);
        }
      }
      return this.finishOp(types$12.question, 1);
    };
    pp2.readToken_numberSign = function() {
      var ecmaVersion22 = this.options.ecmaVersion;
      var code2 = 35;
      if (ecmaVersion22 >= 13) {
        ++this.pos;
        code2 = this.fullCharCodeAtPos();
        if (isIdentifierStart2(code2, true) || code2 === 92) {
          return this.finishToken(types$12.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString2(code2) + "'");
    };
    pp2.getTokenFromCode = function(code2) {
      switch (code2) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$12.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$12.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$12.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$12.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$12.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$12.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$12.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$12.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$12.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$12.backQuote);
        case 48:
          var next2 = this.input.charCodeAt(this.pos + 1);
          if (next2 === 120 || next2 === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next2 === 111 || next2 === 79) {
              return this.readRadixNumber(8);
            }
            if (next2 === 98 || next2 === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code2);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code2);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code2);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code2);
        case 60:
        case 62:
          return this.readToken_lt_gt(code2);
        case 61:
        case 33:
          return this.readToken_eq_excl(code2);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$12.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString2(code2) + "'");
    };
    pp2.finishOp = function(type2, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type2, str);
    };
    pp2.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch2 = this.input.charAt(this.pos);
        if (lineBreak2.test(ch2)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped) {
          if (ch2 === "[") {
            inClass = true;
          } else if (ch2 === "]" && inClass) {
            inClass = false;
          } else if (ch2 === "/" && !inClass) {
            break;
          }
          escaped = ch2 === "\\";
        } else {
          escaped = false;
        }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e2) {
      }
      return this.finishToken(types$12.regexp, { pattern, flags, value });
    };
    pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i22 = 0, e2 = len == null ? Infinity : len; i22 < e2; ++i22, ++this.pos) {
        var code2 = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code2 === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i22 === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code2;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (code2 >= 48 && code2 <= 57) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code2;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    function stringToNumber2(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8);
      }
      return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt2(str) {
      if (typeof BigInt !== "function") {
        return null;
      }
      return BigInt(str.replace(/_/g, ""));
    }
    pp2.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt2(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$12.num, val);
    };
    pp2.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next2 = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
        var val$1 = stringToBigInt2(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next2 === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next2 = this.input.charCodeAt(this.pos);
      }
      if ((next2 === 69 || next2 === 101) && !octal) {
        next2 = this.input.charCodeAt(++this.pos);
        if (next2 === 43 || next2 === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart2(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber2(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$12.num, val);
    };
    pp2.readCodePoint = function() {
      var ch2 = this.input.charCodeAt(this.pos), code2;
      if (ch2 === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code2 > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code2 = this.readHexChar(4);
      }
      return code2;
    };
    pp2.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === quote) {
          break;
        }
        if (ch2 === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch2 === 8232 || ch2 === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine2(ch2)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$12.string, out);
    };
    var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
    pp2.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp2.invalidStringToken = function(position2, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR2;
      } else {
        this.raise(position2, message);
      }
    };
    pp2.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
            if (ch2 === 36) {
              this.pos += 2;
              return this.finishToken(types$12.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$12.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$12.template, out);
        }
        if (ch2 === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine2(ch2)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch2) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += `
`;
              break;
            default:
              out += String.fromCharCode(ch2);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp2.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
          case "\r":
            if (this.input[this.pos + 1] === `
`) {
              ++this.pos;
            }
          case `
`:
          case "\u2028":
          case "\u2029":
            ++this.curLine;
            this.lineStart = this.pos + 1;
            break;
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp2.readEscapedChar = function(inTemplate) {
      var ch2 = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch2) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString2(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
          }
        default:
          if (ch2 >= 48 && ch2 <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch2 = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine2(ch2)) {
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          }
          return String.fromCharCode(ch2);
      }
    };
    pp2.readHexChar = function(len) {
      var codePos = this.pos;
      var n2 = this.readInt(16, len);
      if (n2 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n2;
    };
    pp2.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch2 = this.fullCharCodeAtPos();
        if (isIdentifierChar2(ch2, astral)) {
          this.pos += ch2 <= 65535 ? 1 : 2;
        } else if (ch2 === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString2(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp2.readWord = function() {
      var word = this.readWord1();
      var type2 = types$12.name;
      if (this.keywords.test(word)) {
        type2 = keywords2[word];
      }
      return this.finishToken(type2, word);
    };
    var version2 = "8.12.1";
    Parser3.acorn = {
      Parser: Parser3,
      version: version2,
      defaultOptions: defaultOptions2,
      Position: Position3,
      SourceLocation: SourceLocation3,
      getLineInfo: getLineInfo2,
      Node: Node3,
      TokenType: TokenType3,
      tokTypes: types$12,
      keywordTypes: keywords2,
      TokContext: TokContext3,
      tokContexts: types2,
      isIdentifierChar: isIdentifierChar2,
      isIdentifierStart: isIdentifierStart2,
      Token: Token3,
      isNewLine: isNewLine2,
      lineBreak: lineBreak2,
      lineBreakG: lineBreakG2,
      nonASCIIwhitespace: nonASCIIwhitespace2
    };
    function parse32(input, options) {
      return Parser3.parse(input, options);
    }
    function parseExpressionAt2(input, pos, options) {
      return Parser3.parseExpressionAt(input, pos, options);
    }
    function tokenizer2(input, options) {
      return Parser3.tokenizer(input, options);
    }
    exports2.Node = Node3;
    exports2.Parser = Parser3;
    exports2.Position = Position3;
    exports2.SourceLocation = SourceLocation3;
    exports2.TokContext = TokContext3;
    exports2.Token = Token3;
    exports2.TokenType = TokenType3;
    exports2.defaultOptions = defaultOptions2;
    exports2.getLineInfo = getLineInfo2;
    exports2.isIdentifierChar = isIdentifierChar2;
    exports2.isIdentifierStart = isIdentifierStart2;
    exports2.isNewLine = isNewLine2;
    exports2.keywordTypes = keywords2;
    exports2.lineBreak = lineBreak2;
    exports2.lineBreakG = lineBreakG2;
    exports2.nonASCIIwhitespace = nonASCIIwhitespace2;
    exports2.parse = parse32;
    exports2.parseExpressionAt = parseExpressionAt2;
    exports2.tokContexts = types2;
    exports2.tokTypes = types$12;
    exports2.tokenizer = tokenizer2;
    exports2.version = version2;
  });
});
var require_acorn_jsx = __commonJS((exports, module) => {
  var XHTMLEntities = require_xhtml();
  var hexNumber = /^[\da-fA-F]+$/;
  var decimalNumber = /^\d+$/;
  var acornJsxMap = /* @__PURE__ */ new WeakMap();
  function getJsxTokens(acorn) {
    acorn = acorn.Parser.acorn || acorn;
    let acornJsx = acornJsxMap.get(acorn);
    if (!acornJsx) {
      const tt = acorn.tokTypes;
      const TokContext3 = acorn.TokContext;
      const TokenType3 = acorn.TokenType;
      const tc_oTag = new TokContext3("<tag", false);
      const tc_cTag = new TokContext3("</tag", false);
      const tc_expr = new TokContext3("<tag>...</tag>", true, true);
      const tokContexts = {
        tc_oTag,
        tc_cTag,
        tc_expr
      };
      const tokTypes = {
        jsxName: new TokenType3("jsxName"),
        jsxText: new TokenType3("jsxText", { beforeExpr: true }),
        jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
        jsxTagEnd: new TokenType3("jsxTagEnd")
      };
      tokTypes.jsxTagStart.updateContext = function() {
        this.context.push(tc_expr);
        this.context.push(tc_oTag);
        this.exprAllowed = false;
      };
      tokTypes.jsxTagEnd.updateContext = function(prevType) {
        let out = this.context.pop();
        if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
          this.context.pop();
          this.exprAllowed = this.curContext() === tc_expr;
        } else {
          this.exprAllowed = true;
        }
      };
      acornJsx = { tokContexts, tokTypes };
      acornJsxMap.set(acorn, acornJsx);
    }
    return acornJsx;
  }
  function getQualifiedJSXName(object) {
    if (!object)
      return object;
    if (object.type === "JSXIdentifier")
      return object.name;
    if (object.type === "JSXNamespacedName")
      return object.namespace.name + ":" + object.name.name;
    if (object.type === "JSXMemberExpression")
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
  module.exports = function(options) {
    options = options || {};
    return function(Parser3) {
      return plugin({
        allowNamespaces: options.allowNamespaces !== false,
        allowNamespacedObjects: !!options.allowNamespacedObjects,
        autoCloseVoidElements: !!options.autoCloseVoidElements
      }, Parser3);
    };
  };
  Object.defineProperty(module.exports, "tokTypes", {
    get: function get_tokTypes() {
      return getJsxTokens(require_acorn()).tokTypes;
    },
    configurable: true,
    enumerable: true
  });
  function plugin(options, Parser3) {
    const acorn = Parser3.acorn || require_acorn();
    const acornJsx = getJsxTokens(acorn);
    const tt = acorn.tokTypes;
    const tok = acornJsx.tokTypes;
    const tokContexts = acorn.tokContexts;
    const tc_oTag = acornJsx.tokContexts.tc_oTag;
    const tc_cTag = acornJsx.tokContexts.tc_cTag;
    const tc_expr = acornJsx.tokContexts.tc_expr;
    const isNewLine2 = acorn.isNewLine;
    const isIdentifierStart2 = acorn.isIdentifierStart;
    const isIdentifierChar2 = acorn.isIdentifierChar;
    return class extends Parser3 {
      static get acornJsx() {
        return acornJsx;
      }
      jsx_readToken() {
        let out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length)
            this.raise(this.start, "Unterminated JSX contents");
          let ch2 = this.input.charCodeAt(this.pos);
          switch (ch2) {
            case 60:
            case 123:
              if (this.pos === this.start) {
                if (ch2 === 60 && this.exprAllowed) {
                  ++this.pos;
                  return this.finishToken(tok.jsxTagStart);
                }
                return this.getTokenFromCode(ch2);
              }
              out += this.input.slice(chunkStart, this.pos);
              return this.finishToken(tok.jsxText, out);
            case 38:
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
              break;
            case 62:
            case 125:
              this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch2 === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
            default:
              if (isNewLine2(ch2)) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readNewLine(true);
                chunkStart = this.pos;
              } else {
                ++this.pos;
              }
          }
        }
      }
      jsx_readNewLine(normalizeCRLF) {
        let ch2 = this.input.charCodeAt(this.pos);
        let out;
        ++this.pos;
        if (ch2 === 13 && this.input.charCodeAt(this.pos) === 10) {
          ++this.pos;
          out = normalizeCRLF ? `
` : `\r
`;
        } else {
          out = String.fromCharCode(ch2);
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        return out;
      }
      jsx_readString(quote) {
        let out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length)
            this.raise(this.start, "Unterminated string constant");
          let ch2 = this.input.charCodeAt(this.pos);
          if (ch2 === quote)
            break;
          if (ch2 === 38) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
          } else if (isNewLine2(ch2)) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readNewLine(false);
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(tt.string, out);
      }
      jsx_readEntity() {
        let str = "", count = 0, entity;
        let ch2 = this.input[this.pos];
        if (ch2 !== "&")
          this.raise(this.pos, "Entity must start with an ampersand");
        let startPos = ++this.pos;
        while (this.pos < this.input.length && count++ < 10) {
          ch2 = this.input[this.pos++];
          if (ch2 === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);
                if (hexNumber.test(str))
                  entity = String.fromCharCode(parseInt(str, 16));
              } else {
                str = str.substr(1);
                if (decimalNumber.test(str))
                  entity = String.fromCharCode(parseInt(str, 10));
              }
            } else {
              entity = XHTMLEntities[str];
            }
            break;
          }
          str += ch2;
        }
        if (!entity) {
          this.pos = startPos;
          return "&";
        }
        return entity;
      }
      jsx_readWord() {
        let ch2, start = this.pos;
        do {
          ch2 = this.input.charCodeAt(++this.pos);
        } while (isIdentifierChar2(ch2) || ch2 === 45);
        return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
      }
      jsx_parseIdentifier() {
        let node2 = this.startNode();
        if (this.type === tok.jsxName)
          node2.name = this.value;
        else if (this.type.keyword)
          node2.name = this.type.keyword;
        else
          this.unexpected();
        this.next();
        return this.finishNode(node2, "JSXIdentifier");
      }
      jsx_parseNamespacedName() {
        let startPos = this.start, startLoc = this.startLoc;
        let name = this.jsx_parseIdentifier();
        if (!options.allowNamespaces || !this.eat(tt.colon))
          return name;
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.namespace = name;
        node2.name = this.jsx_parseIdentifier();
        return this.finishNode(node2, "JSXNamespacedName");
      }
      jsx_parseElementName() {
        if (this.type === tok.jsxTagEnd)
          return "";
        let startPos = this.start, startLoc = this.startLoc;
        let node2 = this.jsx_parseNamespacedName();
        if (this.type === tt.dot && node2.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
          this.unexpected();
        }
        while (this.eat(tt.dot)) {
          let newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node2;
          newNode.property = this.jsx_parseIdentifier();
          node2 = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node2;
      }
      jsx_parseAttributeValue() {
        switch (this.type) {
          case tt.braceL:
            let node2 = this.jsx_parseExpressionContainer();
            if (node2.expression.type === "JSXEmptyExpression")
              this.raise(node2.start, "JSX attributes must only be assigned a non-empty expression");
            return node2;
          case tok.jsxTagStart:
          case tt.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      jsx_parseEmptyExpression() {
        let node2 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(node2, "JSXEmptyExpression", this.start, this.startLoc);
      }
      jsx_parseExpressionContainer() {
        let node2 = this.startNode();
        this.next();
        node2.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
        this.expect(tt.braceR);
        return this.finishNode(node2, "JSXExpressionContainer");
      }
      jsx_parseAttribute() {
        let node2 = this.startNode();
        if (this.eat(tt.braceL)) {
          this.expect(tt.ellipsis);
          node2.argument = this.parseMaybeAssign();
          this.expect(tt.braceR);
          return this.finishNode(node2, "JSXSpreadAttribute");
        }
        node2.name = this.jsx_parseNamespacedName();
        node2.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
        return this.finishNode(node2, "JSXAttribute");
      }
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node2 = this.startNodeAt(startPos, startLoc);
        node2.attributes = [];
        let nodeName = this.jsx_parseElementName();
        if (nodeName)
          node2.name = nodeName;
        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
          node2.attributes.push(this.jsx_parseAttribute());
        node2.selfClosing = this.eat(tt.slash);
        this.expect(tok.jsxTagEnd);
        const VOID_ELEMENTS2 = [
          "area",
          "base",
          "br",
          "col",
          "embed",
          "hr",
          "img",
          "input",
          "keygen",
          "link",
          "menuitem",
          "meta",
          "param",
          "source",
          "track",
          "wbr"
        ];
        if (options.autoCloseVoidElements && nodeName && VOID_ELEMENTS2.includes(nodeName.name)) {
          node2.selfClosing = true;
        }
        return this.finishNode(node2, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      jsx_parseClosingElementAt(startPos, startLoc) {
        let node2 = this.startNodeAt(startPos, startLoc);
        let nodeName = this.jsx_parseElementName();
        if (nodeName)
          node2.name = nodeName;
        this.expect(tok.jsxTagEnd);
        return this.finishNode(node2, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
      }
      jsx_parseElementAt(startPos, startLoc) {
        let node2 = this.startNodeAt(startPos, startLoc);
        let children = [];
        let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
          }
        }
        let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
        node2["opening" + fragmentOrElement] = openingElement;
        node2["closing" + fragmentOrElement] = closingElement;
        node2.children = children;
        if (this.type === tt.relational && this.value === "<") {
          this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
        }
        return this.finishNode(node2, "JSX" + fragmentOrElement);
      }
      jsx_parseText() {
        let node2 = this.parseLiteral(this.value);
        node2.type = "JSXText";
        return node2;
      }
      jsx_parseElement() {
        let startPos = this.start, startLoc = this.startLoc;
        this.next();
        return this.jsx_parseElementAt(startPos, startLoc);
      }
      parseExprAtom(refShortHandDefaultPos) {
        if (this.type === tok.jsxText)
          return this.jsx_parseText();
        else if (this.type === tok.jsxTagStart)
          return this.jsx_parseElement();
        else
          return super.parseExprAtom(refShortHandDefaultPos);
      }
      readToken(code2) {
        let context = this.curContext();
        if (context === tc_expr)
          return this.jsx_readToken();
        if (context === tc_oTag || context === tc_cTag) {
          if (isIdentifierStart2(code2))
            return this.jsx_readWord();
          if (code2 == 62) {
            ++this.pos;
            return this.finishToken(tok.jsxTagEnd);
          }
          if ((code2 === 34 || code2 === 39) && context == tc_oTag)
            return this.jsx_readString(code2);
        }
        if (code2 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
          ++this.pos;
          return this.finishToken(tok.jsxTagStart);
        }
        return super.readToken(code2);
      }
      updateContext(prevType) {
        if (this.type == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tc_oTag)
            this.context.push(tokContexts.b_expr);
          else if (curContext == tc_expr)
            this.context.push(tokContexts.b_tmpl);
          else
            super.updateContext(prevType);
          this.exprAllowed = true;
        } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
          this.context.length -= 2;
          this.context.push(tc_cTag);
          this.exprAllowed = false;
        } else {
          return super.updateContext(prevType);
        }
      }
    };
  }
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set) {
  var pos = 65536;
  for (var i2 = 0; i2 < set.length; i2 += 2) {
    pos += set[i2];
    if (pos > code2) {
      return false;
    }
    pos += set[i2 + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
  if (options === void 0)
    options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from2, end) {
  if (end === void 0)
    end = code2.length;
  for (var i2 = from2; i2 < end; i2++) {
    var next2 = code2.charCodeAt(i2);
    if (isNewLine(next2)) {
      return i2 < end - 1 && next2 === 13 && code2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$1 = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn$1 = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty$1.call(obj, propName);
};
var isArray$1 = Array.isArray || function(obj) {
  return toString$1.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line2, col) {
  this.line = line2;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p2, start, end) {
  this.start = start;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line2 = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line2, offset2 - cur);
    }
    ++line2;
    cur = nextBreak;
  }
}
var defaultOptions = {
  ecmaVersion: null,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowAwaitOutsideFunction: null,
  allowSuperOutsideMethod: null,
  allowHashBang: false,
  checkPrivateFields: true,
  locations: false,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn$1(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`);
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray$1(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token2) {
      return tokens.push(token2);
    };
  }
  if (isArray$1(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text2, start, end, startLoc, endLoc) {
    var comment2 = {
      type: block ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment2.range = [start, end];
    }
    array.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(`
`, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    cls = plugins[i2](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match2 = literal.exec(this.input.slice(start));
    if (!match2) {
      return false;
    }
    if ((match2[1] || match2[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match2[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match2[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
      var name = list2[i2];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node2.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node2.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node2, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node2, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node2 === void 0)
    node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init) {
  node2.init = init;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
  }
  node2.left = init;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node2.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion2 = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator2 = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator2 = true;
  }
  if (!keyName && !isAsync && !isGenerator2) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator2 || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator2, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator2, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator2) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator2, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id2 = used[i2];
    if (!hasOwn$1(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next2 = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next2 = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node2, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node2.exported = this.parseModuleExportName();
      this.checkExport(exports, node2.exported, this.lastTokStart);
    } else {
      node2.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node2, "ExportAllDeclaration");
};
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node2, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node2.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseExportDeclaration(node2);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
        var spec = list2[i2];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node2) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration2 = this.parseMaybeAssign();
    this.semicolon();
    return declaration2;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn$1(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
      var prop = list2[i2];
      this.checkPatternExport(exports, prop);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$12 = pat.elements; i$1 < list$12.length; i$1 += 1) {
      var elt = list$12[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
    var decl = list2[i2];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node2 = this.startNode();
  node2.local = this.parseModuleExportName();
  node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
  this.checkExport(exports, node2.exported, node2.exported.start);
  return this.finishNode(node2, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node2 = this.startNode();
  node2.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node2.local = this.parseIdent();
  } else {
    this.checkUnreserved(node2.imported);
    node2.local = node2.imported;
  }
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node2 = this.startNode();
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node2 = this.startNode();
  this.next();
  this.expectContextual("as");
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close3, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close3)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close3)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close3);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn$1(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
        var prop = list2[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$12 = expr.elements; i$1 < list$12.length; i$1 += 1) {
        var elem = list$12[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token2, isExpr, preserveSpace, override, generator) {
  this.token = token2;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types$2 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types$2.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$2.f_expr || parent === types$2.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types$2.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context = this.context[i2];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types$2.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types$2.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$2.b_stat)) {
    this.context.push(types$2.f_expr);
  } else {
    this.context.push(types$2.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types$2.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types$2.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types$2.f_expr) {
      this.context[index2] = types$2.f_expr_gen;
    } else {
      this.context[index2] = types$2.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.operator = this.value;
      node$12.prefix = false;
      node$12.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$12, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node2) {
  return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
}
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base2 = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base2;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base2 = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$12 = this.startNodeAt(startPos, startLoc);
    node$12.callee = base2;
    node$12.arguments = exprList;
    if (optionalSupported) {
      node$12.optional = optional;
    }
    base2 = this.finishNode(node$12, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types$2.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node2 = this.parseLiteral(value.value);
      node2.regex = { pattern: value.pattern, flags: value.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types$2.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node2);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "import";
    node2.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node2);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node2 = this.startNode();
  node2.value = value;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "new";
    node2.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, `
`),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator2, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator2 = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator2 && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator2 = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator2, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator2, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator2 || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator2, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator2 || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator2 || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator2, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator2;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close3, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close3)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close3)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parseIdentNode = function() {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
    }
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node$1 = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node$1(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node$1(this, pos, loc);
};
function finishNodeAt(node2, type2, pos, loc) {
  node2.type = type2;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type2) {
  return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type2, pos, loc) {
  return finishNodeAt.call(this, node2, type2, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node$1(this, node2.start, this.startLoc);
  for (var prop in node2) {
    newNode[prop] = node2[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion2) {
  var d2 = data[ecmaVersion2] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i = 0, list$2 = [9, 10, 11, 12, 13, 14]; i < list$2.length; i += 1) {
  ecmaVersion = list$2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list$2;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base2) {
  this.parent = parent;
  this.base = base2 || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i2 >= l2) {
    return -1;
  }
  var c2 = s.charCodeAt(i2);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2) {
    return c2;
  }
  var next2 = s.charCodeAt(i2 + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c2 << 10) + next2 - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i2 >= l2) {
    return l2;
  }
  var c2 = s.charCodeAt(i2), next2;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2 || (next2 = s.charCodeAt(i2 + 1)) < 56320 || next2 > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch2) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0)
    forceU = false;
  var pos = this.pos;
  for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
    var ch2 = list2[i2];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch2) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u2 = false;
  var v2 = false;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u2 = true;
    }
    if (flag === "v") {
      v2 = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u2 && v2) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _2 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(41)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(93) || state.eat(125)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
    var name = list2[i2];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(124)) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(123)) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(94) || state.eat(36)) {
    return true;
  }
  if (state.eat(92)) {
    if (state.eat(66) || state.eat(98)) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(40) && state.eat(63)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(60);
    }
    if (state.eat(61) || state.eat(33)) {
      this.regexp_disjunction(state);
      if (!state.eat(41)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(63);
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(123)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(125)) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(40)) {
    if (state.eat(63) && state.eat(58)) {
      this.regexp_disjunction(state);
      if (state.eat(41)) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(40)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(41)) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch2 = state.current();
  if (isSyntaxCharacter(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch2) {
  return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch2 = 0;
  while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch2 = state.current();
  if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(63)) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
          var altID = list2[i2];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch2) {
  return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch2) {
  return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(107)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(99)) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch2 = state.current();
  if (ch2 === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch2 === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch2 === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch2 === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch2 === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch2 = state.current();
  if (isControlLetter(ch2)) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch2) {
  return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(117)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch2) {
  return ch2 >= 0 && ch2 <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(47)) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch2 = state.current();
  if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch2 = state.current();
  if (ch2 >= 49 && ch2 <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
      state.advance();
    } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch2 = state.current();
  if (isCharacterClassEscape(ch2)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch2 === 80) || ch2 === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch2) {
  return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn$1(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch2) {
  return isControlLetter(ch2) || ch2 === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch2) {
  return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (!state.eat(93)) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch2 = state.current();
  if (ch2 !== 93) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(98)) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(45)) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(99)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars([38, 38])) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars([45, 45])) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (state.eat(93)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(92)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars([92, 113])) {
    if (state.eat(123)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(125)) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(124)) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(98)) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch2 = state.current();
  if (ch2 < 0 || ch2 === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch2)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch2)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch2;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch2) {
  return ch2 === 33 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || ch2 === 46 || ch2 >= 58 && ch2 <= 64 || ch2 === 94 || ch2 === 96 || ch2 === 126;
}
function isClassSetSyntaxCharacter(ch2) {
  return ch2 === 40 || ch2 === 41 || ch2 === 45 || ch2 === 47 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch2 = state.current();
  if (isClassSetReservedPunctuator(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch2) {
  return ch2 === 33 || ch2 === 35 || ch2 === 37 || ch2 === 38 || ch2 === 44 || ch2 === 45 || ch2 >= 58 && ch2 <= 62 || ch2 === 64 || ch2 === 96 || ch2 === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch2 = state.current();
  if (isDecimalDigit(ch2) || ch2 === 95) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(120)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch2 = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch2 = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
}
function hexToInt(ch2) {
  if (ch2 >= 65 && ch2 <= 70) {
    return 10 + (ch2 - 65);
  }
  if (ch2 >= 97 && ch2 <= 102) {
    return 10 + (ch2 - 97);
  }
  return ch2 - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch2 = state.current();
  if (isOctalDigit(ch2)) {
    state.lastIntValue = ch2 - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length2) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i2 = 0; i2 < length2; ++i2) {
    var ch2 = state.current();
    if (!isHexDigit(ch2)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token2 = this$1$1.getToken();
        return {
          done: token2.type === types$1.eof,
          value: token2
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code2 : (code2 << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch2 = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch2)) {
    ch2 = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch2 = this.input.charCodeAt(this.pos);
      switch (ch2) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  if (ecmaVersion2 >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion2 >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion2 >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch2 = this.input.charAt(this.pos);
    if (lineBreak.test(ch2)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch2 === "[") {
        inClass = true;
      } else if (ch2 === "]" && inClass) {
        inClass = false;
      } else if (ch2 === "/" && !inClass) {
        break;
      }
      escaped = ch2 === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e2 = len == null ? Infinity : len; i2 < e2; ++i2, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch2 = this.input.charCodeAt(this.pos), code2;
  if (ch2 === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === quote) {
      break;
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch2 === 8232 || ch2 === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch2)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch2 === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch2)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch2) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += `
`;
          break;
        default:
          out += String.fromCharCode(ch2);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === `
`) {
          ++this.pos;
        }
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch2 = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch2) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(codePos, "Invalid escape sequence in template string");
      }
    default:
      if (ch2 >= 48 && ch2 <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch2 = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch2)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch2);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch2 = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch2, astral)) {
      this.pos += ch2 <= 65535 ? 1 : 2;
    } else if (ch2 === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word)) {
    type2 = keywords[word];
  }
  return this.finishToken(type2, word);
};
var version = "8.12.1";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node: Node$1,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types$2,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
var AcornJSX = __toESM(require_acorn_jsx());
var attributeNames_default = {
  acceptcharset: "acceptCharset",
  accesskey: "accessKey",
  allowfullscreen: "allowFullScreen",
  autocapitalize: "autoCapitalize",
  autocomplete: "autoComplete",
  autofocus: "autoFocus",
  autoplay: "autoPlay",
  cellpadding: "cellPadding",
  cellspacing: "cellSpacing",
  charset: "charSet",
  class: "className",
  colspan: "colSpan",
  contenteditable: "contentEditable",
  crossorigin: "crossOrigin",
  datetime: "dateTime",
  enctype: "encType",
  for: "htmlFor",
  formaction: "formAction",
  formenctype: "formEncType",
  formmethod: "formMethod",
  formnovalidate: "formNoValidate",
  formtarget: "formTarget",
  frameborder: "frameBorder",
  hreflang: "hrefLang",
  httpequiv: "httpEquiv",
  inputmode: "inputMode",
  keyparams: "keyParams",
  keytype: "keyType",
  marginheight: "marginHeight",
  marginwidth: "marginWidth",
  maxlength: "maxLength",
  mediagroup: "mediaGroup",
  minlength: "minLength",
  novalidate: "noValidate",
  radiogroup: "radioGroup",
  readonly: "readOnly",
  referrerpolicy: "referrerPolicy",
  rowspan: "rowSpan",
  spellcheck: "spellCheck",
  srcdoc: "srcDoc",
  srclang: "srcLang",
  srcset: "srcSet",
  tabindex: "tabIndex",
  usemap: "useMap"
};
var VOID_ELEMENTS = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var NO_WHITESPACE = [
  "table",
  "tbody",
  "tfoot",
  "thead",
  "tr"
];
function canHaveChildren(tagName) {
  return VOID_ELEMENTS.indexOf(tagName.toLowerCase()) === -1;
}
function canHaveWhitespace(tagName) {
  return NO_WHITESPACE.indexOf(tagName.toLowerCase()) !== -1;
}
class NullishShortCircuit extends Error {
  constructor(message = "Nullish value encountered") {
    super(message);
    this.name = "NullishShortCircuit";
  }
}
var hash = (value = "", radix = 16) => {
  const string2 = String(value);
  let h2 = 0;
  string2.split("").forEach((char2) => {
    h2 = (h2 << 5) - h2 + char2.charCodeAt(0);
    h2 &= h2;
  });
  return Math.abs(h2).toString(radix);
};
var randomHash = () => hash(Math.random().toString());
var camelCase = (string2) => string2.replace(/([A-Z])([A-Z])/g, "$1 $2").replace(/([a-z])([A-Z])/g, "$1 $2").replace(/[^a-zA-Z\u00C0-\u00ff]/g, " ").toLowerCase().split(" ").filter((value) => value).map((s, i2) => i2 > 0 ? s[0].toUpperCase() + s.slice(1) : s).join("");
var parseStyle$1 = (style) => {
  switch (typeof style) {
    case "string":
      return style.split(";").filter((r2) => r2).reduce((map, rule) => {
        const name = rule.slice(0, rule.indexOf(":")).trim();
        const value = rule.slice(rule.indexOf(":") + 1).trim();
        return {
          ...map,
          [camelCase(name)]: value
        };
      }, {});
    case "object":
      return style;
    default:
      return;
  }
};
var pathToArrayPath = (path2) => {
  if (path2 == null || path2 === "")
    return [];
  return path2.split(".");
};
var resolveArrayPath = (object, path2) => {
  const [property, ...subPath] = path2;
  if (object == null || property == null) {
    return;
  }
  return subPath.length === 0 ? object[property] : resolveArrayPath(object[property], subPath);
};
var resolvePath = (object, path2) => resolveArrayPath(object, pathToArrayPath(path2));
function handleNaN(child) {
  return Number.isNaN(child) ? "NaN" : child;
}
class JsxParser extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "ParsedChildren", null);
    __privateAdd(this, _parseJSX, (jsx2) => {
      const parser = Parser.extend(AcornJSX.default({
        autoCloseVoidElements: this.props.autoCloseVoidElements
      }));
      const wrappedJsx = `<root>${jsx2}</root>`;
      let parsed = [];
      try {
        parsed = parser.parse(wrappedJsx, { ecmaVersion: "latest" });
        parsed = parsed.body[0].expression.children || [];
      } catch (error) {
        if (this.props.showWarnings)
          console.warn(error);
        if (this.props.onError)
          this.props.onError(error);
        if (this.props.renderError) {
          return this.props.renderError({ error: String(error) });
        }
        return null;
      }
      return parsed.map((p2) => __privateGet(this, _parseExpression).call(this, p2)).filter(Boolean);
    });
    __privateAdd(this, _parseExpression, (expression, scope) => {
      var _a2, _b2;
      switch (expression.type) {
        case "JSXAttribute":
          if (expression.value === null)
            return true;
          return __privateGet(this, _parseExpression).call(this, expression.value, scope);
        case "JSXElement":
        case "JSXFragment":
          return __privateGet(this, _parseElement).call(this, expression, scope);
        case "JSXExpressionContainer":
          return __privateGet(this, _parseExpression).call(this, expression.expression, scope);
        case "JSXText":
          const key = this.props.disableKeyGeneration ? void 0 : randomHash();
          return this.props.disableFragments ? expression.value : /* @__PURE__ */ React.createElement(reactExports.Fragment, {
            key
          }, expression.value);
        case "ArrayExpression":
          return expression.elements.map((ele) => __privateGet(this, _parseExpression).call(this, ele, scope));
        case "BinaryExpression":
          const binaryLeft = __privateGet(this, _parseExpression).call(this, expression.left, scope);
          const binaryRight = __privateGet(this, _parseExpression).call(this, expression.right, scope);
          let binaryResult;
          switch (expression.operator) {
            case "-":
              binaryResult = binaryLeft - binaryRight;
              break;
            case "!=":
              binaryResult = binaryLeft != binaryRight;
              break;
            case "!==":
              binaryResult = binaryLeft !== binaryRight;
              break;
            case "*":
              binaryResult = binaryLeft * binaryRight;
              break;
            case "**":
              binaryResult = binaryLeft ** binaryRight;
              break;
            case "/":
              binaryResult = binaryLeft / binaryRight;
              break;
            case "%":
              binaryResult = binaryLeft % binaryRight;
              break;
            case "+":
              binaryResult = binaryLeft + binaryRight;
              break;
            case "<":
              binaryResult = binaryLeft < binaryRight;
              break;
            case "<=":
              binaryResult = binaryLeft <= binaryRight;
              break;
            case "==":
              binaryResult = binaryLeft == binaryRight;
              break;
            case "===":
              binaryResult = binaryLeft === binaryRight;
              break;
            case ">":
              binaryResult = binaryLeft > binaryRight;
              break;
            case ">=":
              binaryResult = binaryLeft >= binaryRight;
              break;
            default:
              this.props.onError(new Error(`Unsupported binary operator: ${expression.operator}`));
              return;
          }
          return handleNaN(binaryResult);
        case "CallExpression":
          const parsedCallee = __privateGet(this, _parseExpression).call(this, expression.callee, scope);
          if (parsedCallee === void 0) {
            if (expression.optional) {
              throw new NullishShortCircuit();
            }
            this.props.onError(new Error(`The expression '${expression.callee}' could not be resolved, resulting in an undefined return value.`));
            return;
          }
          return parsedCallee(...expression.arguments.map((arg) => __privateGet(this, _parseExpression).call(this, arg, scope)));
        case "ConditionalExpression":
          return __privateGet(this, _parseExpression).call(this, expression.test, scope) ? __privateGet(this, _parseExpression).call(this, expression.consequent, scope) : __privateGet(this, _parseExpression).call(this, expression.alternate, scope);
        case "ExpressionStatement":
          return __privateGet(this, _parseExpression).call(this, expression.expression, scope);
        case "Identifier":
          if (expression.name === "Infinity")
            return Infinity;
          if (expression.name === "-Infinity")
            return -Infinity;
          if (expression.name === "NaN")
            return NaN;
          if (scope && expression.name in scope) {
            return handleNaN(scope[expression.name]);
          }
          return handleNaN((this.props.bindings || {})[expression.name]);
        case "Literal":
          return expression.value;
        case "LogicalExpression":
          const left = __privateGet(this, _parseExpression).call(this, expression.left, scope);
          if (expression.operator === "||" && left)
            return left;
          if (expression.operator === "&&" && left || expression.operator === "||" && !left) {
            return __privateGet(this, _parseExpression).call(this, expression.right, scope);
          }
          return false;
        case "MemberExpression":
          return __privateGet(this, _parseMemberExpression).call(this, expression, scope);
        case "ChainExpression":
          return __privateGet(this, _parseChainExpression).call(this, expression, scope);
        case "ObjectExpression":
          const object = {};
          expression.properties.forEach((prop) => {
            object[prop.key.name || prop.key.value] = __privateGet(this, _parseExpression).call(this, prop.value, scope);
          });
          return object;
        case "TemplateElement":
          return expression.value.cooked;
        case "TemplateLiteral":
          return [...expression.expressions, ...expression.quasis].sort((a, b2) => {
            if (a.start < b2.start)
              return -1;
            return 1;
          }).map((item) => __privateGet(this, _parseExpression).call(this, item, scope)).join("");
        case "UnaryExpression":
          const unaryValue = __privateGet(this, _parseExpression).call(this, expression.argument, scope);
          switch (expression.operator) {
            case "+":
              return +unaryValue;
            case "-":
              return -unaryValue;
            case "!":
              return !unaryValue;
          }
          return;
        case "ArrowFunctionExpression":
          if (expression.async || expression.generator) {
            (_b2 = (_a2 = this.props).onError) == null ? void 0 : _b2.call(_a2, new Error("Async and generator arrow functions are not supported."));
          }
          return (...args) => {
            const functionScope = { ...scope };
            expression.params.forEach((param, idx) => {
              functionScope[param.name] = args[idx];
            });
            return __privateGet(this, _parseExpression).call(this, expression.body, functionScope);
          };
        default:
          this.props.onError(new Error(`The expression type '${expression.type}' is not supported.`));
          return;
      }
    });
    __privateAdd(this, _parseChainExpression, (expression, scope) => {
      try {
        return __privateGet(this, _parseExpression).call(this, expression.expression, scope);
      } catch (error) {
        if (error instanceof NullishShortCircuit)
          return;
        throw error;
      }
    });
    __privateAdd(this, _parseMemberExpression, (expression, scope) => {
      const object = __privateGet(this, _parseExpression).call(this, expression.object, scope);
      let property;
      if (expression.computed) {
        property = __privateGet(this, _parseExpression).call(this, expression.property, scope);
      } else if (expression.property.type === "Identifier") {
        property = expression.property.name;
      } else {
        this.props.onError(new Error("Only simple MemberExpressions are supported."));
        return;
      }
      if (object === null || object === void 0) {
        if (expression.optional)
          throw new NullishShortCircuit();
      }
      let member;
      try {
        member = object[property];
      } catch {
        this.props.onError(new Error(`The property '${property}' could not be resolved on the object '${object}'.`));
        return;
      }
      if (typeof member === "function")
        return member.bind(object);
      return member;
    });
    __privateAdd(this, _parseName, (element2) => {
      if (element2.type === "JSXIdentifier") {
        return element2.name;
      }
      return `${__privateGet(this, _parseName).call(this, element2.object)}.${__privateGet(this, _parseName).call(this, element2.property)}`;
    });
    __privateAdd(this, _parseElement, (element2, scope) => {
      const { allowUnknownElements, components, componentsOnly, onError } = this.props;
      const { children: childNodes = [] } = element2;
      const openingTag = element2.type === "JSXElement" ? element2.openingElement : element2.openingFragment;
      const { attributes = [] } = openingTag;
      const name = element2.type === "JSXElement" ? __privateGet(this, _parseName).call(this, openingTag.name) : "";
      const blacklistedAttrs = (this.props.blacklistedAttrs || []).map((attr) => attr instanceof RegExp ? attr : new RegExp(attr, "i"));
      const blacklistedTags = (this.props.blacklistedTags || []).map((tag) => tag.trim().toLowerCase()).filter(Boolean);
      if (/^(html|head|body)$/i.test(name)) {
        return childNodes.map((c2) => __privateGet(this, _parseElement).call(this, c2, scope));
      }
      const tagName = name.trim().toLowerCase();
      if (blacklistedTags.indexOf(tagName) !== -1) {
        onError(new Error(`The tag <${name}> is blacklisted, and will not be rendered.`));
        return null;
      }
      if (name !== "" && !resolvePath(components, name)) {
        if (componentsOnly) {
          onError(new Error(`The component <${name}> is unrecognized, and will not be rendered.`));
          return this.props.renderUnrecognized(name);
        }
        if (!allowUnknownElements && document.createElement(name) instanceof HTMLUnknownElement) {
          onError(new Error(`The tag <${name}> is unrecognized in this browser, and will not be rendered.`));
          return this.props.renderUnrecognized(name);
        }
      }
      let children;
      let component = element2.type === "JSXElement" ? resolvePath(components, name) : reactExports.Fragment;
      if (component || canHaveChildren(name)) {
        children = childNodes.map((node2) => __privateGet(this, _parseExpression).call(this, node2, scope));
        if (name.includes(".")) {
          const nameParts = name.split(".");
          const componentPath = nameParts.reduce((acc, part) => acc ? acc[part] : components == null ? void 0 : components[part], null);
          if (componentPath) {
            component = componentPath;
          }
        }
        if (!component && !canHaveWhitespace(name)) {
          children = children.filter((child) => typeof child !== "string" || !/^\s*$/.test(child));
        }
        const childFn = children.find((child) => typeof child === "function");
        if (children.length === 0) {
          children = void 0;
        } else if (childFn) {
          children = childFn;
        } else if (children.length === 1) {
          [children] = children;
        } else if (children.length > 1 && !this.props.disableKeyGeneration) {
          children = children.map((child, key) => (child == null ? void 0 : child.type) && !(child == null ? void 0 : child.key) ? { ...child, key: child.key || key } : child);
        }
      }
      const props = {
        key: this.props.disableKeyGeneration ? void 0 : randomHash()
      };
      attributes.forEach((expr) => {
        if (expr.type === "JSXAttribute") {
          const rawName = expr.name.name;
          const attributeName = attributeNames_default[rawName] || rawName;
          const value = __privateGet(this, _parseExpression).call(this, expr, scope);
          const matches = blacklistedAttrs.filter((re2) => re2.test(attributeName));
          if (matches.length === 0) {
            props[attributeName] = value;
          }
        } else if (expr.type === "JSXSpreadAttribute" && expr.argument.type === "Identifier" || expr.argument.type === "MemberExpression") {
          const value = __privateGet(this, _parseExpression).call(this, expr.argument, scope);
          if (typeof value === "object") {
            Object.keys(value).forEach((rawName) => {
              const attributeName = attributeNames_default[rawName] || rawName;
              const matches = blacklistedAttrs.filter((re2) => re2.test(attributeName));
              if (matches.length === 0) {
                props[attributeName] = value[rawName];
              }
            });
          }
        }
      });
      if (typeof props.style === "string") {
        props.style = parseStyle$1(props.style);
      }
      const lowerName = name.toLowerCase();
      if (lowerName === "option") {
        children = children.props.children;
      }
      return React.createElement(component || lowerName, props, children);
    });
  }
  render() {
    const jsx2 = (this.props.jsx || "").trim().replace(/<!DOCTYPE([^>]*)>/g, "");
    this.ParsedChildren = __privateGet(this, _parseJSX).call(this, jsx2);
    const className = [.../* @__PURE__ */ new Set(["jsx-parser", ...String(this.props.className).split(" ")])].filter(Boolean).join(" ");
    return this.props.renderInWrapper ? /* @__PURE__ */ React.createElement("div", {
      className
    }, this.ParsedChildren) : this.ParsedChildren;
  }
}
_parseJSX = new WeakMap();
_parseExpression = new WeakMap();
_parseChainExpression = new WeakMap();
_parseMemberExpression = new WeakMap();
_parseName = new WeakMap();
_parseElement = new WeakMap();
__publicField(JsxParser, "displayName", "JsxParser");
__publicField(JsxParser, "defaultProps", {
  allowUnknownElements: true,
  autoCloseVoidElements: false,
  bindings: {},
  blacklistedAttrs: [/^on.+/i],
  blacklistedTags: ["script"],
  className: "",
  components: {},
  componentsOnly: false,
  disableFragments: false,
  disableKeyGeneration: false,
  jsx: "",
  onError: () => {
  },
  showWarnings: false,
  renderError: void 0,
  renderInWrapper: true,
  renderUnrecognized: () => null
});
var source_default = JsxParser;
const searchNav = document.querySelector(".search-nav .nav");
const tabContent = document.querySelector(".tab-content");
function AgentSearchNavTab({
  onClick,
  active
}) {
  reactExports.useEffect(() => {
    if (active) {
      var otherTabs = document.querySelectorAll(".nav-link");
      otherTabs.forEach((tab2) => {
        if (tab2.id !== "agentforce-tab") {
          tab2.classList.remove("active");
        }
      });
    }
  }, [active]);
  return /* @__PURE__ */ jsx("li", { className: "nav-item", role: "presentation", children: /* @__PURE__ */ jsx("a", { className: `af-nav-link nav-link${active ? " active" : ""}`, "data-toggle": "tab", role: "tab", "aria-selected": active ? "true" : "false", id: "agentforce-tab", href: "#", onClick, children: "Ask an Agent" }) });
}
function SFRASearchTabAgent({
  children
}) {
  const {
    agent
  } = reactExports.useContext(AgentContext);
  const [active, setActive] = reactExports.useState(false);
  const selectTab = (e2) => {
    e2.preventDefault();
    setActive((prev2) => !prev2);
  };
  reactExports.useEffect(() => {
    if (active) {
      var otherTabContent = document.querySelectorAll(".tab-pane");
      otherTabContent.forEach((tab2) => {
        if (tab2.id !== "agentforce-tab-content") {
          tab2.classList.remove("active");
        }
      });
    }
  }, [active]);
  if (!searchNav || !tabContent) {
    return null;
  }
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    reactDomExports.createPortal(/* @__PURE__ */ jsx(AgentSearchNavTab, { onClick: selectTab, active }), searchNav),
    reactDomExports.createPortal(/* @__PURE__ */ jsx("div", { className: `tab-pane ${active ? "active" : ""} py-4`, id: "agentforce-tab-content", role: "tabpanel", children: active && children }), tabContent)
  ] });
}
function AgentConfig({
  variables,
  sessionKey,
  messagePrefix,
  messageSuffix,
  children
}) {
  const agentContext = reactExports.useContext(AgentContext);
  return /* @__PURE__ */ jsx(AgentProvider, { value: {
    ...agentContext,
    sessionKey: sessionKey || agentContext.sessionKey,
    runtimeContext: {
      ...agentContext.runtimeContext,
      ...variables
    },
    messagePrefix: messagePrefix || agentContext.messagePrefix,
    messageSuffix: messageSuffix || agentContext.messageSuffix
  }, children });
}
const SITE_ID$3 = CONFIG.currentSite;
const STORAGE_KEY = "pinnedProducts-" + SITE_ID$3;
const getPinnedProducts = () => {
  try {
    const savedPinned = localStorage.getItem(STORAGE_KEY);
    return savedPinned ? JSON.parse(savedPinned) : [];
  } catch (error) {
    console.error("Error reading pinned products:", error);
    return [];
  }
};
const savePinnedProducts = (products) => {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(products));
  } catch (error) {
    console.error("Error saving pinned products:", error);
  }
};
function usePinnedProducts() {
  const queryClient2 = useQueryClient();
  const {
    data: pinnedProducts = []
  } = useQuery({
    queryKey: ["pinnedProducts"],
    queryFn: getPinnedProducts,
    // Since this is local state, we don't need refetching
    staleTime: Infinity
  });
  const addPinnedProduct = useMutation({
    mutationFn: async (productId) => {
      const currentProducts = getPinnedProducts();
      if (!currentProducts.includes(productId)) {
        const updatedProducts = [...currentProducts, productId];
        savePinnedProducts(updatedProducts);
        return updatedProducts;
      }
      return currentProducts;
    },
    onSuccess: (updatedProducts) => {
      queryClient2.setQueryData(["pinnedProducts"], updatedProducts);
    }
  });
  const removePinnedProduct = useMutation({
    mutationFn: async (productId) => {
      const currentProducts = getPinnedProducts();
      const updatedProducts = currentProducts.filter((id2) => id2 !== productId);
      savePinnedProducts(updatedProducts);
      return updatedProducts;
    },
    onSuccess: (updatedProducts) => {
      queryClient2.setQueryData(["pinnedProducts"], updatedProducts);
    }
  });
  const setPinnedProducts = useMutation({
    mutationFn: async (products) => {
      savePinnedProducts(products);
      return products;
    },
    onSuccess: (updatedProducts) => {
      queryClient2.setQueryData(["pinnedProducts"], updatedProducts);
    }
  });
  return {
    pinnedProducts,
    addPinnedProduct: (productId) => addPinnedProduct.mutate(productId),
    removePinnedProduct: (productId) => removePinnedProduct.mutate(productId),
    setPinnedProducts: (products) => setPinnedProducts.mutate(products),
    isPending: addPinnedProduct.isPending || removePinnedProduct.isPending || setPinnedProducts.isPending,
    pinnedProductMessagePrefix: "PINNED_PRODUCT_MESSAGE"
  };
}
const protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(uri) {
  const url = (uri || "").trim();
  const first = url.charAt(0);
  if (first === "#" || first === "/") {
    return url;
  }
  const colon = url.indexOf(":");
  if (colon === -1) {
    return url;
  }
  let index2 = -1;
  while (++index2 < protocols.length) {
    const protocol = protocols[index2];
    if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
      return url;
    }
  }
  index2 = url.indexOf("?");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  index2 = url.indexOf("#");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  return "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer = function isBuffer2(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
const isBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer);
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position$1(value.position);
  }
  if ("start" in value || "end" in value) {
    return position$1(value);
  }
  if ("line" in value || "column" in value) {
    return point$2(value);
  }
  return "";
}
function point$2(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position$1(pos) {
  return point$2(pos && pos.start) + "-" + point$2(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
let VFileMessage$1 = class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   >  **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage$1.prototype.file = "";
VFileMessage$1.prototype.name = "";
VFileMessage$1.prototype.reason = "";
VFileMessage$1.prototype.message = "";
VFileMessage$1.prototype.stack = "";
VFileMessage$1.prototype.fatal = null;
VFileMessage$1.prototype.column = null;
VFileMessage$1.prototype.line = null;
VFileMessage$1.prototype.source = null;
VFileMessage$1.prototype.ruleId = null;
VFileMessage$1.prototype.position = null;
const path$1 = { basename: basename$1, dirname: dirname$1, extname: extname$1, join: join$1, sep: "/" };
function basename$1(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$3(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname$1(path2) {
  assertPath$3(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname$1(path2) {
  assertPath$3(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join$1(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$3(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$2(joined);
}
function normalize$2(path2) {
  assertPath$3(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString$1(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString$1(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$3(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc$1 = { cwd: cwd$1 };
function cwd$1() {
  return "/";
}
function isUrl$1(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}
function urlToPath$1(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl$1(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix$1(path2);
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
let VFile$1 = class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer$1(value)) {
      options = { value };
    } else if (isUrl$1(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc$1.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order$1.length) {
      const prop2 = order$1[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order$1.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path2) {
    if (isUrl$1(path2)) {
      path2 = urlToPath$1(path2);
    }
    assertNonEmpty$1(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path$1.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   */
  set dirname(dirname2) {
    assertPath$2(this.basename, "dirname");
    this.path = path$1.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path$1.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty$1(basename2, "basename");
    assertPart$1(basename2, "basename");
    this.path = path$1.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path$1.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   */
  set extname(extname2) {
    assertPart$1(extname2, "extname");
    assertPath$2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path$1.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path$1.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty$1(stem, "stem");
    assertPart$1(stem, "stem");
    this.path = path$1.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage$1(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * >  **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
};
function assertPart$1(part, name) {
  if (part && part.includes(path$1.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path$1.sep + "`"
    );
  }
}
function assertNonEmpty$1(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath$2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer$1(value) {
  return isBuffer$1(value);
}
function bail(error) {
  if (error) {
    throw error;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name) {
  if (name === "__proto__") {
    if (!hasOwn.call(obj, name)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name).value;
    }
  }
  return obj[name];
};
var extend2 = function extend3() {
  var options, name, src, copy2, copyIsArray, clone;
  var target = arguments[0];
  var i2 = 1;
  var length2 = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i2 = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i2 < length2; ++i2) {
    options = arguments[i2];
    if (options != null) {
      for (name in options) {
        src = getProperty(target, name);
        copy2 = getProperty(options, name);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject$1(copy2) || (copyIsArray = isArray(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name, newValue: extend3(deep, clone, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend2);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values);
    function next2(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap$1(fn, next2)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap$1(middleware2, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware2.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware2.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
class VFileMessage2 extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   >  **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
}
VFileMessage2.prototype.file = "";
VFileMessage2.prototype.name = "";
VFileMessage2.prototype.reason = "";
VFileMessage2.prototype.message = "";
VFileMessage2.prototype.stack = "";
VFileMessage2.prototype.fatal = null;
VFileMessage2.prototype.column = null;
VFileMessage2.prototype.line = null;
VFileMessage2.prototype.source = null;
VFileMessage2.prototype.ruleId = null;
VFileMessage2.prototype.position = null;
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$1(joined);
}
function normalize$1(path2) {
  assertPath$1(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile2 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage2(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * >  **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
}
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return isBuffer$1(value);
}
const unified = base().freeze();
const own$6 = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data2;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse4;
  processor.stringify = stringify2;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data(extend$1(true, {}, namespace));
    return destination;
  }
  function data2(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own$6.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject2(entry[1]) && isPlainObject2(value2)) {
          value2 = extend$1(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse4(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser3 = processor.Parser;
    assertParser("parse", Parser3);
    if (newable(Parser3, "parse")) {
      return new Parser3(String(file), file).parse();
    }
    return Parser3(String(file), file);
  }
  function stringify2(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node2;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) ;
          else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own$6.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile2(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || isBuffer$1(value);
}
const emptyOptions = {};
function toString2(value, options) {
  const settings = emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$1(value, includeImageAlt, includeHtml);
}
function one$1(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all$1(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all$1(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all$1(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one$1(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove) list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all3 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all3, extensions[index2]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
const unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(unicodePunctuationRegex);
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}
function factorySpace(effects, ok2, type2, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type2);
      return prefix2(code2);
    }
    return ok2(code2);
  }
  function prefix2(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix2;
    }
    effects.exit(type2);
    return ok2(code2);
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token2 = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token2;
    }
    previous2 = token2;
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data2;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token2, eof) {
    const stream = self2.sliceStream(token2);
    if (eof) stream.push(null);
    token2.previous = childToken;
    if (childToken) childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen2;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen2) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen2 = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset2;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text2, context]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text2, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset2 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset2 = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset2 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close3 = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token2._open = Boolean(marker === 42 ? open : open && (before || !close3));
    token2._close = Boolean(marker === 42 ? close3 : close3 && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset2) {
  point2.column += offset2;
  point2.offset += offset2;
  point2._bufferIndex += offset2;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next2 = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next2;
    }
    return nok(code2);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        contBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char2 = element.textContent;
  if (char2.charCodeAt(char2.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char2 === characterReference2 ? false : char2;
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test2;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test2 = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test2 = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test2 = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token2 = effects.exit("characterReferenceValue");
      if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test2(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      "linePrefix",
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token2;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code2);
  }
  function between(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === 96) {
      token2 = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between(code2);
    }
    effects.consume(code2);
    return data2;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token2.type = "codeTextData";
    return data2(code2);
  }
}
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token2 = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer2 = token2._tokenizer || context.parser[token2.contentType](token2.start);
  const childEvents = tokenizer2.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current2 = token2;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current2) {
    while (events[++startPosition][1] !== current2) {
    }
    startPositions.push(startPosition);
    if (!current2._tokenizer) {
      stream = context.sliceStream(current2);
      if (!current2.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer2.defineSkip(current2.start);
      }
      if (current2._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer2.write(stream);
      if (current2._isInFirstContentOfListItem) {
        tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current2;
    current2 = current2.next;
  }
  current2 = token2;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start = index2 + 1;
      breaks.push(start);
      current2._tokenizer = void 0;
      current2.previous = void 0;
      current2 = current2.next;
    }
  }
  tokenizer2.events = [];
  if (current2) {
    current2._tokenizer = void 0;
    current2.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice2.length - 1]);
    splice(events, start2, 2, slice2);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen2;
  return start;
  function start(code2) {
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen2 || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen2) seen2 = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen2;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen2 = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen2 ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier2;
  return start;
  function start(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier2 = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier2);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context],
      ["enter", text2, context],
      ["exit", text2, context],
      ["exit", content2, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data2(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data2(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data2;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name = buffer2.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration2;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment2;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment2(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration2(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration2;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token2 = events[index2][1];
    if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
      events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
      token2.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset2 = 0;
  let token2;
  let open;
  let close3;
  let media;
  while (index2--) {
    token2 = events[index2][1];
    if (open) {
      if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token2.type === "labelLink") {
        token2._inactive = true;
      }
    } else if (close3) {
      if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
        open = index2;
        if (token2.type !== "labelLink") {
          offset2 = 2;
          break;
        }
      }
    } else if (token2.type === "labelEnd") {
      close3 = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close3][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset2 + 2][1].end),
    end: Object.assign({}, events[close3 - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset2 + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset2 + 4, close3 - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text2, context],
    events[close3 - 2],
    events[close3 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close3 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok2,
      "listItemIndent",
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list$1, ok2, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory("string");
const text$2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data2;
    }
    function data2(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data2;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token2 = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data2.end.line,
            column: data2.end.column - size,
            offset: data2.end.offset - size,
            _index: data2.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token2.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token2);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token2, context],
            ["exit", token2, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser, initialize, from2) {
  let point2 = Object.assign(
    from2 ? Object.assign({}, from2) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now: now2,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now2() {
    const { line: line2, column: column2, offset: offset2, _index, _bufferIndex } = point2;
    return {
      line: line2,
      column: column2,
      offset: offset2,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter(type2, fields) {
    const token2 = fields || {};
    token2.type = type2;
    token2.start = now2();
    context.events.push(["enter", token2, context]);
    stack.push(token2);
    return token2;
  }
  function exit2(type2) {
    const token2 = stack.pop();
    token2.end = now2();
    context.events.push(["exit", token2, context]);
    return token2;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all3 = code2 !== null && map.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from3) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from3,
        context.events.length - from3,
        construct.resolve(context.events.slice(from3), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now2();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function parse$1(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content$1),
    document: create2(document$2),
    flow: create2(flow$1),
    string: create2(string$1),
    text: create2(text$2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser, initial, from2);
    }
  }
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column2 = 1;
  let buffer2 = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match2;
    let next2;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column2 += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column2++;
            break;
          }
          case 9: {
            next2 = Math.ceil(column2 / 4) * 4;
            chunks.push(-2);
            while (column2++ < next2) chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column2 = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column2 = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer2) chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
function decodeNumericCharacterReference(value, base2) {
  const code2 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
    code2 > 1114111
  ) {
    return "";
  }
  return String.fromCharCode(code2);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex2 = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex2 ? 2 : 1), hex2 ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
const own$5 = {}.hasOwnProperty;
const fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(
      postprocess(
        parse$1(options).document().write(preprocess()(value, encoding, true))
      )
    );
  }
);
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile2;
  function compile2(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$5.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point$1(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point$1(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length2) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length2) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") ;
      else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length2++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length2++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length2;
  }
  function setData(key, value) {
    data2[key] = value;
  }
  function getData(key) {
    return data2[key];
  }
  function opener(create2, and) {
    return open;
    function open(token2) {
      enter.call(this, create2(token2), token2);
      if (and) and.call(this, token2);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token2, errorHandler2) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token2, errorHandler2]);
    node2.position = {
      start: point$1(token2.start)
    };
    return node2;
  }
  function closer(and) {
    return close3;
    function close3(token2) {
      if (and) and.call(this, token2);
      exit2.call(this, token2);
    }
  }
  function exit2(token2, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token2.type + "` (" + stringifyPosition({
          start: token2.start,
          end: token2.end
        }) + "): its not open"
      );
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token2, open[0]);
      }
    }
    node2.position.end = point$1(token2.end);
    return node2;
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token2) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data3;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside")) return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitatxheadingsequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token2).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token2) {
    const node2 = this.stack[this.stack.length - 1];
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point$1(token2.start)
      };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point$1(token2.end);
  }
  function onexitlineending(token2) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point$1(token2.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token2) {
    const string2 = this.sliceSerialize(token2);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token2) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token2) {
    setData("characterReferenceType", token2.type);
  }
  function onexitcharacterreferencevalue(token2) {
    const data3 = this.sliceSerialize(token2);
    const type2 = getData("characterReferenceType");
    let value;
    if (type2) {
      value = decodeNumericCharacterReference(
        data3,
        type2 === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data3);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point$1(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem2(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point$1(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$5.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}
function remarkParse(options) {
  const parser = (doc) => {
    const settings = (
      /** @type {Options} */
      this.data("settings")
    );
    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  };
  Object.assign(this, { Parser: parser });
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
  const properties = {};
  if (lang) {
    properties.className = ["language-" + lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next2 = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code2, next2);
        skip = 1;
      } else {
        replace2 = "";
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function footnoteReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  if (index2 === -1) {
    state.footnoteOrder.push(id2);
    state.footnoteCounts[id2] = 1;
    counter = state.footnoteOrder.length;
  } else {
    state.footnoteCounts[id2]++;
    counter = index2 + 1;
  }
  const reuseCounter = state.footnoteCounts[id2];
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + state.clobberPrefix + "fn-" + safeId,
      id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function footnote(state, node2) {
  const footnoteById = state.footnoteById;
  let no = 1;
  while (no in footnoteById) no++;
  const identifier2 = String(no);
  footnoteById[identifier2] = {
    type: "footnoteDefinition",
    identifier: identifier2,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference(state, {
    type: "footnoteReference",
    identifier: identifier2,
    position: node2.position
  });
}
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html$2(state, node2) {
  if (state.dangerous) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return null;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return { type: "text", value: "![" + node2.alt + suffix };
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread2 = node2.spread;
  return spread2 === void 0 || spread2 === null ? node2.children.length > 1 : spread2;
}
function list(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const pointStart = point("start");
const pointEnd = point("end");
function position(node2) {
  return { start: pointStart(node2), end: pointEnd(node2) };
}
function point(type2) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type2] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point3.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point3.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point3.offset > -1 ? point3.offset : null
    };
  }
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start.line && end.line) body.position = { start, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length2 = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length2) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(node2, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match2 = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match2) {
    lines.push(
      trimLine(source.slice(last, match2.index), last > 0, true),
      match2[0]
    );
    last = match2.index + match2[0].length;
    match2 = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  footnote,
  heading,
  html: html$2,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
const convert$1 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test2) {
    if (test2 === void 0 || test2 === null) {
      return ok;
    }
    if (typeof test2 === "string") {
      return typeFactory$1(test2);
    }
    if (typeof test2 === "object") {
      return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
    }
    if (typeof test2 === "function") {
      return castFactory$1(test2);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$1(tests[index2]);
  }
  return castFactory$1(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory$1(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory$1(check) {
  return castFactory$1(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$1(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok() {
  return true;
}
function color$2(d2) {
  return d2;
}
const CONTINUE$1 = true;
const EXIT$1 = false;
const SKIP$1 = "skip";
const visitParents$1 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test2, visitor, reverse) {
    if (typeof test2 === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test2;
      test2 = null;
    }
    const is = convert$1(test2);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color$2(node2.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset2;
        let grandparents;
        if (!test2 || is(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult$1(visitor(node2, parents));
          if (result[0] === EXIT$1) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP$1) {
          offset2 = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset2 > -1 && offset2 < node2.children.length) {
            subresult = factory(node2.children[offset2], offset2, grandparents)();
            if (subresult[0] === EXIT$1) {
              return subresult;
            }
            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult$1(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
const visit$1 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test2, visitor, reverse) {
    if (typeof test2 === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test2;
      test2 = null;
    }
    visitParents$1(tree, test2, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
function generated(node2) {
  return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
}
const own$4 = {}.hasOwnProperty;
function definitions(tree) {
  const cache = /* @__PURE__ */ Object.create(null);
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit$1(tree, "definition", (definition3) => {
    const id2 = clean(definition3.identifier);
    if (id2 && !own$4.call(cache, id2)) {
      cache[id2] = definition3;
    }
  });
  return definition2;
  function definition2(identifier2) {
    const id2 = clean(identifier2);
    return id2 && own$4.call(cache, id2) ? cache[id2] : null;
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}
const own$3 = {}.hasOwnProperty;
function createState$1(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  const footnoteById = {};
  state.dangerous = dangerous;
  state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
  state.footnoteLabel = settings.footnoteLabel || "Footnotes";
  state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
  state.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
  state.unknownHandler = settings.unknownHandler;
  state.passThrough = settings.passThrough;
  state.handlers = { ...handlers, ...settings.handlers };
  state.definition = definitions(tree);
  state.footnoteById = footnoteById;
  state.footnoteOrder = [];
  state.footnoteCounts = {};
  state.patch = patch;
  state.applyData = applyData;
  state.one = oneBound;
  state.all = allBound;
  state.wrap = wrap;
  state.augment = augment;
  visit$1(tree, "footnoteDefinition", (definition2) => {
    const id2 = String(definition2.identifier).toUpperCase();
    if (!own$3.call(footnoteById, id2)) {
      footnoteById[id2] = definition2;
    }
  });
  return state;
  function augment(left, right) {
    if (left && "data" in left && left.data) {
      const data2 = left.data;
      if (data2.hName) {
        if (right.type !== "element") {
          right = {
            type: "element",
            tagName: "",
            properties: {},
            children: []
          };
        }
        right.tagName = data2.hName;
      }
      if (right.type === "element" && data2.hProperties) {
        right.properties = { ...right.properties, ...data2.hProperties };
      }
      if ("children" in right && right.children && data2.hChildren) {
        right.children = data2.hChildren;
      }
    }
    if (left) {
      const ctx = "type" in left ? left : { position: left };
      if (!generated(ctx)) {
        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
      }
    }
    return right;
  }
  function state(node2, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function oneBound(node2, parent) {
    return one(state, node2, parent);
  }
  function allBound(parent) {
    return all2(state, parent);
  }
}
function patch(from2, to) {
  if (from2.position) to.position = position(from2);
}
function applyData(from2, to) {
  let result = to;
  if (from2 && from2.data) {
    const hName = from2.data.hName;
    const hChildren = from2.data.hChildren;
    const hProperties = from2.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        result = {
          type: "element",
          tagName: hName,
          properties: {},
          children: []
        };
      }
    }
    if (result.type === "element" && hProperties) {
      result.properties = { ...result.properties, ...hProperties };
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function one(state, node2, parent) {
  const type2 = node2 && node2.type;
  if (!type2) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  if (own$3.call(state.handlers, type2)) {
    return state.handlers[type2](state, node2, parent);
  }
  if (state.passThrough && state.passThrough.includes(type2)) {
    return "children" in node2 ? { ...node2, children: all2(state, node2) } : node2;
  }
  if (state.unknownHandler) {
    return state.unknownHandler(state, node2, parent);
  }
  return defaultUnknownHandler(state, node2);
}
function all2(state, parent) {
  const values = [];
  if ("children" in parent) {
    const nodes = parent.children;
    let index2 = -1;
    while (++index2 < nodes.length) {
      const result = one(state, nodes[index2], parent);
      if (result) {
        if (index2 && nodes[index2 - 1].type === "break") {
          if (!Array.isArray(result) && result.type === "text") {
            result.value = result.value.replace(/^\s+/, "");
          }
          if (!Array.isArray(result) && result.type === "element") {
            const head = result.children[0];
            if (head && head.type === "text") {
              head.value = head.value.replace(/^\s+/, "");
            }
          }
        }
        if (Array.isArray(result)) {
          values.push(...result);
        } else {
          values.push(result);
        }
      }
    }
  }
  return values;
}
function defaultUnknownHandler(state, node2) {
  const data2 = node2.data || {};
  const result = "value" in node2 && !(own$3.call(data2, "hProperties") || own$3.call(data2, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: all2(state, node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function footer(state) {
  const listItems = [];
  let index2 = -1;
  while (++index2 < state.footnoteOrder.length) {
    const def = state.footnoteById[state.footnoteOrder[index2]];
    if (!def) {
      continue;
    }
    const content2 = state.all(def);
    const id2 = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let referenceIndex = 0;
    const backReferences = [];
    while (++referenceIndex <= state.footnoteCounts[id2]) {
      const backReference = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: state.footnoteBackLabel
        },
        children: [{ type: "text", value: "" }]
      };
      if (referenceIndex > 1) {
        backReference.children.push({
          type: "element",
          tagName: "sup",
          children: [{ type: "text", value: String(referenceIndex) }]
        });
      }
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      backReferences.push(backReference);
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: state.clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: state.footnoteLabelTagName,
        properties: {
          // To do: use structured clone.
          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
          id: "footnote-label"
        },
        children: [{ type: "text", value: state.footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
function toHast(tree, options) {
  const state = createState$1(tree, options);
  const node2 = state.one(tree, null);
  const foot = footer(state);
  if (foot) {
    node2.children.push({ type: "text", value: "\n" }, foot);
  }
  return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
}
const remarkRehype = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(destination, options) {
    return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
  }
);
function bridge(destination, options) {
  return (node2, file, next2) => {
    destination.run(toHast(node2, options), file, (error) => {
      next2(error);
    });
  };
}
function mutate(options) {
  return (node2) => toHast(node2, options);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions2, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions2.length) {
    Object.assign(property, definitions2[index2].property);
    Object.assign(normal, definitions2[index2].normal);
  }
  return new Schema(property, normal, space2);
}
function normalize(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number$1 = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number: number$1,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}
const own$2 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$2.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize(prop)] = prop;
      normal[normalize(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}
const xlink = create({
  space: "xlink",
  transform(_2, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_2, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_2, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number$1,
    ariaColIndex: number$1,
    ariaColSpan: number$1,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number$1,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number$1,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number$1,
    ariaRowIndex: number$1,
    ariaRowSpan: number$1,
    ariaSelected: booleanish,
    ariaSetSize: number$1,
    ariaSort: null,
    ariaValueMax: number$1,
    ariaValueMin: number$1,
    ariaValueNow: number$1,
    ariaValueText: null,
    role: null
  }
});
const html$1 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number$1 | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number$1,
    hidden: boolean,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$1,
    // `<img>` and `<object>`
    leftMargin: number$1,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$1,
    // `<body>`
    marginWidth: number$1,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$1,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$1,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number$1,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number$1,
    amplitude: number$1,
    arabicForm: null,
    ascent: number$1,
    attributeName: null,
    attributeType: null,
    azimuth: number$1,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number$1,
    by: null,
    calcMode: null,
    capHeight: number$1,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number$1,
    diffuseConstant: number$1,
    direction: null,
    display: null,
    dur: null,
    divisor: number$1,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number$1,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number$1,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number$1,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number$1,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number$1,
    horizOriginX: number$1,
    horizOriginY: number$1,
    id: null,
    ideographic: number$1,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number$1,
    k: number$1,
    k1: number$1,
    k2: number$1,
    k3: number$1,
    k4: number$1,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number$1,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number$1,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number$1,
    overlineThickness: number$1,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number$1,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number$1,
    pointsAtY: number$1,
    pointsAtZ: number$1,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number$1,
    specularExponent: number$1,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number$1,
    strikethroughThickness: number$1,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number$1,
    strokeOpacity: number$1,
    strokeWidth: null,
    style: null,
    surfaceScale: number$1,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number$1,
    tableValues: null,
    target: null,
    targetX: number$1,
    targetY: number$1,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number$1,
    underlineThickness: number$1,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number$1,
    values: null,
    vAlphabetic: number$1,
    vMathematical: number$1,
    vectorEffect: null,
    vHanging: number$1,
    vIdeographic: number$1,
    version: null,
    vertAdvY: number$1,
    vertOriginX: number$1,
    vertOriginY: number$1,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number$1,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const html = merge([xml, xlink, xmlns, aria, html$1], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
const convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test2) {
    {
      return typeFactory(test2);
    }
  }
);
function typeFactory(check) {
  return castFactory(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function color$1(d2) {
  return d2;
}
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
const visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test2, visitor, reverse) {
    const is = convert(test2);
    const step = 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color$1(node2.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset2;
        let grandparents;
        if (is(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP) {
          offset2 = -1 + step;
          grandparents = parents.concat(node2);
          while (offset2 > -1 && offset2 < node2.children.length) {
            subresult = factory(node2.children[offset2], offset2, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test2, visitor, reverse) {
    visitParents(tree, test2, overload);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  }
  if (options.allowedElements || options.disallowedElements || options.allowElement) {
    return (tree) => {
      visit(tree, "element", (node2, index2, parent_) => {
        const parent = (
          /** @type {Element|Root} */
          parent_
        );
        let remove;
        if (options.allowedElements) {
          remove = !options.allowedElements.includes(node2.tagName);
        } else if (options.disallowedElements) {
          remove = options.disallowedElements.includes(node2.tagName);
        }
        if (!remove && options.allowElement && typeof index2 === "number") {
          remove = !options.allowElement(node2, index2, parent);
        }
        if (remove && typeof index2 === "number") {
          if (options.unwrapDisallowed && node2.children) {
            parent.children.splice(index2, 1, ...node2.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
        return void 0;
      });
    };
  }
}
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
  if ("object" === typeof a && null !== a) {
    var r2 = a.$$typeof;
    switch (r2) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case m:
          case n:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case h:
              case l:
              case q:
              case p:
              case g:
                return a;
              default:
                return r2;
            }
        }
      case c:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = g;
reactIs_production_min.Element = b;
reactIs_production_min.ForwardRef = l;
reactIs_production_min.Fragment = d;
reactIs_production_min.Lazy = q;
reactIs_production_min.Memo = p;
reactIs_production_min.Portal = c;
reactIs_production_min.Profiler = f;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m;
reactIs_production_min.SuspenseList = n;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a) {
  return v(a) === h;
};
reactIs_production_min.isContextProvider = function(a) {
  return v(a) === g;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a) {
  return v(a) === l;
};
reactIs_production_min.isFragment = function(a) {
  return v(a) === d;
};
reactIs_production_min.isLazy = function(a) {
  return v(a) === q;
};
reactIs_production_min.isMemo = function(a) {
  return v(a) === p;
};
reactIs_production_min.isPortal = function(a) {
  return v(a) === c;
};
reactIs_production_min.isProfiler = function(a) {
  return v(a) === f;
};
reactIs_production_min.isStrictMode = function(a) {
  return v(a) === e;
};
reactIs_production_min.isSuspense = function(a) {
  return v(a) === m;
};
reactIs_production_min.isSuspenseList = function(a) {
  return v(a) === n;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
const ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);
function whitespace(thing) {
  const value = (
    // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? (
      // @ts-expect-error looks like a text.
      thing.value || ""
    ) : thing
  );
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}
function stringify$1(values) {
  return values.join(" ").trim();
}
function stringify(values, options) {
  const settings = {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
var styleToObject = { exports: {} };
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
var TRIM_REGEX = /^\s+|\s+$/g;
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
var inlineStyleParser = function(style, options) {
  if (typeof style !== "string") {
    throw new TypeError("First argument must be a string");
  }
  if (!style) return [];
  options = options || {};
  var lineno = 1;
  var column2 = 1;
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i2 = str.lastIndexOf(NEWLINE);
    column2 = ~i2 ? str.length - i2 : column2 + str.length;
  }
  function position2() {
    var start = { line: lineno, column: column2 };
    return function(node2) {
      node2.position = new Position3(start);
      whitespace2();
      return node2;
    };
  }
  function Position3(start) {
    this.start = start;
    this.end = { line: lineno, column: column2 };
    this.source = options.source;
  }
  Position3.prototype.content = style;
  function error(msg) {
    var err = new Error(
      options.source + ":" + lineno + ":" + column2 + ": " + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column2;
    err.source = style;
    if (options.silent) ;
    else {
      throw err;
    }
  }
  function match2(re2) {
    var m2 = re2.exec(style);
    if (!m2) return;
    var str = m2[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m2;
  }
  function whitespace2() {
    match2(WHITESPACE_REGEX);
  }
  function comments(rules) {
    var c2;
    rules = rules || [];
    while (c2 = comment2()) {
      if (c2 !== false) {
        rules.push(c2);
      }
    }
    return rules;
  }
  function comment2() {
    var pos = position2();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i2 = 2;
    while (EMPTY_STRING != style.charAt(i2) && (ASTERISK != style.charAt(i2) || FORWARD_SLASH != style.charAt(i2 + 1))) {
      ++i2;
    }
    i2 += 2;
    if (EMPTY_STRING === style.charAt(i2 - 1)) {
      return error("End of comment missing");
    }
    var str = style.slice(2, i2 - 2);
    column2 += 2;
    updatePosition(str);
    style = style.slice(i2);
    column2 += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  function declaration2() {
    var pos = position2();
    var prop = match2(PROPERTY_REGEX);
    if (!prop) return;
    comment2();
    if (!match2(COLON_REGEX)) return error("property missing ':'");
    var val = match2(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });
    match2(SEMICOLON_REGEX);
    return ret;
  }
  function declarations() {
    var decls = [];
    comments(decls);
    var decl;
    while (decl = declaration2()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace2();
  return declarations();
};
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var parse3 = inlineStyleParser;
function StyleToObject(style, iterator) {
  var output = null;
  if (!style || typeof style !== "string") {
    return output;
  }
  var declaration2;
  var declarations = parse3(style);
  var hasIterator = typeof iterator === "function";
  var property;
  var value;
  for (var i2 = 0, len = declarations.length; i2 < len; i2++) {
    declaration2 = declarations[i2];
    property = declaration2.property;
    value = declaration2.value;
    if (hasIterator) {
      iterator(property, value, declaration2);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }
  return output;
}
styleToObject.exports = StyleToObject;
styleToObject.exports.default = StyleToObject;
var styleToObjectExports = styleToObject.exports;
const StyleToObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(styleToObjectExports);
const own$1 = {}.hasOwnProperty;
const tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(context, node2) {
  const children = [];
  let childIndex = -1;
  let child;
  while (++childIndex < node2.children.length) {
    child = node2.children[childIndex];
    if (child.type === "element") {
      children.push(toReact(context, child, childIndex, node2));
    } else if (child.type === "text") {
      if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
        children.push(child.value);
      }
    } else if (child.type === "raw" && !context.options.skipHtml) {
      children.push(child.value);
    }
  }
  return children;
}
function toReact(context, node2, index2, parent) {
  const options = context.options;
  const transform = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
  const parentSchema = context.schema;
  const name = node2.tagName;
  const properties = {};
  let schema = parentSchema;
  let property;
  if (parentSchema.space === "html" && name === "svg") {
    schema = svg;
    context.schema = schema;
  }
  if (node2.properties) {
    for (property in node2.properties) {
      if (own$1.call(node2.properties, property)) {
        addProperty(properties, property, node2.properties[property], context);
      }
    }
  }
  if (name === "ol" || name === "ul") {
    context.listDepth++;
  }
  const children = childrenToReact(context, node2);
  if (name === "ol" || name === "ul") {
    context.listDepth--;
  }
  context.schema = parentSchema;
  const position2 = node2.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  };
  const component = options.components && own$1.call(options.components, name) ? options.components[name] : name;
  const basic = typeof component === "string" || component === React.Fragment;
  if (!ReactIs.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    );
  }
  properties.key = index2;
  if (name === "a" && options.linkTarget) {
    properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    ) : options.linkTarget;
  }
  if (name === "a" && transform) {
    properties.href = transform(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "code" && parent.type === "element" && parent.tagName !== "pre") {
    properties.inline = true;
  }
  if (!basic && (name === "h1" || name === "h2" || name === "h3" || name === "h4" || name === "h5" || name === "h6")) {
    properties.level = Number.parseInt(name.charAt(1), 10);
  }
  if (name === "img" && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ""),
      String(properties.alt || ""),
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name === "li" && parent.type === "element") {
    const input = getInputElement(node2);
    properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node2);
    properties.ordered = parent.tagName === "ol";
  }
  if (!basic && (name === "ol" || name === "ul")) {
    properties.ordered = name === "ol";
    properties.depth = context.listDepth;
  }
  if (name === "td" || name === "th") {
    if (properties.align) {
      if (!properties.style) properties.style = {};
      properties.style.textAlign = properties.align;
      delete properties.align;
    }
    if (!basic) {
      properties.isHeader = name === "th";
    }
  }
  if (!basic && name === "tr" && parent.type === "element") {
    properties.isHeader = Boolean(parent.tagName === "thead");
  }
  if (options.sourcePos) {
    properties["data-sourcepos"] = flattenPosition(position2);
  }
  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node2.position;
  }
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node2);
    properties.siblingCount = getElementsBeforeCount(parent);
  }
  if (!basic) {
    properties.node = node2;
  }
  return children.length > 0 ? React.createElement(component, properties, children) : React.createElement(component, properties);
}
function getInputElement(node2) {
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "input") {
      return child;
    }
  }
  return null;
}
function getElementsBeforeCount(parent, node2) {
  let index2 = -1;
  let count = 0;
  while (++index2 < parent.children.length) {
    if (parent.children[index2] === node2) break;
    if (parent.children[index2].type === "element") count++;
  }
  return count;
}
function addProperty(props, prop, value, ctx) {
  const info = find(ctx.schema, prop);
  let result = value;
  if (result === null || result === void 0 || result !== result) {
    return;
  }
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify(result) : stringify$1(result);
  }
  if (info.property === "style" && typeof result === "string") {
    result = parseStyle(result);
  }
  if (info.space && info.property) {
    props[own$1.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}
function parseStyle(value) {
  const result = {};
  try {
    StyleToObject$1(value, iterator);
  } catch {
  }
  return result;
  function iterator(name, v2) {
    const k2 = name.slice(0, 4) === "-ms-" ? `ms-${name.slice(4)}` : name;
    result[k2.replace(/-([a-z])/g, styleReplacer)] = v2;
  }
}
function styleReplacer(_2, $1) {
  return $1.toUpperCase();
}
function flattenPosition(pos) {
  return [
    pos.start.line,
    ":",
    pos.start.column,
    "-",
    pos.end.line,
    ":",
    pos.end.column
  ].map(String).join("");
}
const own = {}.hasOwnProperty;
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
const deprecated = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own.call(deprecated, key) && own.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(
        `[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      );
      delete deprecated[key];
    }
  }
  const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(remarkRehype, {
    ...options.remarkRehypeOptions,
    allowDangerousHtml: true
  }).use(options.rehypePlugins || []).use(rehypeFilter, options);
  const file = new VFile$1();
  if (typeof options.children === "string") {
    file.value = options.children;
  } else if (options.children !== void 0 && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    );
  }
  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== "root") {
    throw new TypeError("Expected a `root` node");
  }
  let result = React.createElement(
    React.Fragment,
    {},
    childrenToReact({ options, schema: html, listDepth: 0 }, hastNode)
  );
  if (options.className) {
    result = React.createElement("div", { className: options.className }, result);
  }
  return result;
}
ReactMarkdown.propTypes = {
  // Core options:
  children: PropTypes.string,
  // Layout options:
  className: PropTypes.string,
  // Filter options:
  allowElement: PropTypes.func,
  allowedElements: PropTypes.arrayOf(PropTypes.string),
  disallowedElements: PropTypes.arrayOf(PropTypes.string),
  unwrapDisallowed: PropTypes.bool,
  // Plugin options:
  remarkPlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  skipHtml: PropTypes.bool,
  includeElementIndex: PropTypes.bool,
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  components: PropTypes.object
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jsonata$1 = { exports: {} };
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return (/* @__PURE__ */ function() {
      function r2(e2, n2, t2) {
        function o(i3, f2) {
          if (!n2[i3]) {
            if (!e2[i3]) {
              var c2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f2 && c2) return c2(i3, true);
              if (u2) return u2(i3, true);
              var a = new Error("Cannot find module '" + i3 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p2 = n2[i3] = { exports: {} };
            e2[i3][0].call(p2.exports, function(r3) {
              var n3 = e2[i3][1][r3];
              return o(n3 || r3);
            }, p2, p2.exports, r2, e2, n2, t2);
          }
          return n2[i3].exports;
        }
        for (var u2 = "function" == typeof commonjsRequire && commonjsRequire, i2 = 0; i2 < t2.length; i2++) o(t2[i2]);
        return o;
      }
      return r2;
    }())({ 1: [function(require2, module2, exports2) {
      const utils2 = require2("./utils");
      const dateTime = function() {
        const stringToArray = utils2.stringToArray;
        const few = [
          "Zero",
          "One",
          "Two",
          "Three",
          "Four",
          "Five",
          "Six",
          "Seven",
          "Eight",
          "Nine",
          "Ten",
          "Eleven",
          "Twelve",
          "Thirteen",
          "Fourteen",
          "Fifteen",
          "Sixteen",
          "Seventeen",
          "Eighteen",
          "Nineteen"
        ];
        const ordinals = [
          "Zeroth",
          "First",
          "Second",
          "Third",
          "Fourth",
          "Fifth",
          "Sixth",
          "Seventh",
          "Eighth",
          "Ninth",
          "Tenth",
          "Eleventh",
          "Twelfth",
          "Thirteenth",
          "Fourteenth",
          "Fifteenth",
          "Sixteenth",
          "Seventeenth",
          "Eighteenth",
          "Nineteenth"
        ];
        const decades = ["Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety", "Hundred"];
        const magnitudes = ["Thousand", "Million", "Billion", "Trillion"];
        function numberToWords(value, ordinal) {
          var lookup2 = function(num, prev2, ord) {
            var words2 = "";
            if (num <= 19) {
              words2 = (prev2 ? " and " : "") + (ord ? ordinals[num] : few[num]);
            } else if (num < 100) {
              const tens = Math.floor(num / 10);
              const remainder = num % 10;
              words2 = (prev2 ? " and " : "") + decades[tens - 2];
              if (remainder > 0) {
                words2 += "-" + lookup2(remainder, false, ord);
              } else if (ord) {
                words2 = words2.substring(0, words2.length - 1) + "ieth";
              }
            } else if (num < 1e3) {
              const hundreds = Math.floor(num / 100);
              const remainder = num % 100;
              words2 = (prev2 ? ", " : "") + few[hundreds] + " Hundred";
              if (remainder > 0) {
                words2 += lookup2(remainder, true, ord);
              } else if (ord) {
                words2 += "th";
              }
            } else {
              var mag = Math.floor(Math.log10(num) / 3);
              if (mag > magnitudes.length) {
                mag = magnitudes.length;
              }
              const factor = Math.pow(10, mag * 3);
              const mant = Math.floor(num / factor);
              const remainder = num - mant * factor;
              words2 = (prev2 ? ", " : "") + lookup2(mant, false, false) + " " + magnitudes[mag - 1];
              if (remainder > 0) {
                words2 += lookup2(remainder, true, ord);
              } else if (ord) {
                words2 += "th";
              }
            }
            return words2;
          };
          var words = lookup2(value, false, ordinal);
          return words;
        }
        const wordValues = {};
        few.forEach(function(word, index2) {
          wordValues[word.toLowerCase()] = index2;
        });
        ordinals.forEach(function(word, index2) {
          wordValues[word.toLowerCase()] = index2;
        });
        decades.forEach(function(word, index2) {
          const lword = word.toLowerCase();
          wordValues[lword] = (index2 + 2) * 10;
          wordValues[lword.substring(0, word.length - 1) + "ieth"] = wordValues[lword];
        });
        wordValues.hundredth = 100;
        magnitudes.forEach(function(word, index2) {
          const lword = word.toLowerCase();
          const val = Math.pow(10, (index2 + 1) * 3);
          wordValues[lword] = val;
          wordValues[lword + "th"] = val;
        });
        function wordsToNumber(text2) {
          const parts = text2.split(/,\s|\sand\s|[\s\\-]/);
          const values = parts.map((part) => wordValues[part]);
          let segs = [0];
          values.forEach((value) => {
            if (value < 100) {
              let top = segs.pop();
              if (top >= 1e3) {
                segs.push(top);
                top = 0;
              }
              segs.push(top + value);
            } else {
              segs.push(segs.pop() * value);
            }
          });
          const result = segs.reduce((a, b2) => a + b2, 0);
          return result;
        }
        const romanNumerals = [
          [1e3, "m"],
          [900, "cm"],
          [500, "d"],
          [400, "cd"],
          [100, "c"],
          [90, "xc"],
          [50, "l"],
          [40, "xl"],
          [10, "x"],
          [9, "ix"],
          [5, "v"],
          [4, "iv"],
          [1, "i"]
        ];
        const romanValues = { "M": 1e3, "D": 500, "C": 100, "L": 50, "X": 10, "V": 5, "I": 1 };
        function decimalToRoman(value) {
          for (var index2 = 0; index2 < romanNumerals.length; index2++) {
            const numeral = romanNumerals[index2];
            if (value >= numeral[0]) {
              return numeral[1] + decimalToRoman(value - numeral[0]);
            }
          }
          return "";
        }
        function romanToDecimal(roman) {
          var decimal = 0;
          var max = 1;
          for (var i2 = roman.length - 1; i2 >= 0; i2--) {
            const digit = roman[i2];
            const value = romanValues[digit];
            if (value < max) {
              decimal -= value;
            } else {
              max = value;
              decimal += value;
            }
          }
          return decimal;
        }
        function decimalToLetters(value, aChar) {
          var letters = [];
          var aCode = aChar.charCodeAt(0);
          while (value > 0) {
            letters.unshift(String.fromCharCode((value - 1) % 26 + aCode));
            value = Math.floor((value - 1) / 26);
          }
          return letters.join("");
        }
        function lettersToDecimal(letters, aChar) {
          var aCode = aChar.charCodeAt(0);
          var decimal = 0;
          for (var i2 = 0; i2 < letters.length; i2++) {
            decimal += (letters.charCodeAt(letters.length - i2 - 1) - aCode + 1) * Math.pow(26, i2);
          }
          return decimal;
        }
        function formatInteger(value, picture) {
          if (typeof value === "undefined") {
            return void 0;
          }
          value = Math.floor(value);
          const format = analyseIntegerPicture(picture);
          return _formatInteger(value, format);
        }
        const formats = {
          DECIMAL: "decimal",
          LETTERS: "letters",
          ROMAN: "roman",
          WORDS: "words",
          SEQUENCE: "sequence"
        };
        const tcase = {
          UPPER: "upper",
          LOWER: "lower",
          TITLE: "title"
        };
        function _formatInteger(value, format) {
          let formattedInteger;
          const negative = value < 0;
          value = Math.abs(value);
          switch (format.primary) {
            case formats.LETTERS:
              formattedInteger = decimalToLetters(value, format.case === tcase.UPPER ? "A" : "a");
              break;
            case formats.ROMAN:
              formattedInteger = decimalToRoman(value);
              if (format.case === tcase.UPPER) {
                formattedInteger = formattedInteger.toUpperCase();
              }
              break;
            case formats.WORDS:
              formattedInteger = numberToWords(value, format.ordinal);
              if (format.case === tcase.UPPER) {
                formattedInteger = formattedInteger.toUpperCase();
              } else if (format.case === tcase.LOWER) {
                formattedInteger = formattedInteger.toLowerCase();
              }
              break;
            case formats.DECIMAL:
              formattedInteger = "" + value;
              var padLength = format.mandatoryDigits - formattedInteger.length;
              if (padLength > 0) {
                var padding = new Array(padLength + 1).join("0");
                formattedInteger = padding + formattedInteger;
              }
              if (format.zeroCode !== 48) {
                formattedInteger = stringToArray(formattedInteger).map((code2) => {
                  return String.fromCodePoint(code2.codePointAt(0) + format.zeroCode - 48);
                }).join("");
              }
              if (format.regular) {
                const n2 = Math.floor((formattedInteger.length - 1) / format.groupingSeparators.position);
                for (let ii2 = n2; ii2 > 0; ii2--) {
                  const pos = formattedInteger.length - ii2 * format.groupingSeparators.position;
                  formattedInteger = formattedInteger.substr(0, pos) + format.groupingSeparators.character + formattedInteger.substr(pos);
                }
              } else {
                format.groupingSeparators.reverse().forEach((separator) => {
                  const pos = formattedInteger.length - separator.position;
                  formattedInteger = formattedInteger.substr(0, pos) + separator.character + formattedInteger.substr(pos);
                });
              }
              if (format.ordinal) {
                var suffix123 = { "1": "st", "2": "nd", "3": "rd" };
                var lastDigit = formattedInteger[formattedInteger.length - 1];
                var suffix = suffix123[lastDigit];
                if (!suffix || formattedInteger.length > 1 && formattedInteger[formattedInteger.length - 2] === "1") {
                  suffix = "th";
                }
                formattedInteger = formattedInteger + suffix;
              }
              break;
            case formats.SEQUENCE:
              throw {
                code: "D3130",
                value: format.token
              };
          }
          if (negative) {
            formattedInteger = "-" + formattedInteger;
          }
          return formattedInteger;
        }
        const decimalGroups = [48, 1632, 1776, 1984, 2406, 2534, 2662, 2790, 2918, 3046, 3174, 3302, 3430, 3558, 3664, 3792, 3872, 4160, 4240, 6112, 6160, 6470, 6608, 6784, 6800, 6992, 7088, 7232, 7248, 42528, 43216, 43264, 43472, 43504, 43600, 44016, 65296];
        function analyseIntegerPicture(picture) {
          const format = {
            type: "integer",
            primary: formats.DECIMAL,
            case: tcase.LOWER,
            ordinal: false
          };
          let primaryFormat, formatModifier;
          const semicolon = picture.lastIndexOf(";");
          if (semicolon === -1) {
            primaryFormat = picture;
          } else {
            primaryFormat = picture.substring(0, semicolon);
            formatModifier = picture.substring(semicolon + 1);
            if (formatModifier[0] === "o") {
              format.ordinal = true;
            }
          }
          switch (primaryFormat) {
            case "A":
              format.case = tcase.UPPER;
            case "a":
              format.primary = formats.LETTERS;
              break;
            case "I":
              format.case = tcase.UPPER;
            case "i":
              format.primary = formats.ROMAN;
              break;
            case "W":
              format.case = tcase.UPPER;
              format.primary = formats.WORDS;
              break;
            case "Ww":
              format.case = tcase.TITLE;
              format.primary = formats.WORDS;
              break;
            case "w":
              format.primary = formats.WORDS;
              break;
            default: {
              let zeroCode = null;
              let mandatoryDigits = 0;
              let optionalDigits = 0;
              let groupingSeparators = [];
              let separatorPosition = 0;
              const formatCodepoints = stringToArray(primaryFormat).map((c2) => c2.codePointAt(0)).reverse();
              formatCodepoints.forEach((codePoint) => {
                let digit = false;
                for (let ii2 = 0; ii2 < decimalGroups.length; ii2++) {
                  const group = decimalGroups[ii2];
                  if (codePoint >= group && codePoint <= group + 9) {
                    digit = true;
                    mandatoryDigits++;
                    separatorPosition++;
                    if (zeroCode === null) {
                      zeroCode = group;
                    } else if (group !== zeroCode) {
                      throw {
                        code: "D3131"
                      };
                    }
                    break;
                  }
                }
                if (!digit) {
                  if (codePoint === 35) {
                    separatorPosition++;
                    optionalDigits++;
                  } else {
                    groupingSeparators.push({
                      position: separatorPosition,
                      character: String.fromCodePoint(codePoint)
                    });
                  }
                }
              });
              if (mandatoryDigits > 0) {
                format.primary = formats.DECIMAL;
                format.zeroCode = zeroCode;
                format.mandatoryDigits = mandatoryDigits;
                format.optionalDigits = optionalDigits;
                const regularRepeat = function(separators) {
                  if (separators.length === 0) {
                    return 0;
                  }
                  const sepChar = separators[0].character;
                  for (let ii2 = 1; ii2 < separators.length; ii2++) {
                    if (separators[ii2].character !== sepChar) {
                      return 0;
                    }
                  }
                  const indexes = separators.map((separator) => separator.position);
                  const gcd = function(a, b2) {
                    return b2 === 0 ? a : gcd(b2, a % b2);
                  };
                  const factor = indexes.reduce(gcd);
                  for (let index2 = 1; index2 <= indexes.length; index2++) {
                    if (indexes.indexOf(index2 * factor) === -1) {
                      return 0;
                    }
                  }
                  return factor;
                };
                const regular = regularRepeat(groupingSeparators);
                if (regular > 0) {
                  format.regular = true;
                  format.groupingSeparators = {
                    position: regular,
                    character: groupingSeparators[0].character
                  };
                } else {
                  format.regular = false;
                  format.groupingSeparators = groupingSeparators;
                }
              } else {
                format.primary = formats.SEQUENCE;
                format.token = primaryFormat;
              }
            }
          }
          return format;
        }
        const defaultPresentationModifiers = {
          Y: "1",
          M: "1",
          D: "1",
          d: "1",
          F: "n",
          W: "1",
          w: "1",
          X: "1",
          x: "1",
          H: "1",
          h: "1",
          P: "n",
          m: "01",
          s: "01",
          f: "1",
          Z: "01:01",
          z: "01:01",
          C: "n",
          E: "n"
        };
        function analyseDateTimePicture(picture) {
          var spec = [];
          const format = {
            type: "datetime",
            parts: spec
          };
          const addLiteral = function(start2, end) {
            if (end > start2) {
              let literal2 = picture.substring(start2, end);
              literal2 = literal2.split("]]").join("]");
              spec.push({ type: "literal", value: literal2 });
            }
          };
          var start = 0, pos = 0;
          while (pos < picture.length) {
            if (picture.charAt(pos) === "[") {
              if (picture.charAt(pos + 1) === "[") {
                addLiteral(start, pos);
                spec.push({ type: "literal", value: "[" });
                pos += 2;
                start = pos;
                continue;
              }
              addLiteral(start, pos);
              start = pos;
              pos = picture.indexOf("]", start);
              if (pos === -1) {
                throw {
                  code: "D3135"
                };
              }
              let marker = picture.substring(start + 1, pos);
              marker = marker.split(/\s+/).join("");
              var def = {
                type: "marker",
                component: marker.charAt(0)
                // 1. The component specifier is always present and is always a single letter.
              };
              var comma = marker.lastIndexOf(",");
              var presMod;
              if (comma !== -1) {
                const widthMod = marker.substring(comma + 1);
                const dash2 = widthMod.indexOf("-");
                let min, max;
                const parseWidth = function(wm) {
                  if (typeof wm === "undefined" || wm === "*") {
                    return void 0;
                  } else {
                    return parseInt(wm);
                  }
                };
                if (dash2 === -1) {
                  min = widthMod;
                } else {
                  min = widthMod.substring(0, dash2);
                  max = widthMod.substring(dash2 + 1);
                }
                const widthDef = {
                  min: parseWidth(min),
                  max: parseWidth(max)
                };
                def.width = widthDef;
                presMod = marker.substring(1, comma);
              } else {
                presMod = marker.substring(1);
              }
              if (presMod.length === 1) {
                def.presentation1 = presMod;
              } else if (presMod.length > 1) {
                var lastChar = presMod.charAt(presMod.length - 1);
                if ("atco".indexOf(lastChar) !== -1) {
                  def.presentation2 = lastChar;
                  if (lastChar === "o") {
                    def.ordinal = true;
                  }
                  def.presentation1 = presMod.substring(0, presMod.length - 1);
                } else {
                  def.presentation1 = presMod;
                }
              } else {
                def.presentation1 = defaultPresentationModifiers[def.component];
              }
              if (typeof def.presentation1 === "undefined") {
                throw {
                  code: "D3132",
                  value: def.component
                };
              }
              if (def.presentation1[0] === "n") {
                def.names = tcase.LOWER;
              } else if (def.presentation1[0] === "N") {
                if (def.presentation1[1] === "n") {
                  def.names = tcase.TITLE;
                } else {
                  def.names = tcase.UPPER;
                }
              } else if ("YMDdFWwXxHhmsf".indexOf(def.component) !== -1) {
                var integerPattern = def.presentation1;
                if (def.presentation2) {
                  integerPattern += ";" + def.presentation2;
                }
                def.integerFormat = analyseIntegerPicture(integerPattern);
                if (def.width && def.width.min !== void 0) {
                  if (def.integerFormat.mandatoryDigits < def.width.min) {
                    def.integerFormat.mandatoryDigits = def.width.min;
                  }
                }
                if ("YMD".indexOf(def.component) !== -1) {
                  def.n = -1;
                  if (def.width && def.width.max !== void 0) {
                    def.n = def.width.max;
                    def.integerFormat.mandatoryDigits = def.n;
                  } else {
                    var w2 = def.integerFormat.mandatoryDigits + def.integerFormat.optionalDigits;
                    if (w2 >= 2) {
                      def.n = w2;
                    }
                  }
                }
              }
              if (def.component === "Z" || def.component === "z") {
                def.integerFormat = analyseIntegerPicture(def.presentation1);
              }
              spec.push(def);
              start = pos + 1;
            }
            pos++;
          }
          addLiteral(start, pos);
          return format;
        }
        const days = ["", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const millisInADay = 1e3 * 60 * 60 * 24;
        const startOfFirstWeek = function(ym) {
          const jan1 = Date.UTC(ym.year, ym.month);
          var dayOfJan1 = new Date(jan1).getUTCDay();
          if (dayOfJan1 === 0) {
            dayOfJan1 = 7;
          }
          return dayOfJan1 > 4 ? jan1 + (8 - dayOfJan1) * millisInADay : jan1 - (dayOfJan1 - 1) * millisInADay;
        };
        const yearMonth = function(year, month) {
          return {
            year,
            month,
            nextMonth: function() {
              return month === 11 ? yearMonth(year + 1, 0) : yearMonth(year, month + 1);
            },
            previousMonth: function() {
              return month === 0 ? yearMonth(year - 1, 11) : yearMonth(year, month - 1);
            },
            nextYear: function() {
              return yearMonth(year + 1, month);
            },
            previousYear: function() {
              return yearMonth(year - 1, month);
            }
          };
        };
        const deltaWeeks = function(start, end) {
          return (end - start) / (millisInADay * 7) + 1;
        };
        const getDateTimeFragment = (date, component) => {
          let componentValue;
          switch (component) {
            case "Y":
              componentValue = date.getUTCFullYear();
              break;
            case "M":
              componentValue = date.getUTCMonth() + 1;
              break;
            case "D":
              componentValue = date.getUTCDate();
              break;
            case "d": {
              const today = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
              const firstJan = Date.UTC(date.getUTCFullYear(), 0);
              componentValue = (today - firstJan) / millisInADay + 1;
              break;
            }
            case "F":
              componentValue = date.getUTCDay();
              if (componentValue === 0) {
                componentValue = 7;
              }
              break;
            case "W": {
              const thisYear = yearMonth(date.getUTCFullYear(), 0);
              const startOfWeek1 = startOfFirstWeek(thisYear);
              const today = Date.UTC(thisYear.year, date.getUTCMonth(), date.getUTCDate());
              let week = deltaWeeks(startOfWeek1, today);
              if (week > 52) {
                const startOfFollowingYear = startOfFirstWeek(thisYear.nextYear());
                if (today >= startOfFollowingYear) {
                  week = 1;
                }
              } else if (week < 1) {
                const startOfPreviousYear = startOfFirstWeek(thisYear.previousYear());
                week = deltaWeeks(startOfPreviousYear, today);
              }
              componentValue = Math.floor(week);
              break;
            }
            case "w": {
              const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
              const startOfWeek1 = startOfFirstWeek(thisMonth);
              const today = Date.UTC(thisMonth.year, thisMonth.month, date.getUTCDate());
              let week = deltaWeeks(startOfWeek1, today);
              if (week > 4) {
                const startOfFollowingMonth = startOfFirstWeek(thisMonth.nextMonth());
                if (today >= startOfFollowingMonth) {
                  week = 1;
                }
              } else if (week < 1) {
                const startOfPreviousMonth = startOfFirstWeek(thisMonth.previousMonth());
                week = deltaWeeks(startOfPreviousMonth, today);
              }
              componentValue = Math.floor(week);
              break;
            }
            case "X": {
              const thisYear = yearMonth(date.getUTCFullYear(), 0);
              const startOfISOYear = startOfFirstWeek(thisYear);
              const endOfISOYear = startOfFirstWeek(thisYear.nextYear());
              const now2 = date.getTime();
              if (now2 < startOfISOYear) {
                componentValue = thisYear.year - 1;
              } else if (now2 >= endOfISOYear) {
                componentValue = thisYear.year + 1;
              } else {
                componentValue = thisYear.year;
              }
              break;
            }
            case "x": {
              const thisMonth = yearMonth(date.getUTCFullYear(), date.getUTCMonth());
              const startOfISOMonth = startOfFirstWeek(thisMonth);
              const nextMonth = thisMonth.nextMonth();
              const endOfISOMonth = startOfFirstWeek(nextMonth);
              const now2 = date.getTime();
              if (now2 < startOfISOMonth) {
                componentValue = thisMonth.previousMonth().month + 1;
              } else if (now2 >= endOfISOMonth) {
                componentValue = nextMonth.month + 1;
              } else {
                componentValue = thisMonth.month + 1;
              }
              break;
            }
            case "H":
              componentValue = date.getUTCHours();
              break;
            case "h":
              componentValue = date.getUTCHours();
              componentValue = componentValue % 12;
              if (componentValue === 0) {
                componentValue = 12;
              }
              break;
            case "P":
              componentValue = date.getUTCHours() >= 12 ? "pm" : "am";
              break;
            case "m":
              componentValue = date.getUTCMinutes();
              break;
            case "s":
              componentValue = date.getUTCSeconds();
              break;
            case "f":
              componentValue = date.getUTCMilliseconds();
              break;
            case "Z":
            case "z":
              break;
            case "C":
              componentValue = "ISO";
              break;
            case "E":
              componentValue = "ISO";
              break;
          }
          return componentValue;
        };
        let iso8601Spec = null;
        function formatDateTime(millis, picture, timezone) {
          var offsetHours = 0;
          var offsetMinutes = 0;
          if (typeof timezone !== "undefined") {
            const offset2 = parseInt(timezone);
            offsetHours = Math.floor(offset2 / 100);
            offsetMinutes = offset2 % 100;
          }
          var formatComponent = function(date, markerSpec) {
            var componentValue = getDateTimeFragment(date, markerSpec.component);
            if ("YMDdFWwXxHhms".indexOf(markerSpec.component) !== -1) {
              if (markerSpec.component === "Y") {
                if (markerSpec.n !== -1) {
                  componentValue = componentValue % Math.pow(10, markerSpec.n);
                }
              }
              if (markerSpec.names) {
                if (markerSpec.component === "M" || markerSpec.component === "x") {
                  componentValue = months[componentValue - 1];
                } else if (markerSpec.component === "F") {
                  componentValue = days[componentValue];
                } else {
                  throw {
                    code: "D3133",
                    value: markerSpec.component
                  };
                }
                if (markerSpec.names === tcase.UPPER) {
                  componentValue = componentValue.toUpperCase();
                } else if (markerSpec.names === tcase.LOWER) {
                  componentValue = componentValue.toLowerCase();
                }
                if (markerSpec.width && componentValue.length > markerSpec.width.max) {
                  componentValue = componentValue.substring(0, markerSpec.width.max);
                }
              } else {
                componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
              }
            } else if (markerSpec.component === "f") {
              componentValue = _formatInteger(componentValue, markerSpec.integerFormat);
            } else if (markerSpec.component === "Z" || markerSpec.component === "z") {
              const offset2 = offsetHours * 100 + offsetMinutes;
              if (markerSpec.integerFormat.regular) {
                componentValue = _formatInteger(offset2, markerSpec.integerFormat);
              } else {
                const numDigits = markerSpec.integerFormat.mandatoryDigits;
                if (numDigits === 1 || numDigits === 2) {
                  componentValue = _formatInteger(offsetHours, markerSpec.integerFormat);
                  if (offsetMinutes !== 0) {
                    componentValue += ":" + formatInteger(offsetMinutes, "00");
                  }
                } else if (numDigits === 3 || numDigits === 4) {
                  componentValue = _formatInteger(offset2, markerSpec.integerFormat);
                } else {
                  throw {
                    code: "D3134",
                    value: numDigits
                  };
                }
              }
              if (offset2 >= 0) {
                componentValue = "+" + componentValue;
              }
              if (markerSpec.component === "z") {
                componentValue = "GMT" + componentValue;
              }
              if (offset2 === 0 && markerSpec.presentation2 === "t") {
                componentValue = "Z";
              }
            } else if (markerSpec.component === "P") {
              if (markerSpec.names === tcase.UPPER) {
                componentValue = componentValue.toUpperCase();
              }
            }
            return componentValue;
          };
          let formatSpec;
          if (typeof picture === "undefined") {
            if (iso8601Spec === null) {
              iso8601Spec = analyseDateTimePicture("[Y0001]-[M01]-[D01]T[H01]:[m01]:[s01].[f001][Z01:01t]");
            }
            formatSpec = iso8601Spec;
          } else {
            formatSpec = analyseDateTimePicture(picture);
          }
          const offsetMillis = (60 * offsetHours + offsetMinutes) * 60 * 1e3;
          const dateTime2 = new Date(millis + offsetMillis);
          let result = "";
          formatSpec.parts.forEach(function(part) {
            if (part.type === "literal") {
              result += part.value;
            } else {
              result += formatComponent(dateTime2, part);
            }
          });
          return result;
        }
        function generateRegex(formatSpec) {
          var matcher = {};
          if (formatSpec.type === "datetime") {
            matcher.type = "datetime";
            matcher.parts = formatSpec.parts.map(function(part) {
              var res = {};
              if (part.type === "literal") {
                res.regex = part.value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              } else if (part.component === "Z" || part.component === "z") {
                let separator;
                if (!Array.isArray(part.integerFormat.groupingSeparators)) {
                  separator = part.integerFormat.groupingSeparators;
                }
                res.regex = "";
                if (part.component === "z") {
                  res.regex = "GMT";
                }
                res.regex += "[-+][0-9]+";
                if (separator) {
                  res.regex += separator.character + "[0-9]+";
                }
                res.parse = function(value) {
                  if (part.component === "z") {
                    value = value.substring(3);
                  }
                  let offsetHours = 0, offsetMinutes = 0;
                  if (separator) {
                    offsetHours = Number.parseInt(value.substring(0, value.indexOf(separator.character)));
                    offsetMinutes = Number.parseInt(value.substring(value.indexOf(separator.character) + 1));
                  } else {
                    const numdigits = value.length - 1;
                    if (numdigits <= 2) {
                      offsetHours = Number.parseInt(value);
                    } else {
                      offsetHours = Number.parseInt(value.substring(0, 3));
                      offsetMinutes = Number.parseInt(value.substring(3));
                    }
                  }
                  return offsetHours * 60 + offsetMinutes;
                };
              } else if (part.integerFormat) {
                part.integerFormat.n = part.n;
                res = generateRegex(part.integerFormat);
              } else {
                res.regex = "[a-zA-Z]+";
                var lookup2 = {};
                if (part.component === "M" || part.component === "x") {
                  months.forEach(function(name, index2) {
                    if (part.width && part.width.max) {
                      lookup2[name.substring(0, part.width.max)] = index2 + 1;
                    } else {
                      lookup2[name] = index2 + 1;
                    }
                  });
                } else if (part.component === "F") {
                  days.forEach(function(name, index2) {
                    if (index2 > 0) {
                      if (part.width && part.width.max) {
                        lookup2[name.substring(0, part.width.max)] = index2;
                      } else {
                        lookup2[name] = index2;
                      }
                    }
                  });
                } else if (part.component === "P") {
                  lookup2 = { "am": 0, "AM": 0, "pm": 1, "PM": 1 };
                } else {
                  throw {
                    code: "D3133",
                    value: part.component
                  };
                }
                res.parse = function(value) {
                  return lookup2[value];
                };
              }
              res.component = part.component;
              return res;
            });
          } else {
            matcher.type = "integer";
            const isUpper = formatSpec.case === tcase.UPPER;
            let occurrences;
            if (formatSpec.n && formatSpec.n > 0) {
              if (formatSpec.optionalDigits === 0) {
                occurrences = `{${formatSpec.n}}`;
              } else {
                occurrences = `{${formatSpec.n - formatSpec.optionalDigits},${formatSpec.n}}`;
              }
            } else {
              occurrences = "+";
            }
            switch (formatSpec.primary) {
              case formats.LETTERS:
                matcher.regex = isUpper ? "[A-Z]+" : "[a-z]+";
                matcher.parse = function(value) {
                  return lettersToDecimal(value, isUpper ? "A" : "a");
                };
                break;
              case formats.ROMAN:
                matcher.regex = isUpper ? "[MDCLXVI]+" : "[mdclxvi]+";
                matcher.parse = function(value) {
                  return romanToDecimal(isUpper ? value : value.toUpperCase());
                };
                break;
              case formats.WORDS:
                matcher.regex = "(?:" + Object.keys(wordValues).concat("and", "[\\-, ]").join("|") + ")+";
                matcher.parse = function(value) {
                  return wordsToNumber(value.toLowerCase());
                };
                break;
              case formats.DECIMAL:
                matcher.regex = `[0-9]${occurrences}`;
                if (formatSpec.ordinal) {
                  matcher.regex += "(?:th|st|nd|rd)";
                }
                matcher.parse = function(value) {
                  let digits = value;
                  if (formatSpec.ordinal) {
                    digits = value.substring(0, value.length - 2);
                  }
                  if (formatSpec.regular) {
                    digits = digits.split(",").join("");
                  } else {
                    formatSpec.groupingSeparators.forEach((sep) => {
                      digits = digits.split(sep.character).join("");
                    });
                  }
                  if (formatSpec.zeroCode !== 48) {
                    digits = digits.split("").map((char2) => String.fromCodePoint(char2.codePointAt(0) - formatSpec.zeroCode + 48)).join("");
                  }
                  return parseInt(digits);
                };
                break;
              case formats.SEQUENCE:
                throw {
                  code: "D3130",
                  value: formatSpec.token
                };
            }
          }
          return matcher;
        }
        function parseInteger(value, picture) {
          if (typeof value === "undefined") {
            return void 0;
          }
          const formatSpec = analyseIntegerPicture(picture);
          const matchSpec = generateRegex(formatSpec);
          const result = matchSpec.parse(value);
          return result;
        }
        function parseDateTime(timestamp, picture) {
          const formatSpec = analyseDateTimePicture(picture);
          const matchSpec = generateRegex(formatSpec);
          const fullRegex = "^" + matchSpec.parts.map((part) => "(" + part.regex + ")").join("") + "$";
          const matcher = new RegExp(fullRegex, "i");
          var info = matcher.exec(timestamp);
          if (info !== null) {
            const dmA = 161;
            const dmB = 130;
            const dmC = 84;
            const dmD = 72;
            const tmA = 23;
            const tmB = 47;
            const components = {};
            for (let i2 = 1; i2 < info.length; i2++) {
              const mpart = matchSpec.parts[i2 - 1];
              if (mpart.parse) {
                components[mpart.component] = mpart.parse(info[i2]);
              }
            }
            if (Object.getOwnPropertyNames(components).length === 0) {
              return void 0;
            }
            let mask = 0;
            const shift = (bit) => {
              mask <<= 1;
              mask += bit ? 1 : 0;
            };
            const isType = (type2) => {
              return !(~type2 & mask) && !!(type2 & mask);
            };
            "YXMxWwdD".split("").forEach((part) => shift(components[part]));
            const dateA = isType(dmA);
            const dateB = !dateA && isType(dmB);
            const dateC = isType(dmC);
            const dateD = !dateC && isType(dmD);
            mask = 0;
            "PHhmsf".split("").forEach((part) => shift(components[part]));
            const timeA = isType(tmA);
            const timeB = !timeA && isType(tmB);
            const dateComps = dateB ? "YD" : dateC ? "XxwF" : dateD ? "XWF" : "YMD";
            const timeComps = timeB ? "Phmsf" : "Hmsf";
            const comps = dateComps + timeComps;
            const now2 = this.environment.timestamp;
            let startSpecified = false;
            let endSpecified = false;
            comps.split("").forEach((part) => {
              if (typeof components[part] === "undefined") {
                if (startSpecified) {
                  components[part] = "MDd".indexOf(part) !== -1 ? 1 : 0;
                  endSpecified = true;
                } else {
                  components[part] = getDateTimeFragment(now2, part);
                }
              } else {
                startSpecified = true;
                if (endSpecified) {
                  throw {
                    code: "D3136"
                  };
                }
              }
            });
            if (components.M > 0) {
              components.M -= 1;
            } else {
              components.M = 0;
            }
            if (dateB) {
              const firstJan = Date.UTC(components.Y, 0);
              const offsetMillis = (components.d - 1) * 1e3 * 60 * 60 * 24;
              const derivedDate = new Date(firstJan + offsetMillis);
              components.M = derivedDate.getUTCMonth();
              components.D = derivedDate.getUTCDate();
            }
            if (dateC) {
              throw {
                code: "D3136"
              };
            }
            if (dateD) {
              throw {
                code: "D3136"
              };
            }
            if (timeB) {
              components.H = components.h === 12 ? 0 : components.h;
              if (components.P === 1) {
                components.H += 12;
              }
            }
            var millis = Date.UTC(components.Y, components.M, components.D, components.H, components.m, components.s, components.f);
            if (components.Z || components.z) {
              millis -= (components.Z || components.z) * 60 * 1e3;
            }
            return millis;
          }
        }
        var iso8601regex = new RegExp("^\\d{4}(-[01]\\d)*(-[0-3]\\d)*(T[0-2]\\d:[0-5]\\d:[0-5]\\d)*(\\.\\d+)?([+-][0-2]\\d:?[0-5]\\d|Z)?$");
        function toMillis(timestamp, picture) {
          if (typeof timestamp === "undefined") {
            return void 0;
          }
          if (typeof picture === "undefined") {
            if (!iso8601regex.test(timestamp)) {
              throw {
                stack: new Error().stack,
                code: "D3110",
                value: timestamp
              };
            }
            return Date.parse(timestamp);
          } else {
            return parseDateTime.call(this, timestamp, picture);
          }
        }
        function fromMillis(millis, picture, timezone) {
          if (typeof millis === "undefined") {
            return void 0;
          }
          return formatDateTime.call(this, millis, picture, timezone);
        }
        return {
          formatInteger,
          parseInteger,
          fromMillis,
          toMillis
        };
      }();
      module2.exports = dateTime;
    }, { "./utils": 6 }], 2: [function(require2, module2, exports2) {
      (function(global2) {
        (function() {
          var utils2 = require2("./utils");
          const functions = (() => {
            var isNumeric = utils2.isNumeric;
            var isArrayOfStrings = utils2.isArrayOfStrings;
            var isArrayOfNumbers = utils2.isArrayOfNumbers;
            var createSequence = utils2.createSequence;
            var isSequence = utils2.isSequence;
            var isFunction2 = utils2.isFunction;
            var isLambda = utils2.isLambda;
            var isPromise2 = utils2.isPromise;
            var getFunctionArity = utils2.getFunctionArity;
            var deepEquals = utils2.isDeepEqual;
            var stringToArray = utils2.stringToArray;
            function sum(args) {
              if (typeof args === "undefined") {
                return void 0;
              }
              var total = 0;
              args.forEach(function(num) {
                total += num;
              });
              return total;
            }
            function count(args) {
              if (typeof args === "undefined") {
                return 0;
              }
              return args.length;
            }
            function max(args) {
              if (typeof args === "undefined" || args.length === 0) {
                return void 0;
              }
              return Math.max.apply(Math, args);
            }
            function min(args) {
              if (typeof args === "undefined" || args.length === 0) {
                return void 0;
              }
              return Math.min.apply(Math, args);
            }
            function average(args) {
              if (typeof args === "undefined" || args.length === 0) {
                return void 0;
              }
              var total = 0;
              args.forEach(function(num) {
                total += num;
              });
              return total / args.length;
            }
            function string2(arg, prettify = false) {
              if (typeof arg === "undefined") {
                return void 0;
              }
              var str;
              if (typeof arg === "string") {
                str = arg;
              } else if (isFunction2(arg)) {
                str = "";
              } else if (typeof arg === "number" && !isFinite(arg)) {
                throw {
                  code: "D3001",
                  value: arg,
                  stack: new Error().stack
                };
              } else {
                var space2 = prettify ? 2 : 0;
                if (Array.isArray(arg) && arg.outerWrapper) {
                  arg = arg[0];
                }
                str = JSON.stringify(arg, function(key, val) {
                  return typeof val !== "undefined" && val !== null && val.toPrecision && isNumeric(val) ? Number(val.toPrecision(15)) : val && isFunction2(val) ? "" : val;
                }, space2);
              }
              return str;
            }
            function substring(str, start, length3) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var strArray = stringToArray(str);
              var strLength = strArray.length;
              if (strLength + start < 0) {
                start = 0;
              }
              if (typeof length3 !== "undefined") {
                if (length3 <= 0) {
                  return "";
                }
                var end = start >= 0 ? start + length3 : strLength + start + length3;
                return strArray.slice(start, end).join("");
              }
              return strArray.slice(start).join("");
            }
            function substringBefore(str, chars2) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var pos = str.indexOf(chars2);
              if (pos > -1) {
                return str.substr(0, pos);
              } else {
                return str;
              }
            }
            function substringAfter(str, chars2) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var pos = str.indexOf(chars2);
              if (pos > -1) {
                return str.substr(pos + chars2.length);
              } else {
                return str;
              }
            }
            function lowercase(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              return str.toLowerCase();
            }
            function uppercase(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              return str.toUpperCase();
            }
            function length2(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              return stringToArray(str).length;
            }
            function trim2(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var result = str.replace(/[ \t\n\r]+/gm, " ");
              if (result.charAt(0) === " ") {
                result = result.substring(1);
              }
              if (result.charAt(result.length - 1) === " ") {
                result = result.substring(0, result.length - 1);
              }
              return result;
            }
            function pad(str, width, char2) {
              if (typeof str === "undefined") {
                return void 0;
              }
              if (typeof char2 === "undefined" || char2.length === 0) {
                char2 = " ";
              }
              var result;
              var padLength = Math.abs(width) - length2(str);
              if (padLength > 0) {
                var padding = new Array(padLength + 1).join(char2);
                if (char2.length > 1) {
                  padding = substring(padding, 0, padLength);
                }
                if (width > 0) {
                  result = str + padding;
                } else {
                  result = padding + str;
                }
              } else {
                result = str;
              }
              return result;
            }
            async function evaluateMatcher(matcher, str) {
              var result = matcher.apply(this, [str]);
              if (isPromise2(result)) {
                result = await result;
              }
              if (result && !(typeof result.start === "number" || result.end === "number" || Array.isArray(result.groups) || isFunction2(result.next))) {
                throw {
                  code: "T1010",
                  stack: new Error().stack
                };
              }
              return result;
            }
            async function contains(str, token2) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var result;
              if (typeof token2 === "string") {
                result = str.indexOf(token2) !== -1;
              } else {
                var matches = await evaluateMatcher(token2, str);
                result = typeof matches !== "undefined";
              }
              return result;
            }
            async function match2(str, regex, limit) {
              if (typeof str === "undefined") {
                return void 0;
              }
              if (limit < 0) {
                throw {
                  stack: new Error().stack,
                  value: limit,
                  code: "D3040",
                  index: 3
                };
              }
              var result = createSequence();
              if (typeof limit === "undefined" || limit > 0) {
                var count2 = 0;
                var matches = await evaluateMatcher(regex, str);
                if (typeof matches !== "undefined") {
                  while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                    result.push({
                      match: matches.match,
                      index: matches.start,
                      groups: matches.groups
                    });
                    matches = await evaluateMatcher(matches.next);
                    count2++;
                  }
                }
              }
              return result;
            }
            async function replace2(str, pattern, replacement, limit) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var self2 = this;
              if (pattern === "") {
                throw {
                  code: "D3010",
                  stack: new Error().stack,
                  value: pattern,
                  index: 2
                };
              }
              if (limit < 0) {
                throw {
                  code: "D3011",
                  stack: new Error().stack,
                  value: limit,
                  index: 4
                };
              }
              var replacer;
              if (typeof replacement === "string") {
                replacer = function(regexMatch) {
                  var substitute = "";
                  var position3 = 0;
                  var index3 = replacement.indexOf("$", position3);
                  while (index3 !== -1 && position3 < replacement.length) {
                    substitute += replacement.substring(position3, index3);
                    position3 = index3 + 1;
                    var dollarVal = replacement.charAt(position3);
                    if (dollarVal === "$") {
                      substitute += "$";
                      position3++;
                    } else if (dollarVal === "0") {
                      substitute += regexMatch.match;
                      position3++;
                    } else {
                      var maxDigits;
                      if (regexMatch.groups.length === 0) {
                        maxDigits = 1;
                      } else {
                        maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                      }
                      index3 = parseInt(replacement.substring(position3, position3 + maxDigits), 10);
                      if (maxDigits > 1 && index3 > regexMatch.groups.length) {
                        index3 = parseInt(replacement.substring(position3, position3 + maxDigits - 1), 10);
                      }
                      if (!isNaN(index3)) {
                        if (regexMatch.groups.length > 0) {
                          var submatch = regexMatch.groups[index3 - 1];
                          if (typeof submatch !== "undefined") {
                            substitute += submatch;
                          }
                        }
                        position3 += index3.toString().length;
                      } else {
                        substitute += "$";
                      }
                    }
                    index3 = replacement.indexOf("$", position3);
                  }
                  substitute += replacement.substring(position3);
                  return substitute;
                };
              } else {
                replacer = replacement;
              }
              var result = "";
              var position2 = 0;
              if (typeof limit === "undefined" || limit > 0) {
                var count2 = 0;
                if (typeof pattern === "string") {
                  var index2 = str.indexOf(pattern, position2);
                  while (index2 !== -1 && (typeof limit === "undefined" || count2 < limit)) {
                    result += str.substring(position2, index2);
                    result += replacement;
                    position2 = index2 + pattern.length;
                    count2++;
                    index2 = str.indexOf(pattern, position2);
                  }
                  result += str.substring(position2);
                } else {
                  var matches = await evaluateMatcher(pattern, str);
                  if (typeof matches !== "undefined") {
                    while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                      result += str.substring(position2, matches.start);
                      var replacedWith = replacer.apply(self2, [matches]);
                      if (isPromise2(replacedWith)) {
                        replacedWith = await replacedWith;
                      }
                      if (typeof replacedWith === "string") {
                        result += replacedWith;
                      } else {
                        throw {
                          code: "D3012",
                          stack: new Error().stack,
                          value: replacedWith
                        };
                      }
                      position2 = matches.start + matches.match.length;
                      count2++;
                      matches = await evaluateMatcher(matches.next);
                    }
                    result += str.substring(position2);
                  } else {
                    result = str;
                  }
                }
              } else {
                result = str;
              }
              return result;
            }
            function base64encode(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var btoa2 = typeof window !== "undefined" ? (
                /* istanbul ignore next */
                window.btoa
              ) : function(str2) {
                return new global2.Buffer.from(str2, "binary").toString("base64");
              };
              return btoa2(str);
            }
            function base64decode(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var atob = typeof window !== "undefined" ? (
                /* istanbul ignore next */
                window.atob
              ) : function(str2) {
                return new global2.Buffer.from(str2, "base64").toString("binary");
              };
              return atob(str);
            }
            function encodeUrlComponent(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var returnVal;
              try {
                returnVal = encodeURIComponent(str);
              } catch (e2) {
                throw {
                  code: "D3140",
                  stack: new Error().stack,
                  value: str,
                  functionName: "encodeUrlComponent"
                };
              }
              return returnVal;
            }
            function encodeUrl(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var returnVal;
              try {
                returnVal = encodeURI(str);
              } catch (e2) {
                throw {
                  code: "D3140",
                  stack: new Error().stack,
                  value: str,
                  functionName: "encodeUrl"
                };
              }
              return returnVal;
            }
            function decodeUrlComponent(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var returnVal;
              try {
                returnVal = decodeURIComponent(str);
              } catch (e2) {
                throw {
                  code: "D3140",
                  stack: new Error().stack,
                  value: str,
                  functionName: "decodeUrlComponent"
                };
              }
              return returnVal;
            }
            function decodeUrl(str) {
              if (typeof str === "undefined") {
                return void 0;
              }
              var returnVal;
              try {
                returnVal = decodeURI(str);
              } catch (e2) {
                throw {
                  code: "D3140",
                  stack: new Error().stack,
                  value: str,
                  functionName: "decodeUrl"
                };
              }
              return returnVal;
            }
            async function split(str, separator, limit) {
              if (typeof str === "undefined") {
                return void 0;
              }
              if (limit < 0) {
                throw {
                  code: "D3020",
                  stack: new Error().stack,
                  value: limit,
                  index: 3
                };
              }
              var result = [];
              if (typeof limit === "undefined" || limit > 0) {
                if (typeof separator === "string") {
                  result = str.split(separator, limit);
                } else {
                  var count2 = 0;
                  var matches = await evaluateMatcher(separator, str);
                  if (typeof matches !== "undefined") {
                    var start = 0;
                    while (typeof matches !== "undefined" && (typeof limit === "undefined" || count2 < limit)) {
                      result.push(str.substring(start, matches.start));
                      start = matches.end;
                      matches = await evaluateMatcher(matches.next);
                      count2++;
                    }
                    if (typeof limit === "undefined" || count2 < limit) {
                      result.push(str.substring(start));
                    }
                  } else {
                    result.push(str);
                  }
                }
              }
              return result;
            }
            function join2(strs, separator) {
              if (typeof strs === "undefined") {
                return void 0;
              }
              if (typeof separator === "undefined") {
                separator = "";
              }
              return strs.join(separator);
            }
            function formatNumber(value, picture, options) {
              if (typeof value === "undefined") {
                return void 0;
              }
              var defaults2 = {
                "decimal-separator": ".",
                "grouping-separator": ",",
                "exponent-separator": "e",
                "infinity": "Infinity",
                "minus-sign": "-",
                "NaN": "NaN",
                "percent": "%",
                "per-mille": "",
                "zero-digit": "0",
                "digit": "#",
                "pattern-separator": ";"
              };
              var properties = defaults2;
              if (typeof options !== "undefined") {
                Object.keys(options).forEach(function(key) {
                  properties[key] = options[key];
                });
              }
              var decimalDigitFamily = [];
              var zeroCharCode = properties["zero-digit"].charCodeAt(0);
              for (var ii2 = zeroCharCode; ii2 < zeroCharCode + 10; ii2++) {
                decimalDigitFamily.push(String.fromCharCode(ii2));
              }
              var activeChars = decimalDigitFamily.concat([properties["decimal-separator"], properties["exponent-separator"], properties["grouping-separator"], properties.digit, properties["pattern-separator"]]);
              var subPictures = picture.split(properties["pattern-separator"]);
              if (subPictures.length > 2) {
                throw {
                  code: "D3080",
                  stack: new Error().stack
                };
              }
              var splitParts = function(subpicture) {
                var prefix2 = function() {
                  var ch2;
                  for (var ii3 = 0; ii3 < subpicture.length; ii3++) {
                    ch2 = subpicture.charAt(ii3);
                    if (activeChars.indexOf(ch2) !== -1 && ch2 !== properties["exponent-separator"]) {
                      return subpicture.substring(0, ii3);
                    }
                  }
                }();
                var suffix = function() {
                  var ch2;
                  for (var ii3 = subpicture.length - 1; ii3 >= 0; ii3--) {
                    ch2 = subpicture.charAt(ii3);
                    if (activeChars.indexOf(ch2) !== -1 && ch2 !== properties["exponent-separator"]) {
                      return subpicture.substring(ii3 + 1);
                    }
                  }
                }();
                var activePart = subpicture.substring(prefix2.length, subpicture.length - suffix.length);
                var mantissaPart, exponentPart, integerPart, fractionalPart;
                var exponentPosition = subpicture.indexOf(properties["exponent-separator"], prefix2.length);
                if (exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                  mantissaPart = activePart;
                  exponentPart = void 0;
                } else {
                  mantissaPart = activePart.substring(0, exponentPosition);
                  exponentPart = activePart.substring(exponentPosition + 1);
                }
                var decimalPosition = mantissaPart.indexOf(properties["decimal-separator"]);
                if (decimalPosition === -1) {
                  integerPart = mantissaPart;
                  fractionalPart = suffix;
                } else {
                  integerPart = mantissaPart.substring(0, decimalPosition);
                  fractionalPart = mantissaPart.substring(decimalPosition + 1);
                }
                return {
                  prefix: prefix2,
                  suffix,
                  activePart,
                  mantissaPart,
                  exponentPart,
                  integerPart,
                  fractionalPart,
                  subpicture
                };
              };
              var validate = function(parts2) {
                var error2;
                var ii3;
                var subpicture = parts2.subpicture;
                var decimalPos2 = subpicture.indexOf(properties["decimal-separator"]);
                if (decimalPos2 !== subpicture.lastIndexOf(properties["decimal-separator"])) {
                  error2 = "D3081";
                }
                if (subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                  error2 = "D3082";
                }
                if (subpicture.indexOf(properties["per-mille"]) !== subpicture.lastIndexOf(properties["per-mille"])) {
                  error2 = "D3083";
                }
                if (subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties["per-mille"]) !== -1) {
                  error2 = "D3084";
                }
                var valid2 = false;
                for (ii3 = 0; ii3 < parts2.mantissaPart.length; ii3++) {
                  var ch2 = parts2.mantissaPart.charAt(ii3);
                  if (decimalDigitFamily.indexOf(ch2) !== -1 || ch2 === properties.digit) {
                    valid2 = true;
                    break;
                  }
                }
                if (!valid2) {
                  error2 = "D3085";
                }
                var charTypes = parts2.activePart.split("").map(function(char2) {
                  return activeChars.indexOf(char2) === -1 ? "p" : "a";
                }).join("");
                if (charTypes.indexOf("p") !== -1) {
                  error2 = "D3086";
                }
                if (decimalPos2 !== -1) {
                  if (subpicture.charAt(decimalPos2 - 1) === properties["grouping-separator"] || subpicture.charAt(decimalPos2 + 1) === properties["grouping-separator"]) {
                    error2 = "D3087";
                  }
                } else if (parts2.integerPart.charAt(parts2.integerPart.length - 1) === properties["grouping-separator"]) {
                  error2 = "D3088";
                }
                if (subpicture.indexOf(properties["grouping-separator"] + properties["grouping-separator"]) !== -1) {
                  error2 = "D3089";
                }
                var optionalDigitPos = parts2.integerPart.indexOf(properties.digit);
                if (optionalDigitPos !== -1 && parts2.integerPart.substring(0, optionalDigitPos).split("").filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) > -1;
                }).length > 0) {
                  error2 = "D3090";
                }
                optionalDigitPos = parts2.fractionalPart.lastIndexOf(properties.digit);
                if (optionalDigitPos !== -1 && parts2.fractionalPart.substring(optionalDigitPos).split("").filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) > -1;
                }).length > 0) {
                  error2 = "D3091";
                }
                var exponentExists = typeof parts2.exponentPart === "string";
                if (exponentExists && parts2.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties["per-mille"]) !== -1)) {
                  error2 = "D3092";
                }
                if (exponentExists && (parts2.exponentPart.length === 0 || parts2.exponentPart.split("").filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) === -1;
                }).length > 0)) {
                  error2 = "D3093";
                }
                if (error2) {
                  throw {
                    code: error2,
                    stack: new Error().stack
                  };
                }
              };
              var analyse = function(parts2) {
                var getGroupingPositions = function(part, toLeft) {
                  var positions = [];
                  var groupingPosition = part.indexOf(properties["grouping-separator"]);
                  while (groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split("").filter(function(char2) {
                      return decimalDigitFamily.indexOf(char2) !== -1 || char2 === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts2.integerPart.indexOf(properties["grouping-separator"], groupingPosition + 1);
                  }
                  return positions;
                };
                var integerPartGroupingPositions = getGroupingPositions(parts2.integerPart);
                var regular = function(indexes) {
                  if (indexes.length === 0) {
                    return 0;
                  }
                  var gcd = function(a, b2) {
                    return b2 === 0 ? a : gcd(b2, a % b2);
                  };
                  var factor = indexes.reduce(gcd);
                  for (var index2 = 1; index2 <= indexes.length; index2++) {
                    if (indexes.indexOf(index2 * factor) === -1) {
                      return 0;
                    }
                  }
                  return factor;
                };
                var regularGrouping = regular(integerPartGroupingPositions);
                var fractionalPartGroupingPositions = getGroupingPositions(parts2.fractionalPart, true);
                var minimumIntegerPartSize = parts2.integerPart.split("").filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) !== -1;
                }).length;
                var scalingFactor = minimumIntegerPartSize;
                var fractionalPartArray = parts2.fractionalPart.split("");
                var minimumFactionalPartSize = fractionalPartArray.filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) !== -1;
                }).length;
                var maximumFactionalPartSize = fractionalPartArray.filter(function(char2) {
                  return decimalDigitFamily.indexOf(char2) !== -1 || char2 === properties.digit;
                }).length;
                var exponentPresent = typeof parts2.exponentPart === "string";
                if (minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                  if (exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                  } else {
                    minimumIntegerPartSize = 1;
                  }
                }
                if (exponentPresent && minimumIntegerPartSize === 0 && parts2.integerPart.indexOf(properties.digit) !== -1) {
                  minimumIntegerPartSize = 1;
                }
                if (minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                  minimumFactionalPartSize = 1;
                }
                var minimumExponentSize = 0;
                if (exponentPresent) {
                  minimumExponentSize = parts2.exponentPart.split("").filter(function(char2) {
                    return decimalDigitFamily.indexOf(char2) !== -1;
                  }).length;
                }
                return {
                  integerPartGroupingPositions,
                  regularGrouping,
                  minimumIntegerPartSize,
                  scalingFactor,
                  prefix: parts2.prefix,
                  fractionalPartGroupingPositions,
                  minimumFactionalPartSize,
                  maximumFactionalPartSize,
                  minimumExponentSize,
                  suffix: parts2.suffix,
                  picture: parts2.subpicture
                };
              };
              var parts = subPictures.map(splitParts);
              parts.forEach(validate);
              var variables = parts.map(analyse);
              var minus_sign = properties["minus-sign"];
              var zero_digit = properties["zero-digit"];
              var decimal_separator = properties["decimal-separator"];
              var grouping_separator = properties["grouping-separator"];
              if (variables.length === 1) {
                variables.push(JSON.parse(JSON.stringify(variables[0])));
                variables[1].prefix = minus_sign + variables[1].prefix;
              }
              var pic;
              if (value >= 0) {
                pic = variables[0];
              } else {
                pic = variables[1];
              }
              var adjustedNumber;
              if (pic.picture.indexOf(properties.percent) !== -1) {
                adjustedNumber = value * 100;
              } else if (pic.picture.indexOf(properties["per-mille"]) !== -1) {
                adjustedNumber = value * 1e3;
              } else {
                adjustedNumber = value;
              }
              var mantissa, exponent;
              if (pic.minimumExponentSize === 0) {
                mantissa = adjustedNumber;
              } else {
                var maxMantissa = Math.pow(10, pic.scalingFactor);
                var minMantissa = Math.pow(10, pic.scalingFactor - 1);
                mantissa = adjustedNumber;
                exponent = 0;
                while (mantissa < minMantissa) {
                  mantissa *= 10;
                  exponent -= 1;
                }
                while (mantissa > maxMantissa) {
                  mantissa /= 10;
                  exponent += 1;
                }
              }
              var roundedNumber = round(mantissa, pic.maximumFactionalPartSize);
              var makeString = function(value2, dp) {
                var str = Math.abs(value2).toFixed(dp);
                if (zero_digit !== "0") {
                  str = str.split("").map(function(digit) {
                    if (digit >= "0" && digit <= "9") {
                      return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                      return digit;
                    }
                  }).join("");
                }
                return str;
              };
              var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
              var decimalPos = stringValue.indexOf(".");
              if (decimalPos === -1) {
                stringValue = stringValue + decimal_separator;
              } else {
                stringValue = stringValue.replace(".", decimal_separator);
              }
              while (stringValue.charAt(0) === zero_digit) {
                stringValue = stringValue.substring(1);
              }
              while (stringValue.charAt(stringValue.length - 1) === zero_digit) {
                stringValue = stringValue.substring(0, stringValue.length - 1);
              }
              decimalPos = stringValue.indexOf(decimal_separator);
              var padLeft = pic.minimumIntegerPartSize - decimalPos;
              var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
              stringValue = (padLeft > 0 ? new Array(padLeft + 1).join(zero_digit) : "") + stringValue;
              stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join(zero_digit) : "");
              decimalPos = stringValue.indexOf(decimal_separator);
              if (pic.regularGrouping > 0) {
                var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
                for (var group = 1; group <= groupCount; group++) {
                  stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), grouping_separator, stringValue.slice(decimalPos - group * pic.regularGrouping)].join("");
                }
              } else {
                pic.integerPartGroupingPositions.forEach(function(pos) {
                  stringValue = [stringValue.slice(0, decimalPos - pos), grouping_separator, stringValue.slice(decimalPos - pos)].join("");
                  decimalPos++;
                });
              }
              decimalPos = stringValue.indexOf(decimal_separator);
              pic.fractionalPartGroupingPositions.forEach(function(pos) {
                stringValue = [stringValue.slice(0, pos + decimalPos + 1), grouping_separator, stringValue.slice(pos + decimalPos + 1)].join("");
              });
              decimalPos = stringValue.indexOf(decimal_separator);
              if (pic.picture.indexOf(decimal_separator) === -1 || decimalPos === stringValue.length - 1) {
                stringValue = stringValue.substring(0, stringValue.length - 1);
              }
              if (typeof exponent !== "undefined") {
                var stringExponent = makeString(exponent, 0);
                padLeft = pic.minimumExponentSize - stringExponent.length;
                if (padLeft > 0) {
                  stringExponent = new Array(padLeft + 1).join(zero_digit) + stringExponent;
                }
                stringValue = stringValue + properties["exponent-separator"] + (exponent < 0 ? minus_sign : "") + stringExponent;
              }
              stringValue = pic.prefix + stringValue + pic.suffix;
              return stringValue;
            }
            function formatBase(value, radix) {
              if (typeof value === "undefined") {
                return void 0;
              }
              value = round(value);
              if (typeof radix === "undefined") {
                radix = 10;
              } else {
                radix = round(radix);
              }
              if (radix < 2 || radix > 36) {
                throw {
                  code: "D3100",
                  stack: new Error().stack,
                  value: radix
                };
              }
              var result = value.toString(radix);
              return result;
            }
            function number2(arg) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              if (typeof arg === "number") {
                result = arg;
              } else if (typeof arg === "string" && /^-?[0-9]+(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
                result = parseFloat(arg);
              } else if (typeof arg === "string" && /^(0[xX][0-9A-Fa-f]+)|(0[oO][0-7]+)|(0[bB][0-1]+)$/.test(arg)) {
                result = Number(arg);
              } else if (arg === true) {
                result = 1;
              } else if (arg === false) {
                result = 0;
              } else {
                throw {
                  code: "D3030",
                  value: arg,
                  stack: new Error().stack,
                  index: 1
                };
              }
              return result;
            }
            function abs2(arg) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              result = Math.abs(arg);
              return result;
            }
            function floor(arg) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              result = Math.floor(arg);
              return result;
            }
            function ceil(arg) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              result = Math.ceil(arg);
              return result;
            }
            function round(arg, precision) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              if (precision) {
                var value = arg.toString().split("e");
                arg = +(value[0] + "e" + (value[1] ? +value[1] + precision : precision));
              }
              result = Math.round(arg);
              var diff = result - arg;
              if (Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
                result = result - 1;
              }
              if (precision) {
                value = result.toString().split("e");
                result = +(value[0] + "e" + (value[1] ? +value[1] - precision : -precision));
              }
              if (Object.is(result, -0)) {
                result = 0;
              }
              return result;
            }
            function sqrt(arg) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              if (arg < 0) {
                throw {
                  stack: new Error().stack,
                  code: "D3060",
                  index: 1,
                  value: arg
                };
              }
              result = Math.sqrt(arg);
              return result;
            }
            function power(arg, exp) {
              var result;
              if (typeof arg === "undefined") {
                return void 0;
              }
              result = Math.pow(arg, exp);
              if (!isFinite(result)) {
                throw {
                  stack: new Error().stack,
                  code: "D3061",
                  index: 1,
                  value: arg,
                  exp
                };
              }
              return result;
            }
            function random() {
              return Math.random();
            }
            function boolean2(arg) {
              if (typeof arg === "undefined") {
                return void 0;
              }
              var result = false;
              if (Array.isArray(arg)) {
                if (arg.length === 1) {
                  result = boolean2(arg[0]);
                } else if (arg.length > 1) {
                  var trues = arg.filter(function(val) {
                    return boolean2(val);
                  });
                  result = trues.length > 0;
                }
              } else if (typeof arg === "string") {
                if (arg.length > 0) {
                  result = true;
                }
              } else if (isNumeric(arg)) {
                if (arg !== 0) {
                  result = true;
                }
              } else if (arg !== null && typeof arg === "object") {
                if (Object.keys(arg).length > 0) {
                  result = true;
                }
              } else if (typeof arg === "boolean" && arg === true) {
                result = true;
              }
              return result;
            }
            function not(arg) {
              if (typeof arg === "undefined") {
                return void 0;
              }
              return !boolean2(arg);
            }
            function hofFuncArgs(func, arg1, arg2, arg3) {
              var func_args = [arg1];
              var length3 = getFunctionArity(func);
              if (length3 >= 2) {
                func_args.push(arg2);
              }
              if (length3 >= 3) {
                func_args.push(arg3);
              }
              return func_args;
            }
            async function map(arr, func) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              var result = createSequence();
              for (var i2 = 0; i2 < arr.length; i2++) {
                var func_args = hofFuncArgs(func, arr[i2], i2, arr);
                var res = await func.apply(this, func_args);
                if (typeof res !== "undefined") {
                  result.push(res);
                }
              }
              return result;
            }
            async function filter3(arr, func) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              var result = createSequence();
              for (var i2 = 0; i2 < arr.length; i2++) {
                var entry = arr[i2];
                var func_args = hofFuncArgs(func, entry, i2, arr);
                var res = await func.apply(this, func_args);
                if (boolean2(res)) {
                  result.push(entry);
                }
              }
              return result;
            }
            async function single(arr, func) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              var hasFoundMatch = false;
              var result;
              for (var i2 = 0; i2 < arr.length; i2++) {
                var entry = arr[i2];
                var positiveResult = true;
                if (typeof func !== "undefined") {
                  var func_args = hofFuncArgs(func, entry, i2, arr);
                  var res = await func.apply(this, func_args);
                  positiveResult = boolean2(res);
                }
                if (positiveResult) {
                  if (!hasFoundMatch) {
                    result = entry;
                    hasFoundMatch = true;
                  } else {
                    throw {
                      stack: new Error().stack,
                      code: "D3138",
                      index: i2
                    };
                  }
                }
              }
              if (!hasFoundMatch) {
                throw {
                  stack: new Error().stack,
                  code: "D3139"
                };
              }
              return result;
            }
            function zip() {
              var result = [];
              var args = Array.prototype.slice.call(arguments);
              var length3 = Math.min.apply(Math, args.map(function(arg) {
                if (Array.isArray(arg)) {
                  return arg.length;
                }
                return 0;
              }));
              for (var i2 = 0; i2 < length3; i2++) {
                var tuple = args.map((arg) => {
                  return arg[i2];
                });
                result.push(tuple);
              }
              return result;
            }
            async function foldLeft(sequence, func, init) {
              if (typeof sequence === "undefined") {
                return void 0;
              }
              var result;
              var arity = getFunctionArity(func);
              if (arity < 2) {
                throw {
                  stack: new Error().stack,
                  code: "D3050",
                  index: 1
                };
              }
              var index2;
              if (typeof init === "undefined" && sequence.length > 0) {
                result = sequence[0];
                index2 = 1;
              } else {
                result = init;
                index2 = 0;
              }
              while (index2 < sequence.length) {
                var args = [result, sequence[index2]];
                if (arity >= 3) {
                  args.push(index2);
                }
                if (arity >= 4) {
                  args.push(sequence);
                }
                result = await func.apply(this, args);
                index2++;
              }
              return result;
            }
            function keys2(arg) {
              var result = createSequence();
              if (Array.isArray(arg)) {
                var merge3 = {};
                arg.forEach(function(item) {
                  var allkeys = keys2(item);
                  allkeys.forEach(function(key) {
                    merge3[key] = true;
                  });
                });
                result = keys2(merge3);
              } else if (arg !== null && typeof arg === "object" && !isFunction2(arg)) {
                Object.keys(arg).forEach((key) => result.push(key));
              }
              return result;
            }
            function lookup2(input, key) {
              var result;
              if (Array.isArray(input)) {
                result = createSequence();
                for (var ii2 = 0; ii2 < input.length; ii2++) {
                  var res = lookup2(input[ii2], key);
                  if (typeof res !== "undefined") {
                    if (Array.isArray(res)) {
                      res.forEach((val) => result.push(val));
                    } else {
                      result.push(res);
                    }
                  }
                }
              } else if (input !== null && typeof input === "object" && !isFunction2(input)) {
                result = input[key];
              }
              return result;
            }
            function append3(arg1, arg2) {
              if (typeof arg1 === "undefined") {
                return arg2;
              }
              if (typeof arg2 === "undefined") {
                return arg1;
              }
              if (!Array.isArray(arg1)) {
                arg1 = createSequence(arg1);
              }
              if (!Array.isArray(arg2)) {
                arg2 = [arg2];
              }
              return arg1.concat(arg2);
            }
            function exists(arg) {
              if (typeof arg === "undefined") {
                return false;
              } else {
                return true;
              }
            }
            function spread2(arg) {
              var result = createSequence();
              if (Array.isArray(arg)) {
                arg.forEach(function(item) {
                  result = append3(result, spread2(item));
                });
              } else if (arg !== null && typeof arg === "object" && !isLambda(arg)) {
                for (var key in arg) {
                  var obj = {};
                  obj[key] = arg[key];
                  result.push(obj);
                }
              } else {
                result = arg;
              }
              return result;
            }
            function merge2(arg) {
              if (typeof arg === "undefined") {
                return void 0;
              }
              var result = {};
              arg.forEach(function(obj) {
                for (var prop in obj) {
                  result[prop] = obj[prop];
                }
              });
              return result;
            }
            function reverse(arr) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              if (arr.length <= 1) {
                return arr;
              }
              var length3 = arr.length;
              var result = new Array(length3);
              for (var i2 = 0; i2 < length3; i2++) {
                result[length3 - i2 - 1] = arr[i2];
              }
              return result;
            }
            async function each(obj, func) {
              var result = createSequence();
              for (var key in obj) {
                var func_args = hofFuncArgs(func, obj[key], key, obj);
                var val = await func.apply(this, func_args);
                if (typeof val !== "undefined") {
                  result.push(val);
                }
              }
              return result;
            }
            function error(message) {
              throw {
                code: "D3137",
                stack: new Error().stack,
                message: message || "$error() function evaluated"
              };
            }
            function assert(condition, message) {
              if (!condition) {
                throw {
                  code: "D3141",
                  stack: new Error().stack,
                  message: message || "$assert() statement failed"
                };
              }
              return void 0;
            }
            function type2(value) {
              if (value === void 0) {
                return void 0;
              }
              if (value === null) {
                return "null";
              }
              if (isNumeric(value)) {
                return "number";
              }
              if (typeof value === "string") {
                return "string";
              }
              if (typeof value === "boolean") {
                return "boolean";
              }
              if (Array.isArray(value)) {
                return "array";
              }
              if (isFunction2(value)) {
                return "function";
              }
              return "object";
            }
            async function sort(arr, comparator) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              if (arr.length <= 1) {
                return arr;
              }
              var comp;
              if (typeof comparator === "undefined") {
                if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                  throw {
                    stack: new Error().stack,
                    code: "D3070",
                    index: 1
                  };
                }
                comp = async function(a, b2) {
                  return a > b2;
                };
              } else {
                comp = comparator;
              }
              var merge3 = async function(l2, r2) {
                var merge_iter = async function(result2, left, right) {
                  if (left.length === 0) {
                    Array.prototype.push.apply(result2, right);
                  } else if (right.length === 0) {
                    Array.prototype.push.apply(result2, left);
                  } else if (await comp(left[0], right[0])) {
                    result2.push(right[0]);
                    await merge_iter(result2, left, right.slice(1));
                  } else {
                    result2.push(left[0]);
                    await merge_iter(result2, left.slice(1), right);
                  }
                };
                var merged = [];
                await merge_iter(merged, l2, r2);
                return merged;
              };
              var msort = async function(array) {
                if (!Array.isArray(array) || array.length <= 1) {
                  return array;
                } else {
                  var middle = Math.floor(array.length / 2);
                  var left = array.slice(0, middle);
                  var right = array.slice(middle);
                  left = await msort(left);
                  right = await msort(right);
                  return await merge3(left, right);
                }
              };
              var result = await msort(arr);
              return result;
            }
            function shuffle(arr) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              if (arr.length <= 1) {
                return arr;
              }
              var result = new Array(arr.length);
              for (var i2 = 0; i2 < arr.length; i2++) {
                var j = Math.floor(Math.random() * (i2 + 1));
                if (i2 !== j) {
                  result[i2] = result[j];
                }
                result[j] = arr[i2];
              }
              return result;
            }
            function distinct(arr) {
              if (typeof arr === "undefined") {
                return void 0;
              }
              if (!Array.isArray(arr) || arr.length <= 1) {
                return arr;
              }
              var results = isSequence(arr) ? createSequence() : [];
              for (var ii2 = 0; ii2 < arr.length; ii2++) {
                var value = arr[ii2];
                var includes = false;
                for (var jj2 = 0; jj2 < results.length; jj2++) {
                  if (deepEquals(value, results[jj2])) {
                    includes = true;
                    break;
                  }
                }
                if (!includes) {
                  results.push(value);
                }
              }
              return results;
            }
            async function sift(arg, func) {
              var result = {};
              for (var item in arg) {
                var entry = arg[item];
                var func_args = hofFuncArgs(func, entry, item, arg);
                var res = await func.apply(this, func_args);
                if (boolean2(res)) {
                  result[item] = entry;
                }
              }
              if (Object.keys(result).length === 0) {
                result = void 0;
              }
              return result;
            }
            return {
              sum,
              count,
              max,
              min,
              average,
              string: string2,
              substring,
              substringBefore,
              substringAfter,
              lowercase,
              uppercase,
              length: length2,
              trim: trim2,
              pad,
              match: match2,
              contains,
              replace: replace2,
              split,
              join: join2,
              formatNumber,
              formatBase,
              number: number2,
              floor,
              ceil,
              round,
              abs: abs2,
              sqrt,
              power,
              random,
              boolean: boolean2,
              not,
              map,
              zip,
              filter: filter3,
              single,
              foldLeft,
              sift,
              keys: keys2,
              lookup: lookup2,
              append: append3,
              exists,
              spread: spread2,
              merge: merge2,
              reverse,
              each,
              error,
              assert,
              type: type2,
              sort,
              shuffle,
              distinct,
              base64encode,
              base64decode,
              encodeUrlComponent,
              encodeUrl,
              decodeUrlComponent,
              decodeUrl
            };
          })();
          module2.exports = functions;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./utils": 6 }], 3: [function(require2, module2, exports2) {
      var datetime = require2("./datetime");
      var fn = require2("./functions");
      var utils2 = require2("./utils");
      var parser = require2("./parser");
      var parseSignature = require2("./signature");
      var jsonata2 = function() {
        var isNumeric = utils2.isNumeric;
        var isArrayOfStrings = utils2.isArrayOfStrings;
        var isArrayOfNumbers = utils2.isArrayOfNumbers;
        var createSequence = utils2.createSequence;
        var isSequence = utils2.isSequence;
        var isFunction2 = utils2.isFunction;
        var isLambda = utils2.isLambda;
        var isIterable = utils2.isIterable;
        var isPromise2 = utils2.isPromise;
        var getFunctionArity = utils2.getFunctionArity;
        var isDeepEqual = utils2.isDeepEqual;
        var staticFrame = createFrame(null);
        async function evaluate(expr, input, environment) {
          var result;
          var entryCallback = environment.lookup(Symbol.for("jsonata.__evaluate_entry"));
          if (entryCallback) {
            await entryCallback(expr, input, environment);
          }
          switch (expr.type) {
            case "path":
              result = await evaluatePath(expr, input, environment);
              break;
            case "binary":
              result = await evaluateBinary(expr, input, environment);
              break;
            case "unary":
              result = await evaluateUnary(expr, input, environment);
              break;
            case "name":
              result = evaluateName(expr, input);
              break;
            case "string":
            case "number":
            case "value":
              result = evaluateLiteral(expr);
              break;
            case "wildcard":
              result = evaluateWildcard(expr, input);
              break;
            case "descendant":
              result = evaluateDescendants(expr, input);
              break;
            case "parent":
              result = environment.lookup(expr.slot.label);
              break;
            case "condition":
              result = await evaluateCondition(expr, input, environment);
              break;
            case "block":
              result = await evaluateBlock(expr, input, environment);
              break;
            case "bind":
              result = await evaluateBindExpression(expr, input, environment);
              break;
            case "regex":
              result = evaluateRegex(expr);
              break;
            case "function":
              result = await evaluateFunction(expr, input, environment);
              break;
            case "variable":
              result = evaluateVariable(expr, input, environment);
              break;
            case "lambda":
              result = evaluateLambda(expr, input, environment);
              break;
            case "partial":
              result = await evaluatePartialApplication(expr, input, environment);
              break;
            case "apply":
              result = await evaluateApplyExpression(expr, input, environment);
              break;
            case "transform":
              result = evaluateTransformExpression(expr, input, environment);
              break;
          }
          if (Object.prototype.hasOwnProperty.call(expr, "predicate")) {
            for (var ii2 = 0; ii2 < expr.predicate.length; ii2++) {
              result = await evaluateFilter(expr.predicate[ii2].expr, result, environment);
            }
          }
          if (expr.type !== "path" && Object.prototype.hasOwnProperty.call(expr, "group")) {
            result = await evaluateGroupExpression(expr.group, result, environment);
          }
          var exitCallback = environment.lookup(Symbol.for("jsonata.__evaluate_exit"));
          if (exitCallback) {
            await exitCallback(expr, input, environment, result);
          }
          if (result && isSequence(result) && !result.tupleStream) {
            if (expr.keepArray) {
              result.keepSingleton = true;
            }
            if (result.length === 0) {
              result = void 0;
            } else if (result.length === 1) {
              result = result.keepSingleton ? result : result[0];
            }
          }
          return result;
        }
        async function evaluatePath(expr, input, environment) {
          var inputSequence;
          if (Array.isArray(input) && expr.steps[0].type !== "variable") {
            inputSequence = input;
          } else {
            inputSequence = createSequence(input);
          }
          var resultSequence;
          var isTupleStream = false;
          var tupleBindings = void 0;
          for (var ii2 = 0; ii2 < expr.steps.length; ii2++) {
            var step = expr.steps[ii2];
            if (step.tuple) {
              isTupleStream = true;
            }
            if (ii2 === 0 && step.consarray) {
              resultSequence = await evaluate(step, inputSequence, environment);
            } else {
              if (isTupleStream) {
                tupleBindings = await evaluateTupleStep(step, inputSequence, tupleBindings, environment);
              } else {
                resultSequence = await evaluateStep(step, inputSequence, environment, ii2 === expr.steps.length - 1);
              }
            }
            if (!isTupleStream && (typeof resultSequence === "undefined" || resultSequence.length === 0)) {
              break;
            }
            if (typeof step.focus === "undefined") {
              inputSequence = resultSequence;
            }
          }
          if (isTupleStream) {
            if (expr.tuple) {
              resultSequence = tupleBindings;
            } else {
              resultSequence = createSequence();
              for (ii2 = 0; ii2 < tupleBindings.length; ii2++) {
                resultSequence.push(tupleBindings[ii2]["@"]);
              }
            }
          }
          if (expr.keepSingletonArray) {
            if (Array.isArray(resultSequence) && resultSequence.cons && !resultSequence.sequence) {
              resultSequence = createSequence(resultSequence);
            }
            resultSequence.keepSingleton = true;
          }
          if (expr.hasOwnProperty("group")) {
            resultSequence = await evaluateGroupExpression(expr.group, isTupleStream ? tupleBindings : resultSequence, environment);
          }
          return resultSequence;
        }
        function createFrameFromTuple(environment, tuple) {
          var frame2 = createFrame(environment);
          for (const prop in tuple) {
            frame2.bind(prop, tuple[prop]);
          }
          return frame2;
        }
        async function evaluateStep(expr, input, environment, lastStep) {
          var result;
          if (expr.type === "sort") {
            result = await evaluateSortExpression(expr, input, environment);
            if (expr.stages) {
              result = await evaluateStages(expr.stages, result, environment);
            }
            return result;
          }
          result = createSequence();
          for (var ii2 = 0; ii2 < input.length; ii2++) {
            var res = await evaluate(expr, input[ii2], environment);
            if (expr.stages) {
              for (var ss = 0; ss < expr.stages.length; ss++) {
                res = await evaluateFilter(expr.stages[ss].expr, res, environment);
              }
            }
            if (typeof res !== "undefined") {
              result.push(res);
            }
          }
          var resultSequence = createSequence();
          if (lastStep && result.length === 1 && Array.isArray(result[0]) && !isSequence(result[0])) {
            resultSequence = result[0];
          } else {
            result.forEach(function(res2) {
              if (!Array.isArray(res2) || res2.cons) {
                resultSequence.push(res2);
              } else {
                res2.forEach((val) => resultSequence.push(val));
              }
            });
          }
          return resultSequence;
        }
        async function evaluateStages(stages, input, environment) {
          var result = input;
          for (var ss = 0; ss < stages.length; ss++) {
            var stage = stages[ss];
            switch (stage.type) {
              case "filter":
                result = await evaluateFilter(stage.expr, result, environment);
                break;
              case "index":
                for (var ee2 = 0; ee2 < result.length; ee2++) {
                  var tuple = result[ee2];
                  tuple[stage.value] = ee2;
                }
                break;
            }
          }
          return result;
        }
        async function evaluateTupleStep(expr, input, tupleBindings, environment) {
          var result;
          if (expr.type === "sort") {
            if (tupleBindings) {
              result = await evaluateSortExpression(expr, tupleBindings, environment);
            } else {
              var sorted = await evaluateSortExpression(expr, input, environment);
              result = createSequence();
              result.tupleStream = true;
              for (var ss = 0; ss < sorted.length; ss++) {
                var tuple = { "@": sorted[ss] };
                tuple[expr.index] = ss;
                result.push(tuple);
              }
            }
            if (expr.stages) {
              result = await evaluateStages(expr.stages, result, environment);
            }
            return result;
          }
          result = createSequence();
          result.tupleStream = true;
          var stepEnv = environment;
          if (tupleBindings === void 0) {
            tupleBindings = input.map((item) => {
              return { "@": item };
            });
          }
          for (var ee2 = 0; ee2 < tupleBindings.length; ee2++) {
            stepEnv = createFrameFromTuple(environment, tupleBindings[ee2]);
            var res = await evaluate(expr, tupleBindings[ee2]["@"], stepEnv);
            if (typeof res !== "undefined") {
              if (!Array.isArray(res)) {
                res = [res];
              }
              for (var bb2 = 0; bb2 < res.length; bb2++) {
                tuple = {};
                Object.assign(tuple, tupleBindings[ee2]);
                if (res.tupleStream) {
                  Object.assign(tuple, res[bb2]);
                } else {
                  if (expr.focus) {
                    tuple[expr.focus] = res[bb2];
                    tuple["@"] = tupleBindings[ee2]["@"];
                  } else {
                    tuple["@"] = res[bb2];
                  }
                  if (expr.index) {
                    tuple[expr.index] = bb2;
                  }
                  if (expr.ancestor) {
                    tuple[expr.ancestor.label] = tupleBindings[ee2]["@"];
                  }
                }
                result.push(tuple);
              }
            }
          }
          if (expr.stages) {
            result = await evaluateStages(expr.stages, result, environment);
          }
          return result;
        }
        async function evaluateFilter(predicate, input, environment) {
          var results = createSequence();
          if (input && input.tupleStream) {
            results.tupleStream = true;
          }
          if (!Array.isArray(input)) {
            input = createSequence(input);
          }
          if (predicate.type === "number") {
            var index2 = Math.floor(predicate.value);
            if (index2 < 0) {
              index2 = input.length + index2;
            }
            var item = input[index2];
            if (typeof item !== "undefined") {
              if (Array.isArray(item)) {
                results = item;
              } else {
                results.push(item);
              }
            }
          } else {
            for (index2 = 0; index2 < input.length; index2++) {
              var item = input[index2];
              var context = item;
              var env = environment;
              if (input.tupleStream) {
                context = item["@"];
                env = createFrameFromTuple(environment, item);
              }
              var res = await evaluate(predicate, context, env);
              if (isNumeric(res)) {
                res = [res];
              }
              if (isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                  var ii2 = Math.floor(ires);
                  if (ii2 < 0) {
                    ii2 = input.length + ii2;
                  }
                  if (ii2 === index2) {
                    results.push(item);
                  }
                });
              } else if (fn.boolean(res)) {
                results.push(item);
              }
            }
          }
          return results;
        }
        async function evaluateBinary(expr, input, environment) {
          var result;
          var lhs = await evaluate(expr.lhs, input, environment);
          var op = expr.value;
          var evalrhs = async () => await evaluate(expr.rhs, input, environment);
          if (op === "and" || op === "or") {
            try {
              return await evaluateBooleanExpression(lhs, evalrhs, op);
            } catch (err) {
              err.position = expr.position;
              err.token = op;
              throw err;
            }
          }
          var rhs = await evalrhs();
          try {
            switch (op) {
              case "+":
              case "-":
              case "*":
              case "/":
              case "%":
                result = evaluateNumericExpression(lhs, rhs, op);
                break;
              case "=":
              case "!=":
                result = evaluateEqualityExpression(lhs, rhs, op);
                break;
              case "<":
              case "<=":
              case ">":
              case ">=":
                result = evaluateComparisonExpression(lhs, rhs, op);
                break;
              case "&":
                result = evaluateStringConcat(lhs, rhs);
                break;
              case "..":
                result = evaluateRangeExpression(lhs, rhs);
                break;
              case "in":
                result = evaluateIncludesExpression(lhs, rhs);
                break;
            }
          } catch (err) {
            err.position = expr.position;
            err.token = op;
            throw err;
          }
          return result;
        }
        async function evaluateUnary(expr, input, environment) {
          var result;
          switch (expr.value) {
            case "-":
              result = await evaluate(expr.expression, input, environment);
              if (typeof result === "undefined") {
                result = void 0;
              } else if (isNumeric(result)) {
                result = -result;
              } else {
                throw {
                  code: "D1002",
                  stack: new Error().stack,
                  position: expr.position,
                  token: expr.value,
                  value: result
                };
              }
              break;
            case "[":
              result = [];
              let generators2 = await Promise.all(expr.expressions.map(async (item2, idx) => {
                environment.isParallelCall = idx > 0;
                return [item2, await evaluate(item2, input, environment)];
              }));
              for (let generator of generators2) {
                var [item, value] = generator;
                if (typeof value !== "undefined") {
                  if (item.value === "[") {
                    result.push(value);
                  } else {
                    result = fn.append(result, value);
                  }
                }
              }
              if (expr.consarray) {
                Object.defineProperty(result, "cons", {
                  enumerable: false,
                  configurable: false,
                  value: true
                });
              }
              break;
            case "{":
              result = await evaluateGroupExpression(expr, input, environment);
              break;
          }
          return result;
        }
        function evaluateName(expr, input, environment) {
          return fn.lookup(input, expr.value);
        }
        function evaluateLiteral(expr) {
          return expr.value;
        }
        function evaluateWildcard(expr, input) {
          var results = createSequence();
          if (Array.isArray(input) && input.outerWrapper && input.length > 0) {
            input = input[0];
          }
          if (input !== null && typeof input === "object") {
            Object.keys(input).forEach(function(key) {
              var value = input[key];
              if (Array.isArray(value)) {
                value = flatten(value);
                results = fn.append(results, value);
              } else {
                results.push(value);
              }
            });
          }
          return results;
        }
        function flatten(arg, flattened) {
          if (typeof flattened === "undefined") {
            flattened = [];
          }
          if (Array.isArray(arg)) {
            arg.forEach(function(item) {
              flatten(item, flattened);
            });
          } else {
            flattened.push(arg);
          }
          return flattened;
        }
        function evaluateDescendants(expr, input) {
          var result;
          var resultSequence = createSequence();
          if (typeof input !== "undefined") {
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
              result = resultSequence[0];
            } else {
              result = resultSequence;
            }
          }
          return result;
        }
        function recurseDescendants(input, results) {
          if (!Array.isArray(input)) {
            results.push(input);
          }
          if (Array.isArray(input)) {
            input.forEach(function(member) {
              recurseDescendants(member, results);
            });
          } else if (input !== null && typeof input === "object") {
            Object.keys(input).forEach(function(key) {
              recurseDescendants(input[key], results);
            });
          }
        }
        function evaluateNumericExpression(lhs, rhs, op) {
          var result;
          if (typeof lhs !== "undefined" && !isNumeric(lhs)) {
            throw {
              code: "T2001",
              stack: new Error().stack,
              value: lhs
            };
          }
          if (typeof rhs !== "undefined" && !isNumeric(rhs)) {
            throw {
              code: "T2002",
              stack: new Error().stack,
              value: rhs
            };
          }
          if (typeof lhs === "undefined" || typeof rhs === "undefined") {
            return result;
          }
          switch (op) {
            case "+":
              result = lhs + rhs;
              break;
            case "-":
              result = lhs - rhs;
              break;
            case "*":
              result = lhs * rhs;
              break;
            case "/":
              result = lhs / rhs;
              break;
            case "%":
              result = lhs % rhs;
              break;
          }
          return result;
        }
        function evaluateEqualityExpression(lhs, rhs, op) {
          var result;
          var ltype = typeof lhs;
          var rtype = typeof rhs;
          if (ltype === "undefined" || rtype === "undefined") {
            return false;
          }
          switch (op) {
            case "=":
              result = isDeepEqual(lhs, rhs);
              break;
            case "!=":
              result = !isDeepEqual(lhs, rhs);
              break;
          }
          return result;
        }
        function evaluateComparisonExpression(lhs, rhs, op) {
          var result;
          var ltype = typeof lhs;
          var rtype = typeof rhs;
          var lcomparable = ltype === "undefined" || ltype === "string" || ltype === "number";
          var rcomparable = rtype === "undefined" || rtype === "string" || rtype === "number";
          if (!lcomparable || !rcomparable) {
            throw {
              code: "T2010",
              stack: new Error().stack,
              value: !(ltype === "string" || ltype === "number") ? lhs : rhs
            };
          }
          if (ltype === "undefined" || rtype === "undefined") {
            return void 0;
          }
          if (ltype !== rtype) {
            throw {
              code: "T2009",
              stack: new Error().stack,
              value: lhs,
              value2: rhs
            };
          }
          switch (op) {
            case "<":
              result = lhs < rhs;
              break;
            case "<=":
              result = lhs <= rhs;
              break;
            case ">":
              result = lhs > rhs;
              break;
            case ">=":
              result = lhs >= rhs;
              break;
          }
          return result;
        }
        function evaluateIncludesExpression(lhs, rhs) {
          var result = false;
          if (typeof lhs === "undefined" || typeof rhs === "undefined") {
            return false;
          }
          if (!Array.isArray(rhs)) {
            rhs = [rhs];
          }
          for (var i2 = 0; i2 < rhs.length; i2++) {
            if (rhs[i2] === lhs) {
              result = true;
              break;
            }
          }
          return result;
        }
        async function evaluateBooleanExpression(lhs, evalrhs, op) {
          var result;
          var lBool = boolize(lhs);
          switch (op) {
            case "and":
              result = lBool && boolize(await evalrhs());
              break;
            case "or":
              result = lBool || boolize(await evalrhs());
              break;
          }
          return result;
        }
        function boolize(value) {
          var booledValue = fn.boolean(value);
          return typeof booledValue === "undefined" ? false : booledValue;
        }
        function evaluateStringConcat(lhs, rhs) {
          var result;
          var lstr = "";
          var rstr = "";
          if (typeof lhs !== "undefined") {
            lstr = fn.string(lhs);
          }
          if (typeof rhs !== "undefined") {
            rstr = fn.string(rhs);
          }
          result = lstr.concat(rstr);
          return result;
        }
        async function evaluateGroupExpression(expr, input, environment) {
          var result = {};
          var groups = {};
          var reduce = input && input.tupleStream ? true : false;
          if (!Array.isArray(input)) {
            input = createSequence(input);
          }
          if (input.length === 0) {
            input.push(void 0);
          }
          for (var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            var env = reduce ? createFrameFromTuple(environment, item) : environment;
            for (var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
              var pair = expr.lhs[pairIndex];
              var key = await evaluate(pair[0], reduce ? item["@"] : item, env);
              if (typeof key !== "string" && key !== void 0) {
                throw {
                  code: "T1003",
                  stack: new Error().stack,
                  position: expr.position,
                  value: key
                };
              }
              if (key !== void 0) {
                var entry = { data: item, exprIndex: pairIndex };
                if (groups.hasOwnProperty(key)) {
                  if (groups[key].exprIndex !== pairIndex) {
                    throw {
                      code: "D1009",
                      stack: new Error().stack,
                      position: expr.position,
                      value: key
                    };
                  }
                  groups[key].data = fn.append(groups[key].data, item);
                } else {
                  groups[key] = entry;
                }
              }
            }
          }
          let generators2 = await Promise.all(Object.keys(groups).map(async (key2, idx) => {
            let entry2 = groups[key2];
            var context = entry2.data;
            var env2 = environment;
            if (reduce) {
              var tuple = reduceTupleStream(entry2.data);
              context = tuple["@"];
              delete tuple["@"];
              env2 = createFrameFromTuple(environment, tuple);
            }
            environment.isParallelCall = idx > 0;
            return [key2, await evaluate(expr.lhs[entry2.exprIndex][1], context, env2)];
          }));
          for (let generator of generators2) {
            var [key, value] = await generator;
            if (typeof value !== "undefined") {
              result[key] = value;
            }
          }
          return result;
        }
        function reduceTupleStream(tupleStream) {
          if (!Array.isArray(tupleStream)) {
            return tupleStream;
          }
          var result = {};
          Object.assign(result, tupleStream[0]);
          for (var ii2 = 1; ii2 < tupleStream.length; ii2++) {
            for (const prop in tupleStream[ii2]) {
              result[prop] = fn.append(result[prop], tupleStream[ii2][prop]);
            }
          }
          return result;
        }
        function evaluateRangeExpression(lhs, rhs) {
          var result;
          if (typeof lhs !== "undefined" && !Number.isInteger(lhs)) {
            throw {
              code: "T2003",
              stack: new Error().stack,
              value: lhs
            };
          }
          if (typeof rhs !== "undefined" && !Number.isInteger(rhs)) {
            throw {
              code: "T2004",
              stack: new Error().stack,
              value: rhs
            };
          }
          if (typeof lhs === "undefined" || typeof rhs === "undefined") {
            return result;
          }
          if (lhs > rhs) {
            return result;
          }
          var size = rhs - lhs + 1;
          if (size > 1e7) {
            throw {
              code: "D2014",
              stack: new Error().stack,
              value: size
            };
          }
          result = new Array(size);
          for (var item = lhs, index2 = 0; item <= rhs; item++, index2++) {
            result[index2] = item;
          }
          result.sequence = true;
          return result;
        }
        async function evaluateBindExpression(expr, input, environment) {
          var value = await evaluate(expr.rhs, input, environment);
          environment.bind(expr.lhs.value, value);
          return value;
        }
        async function evaluateCondition(expr, input, environment) {
          var result;
          var condition = await evaluate(expr.condition, input, environment);
          if (fn.boolean(condition)) {
            result = await evaluate(expr.then, input, environment);
          } else if (typeof expr.else !== "undefined") {
            result = await evaluate(expr.else, input, environment);
          }
          return result;
        }
        async function evaluateBlock(expr, input, environment) {
          var result;
          var frame2 = createFrame(environment);
          for (var ii2 = 0; ii2 < expr.expressions.length; ii2++) {
            result = await evaluate(expr.expressions[ii2], input, frame2);
          }
          return result;
        }
        function evaluateRegex(expr) {
          var re2 = new jsonata3.RegexEngine(expr.value);
          var closure = function(str, fromIndex) {
            var result;
            re2.lastIndex = fromIndex || 0;
            var match2 = re2.exec(str);
            if (match2 !== null) {
              result = {
                match: match2[0],
                start: match2.index,
                end: match2.index + match2[0].length,
                groups: []
              };
              if (match2.length > 1) {
                for (var i2 = 1; i2 < match2.length; i2++) {
                  result.groups.push(match2[i2]);
                }
              }
              result.next = function() {
                if (re2.lastIndex >= str.length) {
                  return void 0;
                } else {
                  var next2 = closure(str, re2.lastIndex);
                  if (next2 && next2.match === "") {
                    throw {
                      code: "D1004",
                      stack: new Error().stack,
                      position: expr.position,
                      value: expr.value.source
                    };
                  }
                  return next2;
                }
              };
            }
            return result;
          };
          return closure;
        }
        function evaluateVariable(expr, input, environment) {
          var result;
          if (expr.value === "") {
            result = input && input.outerWrapper ? input[0] : input;
          } else {
            result = environment.lookup(expr.value);
          }
          return result;
        }
        async function evaluateSortExpression(expr, input, environment) {
          var result;
          var lhs = input;
          var isTupleSort = input.tupleStream ? true : false;
          var comparator = async function(a, b2) {
            var comp = 0;
            for (var index2 = 0; comp === 0 && index2 < expr.terms.length; index2++) {
              var term = expr.terms[index2];
              var context = a;
              var env = environment;
              if (isTupleSort) {
                context = a["@"];
                env = createFrameFromTuple(environment, a);
              }
              var aa2 = await evaluate(term.expression, context, env);
              context = b2;
              env = environment;
              if (isTupleSort) {
                context = b2["@"];
                env = createFrameFromTuple(environment, b2);
              }
              var bb2 = await evaluate(term.expression, context, env);
              var atype = typeof aa2;
              var btype = typeof bb2;
              if (atype === "undefined") {
                comp = btype === "undefined" ? 0 : 1;
                continue;
              }
              if (btype === "undefined") {
                comp = -1;
                continue;
              }
              if (!(atype === "string" || atype === "number") || !(btype === "string" || btype === "number")) {
                throw {
                  code: "T2008",
                  stack: new Error().stack,
                  position: expr.position,
                  value: !(atype === "string" || atype === "number") ? aa2 : bb2
                };
              }
              if (atype !== btype) {
                throw {
                  code: "T2007",
                  stack: new Error().stack,
                  position: expr.position,
                  value: aa2,
                  value2: bb2
                };
              }
              if (aa2 === bb2) {
                continue;
              } else if (aa2 < bb2) {
                comp = -1;
              } else {
                comp = 1;
              }
              if (term.descending === true) {
                comp = -comp;
              }
            }
            return comp === 1;
          };
          var focus = {
            environment,
            input
          };
          result = await fn.sort.apply(focus, [lhs, comparator]);
          return result;
        }
        function evaluateTransformExpression(expr, input, environment) {
          var transformer = async function(obj) {
            if (typeof obj === "undefined") {
              return void 0;
            }
            var cloneFunction = environment.lookup("clone");
            if (!isFunction2(cloneFunction)) {
              throw {
                code: "T2013",
                stack: new Error().stack,
                position: expr.position
              };
            }
            var result = await apply(cloneFunction, [obj], null, environment);
            var matches = await evaluate(expr.pattern, result, environment);
            if (typeof matches !== "undefined") {
              if (!Array.isArray(matches)) {
                matches = [matches];
              }
              for (var ii2 = 0; ii2 < matches.length; ii2++) {
                var match2 = matches[ii2];
                if (match2 && (match2.isPrototypeOf(result) || match2 instanceof Object.constructor)) {
                  throw {
                    code: "D1010",
                    stack: new Error().stack,
                    position: expr.position
                  };
                }
                var update = await evaluate(expr.update, match2, environment);
                var updateType = typeof update;
                if (updateType !== "undefined") {
                  if (updateType !== "object" || update === null || Array.isArray(update)) {
                    throw {
                      code: "T2011",
                      stack: new Error().stack,
                      position: expr.update.position,
                      value: update
                    };
                  }
                  for (var prop in update) {
                    match2[prop] = update[prop];
                  }
                }
                if (typeof expr.delete !== "undefined") {
                  var deletions = await evaluate(expr.delete, match2, environment);
                  if (typeof deletions !== "undefined") {
                    var val = deletions;
                    if (!Array.isArray(deletions)) {
                      deletions = [deletions];
                    }
                    if (!isArrayOfStrings(deletions)) {
                      throw {
                        code: "T2012",
                        stack: new Error().stack,
                        position: expr.delete.position,
                        value: val
                      };
                    }
                    for (var jj2 = 0; jj2 < deletions.length; jj2++) {
                      if (typeof match2 === "object" && match2 !== null) {
                        delete match2[deletions[jj2]];
                      }
                    }
                  }
                }
              }
            }
            return result;
          };
          return defineFunction(transformer, "<(oa):o>");
        }
        var chainAST = parser("function($f, $g) { function($x){ $g($f($x)) } }");
        async function evaluateApplyExpression(expr, input, environment) {
          var result;
          var lhs = await evaluate(expr.lhs, input, environment);
          if (expr.rhs.type === "function") {
            result = await evaluateFunction(expr.rhs, input, environment, { context: lhs });
          } else {
            var func = await evaluate(expr.rhs, input, environment);
            if (!isFunction2(func)) {
              throw {
                code: "T2006",
                stack: new Error().stack,
                position: expr.position,
                value: func
              };
            }
            if (isFunction2(lhs)) {
              var chain = await evaluate(chainAST, null, environment);
              result = await apply(chain, [lhs, func], null, environment);
            } else {
              result = await apply(func, [lhs], null, environment);
            }
          }
          return result;
        }
        async function evaluateFunction(expr, input, environment, applyto) {
          var result;
          var proc2 = await evaluate(expr.procedure, input, environment);
          if (typeof proc2 === "undefined" && expr.procedure.type === "path" && environment.lookup(expr.procedure.steps[0].value)) {
            throw {
              code: "T1005",
              stack: new Error().stack,
              position: expr.position,
              token: expr.procedure.steps[0].value
            };
          }
          var evaluatedArgs = [];
          if (typeof applyto !== "undefined") {
            evaluatedArgs.push(applyto.context);
          }
          for (var jj2 = 0; jj2 < expr.arguments.length; jj2++) {
            const arg = await evaluate(expr.arguments[jj2], input, environment);
            if (isFunction2(arg)) {
              const closure = async function(...params) {
                return await apply(arg, params, null, environment);
              };
              closure.arity = getFunctionArity(arg);
              evaluatedArgs.push(closure);
            } else {
              evaluatedArgs.push(arg);
            }
          }
          var procName = expr.procedure.type === "path" ? expr.procedure.steps[0].value : expr.procedure.value;
          try {
            if (typeof proc2 === "object") {
              proc2.token = procName;
              proc2.position = expr.position;
            }
            result = await apply(proc2, evaluatedArgs, input, environment);
          } catch (err) {
            if (!err.position) {
              err.position = expr.position;
            }
            if (!err.token) {
              err.token = procName;
            }
            throw err;
          }
          return result;
        }
        async function apply(proc2, args, input, environment) {
          var result;
          result = await applyInner(proc2, args, input, environment);
          while (isLambda(result) && result.thunk === true) {
            var next2 = await evaluate(result.body.procedure, result.input, result.environment);
            if (result.body.procedure.type === "variable") {
              next2.token = result.body.procedure.value;
            }
            next2.position = result.body.procedure.position;
            var evaluatedArgs = [];
            for (var ii2 = 0; ii2 < result.body.arguments.length; ii2++) {
              evaluatedArgs.push(await evaluate(result.body.arguments[ii2], result.input, result.environment));
            }
            result = await applyInner(next2, evaluatedArgs, input, environment);
          }
          return result;
        }
        async function applyInner(proc2, args, input, environment) {
          var result;
          try {
            var validatedArgs = args;
            if (proc2) {
              validatedArgs = validateArguments(proc2.signature, args, input);
            }
            if (isLambda(proc2)) {
              result = await applyProcedure(proc2, validatedArgs);
            } else if (proc2 && proc2._jsonata_function === true) {
              var focus = {
                environment,
                input
              };
              result = proc2.implementation.apply(focus, validatedArgs);
              if (isIterable(result)) {
                result = result.next().value;
              }
              if (isPromise2(result)) {
                result = await result;
              }
            } else if (typeof proc2 === "function") {
              result = proc2.apply(input, validatedArgs);
              if (isPromise2(result)) {
                result = await result;
              }
            } else {
              throw {
                code: "T1006",
                stack: new Error().stack
              };
            }
          } catch (err) {
            if (proc2) {
              if (typeof err.token == "undefined" && typeof proc2.token !== "undefined") {
                err.token = proc2.token;
              }
              err.position = proc2.position || err.position;
            }
            throw err;
          }
          return result;
        }
        function evaluateLambda(expr, input, environment) {
          var procedure = {
            _jsonata_lambda: true,
            input,
            environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
          };
          if (expr.thunk === true) {
            procedure.thunk = true;
          }
          procedure.apply = async function(self2, args) {
            return await apply(procedure, args, input, !!self2 ? self2.environment : environment);
          };
          return procedure;
        }
        async function evaluatePartialApplication(expr, input, environment) {
          var result;
          var evaluatedArgs = [];
          for (var ii2 = 0; ii2 < expr.arguments.length; ii2++) {
            var arg = expr.arguments[ii2];
            if (arg.type === "operator" && arg.value === "?") {
              evaluatedArgs.push(arg);
            } else {
              evaluatedArgs.push(await evaluate(arg, input, environment));
            }
          }
          var proc2 = await evaluate(expr.procedure, input, environment);
          if (typeof proc2 === "undefined" && expr.procedure.type === "path" && environment.lookup(expr.procedure.steps[0].value)) {
            throw {
              code: "T1007",
              stack: new Error().stack,
              position: expr.position,
              token: expr.procedure.steps[0].value
            };
          }
          if (isLambda(proc2)) {
            result = partialApplyProcedure(proc2, evaluatedArgs);
          } else if (proc2 && proc2._jsonata_function === true) {
            result = partialApplyNativeFunction(proc2.implementation, evaluatedArgs);
          } else if (typeof proc2 === "function") {
            result = partialApplyNativeFunction(proc2, evaluatedArgs);
          } else {
            throw {
              code: "T1008",
              stack: new Error().stack,
              position: expr.position,
              token: expr.procedure.type === "path" ? expr.procedure.steps[0].value : expr.procedure.value
            };
          }
          return result;
        }
        function validateArguments(signature, args, context) {
          if (typeof signature === "undefined") {
            return args;
          }
          var validatedArgs = signature.validate(args, context);
          return validatedArgs;
        }
        async function applyProcedure(proc2, args) {
          var result;
          var env = createFrame(proc2.environment);
          proc2.arguments.forEach(function(param, index2) {
            env.bind(param.value, args[index2]);
          });
          if (typeof proc2.body === "function") {
            result = await applyNativeFunction(proc2.body, env);
          } else {
            result = await evaluate(proc2.body, proc2.input, env);
          }
          return result;
        }
        function partialApplyProcedure(proc2, args) {
          var env = createFrame(proc2.environment);
          var unboundArgs = [];
          proc2.arguments.forEach(function(param, index2) {
            var arg = args[index2];
            if (arg && arg.type === "operator" && arg.value === "?") {
              unboundArgs.push(param);
            } else {
              env.bind(param.value, arg);
            }
          });
          var procedure = {
            _jsonata_lambda: true,
            input: proc2.input,
            environment: env,
            arguments: unboundArgs,
            body: proc2.body
          };
          return procedure;
        }
        function partialApplyNativeFunction(native, args) {
          var sigArgs = getNativeFunctionArguments(native);
          sigArgs = sigArgs.map(function(sigArg) {
            return "$" + sigArg.trim();
          });
          var body = "function(" + sigArgs.join(", ") + "){ _ }";
          var bodyAST = parser(body);
          bodyAST.body = native;
          var partial = partialApplyProcedure(bodyAST, args);
          return partial;
        }
        async function applyNativeFunction(proc2, env) {
          var sigArgs = getNativeFunctionArguments(proc2);
          var args = sigArgs.map(function(sigArg) {
            return env.lookup(sigArg.trim());
          });
          var focus = {
            environment: env
          };
          var result = proc2.apply(focus, args);
          if (isPromise2(result)) {
            result = await result;
          }
          return result;
        }
        function getNativeFunctionArguments(func) {
          var signature = func.toString();
          var sigParens = /\(([^)]*)\)/.exec(signature)[1];
          var sigArgs = sigParens.split(",");
          return sigArgs;
        }
        function defineFunction(func, signature) {
          var definition2 = {
            _jsonata_function: true,
            implementation: func
          };
          if (typeof signature !== "undefined") {
            definition2.signature = parseSignature(signature);
          }
          return definition2;
        }
        async function functionEval(expr, focus) {
          if (typeof expr === "undefined") {
            return void 0;
          }
          var input = this.input;
          if (typeof focus !== "undefined") {
            input = focus;
            if (Array.isArray(input) && !isSequence(input)) {
              input = createSequence(input);
              input.outerWrapper = true;
            }
          }
          try {
            var ast = parser(expr, false);
          } catch (err) {
            populateMessage(err);
            throw {
              stack: new Error().stack,
              code: "D3120",
              value: err.message,
              error: err
            };
          }
          try {
            var result = await evaluate(ast, input, this.environment);
          } catch (err) {
            populateMessage(err);
            throw {
              stack: new Error().stack,
              code: "D3121",
              value: err.message,
              error: err
            };
          }
          return result;
        }
        function functionClone(arg) {
          if (typeof arg === "undefined") {
            return void 0;
          }
          return JSON.parse(fn.string(arg));
        }
        function createFrame(enclosingEnvironment) {
          var bindings = {};
          const newFrame = {
            bind: function(name, value) {
              bindings[name] = value;
            },
            lookup: function(name) {
              var value;
              if (bindings.hasOwnProperty(name)) {
                value = bindings[name];
              } else if (enclosingEnvironment) {
                value = enclosingEnvironment.lookup(name);
              }
              return value;
            },
            timestamp: enclosingEnvironment ? enclosingEnvironment.timestamp : null,
            async: enclosingEnvironment ? enclosingEnvironment.async : false,
            isParallelCall: enclosingEnvironment ? enclosingEnvironment.isParallelCall : false,
            global: enclosingEnvironment ? enclosingEnvironment.global : {
              ancestry: [null]
            }
          };
          if (enclosingEnvironment) {
            var framePushCallback = enclosingEnvironment.lookup(Symbol.for("jsonata.__createFrame_push"));
            if (framePushCallback) {
              framePushCallback(enclosingEnvironment, newFrame);
            }
          }
          return newFrame;
        }
        staticFrame.bind("sum", defineFunction(fn.sum, "<a<n>:n>"));
        staticFrame.bind("count", defineFunction(fn.count, "<a:n>"));
        staticFrame.bind("max", defineFunction(fn.max, "<a<n>:n>"));
        staticFrame.bind("min", defineFunction(fn.min, "<a<n>:n>"));
        staticFrame.bind("average", defineFunction(fn.average, "<a<n>:n>"));
        staticFrame.bind("string", defineFunction(fn.string, "<x-b?:s>"));
        staticFrame.bind("substring", defineFunction(fn.substring, "<s-nn?:s>"));
        staticFrame.bind("substringBefore", defineFunction(fn.substringBefore, "<s-s:s>"));
        staticFrame.bind("substringAfter", defineFunction(fn.substringAfter, "<s-s:s>"));
        staticFrame.bind("lowercase", defineFunction(fn.lowercase, "<s-:s>"));
        staticFrame.bind("uppercase", defineFunction(fn.uppercase, "<s-:s>"));
        staticFrame.bind("length", defineFunction(fn.length, "<s-:n>"));
        staticFrame.bind("trim", defineFunction(fn.trim, "<s-:s>"));
        staticFrame.bind("pad", defineFunction(fn.pad, "<s-ns?:s>"));
        staticFrame.bind("match", defineFunction(fn.match, "<s-f<s:o>n?:a<o>>"));
        staticFrame.bind("contains", defineFunction(fn.contains, "<s-(sf):b>"));
        staticFrame.bind("replace", defineFunction(fn.replace, "<s-(sf)(sf)n?:s>"));
        staticFrame.bind("split", defineFunction(fn.split, "<s-(sf)n?:a<s>>"));
        staticFrame.bind("join", defineFunction(fn.join, "<a<s>s?:s>"));
        staticFrame.bind("formatNumber", defineFunction(fn.formatNumber, "<n-so?:s>"));
        staticFrame.bind("formatBase", defineFunction(fn.formatBase, "<n-n?:s>"));
        staticFrame.bind("formatInteger", defineFunction(datetime.formatInteger, "<n-s:s>"));
        staticFrame.bind("parseInteger", defineFunction(datetime.parseInteger, "<s-s:n>"));
        staticFrame.bind("number", defineFunction(fn.number, "<(nsb)-:n>"));
        staticFrame.bind("floor", defineFunction(fn.floor, "<n-:n>"));
        staticFrame.bind("ceil", defineFunction(fn.ceil, "<n-:n>"));
        staticFrame.bind("round", defineFunction(fn.round, "<n-n?:n>"));
        staticFrame.bind("abs", defineFunction(fn.abs, "<n-:n>"));
        staticFrame.bind("sqrt", defineFunction(fn.sqrt, "<n-:n>"));
        staticFrame.bind("power", defineFunction(fn.power, "<n-n:n>"));
        staticFrame.bind("random", defineFunction(fn.random, "<:n>"));
        staticFrame.bind("boolean", defineFunction(fn.boolean, "<x-:b>"));
        staticFrame.bind("not", defineFunction(fn.not, "<x-:b>"));
        staticFrame.bind("map", defineFunction(fn.map, "<af>"));
        staticFrame.bind("zip", defineFunction(fn.zip, "<a+>"));
        staticFrame.bind("filter", defineFunction(fn.filter, "<af>"));
        staticFrame.bind("single", defineFunction(fn.single, "<af?>"));
        staticFrame.bind("reduce", defineFunction(fn.foldLeft, "<afj?:j>"));
        staticFrame.bind("sift", defineFunction(fn.sift, "<o-f?:o>"));
        staticFrame.bind("keys", defineFunction(fn.keys, "<x-:a<s>>"));
        staticFrame.bind("lookup", defineFunction(fn.lookup, "<x-s:x>"));
        staticFrame.bind("append", defineFunction(fn.append, "<xx:a>"));
        staticFrame.bind("exists", defineFunction(fn.exists, "<x:b>"));
        staticFrame.bind("spread", defineFunction(fn.spread, "<x-:a<o>>"));
        staticFrame.bind("merge", defineFunction(fn.merge, "<a<o>:o>"));
        staticFrame.bind("reverse", defineFunction(fn.reverse, "<a:a>"));
        staticFrame.bind("each", defineFunction(fn.each, "<o-f:a>"));
        staticFrame.bind("error", defineFunction(fn.error, "<s?:x>"));
        staticFrame.bind("assert", defineFunction(fn.assert, "<bs?:x>"));
        staticFrame.bind("type", defineFunction(fn.type, "<x:s>"));
        staticFrame.bind("sort", defineFunction(fn.sort, "<af?:a>"));
        staticFrame.bind("shuffle", defineFunction(fn.shuffle, "<a:a>"));
        staticFrame.bind("distinct", defineFunction(fn.distinct, "<x:x>"));
        staticFrame.bind("base64encode", defineFunction(fn.base64encode, "<s-:s>"));
        staticFrame.bind("base64decode", defineFunction(fn.base64decode, "<s-:s>"));
        staticFrame.bind("encodeUrlComponent", defineFunction(fn.encodeUrlComponent, "<s-:s>"));
        staticFrame.bind("encodeUrl", defineFunction(fn.encodeUrl, "<s-:s>"));
        staticFrame.bind("decodeUrlComponent", defineFunction(fn.decodeUrlComponent, "<s-:s>"));
        staticFrame.bind("decodeUrl", defineFunction(fn.decodeUrl, "<s-:s>"));
        staticFrame.bind("eval", defineFunction(functionEval, "<sx?:x>"));
        staticFrame.bind("toMillis", defineFunction(datetime.toMillis, "<s-s?:n>"));
        staticFrame.bind("fromMillis", defineFunction(datetime.fromMillis, "<n-s?s?:s>"));
        staticFrame.bind("clone", defineFunction(functionClone, "<(oa)-:o>"));
        var errorCodes = {
          "S0101": "String literal must be terminated by a matching quote",
          "S0102": "Number out of range: {{token}}",
          "S0103": "Unsupported escape sequence: \\{{token}}",
          "S0104": "The escape sequence \\u must be followed by 4 hex digits",
          "S0105": "Quoted property name must be terminated with a backquote (`)",
          "S0106": "Comment has no closing tag",
          "S0201": "Syntax error: {{token}}",
          "S0202": "Expected {{value}}, got {{token}}",
          "S0203": "Expected {{value}} before end of expression",
          "S0204": "Unknown operator: {{token}}",
          "S0205": "Unexpected token: {{token}}",
          "S0206": "Unknown expression type: {{token}}",
          "S0207": "Unexpected end of expression",
          "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
          "S0209": "A predicate cannot follow a grouping expression in a step",
          "S0210": "Each step can only have one grouping expression",
          "S0211": "The symbol {{token}} cannot be used as a unary operator",
          "S0212": "The left side of := must be a variable name (start with $)",
          "S0213": "The literal value {{value}} cannot be used as a step within a path expression",
          "S0214": "The right side of {{token}} must be a variable name (start with $)",
          "S0215": "A context variable binding must precede any predicates on a step",
          "S0216": "A context variable binding must precede the 'order-by' clause on a step",
          "S0217": "The object representing the 'parent' cannot be derived from this expression",
          "S0301": "Empty regular expressions are not allowed",
          "S0302": "No terminating / in regular expression",
          "S0402": "Choice groups containing parameterized types are not supported",
          "S0401": "Type parameters can only be applied to functions and arrays",
          "S0500": "Attempted to evaluate an expression containing syntax error(s)",
          "T0410": "Argument {{index}} of function {{token}} does not match function signature",
          "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
          "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
          "D1001": "Number out of range: {{value}}",
          "D1002": "Cannot negate a non-numeric value: {{value}}",
          "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
          "D1004": "Regular expression matches zero length string",
          "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
          "T1006": "Attempted to invoke a non-function",
          "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
          "T1008": "Attempted to partially apply a non-function",
          "D1009": "Multiple key definitions evaluate to same key: {{value}}",
          "D1010": "Attempted to access the Javascript object prototype",
          // Javascript specific 
          "T1010": "The matcher function argument passed to function {{token}} does not return the correct object structure",
          "T2001": "The left side of the {{token}} operator must evaluate to a number",
          "T2002": "The right side of the {{token}} operator must evaluate to a number",
          "T2003": "The left side of the range operator (..) must evaluate to an integer",
          "T2004": "The right side of the range operator (..) must evaluate to an integer",
          "D2005": "The left side of := must be a variable name (start with $)",
          // defunct - replaced by S0212 parser error
          "T2006": "The right side of the function application operator ~> must be a function",
          "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
          "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
          "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
          "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
          "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
          "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
          "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
          "D2014": "The size of the sequence allocated by the range operator (..) must not exceed 1e6.  Attempted to allocate {{value}}.",
          "D3001": "Attempting to invoke string function on Infinity or NaN",
          "D3010": "Second argument of replace function cannot be an empty string",
          "D3011": "Fourth argument of replace function must evaluate to a positive number",
          "D3012": "Attempted to replace a matched string with a non-string value",
          "D3020": "Third argument of split function must evaluate to a positive number",
          "D3030": "Unable to cast value to a number: {{value}}",
          "D3040": "Third argument of match function must evaluate to a positive number",
          "D3050": "The second argument of reduce function must be a function with at least two arguments",
          "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
          "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
          "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
          "D3080": "The picture string must only contain a maximum of two sub-pictures",
          "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
          "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
          "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
          "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
          "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
          "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
          "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
          "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
          "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
          "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
          "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
          "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
          "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
          "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
          "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}",
          "D3120": "Syntax error in expression passed to function eval: {{value}}",
          "D3121": "Dynamic error evaluating the expression passed to function eval: {{value}}",
          "D3130": "Formatting or parsing an integer as a sequence starting with {{value}} is not supported by this implementation",
          "D3131": "In a decimal digit pattern, all digits must be from the same decimal group",
          "D3132": "Unknown component specifier {{value}} in date/time picture string",
          "D3133": "The 'name' modifier can only be applied to months and days in the date/time picture string, not {{value}}",
          "D3134": "The timezone integer format specifier cannot have more than four digits",
          "D3135": "No matching closing bracket ']' in date/time picture string",
          "D3136": "The date/time picture string is missing specifiers required to parse the timestamp",
          "D3137": "{{{message}}}",
          "D3138": "The $single() function expected exactly 1 matching result.  Instead it matched more.",
          "D3139": "The $single() function expected exactly 1 matching result.  Instead it matched 0.",
          "D3140": "Malformed URL passed to ${{{functionName}}}(): {{value}}",
          "D3141": "{{{message}}}"
        };
        function populateMessage(err) {
          var template = errorCodes[err.code];
          if (typeof template !== "undefined") {
            var message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
              return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
              return JSON.stringify(err[arguments[1]]);
            });
            err.message = message;
          }
        }
        function jsonata3(expr, options) {
          var ast;
          var errors;
          try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
          } catch (err) {
            populateMessage(err);
            throw err;
          }
          var environment = createFrame(staticFrame);
          var timestamp = /* @__PURE__ */ new Date();
          environment.bind("now", defineFunction(function(picture, timezone) {
            return datetime.fromMillis(timestamp.getTime(), picture, timezone);
          }, "<s?s?:s>"));
          environment.bind("millis", defineFunction(function() {
            return timestamp.getTime();
          }, "<:n>"));
          if (options && options.RegexEngine) {
            jsonata3.RegexEngine = options.RegexEngine;
          } else {
            jsonata3.RegexEngine = RegExp;
          }
          return {
            evaluate: async function(input, bindings, callback) {
              if (typeof errors !== "undefined") {
                var err = {
                  code: "S0500",
                  position: 0
                };
                populateMessage(err);
                throw err;
              }
              if (typeof bindings !== "undefined") {
                var exec_env;
                exec_env = createFrame(environment);
                for (var v2 in bindings) {
                  exec_env.bind(v2, bindings[v2]);
                }
              } else {
                exec_env = environment;
              }
              exec_env.bind("$", input);
              timestamp = /* @__PURE__ */ new Date();
              exec_env.timestamp = timestamp;
              if (Array.isArray(input) && !isSequence(input)) {
                input = createSequence(input);
                input.outerWrapper = true;
              }
              var it;
              try {
                it = await evaluate(ast, input, exec_env);
                if (typeof callback === "function") {
                  callback(null, it);
                }
                return it;
              } catch (err2) {
                populateMessage(err2);
                throw err2;
              }
            },
            assign: function(name, value) {
              environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
              var func = defineFunction(implementation, signature);
              environment.bind(name, func);
            },
            ast: function() {
              return ast;
            },
            errors: function() {
              return errors;
            }
          };
        }
        jsonata3.parser = parser;
        return jsonata3;
      }();
      module2.exports = jsonata2;
    }, { "./datetime": 1, "./functions": 2, "./parser": 4, "./signature": 5, "./utils": 6 }], 4: [function(require2, module2, exports2) {
      var parseSignature = require2("./signature");
      const parser = /* @__PURE__ */ (() => {
        var operators = {
          ".": 75,
          "[": 80,
          "]": 0,
          "{": 70,
          "}": 0,
          "(": 80,
          ")": 0,
          ",": 0,
          "@": 80,
          "#": 80,
          ";": 80,
          ":": 80,
          "?": 20,
          "+": 50,
          "-": 50,
          "*": 60,
          "/": 60,
          "%": 60,
          "|": 20,
          "=": 40,
          "<": 40,
          ">": 40,
          "^": 40,
          "**": 60,
          "..": 20,
          ":=": 10,
          "!=": 40,
          "<=": 40,
          ">=": 40,
          "~>": 40,
          "and": 30,
          "or": 25,
          "in": 40,
          "&": 50,
          "!": 0,
          // not an operator, but needed as a stop character for name tokens
          "~": 0
          // not an operator, but needed as a stop character for name tokens
        };
        var escapes = {
          // JSON string escape sequences - see json.org
          '"': '"',
          "\\": "\\",
          "/": "/",
          "b": "\b",
          "f": "\f",
          "n": "\n",
          "r": "\r",
          "t": "	"
        };
        var tokenizer2 = function(path2) {
          var position2 = 0;
          var length2 = path2.length;
          var create2 = function(type2, value) {
            var obj = { type: type2, value, position: position2 };
            return obj;
          };
          var scanRegex = function() {
            var start = position2;
            var depth = 0;
            var pattern;
            var flags;
            var isClosingSlash = function(position3) {
              if (path2.charAt(position3) === "/" && depth === 0) {
                var backslashCount = 0;
                while (path2.charAt(position3 - (backslashCount + 1)) === "\\") {
                  backslashCount++;
                }
                if (backslashCount % 2 === 0) {
                  return true;
                }
              }
              return false;
            };
            while (position2 < length2) {
              var currentChar = path2.charAt(position2);
              if (isClosingSlash(position2)) {
                pattern = path2.substring(start, position2);
                if (pattern === "") {
                  throw {
                    code: "S0301",
                    stack: new Error().stack,
                    position: position2
                  };
                }
                position2++;
                currentChar = path2.charAt(position2);
                start = position2;
                while (currentChar === "i" || currentChar === "m") {
                  position2++;
                  currentChar = path2.charAt(position2);
                }
                flags = path2.substring(start, position2) + "g";
                return new RegExp(pattern, flags);
              }
              if ((currentChar === "(" || currentChar === "[" || currentChar === "{") && path2.charAt(position2 - 1) !== "\\") {
                depth++;
              }
              if ((currentChar === ")" || currentChar === "]" || currentChar === "}") && path2.charAt(position2 - 1) !== "\\") {
                depth--;
              }
              position2++;
            }
            throw {
              code: "S0302",
              stack: new Error().stack,
              position: position2
            };
          };
          var next2 = function(prefix2) {
            if (position2 >= length2) return null;
            var currentChar = path2.charAt(position2);
            while (position2 < length2 && " 	\n\r\v".indexOf(currentChar) > -1) {
              position2++;
              currentChar = path2.charAt(position2);
            }
            if (currentChar === "/" && path2.charAt(position2 + 1) === "*") {
              var commentStart = position2;
              position2 += 2;
              currentChar = path2.charAt(position2);
              while (!(currentChar === "*" && path2.charAt(position2 + 1) === "/")) {
                currentChar = path2.charAt(++position2);
                if (position2 >= length2) {
                  throw {
                    code: "S0106",
                    stack: new Error().stack,
                    position: commentStart
                  };
                }
              }
              position2 += 2;
              currentChar = path2.charAt(position2);
              return next2(prefix2);
            }
            if (prefix2 !== true && currentChar === "/") {
              position2++;
              return create2("regex", scanRegex());
            }
            if (currentChar === "." && path2.charAt(position2 + 1) === ".") {
              position2 += 2;
              return create2("operator", "..");
            }
            if (currentChar === ":" && path2.charAt(position2 + 1) === "=") {
              position2 += 2;
              return create2("operator", ":=");
            }
            if (currentChar === "!" && path2.charAt(position2 + 1) === "=") {
              position2 += 2;
              return create2("operator", "!=");
            }
            if (currentChar === ">" && path2.charAt(position2 + 1) === "=") {
              position2 += 2;
              return create2("operator", ">=");
            }
            if (currentChar === "<" && path2.charAt(position2 + 1) === "=") {
              position2 += 2;
              return create2("operator", "<=");
            }
            if (currentChar === "*" && path2.charAt(position2 + 1) === "*") {
              position2 += 2;
              return create2("operator", "**");
            }
            if (currentChar === "~" && path2.charAt(position2 + 1) === ">") {
              position2 += 2;
              return create2("operator", "~>");
            }
            if (Object.prototype.hasOwnProperty.call(operators, currentChar)) {
              position2++;
              return create2("operator", currentChar);
            }
            if (currentChar === '"' || currentChar === "'") {
              var quoteType = currentChar;
              position2++;
              var qstr = "";
              while (position2 < length2) {
                currentChar = path2.charAt(position2);
                if (currentChar === "\\") {
                  position2++;
                  currentChar = path2.charAt(position2);
                  if (Object.prototype.hasOwnProperty.call(escapes, currentChar)) {
                    qstr += escapes[currentChar];
                  } else if (currentChar === "u") {
                    var octets = path2.substr(position2 + 1, 4);
                    if (/^[0-9a-fA-F]+$/.test(octets)) {
                      var codepoint = parseInt(octets, 16);
                      qstr += String.fromCharCode(codepoint);
                      position2 += 4;
                    } else {
                      throw {
                        code: "S0104",
                        stack: new Error().stack,
                        position: position2
                      };
                    }
                  } else {
                    throw {
                      code: "S0103",
                      stack: new Error().stack,
                      position: position2,
                      token: currentChar
                    };
                  }
                } else if (currentChar === quoteType) {
                  position2++;
                  return create2("string", qstr);
                } else {
                  qstr += currentChar;
                }
                position2++;
              }
              throw {
                code: "S0101",
                stack: new Error().stack,
                position: position2
              };
            }
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match2 = numregex.exec(path2.substring(position2));
            if (match2 !== null) {
              var num = parseFloat(match2[0]);
              if (!isNaN(num) && isFinite(num)) {
                position2 += match2[0].length;
                return create2("number", num);
              } else {
                throw {
                  code: "S0102",
                  stack: new Error().stack,
                  position: position2,
                  token: match2[0]
                };
              }
            }
            var name;
            if (currentChar === "`") {
              position2++;
              var end = path2.indexOf("`", position2);
              if (end !== -1) {
                name = path2.substring(position2, end);
                position2 = end + 1;
                return create2("name", name);
              }
              position2 = length2;
              throw {
                code: "S0105",
                stack: new Error().stack,
                position: position2
              };
            }
            var i2 = position2;
            var ch2;
            for (; ; ) {
              ch2 = path2.charAt(i2);
              if (i2 === length2 || " 	\n\r\v".indexOf(ch2) > -1 || Object.prototype.hasOwnProperty.call(operators, ch2)) {
                if (path2.charAt(position2) === "$") {
                  name = path2.substring(position2 + 1, i2);
                  position2 = i2;
                  return create2("variable", name);
                } else {
                  name = path2.substring(position2, i2);
                  position2 = i2;
                  switch (name) {
                    case "or":
                    case "in":
                    case "and":
                      return create2("operator", name);
                    case "true":
                      return create2("value", true);
                    case "false":
                      return create2("value", false);
                    case "null":
                      return create2("value", null);
                    default:
                      if (position2 === length2 && name === "") {
                        return null;
                      }
                      return create2("name", name);
                  }
                }
              } else {
                i2++;
              }
            }
          };
          return next2;
        };
        var parser2 = function(source, recover) {
          var node2;
          var lexer;
          var symbol_table = {};
          var errors = [];
          var remainingTokens = function() {
            var remaining = [];
            if (node2.id !== "(end)") {
              remaining.push({ type: node2.type, value: node2.value, position: node2.position });
            }
            var nxt = lexer();
            while (nxt !== null) {
              remaining.push(nxt);
              nxt = lexer();
            }
            return remaining;
          };
          var base_symbol = {
            nud: function() {
              var err2 = {
                code: "S0211",
                token: this.value,
                position: this.position
              };
              if (recover) {
                err2.remaining = remainingTokens();
                err2.type = "error";
                errors.push(err2);
                return err2;
              } else {
                err2.stack = new Error().stack;
                throw err2;
              }
            }
          };
          var symbol = function(id2, bp) {
            var s = symbol_table[id2];
            bp = bp || 0;
            if (s) {
              if (bp >= s.lbp) {
                s.lbp = bp;
              }
            } else {
              s = Object.create(base_symbol);
              s.id = s.value = id2;
              s.lbp = bp;
              symbol_table[id2] = s;
            }
            return s;
          };
          var handleError = function(err2) {
            if (recover) {
              err2.remaining = remainingTokens();
              errors.push(err2);
              var symbol2 = symbol_table["(error)"];
              node2 = Object.create(symbol2);
              node2.error = err2;
              node2.type = "(error)";
              return node2;
            } else {
              err2.stack = new Error().stack;
              throw err2;
            }
          };
          var advance2 = function(id2, infix2) {
            if (id2 && node2.id !== id2) {
              var code2;
              if (node2.id === "(end)") {
                code2 = "S0203";
              } else {
                code2 = "S0202";
              }
              var err2 = {
                code: code2,
                position: node2.position,
                token: node2.value,
                value: id2
              };
              return handleError(err2);
            }
            var next_token = lexer(infix2);
            if (next_token === null) {
              node2 = symbol_table["(end)"];
              node2.position = source.length;
              return node2;
            }
            var value = next_token.value;
            var type2 = next_token.type;
            var symbol2;
            switch (type2) {
              case "name":
              case "variable":
                symbol2 = symbol_table["(name)"];
                break;
              case "operator":
                symbol2 = symbol_table[value];
                if (!symbol2) {
                  return handleError({
                    code: "S0204",
                    stack: new Error().stack,
                    position: next_token.position,
                    token: value
                  });
                }
                break;
              case "string":
              case "number":
              case "value":
                symbol2 = symbol_table["(literal)"];
                break;
              case "regex":
                type2 = "regex";
                symbol2 = symbol_table["(regex)"];
                break;
              default:
                return handleError({
                  code: "S0205",
                  stack: new Error().stack,
                  position: next_token.position,
                  token: value
                });
            }
            node2 = Object.create(symbol2);
            node2.value = value;
            node2.type = type2;
            node2.position = next_token.position;
            return node2;
          };
          var expression = function(rbp) {
            var left;
            var t2 = node2;
            advance2(null, true);
            left = t2.nud();
            while (rbp < node2.lbp) {
              t2 = node2;
              advance2();
              left = t2.led(left);
            }
            return left;
          };
          var terminal = function(id2) {
            var s = symbol(id2, 0);
            s.nud = function() {
              return this;
            };
          };
          var infix = function(id2, bp, led) {
            var bindingPower = bp || operators[id2];
            var s = symbol(id2, bindingPower);
            s.led = led || function(left) {
              this.lhs = left;
              this.rhs = expression(bindingPower);
              this.type = "binary";
              return this;
            };
            return s;
          };
          var infixr = function(id2, bp, led) {
            var s = symbol(id2, bp);
            s.led = led;
            return s;
          };
          var prefix2 = function(id2, nud) {
            var s = symbol(id2);
            s.nud = nud || function() {
              this.expression = expression(70);
              this.type = "unary";
              return this;
            };
            return s;
          };
          terminal("(end)");
          terminal("(name)");
          terminal("(literal)");
          terminal("(regex)");
          symbol(":");
          symbol(";");
          symbol(",");
          symbol(")");
          symbol("]");
          symbol("}");
          symbol("..");
          infix(".");
          infix("+");
          infix("-");
          infix("*");
          infix("/");
          infix("%");
          infix("=");
          infix("<");
          infix(">");
          infix("!=");
          infix("<=");
          infix(">=");
          infix("&");
          infix("and");
          infix("or");
          infix("in");
          terminal("and");
          terminal("or");
          terminal("in");
          prefix2("-");
          infix("~>");
          infixr("(error)", 10, function(left) {
            this.lhs = left;
            this.error = node2.error;
            this.remaining = remainingTokens();
            this.type = "error";
            return this;
          });
          prefix2("*", function() {
            this.type = "wildcard";
            return this;
          });
          prefix2("**", function() {
            this.type = "descendant";
            return this;
          });
          prefix2("%", function() {
            this.type = "parent";
            return this;
          });
          infix("(", operators["("], function(left) {
            this.procedure = left;
            this.type = "function";
            this.arguments = [];
            if (node2.id !== ")") {
              for (; ; ) {
                if (node2.type === "operator" && node2.id === "?") {
                  this.type = "partial";
                  this.arguments.push(node2);
                  advance2("?");
                } else {
                  this.arguments.push(expression(0));
                }
                if (node2.id !== ",") break;
                advance2(",");
              }
            }
            advance2(")", true);
            if (left.type === "name" && (left.value === "function" || left.value === "")) {
              this.arguments.forEach(function(arg, index2) {
                if (arg.type !== "variable") {
                  return handleError({
                    code: "S0208",
                    stack: new Error().stack,
                    position: arg.position,
                    token: arg.value,
                    value: index2 + 1
                  });
                }
              });
              this.type = "lambda";
              if (node2.id === "<") {
                var sigPos = node2.position;
                var depth = 1;
                var sig = "<";
                while (depth > 0 && node2.id !== "{" && node2.id !== "(end)") {
                  var tok = advance2();
                  if (tok.id === ">") {
                    depth--;
                  } else if (tok.id === "<") {
                    depth++;
                  }
                  sig += tok.value;
                }
                advance2(">");
                try {
                  this.signature = parseSignature(sig);
                } catch (err2) {
                  err2.position = sigPos + err2.offset;
                  return handleError(err2);
                }
              }
              advance2("{");
              this.body = expression(0);
              advance2("}");
            }
            return this;
          });
          prefix2("(", function() {
            var expressions = [];
            while (node2.id !== ")") {
              expressions.push(expression(0));
              if (node2.id !== ";") {
                break;
              }
              advance2(";");
            }
            advance2(")", true);
            this.type = "block";
            this.expressions = expressions;
            return this;
          });
          prefix2("[", function() {
            var a = [];
            if (node2.id !== "]") {
              for (; ; ) {
                var item = expression(0);
                if (node2.id === "..") {
                  var range = { type: "binary", value: "..", position: node2.position, lhs: item };
                  advance2("..");
                  range.rhs = expression(0);
                  item = range;
                }
                a.push(item);
                if (node2.id !== ",") {
                  break;
                }
                advance2(",");
              }
            }
            advance2("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
          });
          infix("[", operators["["], function(left) {
            if (node2.id === "]") {
              var step = left;
              while (step && step.type === "binary" && step.value === "[") {
                step = step.lhs;
              }
              step.keepArray = true;
              advance2("]");
              return left;
            } else {
              this.lhs = left;
              this.rhs = expression(operators["]"]);
              this.type = "binary";
              advance2("]", true);
              return this;
            }
          });
          infix("^", operators["^"], function(left) {
            advance2("(");
            var terms = [];
            for (; ; ) {
              var term = {
                descending: false
              };
              if (node2.id === "<") {
                advance2("<");
              } else if (node2.id === ">") {
                term.descending = true;
                advance2(">");
              } else ;
              term.expression = expression(0);
              terms.push(term);
              if (node2.id !== ",") {
                break;
              }
              advance2(",");
            }
            advance2(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = "binary";
            return this;
          });
          var objectParser = function(left) {
            var a = [];
            if (node2.id !== "}") {
              for (; ; ) {
                var n2 = expression(0);
                advance2(":");
                var v2 = expression(0);
                a.push([n2, v2]);
                if (node2.id !== ",") {
                  break;
                }
                advance2(",");
              }
            }
            advance2("}", true);
            if (typeof left === "undefined") {
              this.lhs = a;
              this.type = "unary";
            } else {
              this.lhs = left;
              this.rhs = a;
              this.type = "binary";
            }
            return this;
          };
          prefix2("{", objectParser);
          infix("{", operators["{"], objectParser);
          infixr(":=", operators[":="], function(left) {
            if (left.type !== "variable") {
              return handleError({
                code: "S0212",
                stack: new Error().stack,
                position: left.position,
                token: left.value
              });
            }
            this.lhs = left;
            this.rhs = expression(operators[":="] - 1);
            this.type = "binary";
            return this;
          });
          infix("@", operators["@"], function(left) {
            this.lhs = left;
            this.rhs = expression(operators["@"]);
            if (this.rhs.type !== "variable") {
              return handleError({
                code: "S0214",
                stack: new Error().stack,
                position: this.rhs.position,
                token: "@"
              });
            }
            this.type = "binary";
            return this;
          });
          infix("#", operators["#"], function(left) {
            this.lhs = left;
            this.rhs = expression(operators["#"]);
            if (this.rhs.type !== "variable") {
              return handleError({
                code: "S0214",
                stack: new Error().stack,
                position: this.rhs.position,
                token: "#"
              });
            }
            this.type = "binary";
            return this;
          });
          infix("?", operators["?"], function(left) {
            this.type = "condition";
            this.condition = left;
            this.then = expression(0);
            if (node2.id === ":") {
              advance2(":");
              this.else = expression(0);
            }
            return this;
          });
          prefix2("|", function() {
            this.type = "transform";
            this.pattern = expression(0);
            advance2("|");
            this.update = expression(0);
            if (node2.id === ",") {
              advance2(",");
              this.delete = expression(0);
            }
            advance2("|");
            return this;
          });
          var tailCallOptimize = function(expr2) {
            var result;
            if (expr2.type === "function" && !expr2.predicate) {
              var thunk = { type: "lambda", thunk: true, arguments: [], position: expr2.position };
              thunk.body = expr2;
              result = thunk;
            } else if (expr2.type === "condition") {
              expr2.then = tailCallOptimize(expr2.then);
              if (typeof expr2.else !== "undefined") {
                expr2.else = tailCallOptimize(expr2.else);
              }
              result = expr2;
            } else if (expr2.type === "block") {
              var length2 = expr2.expressions.length;
              if (length2 > 0) {
                expr2.expressions[length2 - 1] = tailCallOptimize(expr2.expressions[length2 - 1]);
              }
              result = expr2;
            } else {
              result = expr2;
            }
            return result;
          };
          var ancestorLabel = 0;
          var ancestorIndex = 0;
          var ancestry = [];
          var seekParent = function(node3, slot) {
            switch (node3.type) {
              case "name":
              case "wildcard":
                slot.level--;
                if (slot.level === 0) {
                  if (typeof node3.ancestor === "undefined") {
                    node3.ancestor = slot;
                  } else {
                    ancestry[slot.index].slot.label = node3.ancestor.label;
                    node3.ancestor = slot;
                  }
                  node3.tuple = true;
                }
                break;
              case "parent":
                slot.level++;
                break;
              case "block":
                if (node3.expressions.length > 0) {
                  node3.tuple = true;
                  slot = seekParent(node3.expressions[node3.expressions.length - 1], slot);
                }
                break;
              case "path":
                node3.tuple = true;
                var index2 = node3.steps.length - 1;
                slot = seekParent(node3.steps[index2--], slot);
                while (slot.level > 0 && index2 >= 0) {
                  slot = seekParent(node3.steps[index2--], slot);
                }
                break;
              default:
                throw {
                  code: "S0217",
                  token: node3.type,
                  position: node3.position
                };
            }
            return slot;
          };
          var pushAncestry = function(result, value) {
            if (typeof value.seekingParent !== "undefined" || value.type === "parent") {
              var slots = typeof value.seekingParent !== "undefined" ? value.seekingParent : [];
              if (value.type === "parent") {
                slots.push(value.slot);
              }
              if (typeof result.seekingParent === "undefined") {
                result.seekingParent = slots;
              } else {
                Array.prototype.push.apply(result.seekingParent, slots);
              }
            }
          };
          var resolveAncestry = function(path2) {
            var index2 = path2.steps.length - 1;
            var laststep = path2.steps[index2];
            var slots = typeof laststep.seekingParent !== "undefined" ? laststep.seekingParent : [];
            if (laststep.type === "parent") {
              slots.push(laststep.slot);
            }
            for (var is = 0; is < slots.length; is++) {
              var slot = slots[is];
              index2 = path2.steps.length - 2;
              while (slot.level > 0) {
                if (index2 < 0) {
                  if (typeof path2.seekingParent === "undefined") {
                    path2.seekingParent = [slot];
                  } else {
                    path2.seekingParent.push(slot);
                  }
                  break;
                }
                var step = path2.steps[index2--];
                while (index2 >= 0 && step.focus && path2.steps[index2].focus) {
                  step = path2.steps[index2--];
                }
                slot = seekParent(step, slot);
              }
            }
          };
          var processAST = function(expr2) {
            var result;
            switch (expr2.type) {
              case "binary":
                switch (expr2.value) {
                  case ".":
                    var lstep = processAST(expr2.lhs);
                    if (lstep.type === "path") {
                      result = lstep;
                    } else {
                      result = { type: "path", steps: [lstep] };
                    }
                    if (lstep.type === "parent") {
                      result.seekingParent = [lstep.slot];
                    }
                    var rest = processAST(expr2.rhs);
                    if (rest.type === "function" && rest.procedure.type === "path" && rest.procedure.steps.length === 1 && rest.procedure.steps[0].type === "name" && result.steps[result.steps.length - 1].type === "function") {
                      result.steps[result.steps.length - 1].nextFunction = rest.procedure.steps[0].value;
                    }
                    if (rest.type === "path") {
                      Array.prototype.push.apply(result.steps, rest.steps);
                    } else {
                      if (typeof rest.predicate !== "undefined") {
                        rest.stages = rest.predicate;
                        delete rest.predicate;
                      }
                      result.steps.push(rest);
                    }
                    result.steps.filter(function(step2) {
                      if (step2.type === "number" || step2.type === "value") {
                        throw {
                          code: "S0213",
                          stack: new Error().stack,
                          position: step2.position,
                          value: step2.value
                        };
                      }
                      return step2.type === "string";
                    }).forEach(function(lit) {
                      lit.type = "name";
                    });
                    if (result.steps.filter(function(step2) {
                      return step2.keepArray === true;
                    }).length > 0) {
                      result.keepSingletonArray = true;
                    }
                    var firststep = result.steps[0];
                    if (firststep.type === "unary" && firststep.value === "[") {
                      firststep.consarray = true;
                    }
                    var laststep = result.steps[result.steps.length - 1];
                    if (laststep.type === "unary" && laststep.value === "[") {
                      laststep.consarray = true;
                    }
                    resolveAncestry(result);
                    break;
                  case "[":
                    result = processAST(expr2.lhs);
                    var step = result;
                    var type2 = "predicate";
                    if (result.type === "path") {
                      step = result.steps[result.steps.length - 1];
                      type2 = "stages";
                    }
                    if (typeof step.group !== "undefined") {
                      throw {
                        code: "S0209",
                        stack: new Error().stack,
                        position: expr2.position
                      };
                    }
                    if (typeof step[type2] === "undefined") {
                      step[type2] = [];
                    }
                    var predicate = processAST(expr2.rhs);
                    if (typeof predicate.seekingParent !== "undefined") {
                      predicate.seekingParent.forEach((slot) => {
                        if (slot.level === 1) {
                          seekParent(step, slot);
                        } else {
                          slot.level--;
                        }
                      });
                      pushAncestry(step, predicate);
                    }
                    step[type2].push({ type: "filter", expr: predicate, position: expr2.position });
                    break;
                  case "{":
                    result = processAST(expr2.lhs);
                    if (typeof result.group !== "undefined") {
                      throw {
                        code: "S0210",
                        stack: new Error().stack,
                        position: expr2.position
                      };
                    }
                    result.group = {
                      lhs: expr2.rhs.map(function(pair) {
                        return [processAST(pair[0]), processAST(pair[1])];
                      }),
                      position: expr2.position
                    };
                    break;
                  case "^":
                    result = processAST(expr2.lhs);
                    if (result.type !== "path") {
                      result = { type: "path", steps: [result] };
                    }
                    var sortStep = { type: "sort", position: expr2.position };
                    sortStep.terms = expr2.rhs.map(function(terms) {
                      var expression2 = processAST(terms.expression);
                      pushAncestry(sortStep, expression2);
                      return {
                        descending: terms.descending,
                        expression: expression2
                      };
                    });
                    result.steps.push(sortStep);
                    resolveAncestry(result);
                    break;
                  case ":=":
                    result = { type: "bind", value: expr2.value, position: expr2.position };
                    result.lhs = processAST(expr2.lhs);
                    result.rhs = processAST(expr2.rhs);
                    pushAncestry(result, result.rhs);
                    break;
                  case "@":
                    result = processAST(expr2.lhs);
                    step = result;
                    if (result.type === "path") {
                      step = result.steps[result.steps.length - 1];
                    }
                    if (typeof step.stages !== "undefined" || typeof step.predicate !== "undefined") {
                      throw {
                        code: "S0215",
                        stack: new Error().stack,
                        position: expr2.position
                      };
                    }
                    if (step.type === "sort") {
                      throw {
                        code: "S0216",
                        stack: new Error().stack,
                        position: expr2.position
                      };
                    }
                    if (expr2.keepArray) {
                      step.keepArray = true;
                    }
                    step.focus = expr2.rhs.value;
                    step.tuple = true;
                    break;
                  case "#":
                    result = processAST(expr2.lhs);
                    step = result;
                    if (result.type === "path") {
                      step = result.steps[result.steps.length - 1];
                    } else {
                      result = { type: "path", steps: [result] };
                      if (typeof step.predicate !== "undefined") {
                        step.stages = step.predicate;
                        delete step.predicate;
                      }
                    }
                    if (typeof step.stages === "undefined") {
                      step.index = expr2.rhs.value;
                    } else {
                      step.stages.push({ type: "index", value: expr2.rhs.value, position: expr2.position });
                    }
                    step.tuple = true;
                    break;
                  case "~>":
                    result = { type: "apply", value: expr2.value, position: expr2.position };
                    result.lhs = processAST(expr2.lhs);
                    result.rhs = processAST(expr2.rhs);
                    result.keepArray = result.lhs.keepArray || result.rhs.keepArray;
                    break;
                  default:
                    result = { type: expr2.type, value: expr2.value, position: expr2.position };
                    result.lhs = processAST(expr2.lhs);
                    result.rhs = processAST(expr2.rhs);
                    pushAncestry(result, result.lhs);
                    pushAncestry(result, result.rhs);
                }
                break;
              case "unary":
                result = { type: expr2.type, value: expr2.value, position: expr2.position };
                if (expr2.value === "[") {
                  result.expressions = expr2.expressions.map(function(item) {
                    var value = processAST(item);
                    pushAncestry(result, value);
                    return value;
                  });
                } else if (expr2.value === "{") {
                  result.lhs = expr2.lhs.map(function(pair) {
                    var key = processAST(pair[0]);
                    pushAncestry(result, key);
                    var value = processAST(pair[1]);
                    pushAncestry(result, value);
                    return [key, value];
                  });
                } else {
                  result.expression = processAST(expr2.expression);
                  if (expr2.value === "-" && result.expression.type === "number") {
                    result = result.expression;
                    result.value = -result.value;
                  } else {
                    pushAncestry(result, result.expression);
                  }
                }
                break;
              case "function":
              case "partial":
                result = { type: expr2.type, name: expr2.name, value: expr2.value, position: expr2.position };
                result.arguments = expr2.arguments.map(function(arg) {
                  var argAST = processAST(arg);
                  pushAncestry(result, argAST);
                  return argAST;
                });
                result.procedure = processAST(expr2.procedure);
                break;
              case "lambda":
                result = {
                  type: expr2.type,
                  arguments: expr2.arguments,
                  signature: expr2.signature,
                  position: expr2.position
                };
                var body = processAST(expr2.body);
                result.body = tailCallOptimize(body);
                break;
              case "condition":
                result = { type: expr2.type, position: expr2.position };
                result.condition = processAST(expr2.condition);
                pushAncestry(result, result.condition);
                result.then = processAST(expr2.then);
                pushAncestry(result, result.then);
                if (typeof expr2.else !== "undefined") {
                  result.else = processAST(expr2.else);
                  pushAncestry(result, result.else);
                }
                break;
              case "transform":
                result = { type: expr2.type, position: expr2.position };
                result.pattern = processAST(expr2.pattern);
                result.update = processAST(expr2.update);
                if (typeof expr2.delete !== "undefined") {
                  result.delete = processAST(expr2.delete);
                }
                break;
              case "block":
                result = { type: expr2.type, position: expr2.position };
                result.expressions = expr2.expressions.map(function(item) {
                  var part = processAST(item);
                  pushAncestry(result, part);
                  if (part.consarray || part.type === "path" && part.steps[0].consarray) {
                    result.consarray = true;
                  }
                  return part;
                });
                break;
              case "name":
                result = { type: "path", steps: [expr2] };
                if (expr2.keepArray) {
                  result.keepSingletonArray = true;
                }
                break;
              case "parent":
                result = { type: "parent", slot: { label: "!" + ancestorLabel++, level: 1, index: ancestorIndex++ } };
                ancestry.push(result);
                break;
              case "string":
              case "number":
              case "value":
              case "wildcard":
              case "descendant":
              case "variable":
              case "regex":
                result = expr2;
                break;
              case "operator":
                if (expr2.value === "and" || expr2.value === "or" || expr2.value === "in") {
                  expr2.type = "name";
                  result = processAST(expr2);
                } else if (expr2.value === "?") {
                  result = expr2;
                } else {
                  throw {
                    code: "S0201",
                    stack: new Error().stack,
                    position: expr2.position,
                    token: expr2.value
                  };
                }
                break;
              case "error":
                result = expr2;
                if (expr2.lhs) {
                  result = processAST(expr2.lhs);
                }
                break;
              default:
                var code2 = "S0206";
                if (expr2.id === "(end)") {
                  code2 = "S0207";
                }
                var err2 = {
                  code: code2,
                  position: expr2.position,
                  token: expr2.value
                };
                if (recover) {
                  errors.push(err2);
                  return { type: "error", error: err2 };
                } else {
                  err2.stack = new Error().stack;
                  throw err2;
                }
            }
            if (expr2.keepArray) {
              result.keepArray = true;
            }
            return result;
          };
          lexer = tokenizer2(source);
          advance2();
          var expr = expression(0);
          if (node2.id !== "(end)") {
            var err = {
              code: "S0201",
              position: node2.position,
              token: node2.value
            };
            handleError(err);
          }
          expr = processAST(expr);
          if (expr.type === "parent" || typeof expr.seekingParent !== "undefined") {
            throw {
              code: "S0217",
              token: expr.type,
              position: expr.position
            };
          }
          if (errors.length > 0) {
            expr.errors = errors;
          }
          return expr;
        };
        return parser2;
      })();
      module2.exports = parser;
    }, { "./signature": 5 }], 5: [function(require2, module2, exports2) {
      var utils2 = require2("./utils");
      const signature = /* @__PURE__ */ (() => {
        var arraySignatureMapping = {
          "a": "arrays",
          "b": "booleans",
          "f": "functions",
          "n": "numbers",
          "o": "objects",
          "s": "strings"
        };
        function parseSignature(signature2) {
          var position2 = 1;
          var params = [];
          var param = {};
          var prevParam = param;
          while (position2 < signature2.length) {
            var symbol = signature2.charAt(position2);
            if (symbol === ":") {
              break;
            }
            var next2 = function() {
              params.push(param);
              prevParam = param;
              param = {};
            };
            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
              var depth = 1;
              var position3 = start;
              while (position3 < str.length) {
                position3++;
                symbol = str.charAt(position3);
                if (symbol === closeSymbol) {
                  depth--;
                  if (depth === 0) {
                    break;
                  }
                } else if (symbol === openSymbol) {
                  depth++;
                }
              }
              return position3;
            };
            switch (symbol) {
              case "s":
              case "n":
              case "b":
              case "l":
              case "o":
                param.regex = "[" + symbol + "m]";
                param.type = symbol;
                next2();
                break;
              case "a":
                param.regex = "[asnblfom]";
                param.type = symbol;
                param.array = true;
                next2();
                break;
              case "f":
                param.regex = "f";
                param.type = symbol;
                next2();
                break;
              case "j":
                param.regex = "[asnblom]";
                param.type = symbol;
                next2();
                break;
              case "x":
                param.regex = "[asnblfom]";
                param.type = symbol;
                next2();
                break;
              case "-":
                prevParam.context = true;
                prevParam.contextRegex = new RegExp(prevParam.regex);
                prevParam.regex += "?";
                break;
              case "?":
              case "+":
                prevParam.regex += symbol;
                break;
              case "(":
                var endParen = findClosingBracket(signature2, position2, "(", ")");
                var choice = signature2.substring(position2 + 1, endParen);
                if (choice.indexOf("<") === -1) {
                  param.regex = "[" + choice + "m]";
                } else {
                  throw {
                    code: "S0402",
                    stack: new Error().stack,
                    value: choice,
                    offset: position2
                  };
                }
                param.type = "(" + choice + ")";
                position2 = endParen;
                next2();
                break;
              case "<":
                if (prevParam.type === "a" || prevParam.type === "f") {
                  var endPos = findClosingBracket(signature2, position2, "<", ">");
                  prevParam.subtype = signature2.substring(position2 + 1, endPos);
                  position2 = endPos;
                } else {
                  throw {
                    code: "S0401",
                    stack: new Error().stack,
                    value: prevParam.type,
                    offset: position2
                  };
                }
                break;
            }
            position2++;
          }
          var regexStr = "^" + params.map(function(param2) {
            return "(" + param2.regex + ")";
          }).join("") + "$";
          var regex = new RegExp(regexStr);
          var getSymbol = function(value) {
            var symbol2;
            if (utils2.isFunction(value)) {
              symbol2 = "f";
            } else {
              var type2 = typeof value;
              switch (type2) {
                case "string":
                  symbol2 = "s";
                  break;
                case "number":
                  symbol2 = "n";
                  break;
                case "boolean":
                  symbol2 = "b";
                  break;
                case "object":
                  if (value === null) {
                    symbol2 = "l";
                  } else if (Array.isArray(value)) {
                    symbol2 = "a";
                  } else {
                    symbol2 = "o";
                  }
                  break;
                case "undefined":
                default:
                  symbol2 = "m";
              }
            }
            return symbol2;
          };
          var throwValidationError = function(badArgs, badSig) {
            var partialPattern = "^";
            var goodTo = 0;
            for (var index2 = 0; index2 < params.length; index2++) {
              partialPattern += params[index2].regex;
              var match2 = badSig.match(partialPattern);
              if (match2 === null) {
                throw {
                  code: "T0410",
                  stack: new Error().stack,
                  value: badArgs[goodTo],
                  index: goodTo + 1
                };
              }
              goodTo = match2[0].length;
            }
            throw {
              code: "T0410",
              stack: new Error().stack,
              value: badArgs[goodTo],
              index: goodTo + 1
            };
          };
          return {
            definition: signature2,
            validate: function(args, context) {
              var suppliedSig = "";
              args.forEach(function(arg) {
                suppliedSig += getSymbol(arg);
              });
              var isValid = regex.exec(suppliedSig);
              if (isValid) {
                var validatedArgs = [];
                var argIndex = 0;
                params.forEach(function(param2, index2) {
                  var arg = args[argIndex];
                  var match2 = isValid[index2 + 1];
                  if (match2 === "") {
                    if (param2.context && param2.contextRegex) {
                      var contextType = getSymbol(context);
                      if (param2.contextRegex.test(contextType)) {
                        validatedArgs.push(context);
                      } else {
                        throw {
                          code: "T0411",
                          stack: new Error().stack,
                          value: context,
                          index: argIndex + 1
                        };
                      }
                    } else {
                      validatedArgs.push(arg);
                      argIndex++;
                    }
                  } else {
                    match2.split("").forEach(function(single) {
                      if (param2.type === "a") {
                        if (single === "m") {
                          arg = void 0;
                        } else {
                          arg = args[argIndex];
                          var arrayOK = true;
                          if (typeof param2.subtype !== "undefined") {
                            if (single !== "a" && match2 !== param2.subtype) {
                              arrayOK = false;
                            } else if (single === "a") {
                              if (arg.length > 0) {
                                var itemType = getSymbol(arg[0]);
                                if (itemType !== param2.subtype.charAt(0)) {
                                  arrayOK = false;
                                } else {
                                  var differentItems = arg.filter(function(val) {
                                    return getSymbol(val) !== itemType;
                                  });
                                  arrayOK = differentItems.length === 0;
                                }
                              }
                            }
                          }
                          if (!arrayOK) {
                            throw {
                              code: "T0412",
                              stack: new Error().stack,
                              value: arg,
                              index: argIndex + 1,
                              type: arraySignatureMapping[param2.subtype]
                            };
                          }
                          if (single !== "a") {
                            arg = [arg];
                          }
                        }
                        validatedArgs.push(arg);
                        argIndex++;
                      } else {
                        validatedArgs.push(arg);
                        argIndex++;
                      }
                    });
                  }
                });
                return validatedArgs;
              }
              throwValidationError(args, suppliedSig);
            }
          };
        }
        return parseSignature;
      })();
      module2.exports = signature;
    }, { "./utils": 6 }], 6: [function(require2, module2, exports2) {
      const utils2 = (() => {
        function isNumeric(n2) {
          var isNum = false;
          if (typeof n2 === "number") {
            isNum = !isNaN(n2);
            if (isNum && !isFinite(n2)) {
              throw {
                code: "D1001",
                value: n2,
                stack: new Error().stack
              };
            }
          }
          return isNum;
        }
        function isArrayOfStrings(arg) {
          var result = false;
          if (Array.isArray(arg)) {
            result = arg.filter(function(item) {
              return typeof item !== "string";
            }).length === 0;
          }
          return result;
        }
        function isArrayOfNumbers(arg) {
          var result = false;
          if (Array.isArray(arg)) {
            result = arg.filter(function(item) {
              return !isNumeric(item);
            }).length === 0;
          }
          return result;
        }
        function createSequence() {
          var sequence = [];
          sequence.sequence = true;
          if (arguments.length === 1) {
            sequence.push(arguments[0]);
          }
          return sequence;
        }
        function isSequence(value) {
          return value.sequence === true && Array.isArray(value);
        }
        function isFunction2(arg) {
          return arg && (arg._jsonata_function === true || arg._jsonata_lambda === true) || typeof arg === "function";
        }
        function getFunctionArity(func) {
          var arity = typeof func.arity === "number" ? func.arity : typeof func.implementation === "function" ? func.implementation.length : typeof func.length === "number" ? func.length : func.arguments.length;
          return arity;
        }
        function isLambda(arg) {
          return arg && arg._jsonata_lambda === true;
        }
        var iteratorSymbol = (typeof Symbol === "function" ? Symbol : {}).iterator || "@@iterator";
        function isIterable(arg) {
          return typeof arg === "object" && arg !== null && iteratorSymbol in arg && "next" in arg && typeof arg.next === "function";
        }
        function isDeepEqual(lhs, rhs) {
          if (lhs === rhs) {
            return true;
          }
          if (typeof lhs === "object" && typeof rhs === "object" && lhs !== null && rhs !== null) {
            if (Array.isArray(lhs) && Array.isArray(rhs)) {
              if (lhs.length !== rhs.length) {
                return false;
              }
              for (var ii2 = 0; ii2 < lhs.length; ii2++) {
                if (!isDeepEqual(lhs[ii2], rhs[ii2])) {
                  return false;
                }
              }
              return true;
            }
            var lkeys = Object.getOwnPropertyNames(lhs);
            var rkeys = Object.getOwnPropertyNames(rhs);
            if (lkeys.length !== rkeys.length) {
              return false;
            }
            lkeys = lkeys.sort();
            rkeys = rkeys.sort();
            for (ii2 = 0; ii2 < lkeys.length; ii2++) {
              if (lkeys[ii2] !== rkeys[ii2]) {
                return false;
              }
            }
            for (ii2 = 0; ii2 < lkeys.length; ii2++) {
              var key = lkeys[ii2];
              if (!isDeepEqual(lhs[key], rhs[key])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        function isPromise2(arg) {
          return typeof arg === "object" && arg !== null && "then" in arg && typeof arg.then === "function";
        }
        function stringToArray(str) {
          var arr = [];
          for (let char2 of str) {
            arr.push(char2);
          }
          return arr;
        }
        return {
          isNumeric,
          isArrayOfStrings,
          isArrayOfNumbers,
          createSequence,
          isSequence,
          isFunction: isFunction2,
          isLambda,
          isIterable,
          getFunctionArity,
          isDeepEqual,
          stringToArray,
          isPromise: isPromise2
        };
      })();
      module2.exports = utils2;
    }, {}] }, {}, [3])(3);
  });
})(jsonata$1);
var jsonataExports = jsonata$1.exports;
const jsonata = /* @__PURE__ */ getDefaultExportFromCjs(jsonataExports);
function useExpr(expr, data2) {
  const [result, setResult] = reactExports.useState();
  const [isLoading, setIsLoading] = reactExports.useState(!!expr && !!data2);
  const [error, setError] = reactExports.useState();
  reactExports.useEffect(() => {
    if (!expr || !data2) {
      setResult(void 0);
      return;
    }
    setIsLoading(true);
    const evaluateExpression = async () => {
      try {
        const expression = jsonata(expr);
        const evaluationResult = await expression.evaluate(data2);
        setResult(evaluationResult);
      } catch (err) {
        console.error("JSONata evaluation error:", err);
        setError(err);
      } finally {
        setIsLoading(false);
      }
    };
    evaluateExpression();
  }, [expr, data2]);
  return {
    isLoading,
    result,
    error
  };
}
const SITE_ID$2 = CONFIG.currentSite;
const PRODUCT_TILE_URL = `/on/demandware.store/Sites-${SITE_ID$2}-Site/default/Tile-Show`;
const PRODUCT_TILE_BATCH_URL = `/on/demandware.store/Sites-${SITE_ID$2}-Site/default/Tile-Batch`;
function useProductTile(productId) {
  return useQuery({
    queryKey: ["productTileJson", productId],
    queryFn: async () => {
      const params = new URLSearchParams({
        pid: productId,
        asJSON: "true"
      });
      const response = await fetch(`${PRODUCT_TILE_URL}?${params.toString()}`, {
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error("Error fetching product tile data");
      }
      const data2 = await response.json();
      return data2;
    }
  });
}
function useProductTiles(productIds) {
  return useQuery({
    queryKey: ["productTileBatch", productIds],
    queryFn: async () => {
      const params = new URLSearchParams({
        pids: productIds.join(",")
      });
      const response = await fetch(`${PRODUCT_TILE_BATCH_URL}?${params.toString()}`, {
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error("Error fetching product tile data");
      }
      const data2 = await response.json();
      return data2.products;
    },
    staleTime: Infinity,
    placeholderData: (prev2) => prev2
  });
}
const BookmarkIcon = ({
  solid = false,
  ...props
}) => solid ? /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { fillRule: "evenodd", d: "M6.32 2.577a49.255 49.255 0 0 1 11.36 0c1.497.174 2.57 1.46 2.57 2.93V21a.75.75 0 0 1-1.085.67L12 18.089l-7.165 3.583A.75.75 0 0 1 3.75 21V5.507c0-1.47 1.073-2.756 2.57-2.93Z", clipRule: "evenodd" }) }) : /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M17.593 3.322c1.1.128 1.907 1.077 1.907 2.185V21L12 17.25 4.5 21V5.507c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0 1 11.186 0Z" }) });
const ArrowPathIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { fillRule: "evenodd", d: "M4.755 10.059a7.5 7.5 0 0 1 12.548-3.364l1.903 1.903h-3.183a.75.75 0 1 0 0 1.5h4.992a.75.75 0 0 0 .75-.75V4.356a.75.75 0 0 0-1.5 0v3.18l-1.9-1.9A9 9 0 0 0 3.306 9.67a.75.75 0 1 0 1.45.388Zm15.408 3.352a.75.75 0 0 0-.919.53 7.5 7.5 0 0 1-12.548 3.364l-1.902-1.903h3.183a.75.75 0 0 0 0-1.5H2.984a.75.75 0 0 0-.75.75v4.992a.75.75 0 0 0 1.5 0v-3.18l1.9 1.9a9 9 0 0 0 15.059-4.035.75.75 0 0 0-.53-.918Z", clipRule: "evenodd" }) });
const SparklesIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 520 520", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { d: "m349 272-69 34a105 105 0 0 0-47 47l-33 67c-5 10-19 10-24 0l-34-68a105 105 0 0 0-47-47l-68-34a13 13 0 0 1 0-24l68-34a105 105 0 0 0 47-47l34-68a13 13 0 0 1 24 0l34 68a105 105 0 0 0 47 47l68 34c10 5 10 19 0 24Zm148 150-30-14a45 45 0 0 1-20-20l-14-30a6 6 0 0 0-10 0l-15 30a45 45 0 0 1-20 20l-30 15c-3 2-3 8 0 10l30 15a45 45 0 0 1 20 20l15 29c2 4 8 4 10 0l14-30a45 45 0 0 1 20-20l30-14c4-2 4-8 0-10Zm0-335-30-15a45 45 0 0 1-20-20l-14-29a6 6 0 0 0-10 0l-15 30a45 45 0 0 1-20 20l-30 14c-3 2-3 8 0 10l30 15a45 45 0 0 1 20 20l15 29c2 4 8 4 10 0l15-30a45 45 0 0 1 20-20l29-14c4-2 4-8 0-10Z" }) });
const AgentSessionIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 520 520", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { d: "M260 40C127 40 21 138 21 259c0 38 11 74 29 106 3 5 4 11 2 17l-31 85c-3 8 5 15 13 13l86-33c5-2 11-1 17 2 36 20 79 32 125 32 131-1 238-98 238-220-1-123-108-221-240-221zm-65 320c0 5-4 9-9 9h-42a9 9 0 0 1-9-9v-54c0-5 4-9 9-9h42c5 0 9 4 9 9zm96 0c0 5-4 9-9 9h-42a9 9 0 0 1-9-9V233c0-5 4-9 9-9h42c5 0 9 4 9 9zm96 0c0 5-4 9-9 9h-42a9 9 0 0 1-9-9V161c0-5 4-9 9-9h42c5 0 9 4 9 9z" }) });
const SendIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 520 520", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { d: "m21 445 44-163h186c5 0 10-5 10-10v-20c0-5-5-10-10-10H65L22 82l-2-8c0-7 7-14 15-13l5 1 450 185c6 2 10 8 10 14s-4 11-9 13L40 464l-6 1c-8-1-14-7-14-15z" }) });
const CloseIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 520 520", fill: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { d: "m310 254 130-131c6-6 6-15 0-21l-20-21c-6-6-15-6-21 0L268 212a10 10 0 0 1-14 0L123 80c-6-6-15-6-21 0l-21 21c-6 6-6 15 0 21l131 131c4 4 4 10 0 14L80 399c-6 6-6 15 0 21l21 21c6 6 15 6 21 0l131-131a10 10 0 0 1 14 0l131 131c6 6 15 6 21 0l21-21c6-6 6-15 0-21L310 268a10 10 0 0 1 0-14z" }) });
const EllipsisVerticalIcon = (props) => /* @__PURE__ */ jsx("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", ...props, children: /* @__PURE__ */ jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 6.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 12.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5ZM12 18.75a.75.75 0 1 1 0-1.5.75.75 0 0 1 0 1.5Z" }) });
const SpinnerIcon = (props) => /* @__PURE__ */ jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", ...props, children: [
  /* @__PURE__ */ jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", "stroke-width": "4" }),
  /* @__PURE__ */ jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
] });
function ProductTile({
  productId,
  ...props
}) {
  const {
    data: data2,
    isLoading
  } = useProductTile(productId);
  return /* @__PURE__ */ jsx(ProductTileView, { productTile: data2, isLoading, ...props });
}
function FallbackProductTileView({
  productTile,
  originalProduct
}) {
  const defaultPrice = {
    sales: {
      value: 0,
      currency: "",
      formatted: "",
      decimalPrice: ""
    },
    list: {
      value: 0,
      currency: "",
      formatted: "",
      decimalPrice: ""
    }
  };
  const fallbackTile = reactExports.useMemo(() => ({
    product: {
      error: false,
      id: originalProduct.productId,
      productName: originalProduct.productName || "Product Unavailable",
      price: originalProduct.price ? originalProduct.price : defaultPrice,
      images: originalProduct.images || {}
    },
    urls: {
      product: originalProduct.productUrl || productTile.urls.product,
      quickView: originalProduct.quickViewUrl || productTile.urls.quickView,
      addToCart: originalProduct.addToCartUrl || productTile.urls.addToCart
    }
  }), [productTile, originalProduct]);
  if (fallbackTile.product.productName === "Product Unavailable" || !Object.keys(fallbackTile.product.images).length) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", { className: "w-full", children: /* @__PURE__ */ jsx(ProductTileView, { productTile: fallbackTile, allowPinning: false, showQuickView: false, openInNewTab: true }) });
}
function ProductTileView({
  productTile,
  showName = true,
  showPrice = true,
  showQuickView = true,
  showBuyButton = false,
  imageViewType = "medium",
  allowPinning = true,
  isLoading = false,
  openInNewTab = false,
  sendPinnedProductMessage = false
}) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k, _l, _m;
  const {
    pinnedProducts,
    addPinnedProduct,
    removePinnedProduct,
    pinnedProductMessagePrefix
  } = usePinnedProducts();
  const {
    sendMessage
  } = useAgentAPI();
  const isPinned = pinnedProducts.includes((_a2 = productTile == null ? void 0 : productTile.product) == null ? void 0 : _a2.id);
  const id2 = (_b2 = productTile == null ? void 0 : productTile.product) == null ? void 0 : _b2.id;
  const productName = (_c2 = productTile == null ? void 0 : productTile.product) == null ? void 0 : _c2.productName;
  const [isHovered, setIsHovered] = reactExports.useState(false);
  const togglePin = () => {
    if (isPinned) {
      removePinnedProduct(id2);
    } else {
      addPinnedProduct(id2);
    }
    if (sendPinnedProductMessage) {
      sendMessage(`${pinnedProductMessagePrefix}_${isPinned ? "unpinned" : "pinned"}_${id2}_${productName}`);
    }
  };
  const getLinkProps = () => openInNewTab ? {
    target: "_blank",
    rel: "noopener noreferrer"
  } : {};
  return /* @__PURE__ */ jsx("div", { className: "w-full", children: /* @__PURE__ */ jsxs("div", { className: "border rounded-lg overflow-hidden relative bg-white h-full", onMouseEnter: () => setIsHovered(true), onMouseLeave: () => setIsHovered(false), children: [
    allowPinning && /* @__PURE__ */ jsx("button", { onClick: togglePin, className: "absolute top-1 right-1 bg-red-500 text-black rounded-full w-9 h-9 p-1 flex items-center justify-center z-10 text-md", "aria-label": "Remove from pinned", children: isPinned ? /* @__PURE__ */ jsx(BookmarkIcon, { solid: true, className: "size-9" }) : /* @__PURE__ */ jsx(BookmarkIcon, { className: "size-9" }) }),
    isLoading ? /* @__PURE__ */ jsx("div", { className: "h-24 w-full flex justify-center items-center bg-gray-100", children: /* @__PURE__ */ jsx("div", { className: "h-3 w-3 animate-spin rounded-full border-2 border-solid border-primary border-r-transparent" }) }) : /* @__PURE__ */ jsxs("div", { className: "text-center p-1 mt-2 relative", children: [
      /* @__PURE__ */ jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ jsx("a", { href: productTile.urls.product, ...getLinkProps(), className: "block", children: ((_g2 = (_f2 = (_e2 = (_d2 = productTile.product) == null ? void 0 : _d2.images) == null ? void 0 : _e2[imageViewType]) == null ? void 0 : _f2[0]) == null ? void 0 : _g2.url) ? /* @__PURE__ */ jsx("img", { src: (_h2 = productTile.product.images[imageViewType]) == null ? void 0 : _h2[0].url, alt: (_i2 = productTile.product.images[imageViewType]) == null ? void 0 : _i2[0].alt, title: (_j2 = productTile.product.images[imageViewType]) == null ? void 0 : _j2[0].title, className: "w-full h-auto object-contain max-h-[150px]", height: 150 }) : /* @__PURE__ */ jsx("img", { src: "/on/demandware.static/Sites-nto-Site/-/default/dwade5f90d/images/noimagelarge.png", className: "w-full h-auto object-contain max-h-[150px]" }) }),
        showQuickView && /* @__PURE__ */ jsx("a", { className: `quickview !hidden absolute bottom-0 left-0 right-0 bg-white text-primary py-2 font-medium border border-primary text-center transition-opacity duration-200 ${isHovered ? "opacity-100" : "opacity-0"} md:!block`, href: productTile.urls.quickView, "aria-label": "Quick shop this product", children: "Quick Shop" })
      ] }),
      (showName || showPrice || showBuyButton) && /* @__PURE__ */ jsxs("div", { className: "h-24 w-full flex justify-center items-center flex-col", children: [
        showName && /* @__PURE__ */ jsx("h5", { className: "text-lg font-medium mb-0", children: productTile.product.productName }),
        showPrice && /* @__PURE__ */ jsx("span", { children: (_m = (_l = (_k = productTile.product) == null ? void 0 : _k.price) == null ? void 0 : _l.sales) == null ? void 0 : _m.formatted }),
        showBuyButton && productTile.urls.addToCart && /* @__PURE__ */ jsx("a", { href: productTile.urls.addToCart, className: "mt-2 bg-primary text-white py-1 px-4 rounded hover:bg-primary-dark transition-colors", children: "Buy Now" })
      ] })
    ] })
  ] }) });
}
const SITE_ID$1 = CONFIG.currentSite;
const CONTENT_ASSET_URL = `/on/demandware.store/Sites-${SITE_ID$1}-Site/default/QLabsStorefront-ContentAsset`;
function useContentAsset(cid) {
  return useQuery({
    queryKey: ["contentAsset", cid],
    queryFn: async () => {
      const params = new URLSearchParams({
        cid
      });
      const response = await fetch(`${CONTENT_ASSET_URL}?${params.toString()}`, {
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error("Error fetching content asset data");
      }
      return await response.json();
    },
    staleTime: Infinity
  });
}
function ContentAsset({
  cid
}) {
  const {
    data: data2,
    isLoading
  } = useContentAsset(cid);
  const contentRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!isLoading && (data2 == null ? void 0 : data2.content) && contentRef.current && typeof window !== "undefined") {
      if (window.jQuery) {
        window.jQuery('[data-toggle="tooltip"]', contentRef.current).tooltip();
      }
    }
  }, [isLoading, data2 == null ? void 0 : data2.content]);
  return /* @__PURE__ */ jsx(ContentAssetView, { content: (data2 == null ? void 0 : data2.content) || "", isLoading, contentRef });
}
function ContentAssetView({
  content: content2,
  isLoading = false,
  contentRef
}) {
  return /* @__PURE__ */ jsx("div", { className: "w-full", children: isLoading ? /* @__PURE__ */ jsx("div", { className: "h-24 w-full flex justify-center items-center bg-gray-100", children: /* @__PURE__ */ jsx("div", { className: "h-3 w-3 animate-spin rounded-full border-2 border-solid border-primary border-r-transparent" }) }) : /* @__PURE__ */ jsx("div", { className: "content-asset-html", dangerouslySetInnerHTML: {
    __html: content2
  }, ref: contentRef }) });
}
function ButtonsView({
  message,
  onUpdate,
  query = "action.output.buttons",
  className = ""
}) {
  const {
    sendMessage
  } = useAgentAPI();
  const {
    result: buttonOptions,
    isLoading
  } = useExpr(query, message.MESSAGE_TYPE === "USER" ? void 0 : message.json);
  const handleButtonClick = (response) => {
    if (response.startsWith("http://") || response.startsWith("https://")) {
      window.location.href = response;
    } else {
      if (sendMessage) {
        sendMessage(response);
        if (onUpdate) {
          onUpdate();
        }
      }
    }
  };
  reactExports.useEffect(() => {
    if (!isLoading && buttonOptions && onUpdate) {
      setTimeout(() => {
        onUpdate();
      }, 100);
    }
  }, [isLoading, buttonOptions]);
  if (!buttonOptions || buttonOptions.length === 0) {
    return null;
  }
  const tileClassName = "border border-primary bg-gray-50 rounded-md p-4 cursor-pointer hover:bg-gray-200 max-w-sm";
  return /* @__PURE__ */ jsx("div", { className: `${className} flex flex-wrap gap-2 justify-center my-4`, children: buttonOptions.map((option, index2) => {
    if (option.cid) {
      return /* @__PURE__ */ jsx("div", { onClick: () => handleButtonClick(option.response || option.text), className: tileClassName, children: /* @__PURE__ */ jsx(ContentAsset, { cid: option.cid }) }, index2);
    }
    if (option.isTile) {
      return /* @__PURE__ */ jsxs("div", { onClick: () => handleButtonClick(option.response || option.text), className: tileClassName, children: [
        /* @__PURE__ */ jsx("div", { className: "mb-3 border-b border-gray-300", children: /* @__PURE__ */ jsxs("p", { className: "font-bold text-black", children: [
          option.imageUrl && /* @__PURE__ */ jsx("span", { className: "inline-block mr-2", children: /* @__PURE__ */ jsx("img", { src: option.imageUrl, alt: "", className: "inline-block object-contain", style: option.maxImageHeight ? {
            maxHeight: option.maxImageHeight
          } : void 0 }) }),
          /* @__PURE__ */ jsx("span", { children: option.text })
        ] }) }),
        option.description && /* @__PURE__ */ jsx("div", { className: "text-medium mb-3", children: option.description }),
        option.html && /* @__PURE__ */ jsx("div", { dangerouslySetInnerHTML: {
          __html: option.html
        } }),
        option.cid && /* @__PURE__ */ jsx(ContentAsset, { cid: option.cid })
      ] }, index2);
    }
    return /* @__PURE__ */ jsxs("button", { onClick: () => handleButtonClick(option.response || option.text), className: `rounded-md border transition-colors
                            ${option.imageUrl ? "border-primary bg-white p-1 flex flex-col items-center" : "bg-primary text-white px-4 py-2"}`, children: [
      option.imageUrl && /* @__PURE__ */ jsx("img", { src: option.imageUrl, alt: option.text, className: "w-full h-auto object-contain mb-1", style: option.maxImageHeight ? {
        maxHeight: option.maxImageHeight
      } : void 0 }),
      /* @__PURE__ */ jsx("span", { children: option.text })
    ] }, index2);
  }) });
}
var EditablePropType = /* @__PURE__ */ ((EditablePropType2) => {
  EditablePropType2["STRING"] = "string";
  EditablePropType2["NUMBER"] = "number";
  EditablePropType2["BOOLEAN"] = "boolean";
  EditablePropType2["OBJECT"] = "object";
  EditablePropType2["TEMPLATE"] = "template";
  EditablePropType2["QUERY"] = "query";
  return EditablePropType2;
})(EditablePropType || {});
function MarkdownMessageView({
  message,
  query = "action.output.userFriendlyMessage ? action.output.userFriendlyMessage : action.output.nextStep"
}) {
  const {
    result,
    isLoading
  } = useExpr(query, message.MESSAGE_TYPE === "USER" ? void 0 : message.json);
  if (message.MESSAGE_TYPE === "AGENT" && message.type !== ResponseMessageType.Inform) {
    return null;
  }
  if (isLoading && message.MESSAGE_TYPE !== "USER") {
    return null;
  }
  const isUser = message.MESSAGE_TYPE === "USER";
  if (result) {
    var content2 = result;
  } else if (message.MESSAGE_TYPE === "USER") {
    content2 = message.text;
  } else {
    content2 = message.message;
  }
  if (!content2) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", { className: `flex ${isUser ? "justify-end" : "justify-start"} mb-4`, children: /* @__PURE__ */ jsx("div", { className: `[&>*:last-child]:!mb-0 rounded-lg p-3 max-w-3/4 ${isUser ? "bg-primary text-white" : "bg-gray-200 text-black"}`, children: /* @__PURE__ */ jsx(ReactMarkdown, { linkTarget: "_blank", children: content2 }) }) });
}
function ProductTilesMessageView({
  message,
  allowPinning = true,
  showQuickView = true,
  showBuyButton = false,
  sendPinnedProductMessage = false,
  onUpdate,
  query = "action.output.products.productId",
  className = ""
}) {
  const {
    result: rawProductIds
  } = useExpr(query, message.MESSAGE_TYPE === "USER" ? void 0 : message.json);
  const productIds = rawProductIds ? Array.isArray(rawProductIds) ? rawProductIds : [rawProductIds] : null;
  const {
    result: products
  } = useExpr("action.output.products", message.MESSAGE_TYPE === "USER" ? void 0 : message.json);
  const {
    data: productTiles,
    isLoading: isTilesLoading
  } = useProductTiles(productIds);
  reactExports.useEffect(() => {
    if (!isTilesLoading && onUpdate) {
      setTimeout(() => {
        onUpdate();
      }, 100);
    }
  }, [isTilesLoading]);
  if (!productIds) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", { className: `${className} md:p-4`, children: /* @__PURE__ */ jsx("div", { className: "flex flex-wrap -mx-2 my-2 justify-center", children: !isTilesLoading && (productTiles == null ? void 0 : productTiles.map((productTile, index2) => /* @__PURE__ */ jsx("div", { className: `${productTiles.length === 1 ? "w-full" : "md:w-1/3 w-1/2"} mb-2 px-2`, children: productTile.product.error && (products == null ? void 0 : products[index2]) ? /* @__PURE__ */ jsx(FallbackProductTileView, { productTile, originalProduct: products[index2] }) : /* @__PURE__ */ jsx(ProductTileView, { productTile, allowPinning, showQuickView, showBuyButton, sendPinnedProductMessage }, productTile.product.id) }, index2))) }) });
}
function SessionEndedMessageView({
  message
}) {
  const {
    resetSession
  } = useAgentAPI();
  if (message.MESSAGE_TYPE !== "AGENT" || message.type !== ResponseMessageType.SessionEnded) {
    return null;
  }
  const handleRestartSession = (e2) => {
    e2.preventDefault();
    resetSession();
  };
  return /* @__PURE__ */ jsx("div", { className: "flex justify-center mb-4", children: /* @__PURE__ */ jsxs("div", { className: "text-center text-gray-500 px-4 py-2", children: [
    /* @__PURE__ */ jsx("p", { className: "mb-0", children: "Session has ended" }),
    /* @__PURE__ */ jsx("a", { href: "#", onClick: handleRestartSession, className: "text-primary hover:underline font-medium", children: "Restart Session" })
  ] }) });
}
const Messages = ({
  style,
  children,
  autoScroll = true,
  ...props
}) => {
  const {
    messages,
    isLoading
  } = useAgentAPI();
  const containerRef = reactExports.useRef(null);
  const scrollContainer = () => {
    if (!autoScroll) return;
    setTimeout(() => {
      var _a2;
      (_a2 = containerRef.current) == null ? void 0 : _a2.scroll(0, containerRef.current.scrollHeight);
    }, 100);
  };
  return /* @__PURE__ */ jsx("div", { style: props.style, ref: containerRef, className: "overflow-y-auto scroll-smooth", children: /* @__PURE__ */ jsx(MessagesView, { messages, isLoading, onUpdate: scrollContainer, ...props, children }) });
};
Messages.displayName = "Messages";
Messages.__editableProps = {
  autoScroll: {
    name: "Auto Scroll",
    type: EditablePropType.BOOLEAN,
    defaultValue: true,
    description: "Automatically scroll to the bottom when new messages are added"
  }
};
function filterTrailingProgressIndicators(arr) {
  const targetType = ResponseMessageType.ProgressIndicator;
  const n2 = arr.length;
  if (n2 === 0) {
    return [];
  }
  let firstNonIndicatorIndex = -1;
  for (let i2 = n2 - 1; i2 >= 0; i2--) {
    if (arr[i2].type !== targetType) {
      firstNonIndicatorIndex = i2;
      break;
    }
  }
  const startIndex = firstNonIndicatorIndex === -1 ? 0 : firstNonIndicatorIndex + 1;
  if (startIndex >= n2) {
    return [];
  }
  return arr.slice(startIndex);
}
function LoadingMessage() {
  const {
    isLoading,
    messages
  } = useAgentAPI();
  if (!isLoading) {
    return null;
  }
  const currentProgressIndicators = filterTrailingProgressIndicators(messages);
  return /* @__PURE__ */ jsx("div", { className: "flex justify-start mb-4", children: /* @__PURE__ */ jsx("div", { className: "bg-gray-200 rounded-lg p-3", children: /* @__PURE__ */ jsxs("div", { className: "flex", children: [
    /* @__PURE__ */ jsx("div", { className: "mt-0 flex-shrink-0", children: /* @__PURE__ */ jsx(SpinnerIcon, { className: "size-5 animate-spin text-primary mr-2" }) }),
    /* @__PURE__ */ jsx("div", { children: currentProgressIndicators.map((msg, index2) => /* @__PURE__ */ jsx("div", { className: "text-gray-500", children: msg.message }, index2)) })
  ] }) }) });
}
const VALID_MESSAGE_TYPES = [ResponseMessageType.Inform, ResponseMessageType.SessionEnded];
function MessagesView({
  messages,
  isLoading,
  onUpdate,
  inlineRecommendations,
  last,
  user = true,
  agent = true,
  skip = [],
  children,
  ...props
}) {
  const viewComponents = React.Children.toArray(children).filter(reactExports.isValidElement);
  reactExports.useEffect(() => {
    if (onUpdate) {
      onUpdate();
    }
  }, [messages]);
  const _messages = reactExports.useMemo(() => {
    var _messages2 = messages;
    if (!agent) {
      _messages2 = messages.filter((msg) => msg.MESSAGE_TYPE !== "AGENT");
    }
    if (!user) {
      _messages2 = messages.filter((msg) => msg.MESSAGE_TYPE !== "USER");
    }
    _messages2 = _messages2.filter((msg) => msg.MESSAGE_TYPE === "USER" || msg.MESSAGE_TYPE === "AGENT" && VALID_MESSAGE_TYPES.includes(msg.type));
    const {
      pinnedProductMessagePrefix
    } = usePinnedProducts();
    _messages2 = _messages2.filter((msg) => {
      var _a2;
      return !(msg.MESSAGE_TYPE === "USER" && ((_a2 = msg.text) == null ? void 0 : _a2.startsWith(pinnedProductMessagePrefix)));
    });
    if (skip.length > 0) {
      _messages2 = _messages2.filter((_2, index2) => !skip.includes(index2 + 1));
    }
    if (last) {
      if (isLoading) {
        last -= 1;
      }
      if (last === 0) {
        return [];
      }
      _messages2 = _messages2.slice(-last);
    }
    return _messages2;
  }, [messages, last, user, agent, isLoading, skip]);
  return /* @__PURE__ */ jsxs("div", { className: "py-1", children: [
    _messages.map((msg, index2) => /* @__PURE__ */ jsx(Fragment, { children: viewComponents.length ? viewComponents.map((viewComponent, index22) => {
      return /* @__PURE__ */ jsx(React.Fragment, { children: reactExports.cloneElement(viewComponent, {
        message: msg,
        ...props
      }) }, index22);
    }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(MarkdownMessageView, { message: msg, ...props, onUpdate }, index2),
      /* @__PURE__ */ jsx(ButtonsView, { message: msg, query: "action.output.buttons", onUpdate, ...props }, index2),
      /* @__PURE__ */ jsx(ProductTilesMessageView, { message: msg, query: "action.output.products.productId", className: `${inlineRecommendations ? "block" : "block md:hidden"}`, onUpdate, sendPinnedProductMessage: props.sendPinnedProductMessage, ...props }, index2),
      /* @__PURE__ */ jsx(SessionEndedMessageView, { message: msg, ...props }, index2)
    ] }) })),
    /* @__PURE__ */ jsx(LoadingMessage, {})
  ] });
}
const ChatInput = function ChatInput2({
  ...props
}) {
  const {
    sendMessage,
    isLoading,
    resetSession
  } = useAgentAPI();
  return /* @__PURE__ */ jsx(ChatInputView, { onSendMessage: sendMessage, disabled: isLoading, resetSession, ...props });
};
ChatInput.displayName = "ChatInput";
ChatInput.__editableProps = {};
function ChatInputView({
  onSendMessage,
  disabled = false,
  placeholder = "",
  showMenu = false,
  resetSession = () => {
  }
}) {
  const [input, setInput] = reactExports.useState("");
  const inputRef = reactExports.useRef(null);
  const [menuOpen, setMenuOpen] = reactExports.useState(false);
  const menuRef = reactExports.useRef(null);
  const handleSubmit = (e2) => {
    e2.preventDefault();
    if (input.trim() && !disabled) {
      onSendMessage == null ? void 0 : onSendMessage(input);
      setInput("");
    }
  };
  const handleResetSession = () => {
    resetSession == null ? void 0 : resetSession();
    setMenuOpen(false);
  };
  return /* @__PURE__ */ jsx("form", { onSubmit: handleSubmit, className: "mt-4", children: /* @__PURE__ */ jsxs("div", { className: "flex", children: [
    /* @__PURE__ */ jsx("input", { ref: inputRef, type: "text", value: input, onChange: (e2) => setInput(e2.target.value), placeholder, disabled, className: "flex-grow rounded-l-lg border p-2 focus:outline-none focus:ring-2 focus:ring-primary" }),
    /* @__PURE__ */ jsx("button", { type: "submit", disabled: disabled || !input.trim(), className: "!bg-primary text-white rounded-r-lg px-4 py-2 disabled:!bg-secondary transition-colors", children: "Send" }),
    showMenu && /* @__PURE__ */ jsxs("div", { className: "relative", ref: menuRef, children: [
      /* @__PURE__ */ jsx("button", { onClick: () => setMenuOpen(!menuOpen), className: "!bg-secondary text-white hover:!bg-primary p-2 transition-colors disabled:!bg-secondary !border-l border-white", style: {
        height: "100%"
      }, children: /* @__PURE__ */ jsx(EllipsisVerticalIcon, { className: "h-5 w-5" }) }),
      menuOpen && /* @__PURE__ */ jsx("div", { className: "absolute left-0 mt-1 w-40 bg-white rounded-md shadow-lg z-10 text-black", children: /* @__PURE__ */ jsx("button", { onClick: handleResetSession, className: "block w-full text-left px-4 py-2 hover:bg-gray-100 rounded-md", role: "menuitem", children: "Reset Session" }) })
    ] })
  ] }) });
}
const Portal = ({
  selector,
  mode = null,
  children
}) => {
  const [targetElement, setTargetElement] = reactExports.useState(null);
  reactExports.useContext(AgentContext);
  reactExports.useEffect(() => {
    var _a2, _b2;
    var target = document.querySelector(selector);
    if (mode === "append" && target) {
      const newElement = document.createElement("div");
      target == null ? void 0 : target.appendChild(newElement);
      target = newElement;
    } else if (mode === "prepend" && target) {
      const newElement = document.createElement("div");
      target == null ? void 0 : target.insertBefore(newElement, target.firstChild);
      target = newElement;
    } else if (mode === "insertAfter" && target) {
      const newElement = document.createElement("div");
      (_a2 = target == null ? void 0 : target.parentNode) == null ? void 0 : _a2.insertBefore(newElement, target.nextSibling);
      target = newElement;
    } else if (mode === "insertBefore" && target) {
      const newElement = document.createElement("div");
      (_b2 = target == null ? void 0 : target.parentNode) == null ? void 0 : _b2.insertBefore(newElement, target);
      target = newElement;
    }
    setTargetElement(target);
  }, [selector]);
  if (!targetElement) return null;
  return reactDomExports.createPortal(children, targetElement);
};
function ProductRecommendations({
  products,
  sendPinnedProductMessage
}) {
  const productIds = products.map((product) => product.productId);
  const {
    data: productTiles,
    isLoading
  } = useProductTiles(productIds);
  return /* @__PURE__ */ jsx(Fragment, { children: !isLoading && productTiles.map((productTile, index2) => /* @__PURE__ */ jsx("div", { className: "md:w-1/3 w-1/2 mb-2 px-2", children: productTile.product.error ? /* @__PURE__ */ jsx(FallbackProductTileView, { productTile, originalProduct: products[index2] }) : /* @__PURE__ */ jsx(ProductTileView, { productTile, sendPinnedProductMessage }) }, index2)) });
}
function ShopperAgentAPI({
  initialMessage: initialMessageProp,
  initialMessageFromQuery,
  initialMessagePrefix = "",
  initialMessageSuffix = "",
  inlineRecommendations = false,
  allowPinning = true,
  chatInputViewPlaceholder = "Search for something else...",
  children,
  ...props
}) {
  var _a2, _b2, _c2;
  const {
    agent
  } = reactExports.useContext(AgentContext);
  const {
    messages,
    isLoading,
    sendMessage,
    data: data2,
    resetSession,
    isActive
  } = useAgentAPI();
  const chatContainerRef = reactExports.useRef(null);
  const initialMessage = reactExports.useMemo(() => {
    if (initialMessageProp) {
      return initialMessageProp;
    }
    if (initialMessageFromQuery) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(initialMessageFromQuery);
    }
  }, []);
  reactExports.useEffect(() => {
    if (initialMessage && !isLoading && messages.length === 1) {
      sendMessage(initialMessagePrefix + initialMessage + initialMessageSuffix);
    }
  }, [initialMessage, isLoading, messages.length]);
  const scrollChatContainer = () => {
    setTimeout(() => {
      var _a3;
      (_a3 = chatContainerRef.current) == null ? void 0 : _a3.scroll(0, chatContainerRef.current.scrollHeight);
    }, 100);
  };
  return /* @__PURE__ */ jsx("div", { className: "container mx-auto px-4", children: /* @__PURE__ */ jsxs("div", { className: "flex flex-wrap -mx-2", children: [
    /* @__PURE__ */ jsx("div", { className: `w-full ${inlineRecommendations ? "" : "md:w-1/2"} px-2`, children: /* @__PURE__ */ jsxs("div", { className: "rounded-lg shadow overflow-hidden", children: [
      /* @__PURE__ */ jsxs("div", { className: "bg-primary text-white px-4 py-3 flex justify-between items-center", children: [
        /* @__PURE__ */ jsx("h5", { className: "text-lg font-medium mb-0", children: "Chat with Agent" }),
        /* @__PURE__ */ jsx("button", { className: "text-white", onClick: () => {
          resetSession();
        }, "aria-label": "Reset chat", children: /* @__PURE__ */ jsx(ArrowPathIcon, { className: "size-6" }) })
      ] }),
      /* @__PURE__ */ jsx("div", { ref: chatContainerRef, className: "p-4 pb-0 overflow-auto scroll-smooth", style: {
        minHeight: "400px",
        maxHeight: "700px"
      }, children: /* @__PURE__ */ jsx(MessagesView, { messages, isLoading, allowPinning, inlineRecommendations, onUpdate: scrollChatContainer, ...props, children }) }),
      /* @__PURE__ */ jsx("div", { className: "bg-gray-50 px-4 py-3", children: /* @__PURE__ */ jsx(ChatInputView, { onSendMessage: sendMessage, disabled: isLoading || !isActive, placeholder: chatInputViewPlaceholder }) })
    ] }) }),
    !inlineRecommendations && /* @__PURE__ */ jsx("div", { className: "w-full md:w-1/2 px-2 md:mt-0 hidden md:block", children: /* @__PURE__ */ jsxs("div", { className: "rounded-lg shadow overflow-hidden h-full", children: [
      /* @__PURE__ */ jsx("div", { className: "bg-primary text-white px-4 py-3", children: /* @__PURE__ */ jsx("h5", { className: "text-lg font-medium mb-0", children: "Recommended Products" }) }),
      /* @__PURE__ */ jsx("div", { className: "p-4 overflow-auto", style: {
        height: "calc(100% - 56px)"
      }, children: data2 && ((_c2 = (_b2 = (_a2 = data2 == null ? void 0 : data2.action) == null ? void 0 : _a2.output) == null ? void 0 : _b2.products) == null ? void 0 : _c2.length) ? /* @__PURE__ */ jsx("div", { className: "flex flex-wrap -mx-2", children: /* @__PURE__ */ jsx(ProductRecommendations, { products: data2.action.output.products, sendPinnedProductMessage: props.sendPinnedProductMessage }) }) : /* @__PURE__ */ jsx("div", { className: "flex justify-center items-center h-full", children: /* @__PURE__ */ jsx("p", { className: "text-gray-500", children: "Waiting for product recommendations..." }) }) })
    ] }) })
  ] }) });
}
const ShopperPinnedProducts = () => {
  const {
    removePinnedProduct,
    pinnedProducts
  } = usePinnedProducts();
  return /* @__PURE__ */ jsx(PinnedProducts, { pinnedProducts, onUnpin: removePinnedProduct });
};
function PinnedProducts({
  pinnedProducts,
  onUnpin
}) {
  if (!pinnedProducts || pinnedProducts.length === 0) {
    return null;
  }
  const {
    data: pinnedProductsData,
    isLoading
  } = useProductTiles(pinnedProducts);
  const [isCollapsed, setIsCollapsed] = reactExports.useState(() => {
    const savedState = sessionStorage.getItem("pinnedProductsCollapsed");
    return savedState ? JSON.parse(savedState) : false;
  });
  const toggleCollapse = () => {
    const newState = !isCollapsed;
    setIsCollapsed(newState);
    sessionStorage.setItem("pinnedProductsCollapsed", JSON.stringify(newState));
  };
  reactExports.useEffect(() => {
    if (pinnedProducts.length === 0) {
      sessionStorage.removeItem("pinnedProductsCollapsed");
    }
  }, [pinnedProducts.length]);
  return /* @__PURE__ */ jsx("div", { className: "w-full", children: /* @__PURE__ */ jsx("div", { className: "shadow overflow-hidden", children: /* @__PURE__ */ jsxs("div", { className: "flex flex-row", children: [
    /* @__PURE__ */ jsx("div", { className: "bg-primary text-white px-4 py-3 flex items-center justify-center min-w-[80px] cursor-pointer hover:bg-primary-dark transition-colors relative", onClick: toggleCollapse, title: isCollapsed ? "Expand pinned products" : "Collapse pinned products", children: isCollapsed ? /* @__PURE__ */ jsx(BookmarkIcon, { solid: true, className: "size-8" }) : /* @__PURE__ */ jsx(BookmarkIcon, { className: "size-8" }) }),
    !isCollapsed ? /* @__PURE__ */ jsx("div", { className: "flex-1 overflow-x-auto pb-1 scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent", children: /* @__PURE__ */ jsx("div", { className: "flex flex-nowrap space-x-4 px-4 py-3", children: pinnedProductsData == null ? void 0 : pinnedProductsData.map((productTileResp) => /* @__PURE__ */ jsx("div", { className: "flex-shrink-0 w-[120px] lg:w-[calc((100%-4rem)/7)] xl:w-[calc((100%-5rem)/8)]", children: /* @__PURE__ */ jsx(ProductTileView, { productTile: productTileResp, showPrice: false, showName: false, showQuickView: false, allowPinning: true, isLoading }) }, productTileResp == null ? void 0 : productTileResp.product.id)) }) }) : /* @__PURE__ */ jsx("div", { className: "flex-1 bg-primary flex items-center px-4" })
  ] }) }) });
}
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref2 = reactExports.useRef(null);
  if (ref2.current === null) {
    ref2.current = init();
  }
  return ref2.current;
}
const isBrowser = typeof window !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element2 = this.props.childRef.current;
    if (element2 && prevProps.isPresent && !this.props.isPresent) {
      const parent = element2.offsetParent;
      const parentWidth = parent instanceof HTMLElement ? parent.offsetWidth || 0 : 0;
      const size = this.props.sizeRef.current;
      size.height = element2.offsetHeight || 0;
      size.width = element2.offsetWidth || 0;
      size.top = element2.offsetTop;
      size.left = element2.offsetLeft;
      size.right = parentWidth - size.width - size.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent, anchorX }) {
  const id2 = reactExports.useId();
  const ref2 = reactExports.useRef(null);
  const size = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  });
  const { nonce } = reactExports.useContext(MotionConfigContext);
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left, right } = size.current;
    if (isPresent || !ref2.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref2.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref2, sizeRef: size, children: reactExports.cloneElement(children, { ref: ref2 }) });
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const memoizedOnExitComplete = reactExports.useCallback((childId) => {
    presenceChildren.set(childId, true);
    for (const isComplete of presenceChildren.values()) {
      if (!isComplete)
        return;
    }
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]);
  const context = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: memoizedOnExitComplete,
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = true) {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left" }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = reactExports.useRef(true);
  const pendingPresentChildren = reactExports.useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key = getChildKey(renderedChildren[i2]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i2, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return null;
  }
  const { forceRender } = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = () => {
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender == null ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && (safeToRemove == null ? void 0 : safeToRemove());
        onExitComplete && onExitComplete();
      }
    };
    return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
  }) });
};
let invariant = () => {
};
const noop = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const MotionGlobalConfig = {
  useManualTiming: false
};
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
const statsBuffer = {
  value: null
};
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  let numCalls = 0;
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    numCalls++;
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      if (stepName && statsBuffer.value) {
        statsBuffer.value.frameloop[stepName].push(numCalls);
      }
      numCalls = 0;
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
    return acc;
  }, {});
  const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
  const processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = false;
    {
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    read.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps[stepsOrder[i2]].cancel(process);
    }
  };
  return { schedule, cancel, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}
const MotionContext = /* @__PURE__ */ reactExports.createContext({});
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref2) {
  return ref2 && typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a2, _b2;
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a2 = window.MotionHandoffIsComplete) == null ? void 0 : _a2.call(window, optimisedAppearId)) && ((_b2 = window.MotionHasOptimisedAnimation) == null ? void 0 : _b2.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a3;
        (_a3 = window.MotionHandoffMarkAsComplete) == null ? void 0 : _a3.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 == null ? void 0 : drag2.isEnabled(props)) || (layout2 == null ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key in correctors) {
    scaleCorrectors[key] = correctors[key];
    if (isCSSVariableName(key)) {
      scaleCorrectors[key].isCSSVariable = true;
    }
  }
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const getValueAsType = (value, type2) => {
  return type2 && typeof value === "number" ? type2.transform(value) : value;
};
const clamp = (min, max, v2) => {
  if (v2 > max)
    return max;
  if (v2 < min)
    return min;
  return v2;
};
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const createUnitType = (unit) => ({
  test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys2 = useDashCase ? dashKeys : camelKeys;
  attrs[keys2.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
}
function calcOrigin$1(origin, offset2, size) {
  return typeof origin === "string" ? origin : px.transform(offset2 + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref2, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref: ref2 } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement == null ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition2, custom, visualElement) {
  if (typeof definition2 === "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition2 = definition2(custom !== void 0 ? custom : props.custom, current2, velocity);
  }
  if (typeof definition2 === "string") {
    definition2 = props.variants && props.variants[definition2];
  }
  if (typeof definition2 === "function") {
    const [current2, velocity] = getValueState(visualElement);
    definition2 = definition2(custom !== void 0 ? custom : props.custom, current2, velocity);
  }
  return definition2;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onUpdate }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onUpdate) {
    state.onMount = (instance) => onUpdate({ props, current: instance, ...state });
    state.onUpdate = (visualElement) => onUpdate(visualElement);
  }
  return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list2.length; i2++) {
      const resolved = resolveVariantFromProps(props, list2[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a2;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a2 = visualElement == null ? void 0 : visualElement.getValue(key)) == null ? void 0 : _a2.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function updateSVGDimensions(instance, renderState) {
  try {
    renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
  } catch (e2) {
    renderState.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
function renderHTML(element2, { style, vars }, styleProp, projection) {
  Object.assign(element2.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element2.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element2, renderState, _styleProp, projection) {
  renderHTML(element2, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element2.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
const layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onUpdate: ({ props, prevProps, current: current2, renderState, latestValues }) => {
      if (!current2)
        return;
      let hasTransform2 = !!props.drag;
      if (!hasTransform2) {
        for (const key in latestValues) {
          if (transformProps.has(key)) {
            hasTransform2 = true;
            break;
          }
        }
      }
      if (!hasTransform2)
        return;
      let needsMeasure = !prevProps;
      if (prevProps) {
        for (let i2 = 0; i2 < layoutProps.length; i2++) {
          const key = layoutProps[i2];
          if (props[key] !== prevProps[key]) {
            needsMeasure = true;
          }
        }
      }
      if (!needsMeasure)
        return;
      frame.read(() => {
        updateSVGDimensions(current2, renderState);
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, isSVGTag(current2.tagName), props.transformTemplate);
          renderSVG(current2, renderState);
        });
      });
    }
  })
};
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent2(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config);
  };
}
function resolveVariant(visualElement, definition2, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition2, custom !== void 0 ? custom : props.custom, visualElement);
}
function getValueTransition(transition, key) {
  return (transition == null ? void 0 : transition[key]) ?? (transition == null ? void 0 : transition["default"]) ?? transition;
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.version = "12.6.5";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current2) {
    this.current = current2;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current2 !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current2, delta) {
    this.set(current2);
    this.prev = void 0;
    this.prevFrameValue = prev2;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition2) {
  const resolved = resolveVariant(visualElement, definition2);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
class GroupAnimation {
  constructor(animations2) {
    this.stop = () => this.runAll("stop");
    this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => animation.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++) {
      this.animations[i2][propName] = newValue;
    }
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => {
      if (supportsScrollTimeline() && animation.attachTimeline) {
        return animation.attachTimeline(timeline);
      } else if (typeof fallback === "function") {
        return fallback(animation);
      }
    });
    return () => {
      subscriptions.forEach((cancel, i2) => {
        cancel && cancel();
        this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max = 0;
    for (let i2 = 0; i2 < this.animations.length; i2++) {
      max = Math.max(max, this.animations[i2].duration);
    }
    return max;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupAnimationWithThen extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
}
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e2) {
    return false;
  }
  return true;
}, "linearEasing");
const generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += easing(i2 / (numPoints - 1)) + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const cubicBezierAsString = ([a, b2, c2, d2]) => `cubic-bezier(${a}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function" && supportsLinearEasing()) {
    return generateLinearEasing(easing, duration);
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
function startWaapiAnimation(element2, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  const animation = element2.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal",
    pseudoElement
  });
  return animation;
}
function isGenerator(type2) {
  return typeof type2 === "function" && "applyToOptions" in type2;
}
function isWaapiSupportedEasing(easing) {
  return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
function attachTimeline(animation, timeline) {
  animation.timeline = timeline;
  animation.onfinish = null;
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type2, testProp) => (v2) => {
  return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 !== "string")
    return v2;
  const [a, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  var _a2, _b2;
  return isNaN(v2) && typeof v2 === "string" && (((_a2 = v2.match(floatRegex)) == null ? void 0 : _a2.length) || 0) + (((_b2 = v2.match(colorRegex)) == null ? void 0 : _b2.length) || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types2 = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i2);
      types2.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types2.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types2.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types: types2 };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types: types2 } = analyseComplexValue(source);
  const numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split[i2];
      if (v2[i2] !== void 0) {
        const type2 = types2[i2];
        if (type2 === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type2 === COLOR_TOKEN) {
          output += color.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter2 = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter: filter2,
  WebkitFilter: filter2
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter2)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i2];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
const radToDeg = (rad) => rad * 180 / Math.PI;
const rotate = (v2) => {
  const angle = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
};
const rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return angle;
};
const rotateZ = rotate;
const scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
const scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform, name) {
  if (!transform || transform === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match2;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match2 = matrix3dMatch;
  } else {
    const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match2 = matrix2dMatch;
  }
  if (!match2) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values = match2[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
  y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver2) => resolver2.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver2) => resolver2.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element2) => {
      const removedTransforms = removeNonTranslationalTransform(element2);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element2, removedTransforms);
      element2.render();
    });
    resolversToMeasure.forEach((resolver2) => resolver2.measureInitialState());
    elementsToMeasure.forEach((element2) => {
      element2.render();
      const restore = transformsToRestore.get(element2);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a2;
          (_a2 = element2.getValue(key)) == null ? void 0 : _a2.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver2) => resolver2.measureEndState());
    resolversToMeasure.forEach((resolver2) => {
      if (resolver2.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver2.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver2) => resolver2.complete());
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver2) => {
    resolver2.readKeyframes();
    if (resolver2.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element2, isAsync = false) {
    this.isComplete = false;
    this.isAsync = false;
    this.needsMeasurement = false;
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element2;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element: element2, motionValue: motionValue2 } = this;
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (unresolvedKeyframes[i2] === null) {
        if (i2 === 0) {
          const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element2 && name) {
            const valueAsRead = element2.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
        }
      }
    }
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete)
      this.scheduleResolve();
  }
}
const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current2) {
  const match2 = splitCSSVariableRegex.exec(current2);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current2, element2, depth = 1) {
  const [token2, fallback] = parseCSSVariable(current2);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element2).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element2, depth + 1) : fallback;
}
const testValueType = (v2) => (type2) => type2.test(v2);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element2) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element2, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element: element2, name } = this;
    if (!element2 || !element2.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element2.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i2] = resolved;
          }
          if (i2 === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        const value = unresolvedKeyframes[i2];
        if (typeof value === "string") {
          unresolvedKeyframes[i2] = parseFloat(value);
        }
      }
    } else {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (isNone(unresolvedKeyframes[i2])) {
        noneKeyframeIndexes.push(i2);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element: element2, unresolvedKeyframes, name } = this;
    if (!element2 || !element2.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element2.measureViewportBox(), window.getComputedStyle(element2.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element2.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a2;
    const { element: element2, name, unresolvedKeyframes } = this;
    if (!element2 || !element2.current)
      return;
    const value = element2.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element2.measureViewportBox(), window.getComputedStyle(element2.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a2 = this.removedTransforms) == null ? void 0 : _a2.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element2.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current2 = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current2)
      return true;
  }
}
function canAnimate(keyframes2, name, type2, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type2 === "spring" || isGenerator(type2)) && velocity;
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({ autoplay = true, delay: delay2 = 0, type: type2 = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.createdAt = time.now();
    this.options = {
      autoplay,
      delay: delay2,
      type: type2,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    if (!this.resolvedAt)
      return this.createdAt;
    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time.now();
    this.hasAttemptedResolve = true;
    const { name, type: type2, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type2, velocity)) {
      if (!delay2) {
        onUpdate && onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete && onComplete();
        this.resolveFinishedPromise();
        return;
      } else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    if (resolvedAnimation === false)
      return;
    this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    if (!this.options.allowFlatten)
      return;
    this.options.type = "keyframes";
    this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
const mixNumber$1 = (from2, to, progress2) => {
  return from2 + (to - from2) * progress2;
};
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a, b2) {
  return (p2) => p2 > 0 ? b2 : a;
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  const expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
function asRGBA(color2) {
  const type2 = getColorType(color2);
  if (!Boolean(type2))
    return false;
  let model = type2.parse(color2);
  if (type2 === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from2, to);
  }
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
const combineFunctions = (a, b2) => (v2) => b2(a(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p2) => p2 <= 0 ? origin : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin;
  }
}
function mixNumber(a, b2) {
  return (p2) => mixNumber$1(a, b2, p2);
}
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b2) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
function mixObject(a, b2) {
  const output = { ...a, ...b2 };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b2[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b2[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type2 = target.types[i2];
    const originIndex = origin.indexes[type2][pointers[type2]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue;
    pointers[type2]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
function mix(from2, to, p2) {
  if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
    return mixNumber$1(from2, to, p2);
  }
  const mixer = getMixer(from2);
  return mixer(from2, to);
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current2) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current2 - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -1e-3 + a * b2;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = /* @__PURE__ */ secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys2) {
  return keys2.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root2 = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root2 * root2;
      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current2 = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0;
        if (dampingRatio < 1) {
          currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current2);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current2) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current2;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = supportsLinearEasing() ? generatorOptions.ease : "easeOut";
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  const nearestBoundary = (v2) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition2) => {
  if (isBezierDefinition(definition2)) {
    invariant(definition2.length === 4);
    const [x1, y1, x2, y2] = definition2;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition2 === "string") {
    return easingLookup[definition2];
  }
  return definition2;
};
const progress = /* @__NO_SIDE_EFFECTS__ */ (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration;
      return state;
    }
  };
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
const percentToProgress = (percent2) => percent2 / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    this.holdTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.startTime = null;
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element: element2, keyframes: keyframes2 } = this.options;
    const KeyframeResolver$1 = (element2 == null ? void 0 : element2.KeyframeResolver) || KeyframeResolver;
    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element2);
    this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten();
    if (this._resolved) {
      Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
  }
  initPlayback(keyframes$1) {
    const { type: type2 = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = isGenerator(type2) ? type2 : generators[type2] || keyframes;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: true, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? /* @__PURE__ */ millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now2 = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? this.calcStartTime();
    } else if (this.state === "finished") {
      this.startTime = now2;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = this.currentTime ?? 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time2) {
    this.startTime = 0;
    return this.tick(time2, true);
  }
  get finished() {
    return this.currentFinishedPromise;
  }
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
const sampleDelta = 10;
const maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t2 = 0;
  while (!state.done && t2 < maxDuration) {
    state = sampleAnimation.sample(t2);
    pregeneratedKeyframes.push(state.value);
    t2 += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t2 - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element: element2, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element2);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    let { duration = 300, times, ease: ease2, type: type2, motionValue: motionValue2, name, startTime } = this.options;
    if (!motionValue2.owner || !motionValue2.owner.current) {
      return false;
    }
    if (typeof ease2 === "string" && supportsLinearEasing() && isUnsupportedEase(ease2)) {
      ease2 = unsupportedEasingFunctions[ease2];
    }
    if (requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element: element2, ...options } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes;
      if (keyframes2.length === 1) {
        keyframes2[1] = keyframes2[0];
      }
      duration = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease2 = pregeneratedAnimation.ease;
      type2 = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    animation.startTime = startTime ?? this.calcStartTime();
    if (this.pendingTimeline) {
      attachTimeline(animation, this.pendingTimeline);
      this.pendingTimeline = void 0;
    } else {
      animation.onfinish = () => {
        const { onComplete } = this.options;
        motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation,
      duration,
      times,
      type: type2,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return /* @__PURE__ */ millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return /* @__PURE__ */ millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  get finished() {
    return this.resolved.animation.finished;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const { resolved } = this;
      if (!resolved)
        return noop;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    if (animation.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle")
      return;
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type: type2, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished") {
      return;
    }
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element: element2, ...options } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type: type2,
        ease: ease2,
        times,
        isGenerator: true
      });
      const sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop();
    this.cancel();
  }
  complete() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type: type2 } = options;
    if (!motionValue2 || !motionValue2.owner || !(motionValue2.owner.current instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type2 !== "inertia";
  }
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element2, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element2
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return new GroupAnimationWithThen([]);
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type: type2 } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type2 && visualElement.animationState && visualElement.animationState.getState()[type2];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a2 = visualElement.presenceContext) == null ? void 0 : _a2.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b2) {
  return a.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition2, options = {}) {
  visualElement.notify("AnimationStart", definition2);
  let animation;
  if (Array.isArray(definition2)) {
    const animations2 = definition2.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition2 === "string") {
    animation = animateVariant(visualElement, definition2, options);
  } else {
    const resolvedDefinition = typeof definition2 === "function" ? resolveVariant(visualElement, definition2, options.custom) : definition2;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition2);
  });
}
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev2[i2] !== next2[i2])
      return false;
  }
  return true;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type2) => (acc, definition2) => {
    var _a2;
    const resolved = resolveVariant(visualElement, definition2, type2 === "exit" ? (_a2 = visualElement.presenceContext) == null ? void 0 : _a2.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type2 = reversePriorityOrder[i2];
      const typeState = state[type2];
      const prop = props[type2] !== void 0 ? props[type2] : context[type2];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type2 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type2] && prop !== props[type2] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type2 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type2), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next2 = resolvedValues[key];
        const prev2 = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
          valueHasChanged = !shallowCompare(next2, prev2);
        } else {
          valueHasChanged = next2 !== prev2;
        }
        if (valueHasChanged) {
          if (next2 !== void 0 && next2 !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next2 !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type: type2 }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type2, isActive) {
    var _a2;
    if (state[type2].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) == null ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) == null ? void 0 : _a3.setActive(type2, isActive);
    });
    state[type2].isActive = isActive;
    const animations2 = animateChanges(type2);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a2;
    this.node.animationState.reset();
    (_a2 = this.unmountControls) == null ? void 0 : _a2.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point2, transformPoint2) {
  if (!transformPoint2)
    return point2;
  const topLeft = transformPoint2({ x: point2.left, y: point2.top });
  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point2, scale2, originPoint) {
  const distanceFromOrigin = point2 - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, boxScale, originPoint);
  }
  return scalePoint(point2, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2];
    delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element2, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element2, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const getContextWindow = ({ current: current2 }) => {
  return current2 ? current2.ownerDocument.defaultView : null;
};
const distance = (a, b2) => Math.abs(a - b2);
function distance2D(a, b2) {
  const xDelta = distance(a.x, b2.x);
  const yDelta = distance(a.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers2, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point3 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point3, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers2;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point: point2 } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point2, timestamp }];
    const { onSessionStart } = handlers2;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers2) {
    this.handlers = handlers2;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b2) {
  return { x: a.x - b2.x, y: a.y - b2.y };
}
function getPanInfo({ point: point2 }, history) {
  return {
    point: point2,
    delta: subtractPoint(point2, lastDevicePoint(history)),
    offset: subtractPoint(point2, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point2, { min, max }, elastic) {
  if (min !== void 0 && point2 < min) {
    point2 = elastic ? mixNumber$1(min, point2, elastic.min) : Math.max(point2, min);
  } else if (max !== void 0 && point2 > max) {
    point2 = elastic ? mixNumber$1(max, point2, elastic.max) : Math.min(point2, max);
  }
  return point2;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current2 = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current2)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current2 = length2 * (parseFloat(current2) / 100);
            }
          }
        }
        this.originPoint[axis] = current2;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset2);
      this.updateAxis("y", info.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis((axis) => {
      var _a2;
      return this.getAnimationState(axis) === "paused" && ((_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.play());
    });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    var _a2;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a2 = this.visualElement.projection) == null ? void 0 : _a2.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.pause();
    });
  }
  getAnimationState(axis) {
    var _a2;
    return (_a2 = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a2.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point2) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point2[axis] - mixNumber$1(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element2 = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element2, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template(shadow);
  }
};
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
function isSVGElement(element2) {
  return element2 instanceof SVGElement && element2.tagName !== "svg";
}
const compareByDepth = (a, b2) => a.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(min, max, easing) {
  return (p2) => {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(/* @__PURE__ */ progress(min, max, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function removePointDelta(point2, translate, scale2, originPoint, boxScale) {
  point2 -= translate;
  point2 = scalePoint(point2, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point2 = scalePoint(point2, 1 / boxScale, originPoint);
  }
  return point2;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b2) {
  return a.min === b2.min && a.max === b2.max;
}
function boxEquals(a, b2) {
  return axisEquals(a.x, b2.x) && axisEquals(a.y, b2.y);
}
function axisEqualsRounded(a, b2) {
  return Math.round(a.min) === Math.round(b2.min) && Math.round(a.max) === Math.round(b2.max);
}
function boxEqualsRounded(a, b2) {
  return axisEqualsRounded(a.x, b2.x) && axisEqualsRounded(a.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b2) {
  return a.translate === b2.translate && a.scale === b2.scale && a.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate2)
      transform += `rotate(${rotate2}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = { visibility: "hidden" };
const animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a2;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a2;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a2 = this.scroll) == null ? void 0 : _a2.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        const { scroll, options } = node2;
        if (node2 !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a2;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a2 = this.parent) == null ? void 0 : _a2.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2;
      (_a2 = this.options.visualElement) == null ? void 0 : _a2.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot2 = this.snapshot;
      const snapshotLatestValues = snapshot2 ? snapshot2.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot2 ? snapshot2.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) == null ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) == null ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            styles[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a2;
        return (_a2 = node2.currentAnimation) == null ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a2;
  const snapshot2 = ((_a2 = node2.resumeFrom) == null ? void 0 : _a2.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot2 && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot2.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot2.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot2.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot2.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot2.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot2.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot: snapshot2,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2);
  output.scale = mixNumber$1(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p2) {
  output.min = mixNumber$1(from2.min, to.min, p2);
  output.max = mixNumber$1(from2.max, to.max, p2);
}
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot2, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot2), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  var _a2;
  return node2 !== node2.root && ((_a2 = node2.scroll) == null ? void 0 : _a2.wasRoot);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root2 = document;
    const elements = (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ?? root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element2) => {
    element2.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
function handleHoverEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.animationState && props.whileHover) {
    node2.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    if (!current2)
      return;
    this.unmount = hover(current2, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element2) {
  return focusableElements.has(element2.tagName) || element2.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type2) {
  target.dispatchEvent(new PointerEvent("pointer" + type2, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element2 = focusEvent.currentTarget;
  if (!element2)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element2))
      return;
    firePointerEvent(element2, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element2, "up");
    });
    const handleBlur = () => firePointerEvent(element2, "cancel");
    element2.addEventListener("keyup", handleKeyup, eventOptions);
    element2.addEventListener("blur", handleBlur, eventOptions);
  });
  element2.addEventListener("keydown", handleKeydown, eventOptions);
  element2.addEventListener("blur", () => element2.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent) || isPressing.has(target))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {
        return;
      }
      isPressing.delete(target);
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (target instanceof HTMLElement) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function handlePressEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
    return;
  }
  if (node2.animationState && props.whileTap) {
    node2.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current: current2 } = this.node;
    if (!current2)
      return;
    this.unmount = press(current2, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element2, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element2, callback);
  rootInteresectionObserver.observe(element2);
  return () => {
    observerCallbacks.delete(element2);
    rootInteresectionObserver.unobserve(element2);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element2, next2, prev2) {
  for (const key in next2) {
    const nextValue = next2[key];
    const prevValue = prev2[key];
    if (isMotionValue(nextValue)) {
      element2.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element2.addValue(key, motionValue(nextValue, { owner: element2 }));
    } else if (prevValue !== nextValue) {
      if (element2.hasValue(key)) {
        const existingValue = element2.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element2.getStaticValue(key);
        element2.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element2 }));
      }
    }
  }
  for (const key in prev2) {
    if (next2[key] === void 0)
      element2.removeValue(key);
  }
  return next2;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState, onUpdate } = visualState;
    this.onUpdate = onUpdate;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
    this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a2 = this.presenceContext) == null ? void 0 : _a2.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b2) {
    return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
function getComputedStyle$1(element2) {
  return window.getComputedStyle(element2);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      return readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
    this.updateDimensions = () => {
      if (this.current && !this.renderState.dimensions) {
        updateSVGDimensions(this.current, this.renderState);
      }
    };
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  onBindTransform() {
    if (this.current && !this.renderState.dimensions) {
      frame.postRender(this.updateDimensions);
    }
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment
  });
};
const createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);
const motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);
const SITE_ID = CONFIG.currentSite;
const UI_STATE_STORAGE_PREFIX = `agent-ui-state-${SITE_ID}`;
const getStorageKey = (agentName, sessionKey) => `${UI_STATE_STORAGE_PREFIX}-${agentName}${sessionKey ? "-" + sessionKey : ""}`;
const loadUIState = (agentName, sessionKey) => {
  if (typeof localStorage === "undefined") return {};
  try {
    const key = getStorageKey(agentName, sessionKey);
    const storedState = localStorage.getItem(key);
    return storedState ? JSON.parse(storedState) : {};
  } catch (e2) {
    console.error("Failed to load agent UI state:", e2);
    return {};
  }
};
const saveUIState = (agentName, sessionKey, state) => {
  if (typeof localStorage === "undefined") return;
  try {
    const key = getStorageKey(agentName, sessionKey);
    localStorage.setItem(key, JSON.stringify(state));
  } catch (e2) {
    console.error("Failed to save agent UI state:", e2);
  }
};
const clearUIState = (agentName, sessionKey) => {
  if (typeof localStorage === "undefined") return;
  try {
    const key = getStorageKey(agentName, sessionKey);
    localStorage.removeItem(key);
  } catch (e2) {
    console.error("Failed to clear agent UI state:", e2);
  }
};
const defaultUIState = {
  userClosedModal: void 0
};
function useAgentUI(agentName, sessionKey) {
  const queryClient2 = useQueryClient();
  const queryKey = ["agentUIState", agentName, sessionKey || ""];
  const isReady = !!sessionKey;
  const {
    data: uiState = defaultUIState
  } = useQuery({
    queryKey,
    queryFn: () => isReady ? loadUIState(agentName, sessionKey) : defaultUIState,
    staleTime: Infinity,
    enabled: isReady
  });
  const updateUIState = useMutation({
    mutationFn: (newState) => {
      queryClient2.setQueryData(queryKey, (old) => {
        const updatedState = {
          ...old,
          ...newState
        };
        saveUIState(agentName, sessionKey, updatedState);
        return updatedState;
      });
      return Promise.resolve();
    }
  });
  const setUserClosedModal = (closed) => {
    if (isReady) {
      updateUIState.mutate({
        userClosedModal: closed
      });
    }
  };
  const resetUIState = () => {
    clearUIState(agentName, sessionKey);
    queryClient2.setQueryData(queryKey, defaultUIState);
  };
  return {
    userClosedModal: uiState.userClosedModal,
    setUserClosedModal,
    resetUIState
  };
}
const ChatModal = ({
  isOpen,
  toggleChat,
  resetUIState,
  modalTitle = "Ask an Agent",
  children,
  ...props
}) => {
  const {
    messages,
    isLoading,
    sendMessage,
    resetSession
  } = useAgentAPI();
  const [newMessage, setNewMessage] = reactExports.useState("");
  const [menuOpen, setMenuOpen] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  const menuRef = reactExports.useRef(null);
  const chatContainerRef = reactExports.useRef(null);
  const skip = props.skip || [];
  reactExports.useEffect(() => {
    if (skip.includes(1) && messages.length === 1) {
      sendMessage("");
    }
  }, [skip, messages.length]);
  reactExports.useEffect(() => {
    if (isOpen && inputRef.current) {
      const focusTimer = setTimeout(() => {
        inputRef.current.focus();
      }, 500);
      return () => clearTimeout(focusTimer);
    }
  }, [isOpen]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (menuRef.current && !menuRef.current.contains(event.target)) {
        setMenuOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const handleSubmit = (e2) => {
    e2.preventDefault();
    if (newMessage.trim()) {
      sendMessage(newMessage);
      setMenuOpen(false);
      setNewMessage("");
    }
  };
  const handleResetSession = () => {
    resetSession();
    resetUIState();
    setMenuOpen(false);
  };
  const scrollChatContainer = () => {
    if (props.autoScroll === false) return;
    setTimeout(() => {
      var _a2;
      (_a2 = chatContainerRef.current) == null ? void 0 : _a2.scroll(0, chatContainerRef.current.scrollHeight);
    }, 100);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs("div", { className: "text-white p-2 flex justify-between items-center", children: [
      /* @__PURE__ */ jsxs("div", { className: "flex items-center space-x-2 pl-2", children: [
        /* @__PURE__ */ jsx(AgentSessionIcon, { className: "h-6 w-6" }),
        /* @__PURE__ */ jsx("h3", { className: "!mb-0 !text-lg", children: modalTitle }),
        /* @__PURE__ */ jsxs("div", { className: "relative", ref: menuRef, children: [
          /* @__PURE__ */ jsx("button", { onClick: () => setMenuOpen(!menuOpen), className: "text-white hover:bg-primary/50 rounded-full p-1 transition-colors", children: /* @__PURE__ */ jsx(EllipsisVerticalIcon, { className: "h-5 w-5" }) }),
          menuOpen && /* @__PURE__ */ jsx("div", { className: "absolute left-0 mt-1 w-40 bg-white rounded-md shadow-lg z-10 text-black", children: /* @__PURE__ */ jsx("button", { onClick: handleResetSession, className: "block w-full text-left px-4 py-2 hover:bg-gray-100 rounded-md", children: "Reset Session" }) })
        ] })
      ] }),
      /* @__PURE__ */ jsx("button", { onClick: toggleChat, className: "text-white hover:bg-primary rounded-full p-1 transition-colors", children: /* @__PURE__ */ jsx(CloseIcon, { className: "h-5 w-5" }) })
    ] }),
    /* @__PURE__ */ jsx("div", { className: "bg-white flex-1 p-3 overflow-y-auto scroll-smooth", style: {
      minHeight: "300px"
    }, ref: chatContainerRef, children: /* @__PURE__ */ jsx(MessagesView, { messages, isLoading, onUpdate: scrollChatContainer, inlineRecommendations: true, ...props, children }) }),
    /* @__PURE__ */ jsxs("form", { onSubmit: handleSubmit, className: "bg-white border-t p-3 flex", children: [
      /* @__PURE__ */ jsx("input", { ref: inputRef, type: "text", value: newMessage, onChange: (e2) => setNewMessage(e2.target.value), placeholder: "Type your question...", className: "flex-1 border border-gray-300 rounded-l-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary" }),
      /* @__PURE__ */ jsx("button", { type: "submit", className: "bg-primary hover:bg-secondary text-white px-4 py-2 rounded-r-lg transition-colors", children: /* @__PURE__ */ jsx(SendIcon, { className: "h-5 w-5" }) })
    ] })
  ] });
};
function shouldAutoOpenModal(autoOpen, autoOpenConditions) {
  if (autoOpen) {
    return true;
  }
  if ((autoOpenConditions == null ? void 0 : autoOpenConditions.pathIncludes) && typeof window !== "undefined" && window.location.pathname.includes(autoOpenConditions == null ? void 0 : autoOpenConditions.pathIncludes)) {
    return true;
  }
  if ((autoOpenConditions == null ? void 0 : autoOpenConditions.selector) && typeof document !== "undefined" && document.querySelector(autoOpenConditions == null ? void 0 : autoOpenConditions.selector)) {
    return true;
  }
  if ((autoOpenConditions == null ? void 0 : autoOpenConditions.selectorWithData) && typeof document !== "undefined") {
    const {
      selector,
      triggeringConditions = [],
      blockingConditions = []
    } = autoOpenConditions.selectorWithData;
    const containers = document.querySelectorAll(selector);
    let hasTriggeringCondition = false;
    let hasBlockingCondition = false;
    for (let i2 = 0; i2 < containers.length; i2++) {
      const container = containers[i2];
      for (const condition of triggeringConditions) {
        const elementsWithAttribute = container.querySelectorAll(`[${condition.attribute}]`);
        for (let j = 0; j < elementsWithAttribute.length; j++) {
          if (elementsWithAttribute[j].getAttribute(condition.attribute) === condition.value) {
            hasTriggeringCondition = true;
            break;
          }
        }
        if (hasTriggeringCondition) break;
      }
      for (const condition of blockingConditions) {
        const elementsWithAttribute = container.querySelectorAll(`[${condition.attribute}]`);
        for (let j = 0; j < elementsWithAttribute.length; j++) {
          if (elementsWithAttribute[j].getAttribute(condition.attribute) === condition.value) {
            hasBlockingCondition = true;
            break;
          }
        }
        if (hasBlockingCondition) break;
      }
      if (hasTriggeringCondition || hasBlockingCondition) break;
    }
    if (hasTriggeringCondition && !hasBlockingCondition) {
      return true;
    }
  }
  return false;
}
const ShopperAgentModal = ({
  buttonText = "Ask an Agent",
  showChatToggleButton = true,
  messagePrefix = "",
  messageSuffix = "",
  children,
  autoOpen = false,
  autoOpenConditions = {},
  ...props
}) => {
  const {
    subscribe,
    isLoading,
    sessionId
  } = useAgentAPI();
  const {
    agent
  } = reactExports.useContext(AgentContext);
  const {
    userClosedModal,
    setUserClosedModal,
    resetUIState
  } = useAgentUI((agent == null ? void 0 : agent.name) || "default", sessionId || null);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const [isLoadingUiPrefs, setIsLoadingUiPrefs] = reactExports.useState(true);
  const hasDecidedToOpen = reactExports.useRef(false);
  const toggleChat = () => {
    setIsOpen(!isOpen);
    setUserClosedModal(isOpen);
  };
  reactExports.useEffect(() => {
    const unsub = subscribe("agent:openModal", () => {
      setIsOpen(true);
      setUserClosedModal(false);
    });
    const unsub1 = subscribe("agent:closeModal", () => {
      setIsOpen(false);
      setUserClosedModal(true);
    });
    const unsub2 = subscribe("agent:toggleModal", () => {
      setIsOpen((prev2) => {
        const localIsOpen = !prev2;
        setUserClosedModal(!localIsOpen);
        return localIsOpen;
      });
    });
    return () => {
      unsub();
      unsub1();
      unsub2();
    };
  }, [subscribe]);
  reactExports.useEffect(() => {
    if (!isLoading && sessionId) {
      setIsLoadingUiPrefs(false);
    }
  }, [isLoading, sessionId]);
  reactExports.useEffect(() => {
    if (!isLoadingUiPrefs && !hasDecidedToOpen.current) {
      hasDecidedToOpen.current = true;
      if (userClosedModal !== true && shouldAutoOpenModal(autoOpen, autoOpenConditions)) {
        setIsOpen(true);
        setUserClosedModal(false);
      }
    }
  }, [isLoadingUiPrefs, userClosedModal, autoOpen, autoOpenConditions]);
  return /* @__PURE__ */ jsxs(AgentConfig, { messagePrefix, messageSuffix, children: [
    showChatToggleButton && /* @__PURE__ */ jsx(ChatToggleButton, { onToggle: toggleChat, text: buttonText }),
    ReactDOM.createPortal(/* @__PURE__ */ jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsx(motion.div, { initial: {
      opacity: 0,
      top: 0,
      left: 16
    }, animate: {
      opacity: 1,
      top: "auto",
      bottom: 16,
      left: 16
    }, exit: {
      opacity: 0,
      top: 0,
      left: 16,
      bottom: "auto"
    }, transition: {
      duration: 0.5,
      ease: "easeOut"
    }, className: "fixed w-90 md:w-116 bg-primary rounded-t-lg shadow-2xl shadow-black/30 flex flex-col z-50 border border-primary", role: "dialog", "aria-modal": "true", style: {
      maxHeight: "50vh"
    }, children: /* @__PURE__ */ jsx(ChatModal, { isOpen, toggleChat, resetUIState, modalTitle: buttonText, ...props, children }) }) }), document.body)
  ] });
};
const ChatToggleButton = ({
  onToggle,
  text: text2
}) => {
  return /* @__PURE__ */ jsxs("button", { onClick: onToggle, className: "flex items-center space-x-2 bg-primary hover:bg-secondary text-white px-4 py-2 rounded-full shadow-md transition-all duration-300", children: [
    /* @__PURE__ */ jsx(SparklesIcon, { className: "h-6 w-6" }),
    /* @__PURE__ */ jsx("span", { children: text2 })
  ] });
};
const productDetailDiv = document.querySelector(".product-detail");
const SFRAProductDetailScope = ({
  children
}) => {
  const pid = reactExports.useMemo(() => {
    var pid2 = productDetailDiv == null ? void 0 : productDetailDiv.getAttribute("data-master-pid");
    if (!pid2) {
      pid2 = productDetailDiv == null ? void 0 : productDetailDiv.getAttribute("data-pid");
    }
    return pid2;
  }, []);
  if (!productDetailDiv || !pid) {
    return null;
  }
  return /* @__PURE__ */ jsx(AgentConfig, { variables: {
    pid
  }, sessionKey: pid, children });
};
const ShopperProductHelper = ({
  buttonText = "Ask an Agent",
  messagePrefix = "",
  messageSuffix = ""
}) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const {
    subscribe
  } = useAgentAPI();
  const toggleChat = () => {
    setIsOpen(!isOpen);
  };
  reactExports.useEffect(() => {
    const unsub = subscribe("agent:openModal", () => {
      setIsOpen(true);
    });
    const unsub1 = subscribe("agent:closeModal", () => {
      setIsOpen(false);
    });
    const unsub2 = subscribe("agent:toggleModal", () => {
      setIsOpen((prev2) => !prev2);
    });
    return () => {
      unsub();
      unsub1();
      unsub2();
    };
  }, [subscribe]);
  return /* @__PURE__ */ jsx(AgentConfig, { messagePrefix, messageSuffix, children: /* @__PURE__ */ jsxs(SFRAProductDetailScope, { children: [
    /* @__PURE__ */ jsx(ChatToggleButton, { onToggle: toggleChat, text: buttonText }),
    ReactDOM.createPortal(/* @__PURE__ */ jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsx(motion.div, { initial: {
      opacity: 0,
      top: 0,
      left: 16
    }, animate: {
      opacity: 1,
      top: "auto",
      bottom: 16,
      left: 16
    }, exit: {
      opacity: 0,
      top: 0,
      left: 16,
      bottom: "auto"
    }, transition: {
      duration: 0.5,
      ease: "easeOut"
    }, className: "fixed w-90 md:w-116 bg-primary rounded-t-lg shadow-2xl shadow-black/30 flex flex-col z-50 border border-primary", role: "dialog", "aria-modal": "true", style: {
      maxHeight: "50vh"
    }, children: /* @__PURE__ */ jsx(ChatModal, { isOpen, toggleChat }) }) }), document.body)
  ] }) });
};
function Query({
  query,
  output = "match",
  children,
  message,
  lastMessage = false,
  ...props
}) {
  const {
    data: data2,
    messages
  } = useAgentAPI();
  const agentMessages = messages == null ? void 0 : messages.filter((m2) => m2.MESSAGE_TYPE === "AGENT");
  const lastAgentMessage = agentMessages == null ? void 0 : agentMessages[agentMessages.length - 1];
  const {
    result,
    isLoading
  } = useExpr(
    query,
    // if message is provided, use that as the data source
    // if lastMessage is true, use the last agent message
    // lastly use the merged data layer
    // this way this component can be used in various contexts
    message ? message == null ? void 0 : message.json : lastMessage ? lastAgentMessage == null ? void 0 : lastAgentMessage.json : data2
  );
  if (isLoading || !result) {
    return null;
  }
  const childrenWithProps = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      return React.cloneElement(child, {
        [output]: result,
        ...props
      });
    }
    return child;
  });
  if (!childrenWithProps) {
    return null;
  }
  return /* @__PURE__ */ jsx(Fragment, { children: childrenWithProps });
}
function Template({
  children,
  ...props
}) {
  const childrenWithProps = React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      return React.cloneElement(child, {
        ...props
      });
    }
    if (typeof child === "string") {
      return jsxToReact(child, {
        props
      });
    }
    return child;
  });
  return /* @__PURE__ */ jsx(Fragment, { children: childrenWithProps });
}
function Comment() {
  return /* @__PURE__ */ jsx(Fragment, {});
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
        }
        link2.crossOrigin = "";
        link2.href = dep;
        if (cspNonce) {
          link2.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const ReactQueryDevtoolsProduction = reactExports.lazy(() => __vitePreload(() => import("./assets/production-DMln5lV4.js").then((n2) => n2.W), true ? [] : void 0).then((d2) => ({
  default: d2.ReactQueryDevtools
})));
const DevTools = ({
  showOnLoad = false
}) => {
  const [showDevtools, setShowDevtools] = reactExports.useState(showOnLoad);
  reactExports.useEffect(() => {
    window.toggleDevtools = () => setShowDevtools((old) => !old);
  }, []);
  return /* @__PURE__ */ jsx(Fragment, { children: showDevtools && /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsx(ReactQueryDevtoolsProduction, {}) }) }) });
};
const ALLOWED_COMPONENTS = {
  Portal,
  DevTools,
  // Old name
  SearchTabAgentAPI: SFRASearchTabAgent,
  SFRASearchTabAgent,
  ShopperAgentAPI,
  ShopperPinnedProducts,
  ShopperProductHelper,
  AgentConfig,
  SFRAProductDetailScope,
  ShopperAgentModal,
  // templating
  Query,
  Template,
  Comment,
  // Message Views
  Messages,
  MarkdownMessageView,
  ProductTilesMessageView,
  ChatInput,
  // Products
  ProductTile
};
[...Object.keys(typeof window !== "undefined" ? window : {}), "window", "eval", "Function"];
function jsxToReact(jsxString, {
  props
}) {
  const allowedComponents = ALLOWED_COMPONENTS;
  return /* @__PURE__ */ jsx(source_default, { bindings: {
    ...props
  }, onError: (e2) => {
    throw e2;
  }, components: allowedComponents, jsx: jsxString, renderInWrapper: false });
}
function CustomDeploymentWrapper({
  children
}) {
  return /* @__PURE__ */ jsx(QueryClientProvider, { client: queryClient, children });
}
function renderFeature(feature) {
  if (!feature.deploymentCode) {
    return;
  }
  const container = document.createElement("div");
  container.id = "root-" + feature.name.replace(/ /g, "-");
  document.body.appendChild(container);
  const root2 = createRoot(container);
  root2.render(/* @__PURE__ */ jsx(CustomDeploymentWrapper, { children: jsxToReact(feature.deploymentCode, {
    props: feature.props || {}
  }) }));
}
function CustomAgentWrapper({
  agent,
  children,
  initialContext = {}
}) {
  const [runtimeContext, setRuntimeContext] = React.useState(initialContext);
  reactExports.useEffect(() => {
    const unsub = qlabsSubscribe("agent:setRuntimeContext", (context) => {
      setRuntimeContext((prevContext) => ({
        ...prevContext,
        ...context
      }));
    }, {
      agentName: agent.name
    });
    return () => {
      unsub();
    };
  }, [agent == null ? void 0 : agent.name, setRuntimeContext]);
  return /* @__PURE__ */ jsx(AgentProvider, { value: {
    agent,
    runtimeContext,
    setRuntimeContext
  }, children: /* @__PURE__ */ jsx(QueryClientProvider, { client: queryClient, children }) });
}
const calcSpacingCSS = (value) => {
  if (!value) {
    return void 0;
  }
  var _value = value;
  if (typeof _value === "number") {
    _value = _value.toFixed(0);
  }
  return `calc(var(--spacing) * ${_value})`;
};
const withContainerStyles = (Component) => {
  const ContainedComponent = ({
    __containerStyles,
    ...props
  }) => {
    const containerStyles = __containerStyles || {};
    const {
      padding,
      margin
    } = containerStyles;
    const styles = {
      backgroundColor: containerStyles.backgroundColor,
      textColor: containerStyles.textColor,
      paddingTop: calcSpacingCSS(padding == null ? void 0 : padding.top),
      paddingRight: calcSpacingCSS(padding == null ? void 0 : padding.right),
      paddingBottom: calcSpacingCSS(padding == null ? void 0 : padding.bottom),
      paddingLeft: calcSpacingCSS(padding == null ? void 0 : padding.left),
      marginTop: calcSpacingCSS(margin == null ? void 0 : margin.top),
      marginRight: calcSpacingCSS(margin == null ? void 0 : margin.right),
      marginBottom: calcSpacingCSS(margin == null ? void 0 : margin.bottom),
      marginLeft: calcSpacingCSS(margin == null ? void 0 : margin.left)
    };
    return /* @__PURE__ */ jsx("div", { style: {
      backgroundColor: styles.backgroundColor,
      color: styles.textColor,
      paddingTop: styles.paddingTop,
      paddingRight: styles.paddingRight,
      paddingBottom: styles.paddingBottom,
      paddingLeft: styles.paddingLeft,
      marginTop: styles.marginTop,
      marginRight: styles.marginRight,
      marginBottom: styles.marginBottom,
      marginLeft: styles.marginLeft
    }, children: /* @__PURE__ */ jsx(Component, { ...props }) });
  };
  return ContainedComponent;
};
function renderCustomAgent(agent) {
  const pdAgents = document.querySelectorAll(`div[data-agent="${agent.__id}"]`);
  if (pdAgents.length > 0) {
    pdAgents.forEach((agentDiv) => {
      const agentId = agentDiv.getAttribute("data-agent");
      if (!agentId) {
        console.warn("Missing data-agent or data-agent-target attribute on template script");
        return;
      }
      let context = {};
      const contextAttr = agentDiv.getAttribute("data-agent-context");
      if (contextAttr) {
        try {
          context = JSON.parse(decodeURIComponent(contextAttr));
        } catch (e2) {
          console.error("Failed to parse data-agent-context:", e2);
        }
      }
      let containerStyles = {};
      const containerStylesAttr = agentDiv.getAttribute("data-__container-styles");
      if (containerStylesAttr) {
        try {
          containerStyles = JSON.parse(decodeURIComponent(containerStylesAttr));
        } catch (e2) {
          console.error("Failed to parse data-__container-styles:", e2);
        }
      }
      try {
        const agentReact = parseAgentHtml(agentDiv);
        const targetElement = document.createElement("div");
        agentDiv.insertAdjacentElement("afterend", targetElement);
        const root22 = createRoot(targetElement);
        const AgentComponent = withContainerStyles(CustomAgentWrapper);
        root22.render(/* @__PURE__ */ jsx(AgentComponent, { __containerStyles: containerStyles, agent, initialContext: context, children: agentReact }));
      } catch (e2) {
        console.error("Error rendering agent component:", e2);
      }
    });
  }
  if (!agent.deploymentCode) {
    return;
  }
  const container = document.createElement("div");
  container.id = "root-" + agent.name.replace(/ /g, "-");
  document.body.appendChild(container);
  const root2 = createRoot(container);
  root2.render(/* @__PURE__ */ jsx(CustomAgentWrapper, { agent, children: jsxToReact(agent.deploymentCode, {
    props: {}
  }) }));
}
function decodeAndParseJson(encodedValue) {
  try {
    const decoded = decodeURIComponent(encodedValue);
    try {
      return JSON.parse(decoded);
    } catch (parseError) {
      console.error(`Error parsing JSON for attribute`, parseError, "\nRaw value:", decoded);
      return void 0;
    }
  } catch (decodeError) {
    console.error(`Error decoding URI component for attribute`, decodeError, "\nRaw value:", encodedValue);
    return void 0;
  }
}
function parseAgentComponentsRecursive(parentElement, componentRegistry = ALLOWED_COMPONENTS) {
  var _a2, _b2, _c2;
  const collectedReactElements = [];
  for (const node2 of parentElement.childNodes) {
    if (node2.nodeType !== 1) {
      continue;
    }
    const componentName = (_a2 = node2.dataset) == null ? void 0 : _a2.agentComponent;
    if (componentName !== void 0) {
      const Component = componentRegistry[componentName];
      if (!Component) {
        console.warn(`Component "${componentName}" not found in registry. Skipping element:`, node2);
        continue;
      }
      const propsAttr = (_b2 = node2.dataset) == null ? void 0 : _b2.props;
      var props = {};
      if (propsAttr) {
        props = decodeAndParseJson(propsAttr);
      }
      const containerStylesAttr = (_c2 = node2.dataset) == null ? void 0 : _c2.__containerStyles;
      if (containerStylesAttr) {
        const containerStyles = decodeAndParseJson(containerStylesAttr);
        if (containerStyles) {
          props.__containerStyles = containerStyles;
        }
      }
      const directChildren = parseAgentComponentsRecursive(node2, componentRegistry);
      try {
        const element2 = React.createElement(withContainerStyles(Component), props, ...directChildren);
        collectedReactElements.push(element2);
      } catch (error) {
        console.error(`Error creating React element for component "${componentName}":`, error, "\nProps:", props, "\nElement:", node2);
      }
    } else {
      const nestedAgentElements = parseAgentComponentsRecursive(node2, componentRegistry);
      collectedReactElements.push(...nestedAgentElements);
    }
  }
  return collectedReactElements;
}
function parseAgentHtml(rootElement) {
  const childReactElements = parseAgentComponentsRecursive(rootElement);
  try {
    return React.createElement(React.Fragment, {}, ...childReactElements);
  } catch (error) {
    console.error("Error creating the Agent element:", error);
    return null;
  }
}
function miawHandlers(siteId) {
  const previousSiteId = window.localStorage.getItem("qlabs-site-id");
  let siteIdChanged = false;
  let clearedSession = false;
  if (previousSiteId !== siteId) {
    console.log(`[QLABS] siteId changed from ${previousSiteId} to ${siteId}`);
    siteIdChanged = true;
  }
  window.localStorage.setItem("qlabs-site-id", siteId);
  try {
    window.addEventListener("onEmbeddedMessagingReady", () => {
      var _a2, _b2;
      if (siteIdChanged && !clearedSession) {
        clearedSession = true;
        window.embeddedservice_bootstrap.userVerificationAPI.clearSession();
      } else {
        window.embeddedservice_bootstrap.prechatAPI.setHiddenPrechatFields({
          siteId,
          scapiShortCode: (_a2 = window == null ? void 0 : window._clientSettings) == null ? void 0 : _a2.scapiShortCode,
          scapiOrgId: (_b2 = window == null ? void 0 : window._clientSettings) == null ? void 0 : _b2.scapiOrgId
        });
      }
    });
  } catch (err) {
    console.error("Error in onEmbeddedMessagingReady event: ", err);
  }
}
const HOSTNAME$1 = new URL(document.baseURI).hostname;
async function migrate() {
  const response = await fetch(`https://${HOSTNAME$1}/on/demandware.store/Sites-Site/default%3bapp%3d__bm_admin/ViewFeatureSwitchPreferences-Show?SelectedMenuItem=feature_switch_manager&CurrentMenuItemId=global-prefs`);
  const html2 = await response.text();
  const parser = new DOMParser();
  const doc = parser.parseFromString(html2, "text/html");
  const form = doc.querySelector('form[name="FormUpdateBetaFeatureSwitchPreferences"]');
  const checkboxes = form.querySelectorAll('input[type="checkbox"]');
  checkboxes.forEach((checkbox) => {
    switch (checkbox.name) {
      case "ScapiHookExecutionEnabled":
        checkbox.checked = true;
        break;
      case "ShopperContextEnabled":
        checkbox.checked = true;
        break;
    }
  });
  const formData = new FormData(form);
  formData.append("ActionButton", "Apply");
  await fetch(form.action, {
    method: form.method || "POST",
    body: formData,
    headers: {}
  });
}
const HOSTNAME = new URL(document.baseURI).hostname;
const MIGRATIONS = {
  ENABLE_COMPOSABLE_FEATURE_TOGGLES: migrate
};
async function getBMAuthGrant() {
  const response = await fetch(`https://${HOSTNAME}/dw/oauth2/access_token`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: `grant_type=urn%3Ademandware%3Aparams%3Aoauth%3Agrant-type%3Aclient-id%3Adwsid%3Adwsecuretoken&client_id=6c957560-464f-4a98-ad0f-5e9662527e27`
  });
  const data2 = await response.json();
  return data2;
}
async function doMigrateInstance() {
  const lastMigration = window.sessionStorage.getItem("qlabs-last-migration");
  if (lastMigration) {
    return;
  }
  if (!document.location.pathname.includes("Sites-Site")) {
    return;
  }
  var config = {};
  var accessToken2;
  try {
    const authGrant = await getBMAuthGrant();
    if (!authGrant || !authGrant.access_token) {
      console.warn("[QLABS] Could not get BM auth grant; must not be logged in");
      return;
    }
    accessToken2 = authGrant.access_token;
    const response = await fetch(`https://${HOSTNAME}/s/-/dw/data/v23_2/global_preferences/preference_groups/qlabs/development`, {
      headers: {
        Authorization: `Bearer ${accessToken2}`
      }
    });
    const orgPrefs = await response.json();
    const configValue = orgPrefs.c_qlabsCompanionConfig ?? "{}";
    config = JSON.parse(configValue);
  } catch (error) {
    console.error("[QLABS] Error during migration", error);
    return;
  }
  const migrationsApplied = config.migrations ?? [];
  const migrationsRequired = Object.keys(MIGRATIONS).filter((migration) => !migrationsApplied.includes(migration));
  if (migrationsRequired.length === 0) {
    console.log("[QLABS] No client migrations required");
    window.sessionStorage.setItem("qlabs-last-migration", (/* @__PURE__ */ new Date()).toISOString());
    return;
  }
  console.log("[QLABS] Migrations required", migrationsRequired);
  for (const migration of migrationsRequired) {
    try {
      await MIGRATIONS[migration]();
      migrationsApplied.push(migration);
    } catch (error) {
      console.error(`[QLABS] Error applying migration ${migration}`, error);
      return;
    }
  }
  try {
    config.migrations = migrationsApplied;
    const response = await fetch(`https://${HOSTNAME}/s/-/dw/data/v23_2/global_preferences/preference_groups/qlabs/development`, {
      method: "PATCH",
      headers: {
        Authorization: `Bearer ${accessToken2}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        c_qlabsCompanionConfig: JSON.stringify(config)
      })
    });
    if (!response.ok) {
      console.error("[QLABS] Error saving updated config", response);
      return;
    }
  } catch (error) {
    console.error("[QLABS] Error saving updated config", error);
    return;
  }
  window.sessionStorage.setItem("qlabs-last-migration", (/* @__PURE__ */ new Date()).toISOString());
}
const newBMStyles = '/* apply new bm style overrides\n\ndata-controller is added by companion script to support controller scoped styles\n*/\n\n/**\nBroken external image fix\nThis selector is brittle but there should not be other (larger) images in this table\n*/\nbody[data-controller="ViewProduct_52-Edit"] #ssaForm > table > tbody img,\nbody[data-controller="ViewProduct_52-Dispatch"] #ssaForm > table > tbody img {\n    max-width: 40px;\n    max-height: 40px;\n}\n\n/**\nProduct Attribute table\n*/\nbody[data-controller="ViewProduct_52-Edit"] td:has(> span[data-dw-tooltip]),\nbody[data-controller="ViewProduct_52-Dispatch"] td:has(> span[data-dw-tooltip]) {\n    min-width: 230px;\n}\n\nbody[data-controller="ViewProduct_52-Edit"] span[data-dw-tooltip],\nbody[data-controller="ViewProduct_52-Dispatch"] span[data-dw-tooltip] {\n    white-space: normal;\n}\n';
const bmStyles = "/* apply old bm style overrides */\n";
function applyNewBMUIPatches() {
  const ccbmElement = document.querySelector("ccbm");
  if (ccbmElement && ccbmElement.classList.contains("ldsbm")) {
    const style = document.createElement("style");
    style.innerHTML = newBMStyles;
    document.head.appendChild(style);
  } else if (ccbmElement) {
    const style = document.createElement("style");
    style.innerHTML = bmStyles;
    document.head.appendChild(style);
  }
}
function isBM() {
  return document.location.pathname.includes("Sites-Site");
}
console.log("[QLABS] Companion Script Loaded");
const INTERVAL = 3e4;
async function keepalive(keepaliveUrl) {
  try {
    const response = await fetch(keepaliveUrl, {
      method: "GET",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      credentials: "include"
    });
    console.log("[QLABS] BM KeepAlive");
  } catch (error) {
    console.error("[QLABS] Error with BM keep alive; are you logged into business manager?", error);
  }
}
function getCompanionConfig() {
  const config = JSON.parse(window.localStorage.getItem("qlabs-companion-config") ?? "{}");
  return config;
}
function setupKeepAliveInterval() {
  var _a2;
  const config = getCompanionConfig();
  if (((_a2 = window == null ? void 0 : window.__qlabsConfig) == null ? void 0 : _a2.keepaliveUrl) && config.enableBMKeepAlive) {
    setInterval(() => keepalive(window.__qlabsConfig.keepaliveUrl), INTERVAL);
  } else {
    console.log("[QLABS] BM KeepAlive Disabled");
  }
}
var runtimeInfo;
var runtimeInfoPromise;
async function getRuntimeInfo() {
  if (runtimeInfo) {
    return runtimeInfo;
  }
  if (!runtimeInfoPromise) {
    runtimeInfoPromise = fetch(window.__qlabsConfig.infoUrl).then((response) => response.json());
  }
  runtimeInfo = await runtimeInfoPromise;
  return runtimeInfo;
}
async function setupAnalyticsTracking() {
  var _a2;
  const config = getCompanionConfig();
  if (config.disableAnalytics) {
    return;
  }
  var info = {
    username: "storefront",
    siteId: ""
  };
  try {
    info = await getRuntimeInfo();
  } catch (error) {
  }
  mixpanel.init(window.__qlabsConfig.mixpanelToken);
  const controller = window.location.pathname.match(/\/on\/demandware.store\/Sites-[^\/]*\/.+\/([^\/]*)/);
  if (controller) {
    document.body.setAttribute("data-controller", controller[1]);
    mixpanel.register({
      controller: controller[1],
      context: "bm"
    });
  } else {
    mixpanel.register({
      context: "storefront",
      controller: ((_a2 = document.querySelector("[data-action]")) == null ? void 0 : _a2.getAttribute("data-action")) ?? "unknown"
    });
  }
  if (info.username) {
    mixpanel.identify(info.username);
  }
  mixpanel.register({
    sandbox: window.__qlabsConfig.sandbox
  });
  mixpanel.track_pageview({
    source: "companion"
  }, {
    event_name: "B2CE Page View"
  });
}
async function setupPatches() {
  await applyNewBMUIPatches();
}
async function addAdditionalScripts() {
  if (!isBM()) {
    return;
  }
  const additionalScripts = window.__qlabsConfig.additionalScripts;
  const info = await getRuntimeInfo();
  console.log("[QLABS] Site ID:", info.siteId);
  if (additionalScripts) {
    const div = document.createElement("div");
    div.innerHTML = additionalScripts;
    div.querySelectorAll("script").forEach((script) => {
      const newScript = document.createElement("script");
      if (script.src.includes("initEmbeddedMessaging") || script.innerHTML.includes("initEmbeddedMessaging")) {
        miawHandlers(info.siteId);
      }
      newScript.text = script.innerHTML;
      if (script.src) {
        newScript.src = script.src;
      }
      if (script.onload) {
        newScript.onload = script.onload;
      }
      document.body.appendChild(newScript);
    });
  }
}
async function setupMIAWDeploymentsBM() {
  if (!isBM()) {
    return;
  }
  const resp = await searchObjects("agents", {
    attrs: {
      type: "MIAW",
      deployBM: true
    }
  });
  const info = await getRuntimeInfo();
  if (resp.data && resp.data.length > 0) {
    const agentObj = resp.data[0];
    const agent = agentObj == null ? void 0 : agentObj.data;
    if (agent) {
      renderAgent(agent, info.siteId);
    }
  }
}
async function setupMIAWDeploymentsStorefront() {
  if (isBM()) {
    return;
  }
  const resp = await fetch(window.__qlabsConfig.storefrontConfigurationUrl);
  const data2 = await resp.json();
  const miawTypeAgents = data2.agents.filter((agent) => agent.type === "MIAW");
  const siteId = data2.siteId;
  if (miawTypeAgents.length > 0) {
    const agent = miawTypeAgents[0];
    renderAgent(agent, siteId);
  }
  const miawCustomTypeAgents = data2.agents.filter((agent) => agent.type === "MIAW_CUSTOM" || agent.type === "AGENT_API");
  if (miawCustomTypeAgents.length > 0) {
    for (const agent of miawCustomTypeAgents) {
      renderCustomAgent(agent);
    }
  }
}
async function setupFeatures() {
  if (isBM()) {
    const resp = await searchObjects("features", {
      attrs: {
        deployBM: true
      }
    });
    if (resp.data && resp.data.length > 0) {
      for (const featureObj of resp.data) {
        const feature = featureObj == null ? void 0 : featureObj.data;
        if (feature) {
          renderFeature(feature);
        }
      }
    }
  } else {
    const resp = await fetch(window.__qlabsConfig.storefrontConfigurationUrl);
    const data2 = await resp.json();
    const features = data2.features;
    if (features.length > 0) {
      for (const feature of features) {
        renderFeature(feature);
      }
    }
  }
}
function setupDevTools() {
  const container = document.createElement("div");
  container.id = "qlabs-companion-devtools";
  document.body.appendChild(container);
  const root2 = createRoot(container);
  root2.render(React.createElement(DevTools, null));
}
window._clientSettings = window._clientSettings || {};
initializeEventManager();
setupAnalyticsTracking();
setupKeepAliveInterval();
setupPatches();
doMigrateInstance();
addAdditionalScripts();
setupMIAWDeploymentsBM();
setupMIAWDeploymentsStorefront();
setupDevTools();
setupFeatures();
export {
  __vitePreload as _,
  jsxRuntimeExports as j,
  onlineManager as o,
  reactExports as r,
  useQueryClient as u
};
//# sourceMappingURL=companion.js.map
(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode('/*! tailwindcss v4.0.14 | MIT License | https://tailwindcss.com */\n@layer theme {\n  :root, :host {\n    --color-red-500: oklch(.637 .237 25.331);\n    --color-blue-300: oklch(.809 .105 251.813);\n    --color-blue-600: oklch(.546 .245 262.881);\n    --color-gray-50: oklch(.985 .002 247.839);\n    --color-gray-100: oklch(.967 .003 264.542);\n    --color-gray-200: oklch(.928 .006 264.531);\n    --color-gray-300: oklch(.872 .01 258.338);\n    --color-gray-500: oklch(.551 .027 264.364);\n    --color-black: #000;\n    --color-white: #fff;\n    --spacing: .25rem;\n    --container-sm: 24rem;\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --font-weight-medium: 500;\n    --font-weight-bold: 700;\n    --radius-md: .375rem;\n    --radius-lg: .5rem;\n    --animate-spin: spin 1s linear infinite;\n    --default-transition-duration: .15s;\n    --default-transition-timing-function: cubic-bezier(.4, 0, .2, 1);\n    --color-primary: var(--toolkit-primary, var(--primary, --color-blue-600));\n    --color-secondary: var(--toolkit-secondary, var(--secondary, --color-blue-300));\n  }\n}\n\n@layer base, components;\n\n@layer utilities {\n  .visible {\n    visibility: visible;\n  }\n\n  .absolute {\n    position: absolute;\n  }\n\n  .fixed {\n    position: fixed;\n  }\n\n  .relative {\n    position: relative;\n  }\n\n  .static {\n    position: static;\n  }\n\n  .sticky {\n    position: sticky;\n  }\n\n  .top-1 {\n    top: calc(var(--spacing) * 1);\n  }\n\n  .right-0 {\n    right: calc(var(--spacing) * 0);\n  }\n\n  .right-1 {\n    right: calc(var(--spacing) * 1);\n  }\n\n  .bottom-0 {\n    bottom: calc(var(--spacing) * 0);\n  }\n\n  .left-0 {\n    left: calc(var(--spacing) * 0);\n  }\n\n  .z-10 {\n    z-index: 10;\n  }\n\n  .z-50 {\n    z-index: 50;\n  }\n\n  .container {\n    width: 100%;\n  }\n\n  @media (width >= 40rem) {\n    .container {\n      max-width: 40rem;\n    }\n  }\n\n  @media (width >= 48rem) {\n    .container {\n      max-width: 48rem;\n    }\n  }\n\n  @media (width >= 64rem) {\n    .container {\n      max-width: 64rem;\n    }\n  }\n\n  @media (width >= 80rem) {\n    .container {\n      max-width: 80rem;\n    }\n  }\n\n  @media (width >= 96rem) {\n    .container {\n      max-width: 96rem;\n    }\n  }\n\n  .-mx-2 {\n    margin-inline: calc(var(--spacing) * -2);\n  }\n\n  .mx-auto {\n    margin-inline: auto;\n  }\n\n  .my-2 {\n    margin-block: calc(var(--spacing) * 2);\n  }\n\n  .my-4 {\n    margin-block: calc(var(--spacing) * 4);\n  }\n\n  .mt-0 {\n    margin-top: calc(var(--spacing) * 0);\n  }\n\n  .mt-1 {\n    margin-top: calc(var(--spacing) * 1);\n  }\n\n  .mt-2 {\n    margin-top: calc(var(--spacing) * 2);\n  }\n\n  .mt-4 {\n    margin-top: calc(var(--spacing) * 4);\n  }\n\n  .mr-2 {\n    margin-right: calc(var(--spacing) * 2);\n  }\n\n  .\\!mb-0 {\n    margin-bottom: calc(var(--spacing) * 0) !important;\n  }\n\n  .mb-0 {\n    margin-bottom: calc(var(--spacing) * 0);\n  }\n\n  .mb-1 {\n    margin-bottom: calc(var(--spacing) * 1);\n  }\n\n  .mb-2 {\n    margin-bottom: calc(var(--spacing) * 2);\n  }\n\n  .mb-3 {\n    margin-bottom: calc(var(--spacing) * 3);\n  }\n\n  .mb-4 {\n    margin-bottom: calc(var(--spacing) * 4);\n  }\n\n  .ml-1 {\n    margin-left: calc(var(--spacing) * 1);\n  }\n\n  .\\!hidden {\n    display: none !important;\n  }\n\n  .block {\n    display: block;\n  }\n\n  .contents {\n    display: contents;\n  }\n\n  .flex {\n    display: flex;\n  }\n\n  .grid {\n    display: grid;\n  }\n\n  .hidden {\n    display: none;\n  }\n\n  .inline {\n    display: inline;\n  }\n\n  .inline-block {\n    display: inline-block;\n  }\n\n  .table {\n    display: table;\n  }\n\n  .size-5 {\n    width: calc(var(--spacing) * 5);\n    height: calc(var(--spacing) * 5);\n  }\n\n  .size-6 {\n    width: calc(var(--spacing) * 6);\n    height: calc(var(--spacing) * 6);\n  }\n\n  .size-8 {\n    width: calc(var(--spacing) * 8);\n    height: calc(var(--spacing) * 8);\n  }\n\n  .size-9 {\n    width: calc(var(--spacing) * 9);\n    height: calc(var(--spacing) * 9);\n  }\n\n  .h-3 {\n    height: calc(var(--spacing) * 3);\n  }\n\n  .h-5 {\n    height: calc(var(--spacing) * 5);\n  }\n\n  .h-6 {\n    height: calc(var(--spacing) * 6);\n  }\n\n  .h-9 {\n    height: calc(var(--spacing) * 9);\n  }\n\n  .h-24 {\n    height: calc(var(--spacing) * 24);\n  }\n\n  .h-auto {\n    height: auto;\n  }\n\n  .h-full {\n    height: 100%;\n  }\n\n  .max-h-\\[150px\\] {\n    max-height: 150px;\n  }\n\n  .w-1\\/2 {\n    width: 50%;\n  }\n\n  .w-3 {\n    width: calc(var(--spacing) * 3);\n  }\n\n  .w-5 {\n    width: calc(var(--spacing) * 5);\n  }\n\n  .w-6 {\n    width: calc(var(--spacing) * 6);\n  }\n\n  .w-9 {\n    width: calc(var(--spacing) * 9);\n  }\n\n  .w-40 {\n    width: calc(var(--spacing) * 40);\n  }\n\n  .w-90 {\n    width: calc(var(--spacing) * 90);\n  }\n\n  .w-\\[120px\\] {\n    width: 120px;\n  }\n\n  .w-full {\n    width: 100%;\n  }\n\n  .max-w-3\\/4 {\n    max-width: 75%;\n  }\n\n  .max-w-sm {\n    max-width: var(--container-sm);\n  }\n\n  .min-w-\\[80px\\] {\n    min-width: 80px;\n  }\n\n  .flex-1 {\n    flex: 1;\n  }\n\n  .flex-shrink-0 {\n    flex-shrink: 0;\n  }\n\n  .flex-grow {\n    flex-grow: 1;\n  }\n\n  .transform {\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n  }\n\n  .animate-spin {\n    animation: var(--animate-spin);\n  }\n\n  .cursor-pointer {\n    cursor: pointer;\n  }\n\n  .flex-col {\n    flex-direction: column;\n  }\n\n  .flex-row {\n    flex-direction: row;\n  }\n\n  .flex-nowrap {\n    flex-wrap: nowrap;\n  }\n\n  .flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .items-center {\n    align-items: center;\n  }\n\n  .justify-between {\n    justify-content: space-between;\n  }\n\n  .justify-center {\n    justify-content: center;\n  }\n\n  .justify-end {\n    justify-content: flex-end;\n  }\n\n  .justify-start {\n    justify-content: flex-start;\n  }\n\n  .gap-2 {\n    gap: calc(var(--spacing) * 2);\n  }\n\n  :where(.space-y-4 > :not(:last-child)) {\n    --tw-space-y-reverse: 0;\n    margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));\n    margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));\n  }\n\n  :where(.space-x-2 > :not(:last-child)) {\n    --tw-space-x-reverse: 0;\n    margin-inline-start: calc(calc(var(--spacing) * 2) * var(--tw-space-x-reverse));\n    margin-inline-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-x-reverse)));\n  }\n\n  :where(.space-x-4 > :not(:last-child)) {\n    --tw-space-x-reverse: 0;\n    margin-inline-start: calc(calc(var(--spacing) * 4) * var(--tw-space-x-reverse));\n    margin-inline-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-x-reverse)));\n  }\n\n  .truncate {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden;\n  }\n\n  .overflow-auto {\n    overflow: auto;\n  }\n\n  .overflow-hidden {\n    overflow: hidden;\n  }\n\n  .overflow-x-auto {\n    overflow-x: auto;\n  }\n\n  .overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .scroll-smooth {\n    scroll-behavior: smooth;\n  }\n\n  .rounded {\n    border-radius: .25rem;\n  }\n\n  .rounded-full {\n    border-radius: 3.40282e38px;\n  }\n\n  .rounded-lg {\n    border-radius: var(--radius-lg);\n  }\n\n  .rounded-md {\n    border-radius: var(--radius-md);\n  }\n\n  .rounded-t-lg {\n    border-top-left-radius: var(--radius-lg);\n    border-top-right-radius: var(--radius-lg);\n  }\n\n  .rounded-l-lg {\n    border-top-left-radius: var(--radius-lg);\n    border-bottom-left-radius: var(--radius-lg);\n  }\n\n  .rounded-r-lg {\n    border-top-right-radius: var(--radius-lg);\n    border-bottom-right-radius: var(--radius-lg);\n  }\n\n  .border {\n    border-style: var(--tw-border-style);\n    border-width: 1px;\n  }\n\n  .border-2 {\n    border-style: var(--tw-border-style);\n    border-width: 2px;\n  }\n\n  .border-t {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 1px;\n  }\n\n  .border-b {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 1px;\n  }\n\n  .\\!border-l {\n    border-left-style: var(--tw-border-style) !important;\n    border-left-width: 1px !important;\n  }\n\n  .border-solid {\n    --tw-border-style: solid;\n    border-style: solid;\n  }\n\n  .border-gray-300 {\n    border-color: var(--color-gray-300);\n  }\n\n  .border-primary {\n    border-color: var(--color-primary);\n  }\n\n  .border-white {\n    border-color: var(--color-white);\n  }\n\n  .border-r-transparent {\n    border-right-color: #0000;\n  }\n\n  .\\!bg-primary {\n    background-color: var(--color-primary) !important;\n  }\n\n  .\\!bg-secondary {\n    background-color: var(--color-secondary) !important;\n  }\n\n  .bg-gray-50 {\n    background-color: var(--color-gray-50);\n  }\n\n  .bg-gray-100 {\n    background-color: var(--color-gray-100);\n  }\n\n  .bg-gray-200 {\n    background-color: var(--color-gray-200);\n  }\n\n  .bg-primary {\n    background-color: var(--color-primary);\n  }\n\n  .bg-red-500 {\n    background-color: var(--color-red-500);\n  }\n\n  .bg-white {\n    background-color: var(--color-white);\n  }\n\n  .object-contain {\n    object-fit: contain;\n  }\n\n  .p-1 {\n    padding: calc(var(--spacing) * 1);\n  }\n\n  .p-2 {\n    padding: calc(var(--spacing) * 2);\n  }\n\n  .p-3 {\n    padding: calc(var(--spacing) * 3);\n  }\n\n  .p-4 {\n    padding: calc(var(--spacing) * 4);\n  }\n\n  .px-1 {\n    padding-inline: calc(var(--spacing) * 1);\n  }\n\n  .px-2 {\n    padding-inline: calc(var(--spacing) * 2);\n  }\n\n  .px-3 {\n    padding-inline: calc(var(--spacing) * 3);\n  }\n\n  .px-4 {\n    padding-inline: calc(var(--spacing) * 4);\n  }\n\n  .py-1 {\n    padding-block: calc(var(--spacing) * 1);\n  }\n\n  .py-2 {\n    padding-block: calc(var(--spacing) * 2);\n  }\n\n  .py-3 {\n    padding-block: calc(var(--spacing) * 3);\n  }\n\n  .py-4 {\n    padding-block: calc(var(--spacing) * 4);\n  }\n\n  .pb-0 {\n    padding-bottom: calc(var(--spacing) * 0);\n  }\n\n  .pb-1 {\n    padding-bottom: calc(var(--spacing) * 1);\n  }\n\n  .pl-2 {\n    padding-left: calc(var(--spacing) * 2);\n  }\n\n  .text-center {\n    text-align: center;\n  }\n\n  .text-left {\n    text-align: left;\n  }\n\n  .\\!text-lg {\n    font-size: var(--text-lg) !important;\n    line-height: var(--tw-leading, var(--text-lg--line-height)) !important;\n  }\n\n  .text-lg {\n    font-size: var(--text-lg);\n    line-height: var(--tw-leading, var(--text-lg--line-height));\n  }\n\n  .font-bold {\n    --tw-font-weight: var(--font-weight-bold);\n    font-weight: var(--font-weight-bold);\n  }\n\n  .font-medium {\n    --tw-font-weight: var(--font-weight-medium);\n    font-weight: var(--font-weight-medium);\n  }\n\n  .text-black {\n    color: var(--color-black);\n  }\n\n  .text-gray-500 {\n    color: var(--color-gray-500);\n  }\n\n  .text-primary {\n    color: var(--color-primary);\n  }\n\n  .text-red-500 {\n    color: var(--color-red-500);\n  }\n\n  .text-white {\n    color: var(--color-white);\n  }\n\n  .italic {\n    font-style: italic;\n  }\n\n  .opacity-0 {\n    opacity: 0;\n  }\n\n  .opacity-25 {\n    opacity: .25;\n  }\n\n  .opacity-75 {\n    opacity: .75;\n  }\n\n  .opacity-100 {\n    opacity: 1;\n  }\n\n  .shadow {\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, #0000001a), 0 1px 2px -1px var(--tw-shadow-color, #0000001a);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .shadow-2xl {\n    --tw-shadow: 0 25px 50px -12px var(--tw-shadow-color, #00000040);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .shadow-lg {\n    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, #0000001a), 0 4px 6px -4px var(--tw-shadow-color, #0000001a);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .shadow-md {\n    --tw-shadow: 0 4px 6px -1px var(--tw-shadow-color, #0000001a), 0 2px 4px -2px var(--tw-shadow-color, #0000001a);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .shadow-black\\/30 {\n    --tw-shadow-color: color-mix(in oklab, var(--color-black) 30%, transparent);\n  }\n\n  .filter {\n    filter: var(--tw-blur, ) var(--tw-brightness, ) var(--tw-contrast, ) var(--tw-grayscale, ) var(--tw-hue-rotate, ) var(--tw-invert, ) var(--tw-saturate, ) var(--tw-sepia, ) var(--tw-drop-shadow, );\n  }\n\n  .transition {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-all {\n    transition-property: all;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .transition-opacity {\n    transition-property: opacity;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n\n  .duration-200 {\n    --tw-duration: .2s;\n    transition-duration: .2s;\n  }\n\n  .duration-300 {\n    --tw-duration: .3s;\n    transition-duration: .3s;\n  }\n\n  @media (hover: hover) {\n    .hover\\:\\!bg-primary:hover {\n      background-color: var(--color-primary) !important;\n    }\n\n    .hover\\:bg-gray-100:hover {\n      background-color: var(--color-gray-100);\n    }\n\n    .hover\\:bg-gray-200:hover {\n      background-color: var(--color-gray-200);\n    }\n\n    .hover\\:bg-primary:hover {\n      background-color: var(--color-primary);\n    }\n\n    .hover\\:bg-primary\\/50:hover {\n      background-color: color-mix(in oklab, var(--color-primary) 50%, transparent);\n    }\n\n    .hover\\:bg-secondary:hover {\n      background-color: var(--color-secondary);\n    }\n\n    .hover\\:underline:hover {\n      text-decoration-line: underline;\n    }\n  }\n\n  .focus\\:ring-2:focus {\n    --tw-ring-shadow: var(--tw-ring-inset, ) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentColor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n\n  .focus\\:ring-primary:focus {\n    --tw-ring-color: var(--color-primary);\n  }\n\n  .focus\\:outline-none:focus {\n    --tw-outline-style: none;\n    outline-style: none;\n  }\n\n  .disabled\\:\\!bg-secondary:disabled {\n    background-color: var(--color-secondary) !important;\n  }\n\n  @media (width >= 48rem) {\n    .md\\:mt-0 {\n      margin-top: calc(var(--spacing) * 0);\n    }\n\n    .md\\:\\!block {\n      display: block !important;\n    }\n\n    .md\\:block {\n      display: block;\n    }\n\n    .md\\:hidden {\n      display: none;\n    }\n\n    .md\\:w-1\\/2 {\n      width: 50%;\n    }\n\n    .md\\:w-1\\/3 {\n      width: 33.3333%;\n    }\n\n    .md\\:w-116 {\n      width: calc(var(--spacing) * 116);\n    }\n\n    .md\\:p-4 {\n      padding: calc(var(--spacing) * 4);\n    }\n  }\n\n  @media (width >= 64rem) {\n    .lg\\:w-\\[calc\\(\\(100\\%-4rem\\)\\/7\\)\\] {\n      width: calc(14.2857% - .571429rem);\n    }\n  }\n\n  @media (width >= 80rem) {\n    .xl\\:w-\\[calc\\(\\(100\\%-5rem\\)\\/8\\)\\] {\n      width: calc(12.5% - .625rem);\n    }\n  }\n\n  .\\[\\&\\>\\*\\:last-child\\]\\:\\!mb-0 > :last-child {\n    margin-bottom: calc(var(--spacing) * 0) !important;\n  }\n}\n\n@property --tw-rotate-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateX(0);\n}\n\n@property --tw-rotate-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateY(0);\n}\n\n@property --tw-rotate-z {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateZ(0);\n}\n\n@property --tw-skew-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewX(0);\n}\n\n@property --tw-skew-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewY(0);\n}\n\n@property --tw-space-y-reverse {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-space-x-reverse {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-border-style {\n  syntax: "*";\n  inherits: false;\n  initial-value: solid;\n}\n\n@property --tw-font-weight {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-shadow-color {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-inset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-inset-shadow-color {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-ring-color {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-inset-ring-color {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-inset-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-ring-inset {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-ring-offset-width {\n  syntax: "<length>";\n  inherits: false;\n  initial-value: 0;\n}\n\n@property --tw-ring-offset-color {\n  syntax: "*";\n  inherits: false;\n  initial-value: #fff;\n}\n\n@property --tw-ring-offset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n\n@property --tw-blur {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-brightness {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-contrast {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-grayscale {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-hue-rotate {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-invert {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-opacity {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-saturate {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-sepia {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-drop-shadow {\n  syntax: "*";\n  inherits: false\n}\n\n@property --tw-duration {\n  syntax: "*";\n  inherits: false\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}'));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
