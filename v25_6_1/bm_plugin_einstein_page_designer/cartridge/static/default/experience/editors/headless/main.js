'use strict'
var C0 = Object.defineProperty
var _0 = (n, e, t) =>
  e in n
    ? C0(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (n[e] = t)
var Qn = (n, e, t) => (_0(n, typeof e != 'symbol' ? e + '' : e, t), t)
const h = require('./objectWithoutPropertiesLoose.js')
var gm = { exports: {} },
  ho = 1
function R0() {
  return (ho = (ho * 9301 + 49297) % 233280), ho / 233280
}
function Z0(n) {
  ho = n
}
var A0 = { nextValue: R0, seed: Z0 },
  Rc = A0,
  ar = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-',
  An,
  _h,
  Ri
function Zc() {
  Ri = !1
}
function ym(n) {
  if (!n) {
    An !== ar && ((An = ar), Zc())
    return
  }
  if (n !== An) {
    if (n.length !== ar.length)
      throw new Error(
        'Custom alphabet for shortid must be ' +
          ar.length +
          ' unique characters. You submitted ' +
          n.length +
          ' characters: ' +
          n
      )
    var e = n.split('').filter(function (t, r, i) {
      return r !== i.lastIndexOf(t)
    })
    if (e.length)
      throw new Error(
        'Custom alphabet for shortid must be ' +
          ar.length +
          ' unique characters. These characters were not unique: ' +
          e.join(', ')
      )
    ;(An = n), Zc()
  }
}
function E0(n) {
  return ym(n), An
}
function D0(n) {
  Rc.seed(n), _h !== n && (Zc(), (_h = n))
}
function X0() {
  An || ym(ar)
  for (var n = An.split(''), e = [], t = Rc.nextValue(), r; n.length > 0; )
    (t = Rc.nextValue()),
      (r = Math.floor(t * n.length)),
      e.push(n.splice(r, 1)[0])
  return e.join('')
}
function bm() {
  return Ri || ((Ri = X0()), Ri)
}
function Y0(n) {
  var e = bm()
  return e[n]
}
function I0() {
  return An || ar
}
var uf = { get: I0, characters: E0, seed: D0, lookup: Y0, shuffled: bm },
  Il = typeof window == 'object' && (window.crypto || window.msCrypto),
  Ac
!Il || !Il.getRandomValues
  ? (Ac = function (n) {
      for (var e = [], t = 0; t < n; t++)
        e.push(Math.floor(Math.random() * 256))
      return e
    })
  : (Ac = function (n) {
      return Il.getRandomValues(new Uint8Array(n))
    })
var j0 = Ac,
  N0 = function (n, e, t) {
    for (
      var r = (2 << (Math.log(e.length - 1) / Math.LN2)) - 1,
        i = -~((1.6 * r * t) / e.length),
        s = '';
      ;

    )
      for (var o = n(i), a = i; a--; )
        if (((s += e[o[a] & r] || ''), s.length === +t)) return s
  },
  M0 = uf,
  V0 = j0,
  W0 = N0
function L0(n) {
  for (var e = 0, t, r = ''; !t; )
    (r = r + W0(V0, M0.get(), 1)), (t = n < Math.pow(16, e + 1)), e++
  return r
}
var B0 = L0,
  Ns = B0,
  U0 = 1567752802062,
  q0 = 7,
  Ms,
  Rh
function z0(n) {
  var e = '',
    t = Math.floor((Date.now() - U0) * 0.001)
  return (
    t === Rh ? Ms++ : ((Ms = 0), (Rh = t)),
    (e = e + Ns(q0)),
    (e = e + Ns(n)),
    Ms > 0 && (e = e + Ns(Ms)),
    (e = e + Ns(t)),
    e
  )
}
var F0 = z0,
  G0 = uf
function H0(n) {
  if (!n || typeof n != 'string' || n.length < 6) return !1
  var e = new RegExp(
    '[^' + G0.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') + ']'
  )
  return !e.test(n)
}
var K0 = H0
;(function (n) {
  var e = uf,
    t = F0,
    r = K0,
    i = 0
  function s(c) {
    return e.seed(c), n.exports
  }
  function o(c) {
    return (i = c), n.exports
  }
  function a(c) {
    return c !== void 0 && e.characters(c), e.shuffled()
  }
  function l() {
    return t(i)
  }
  ;(n.exports = l),
    (n.exports.generate = l),
    (n.exports.seed = s),
    (n.exports.worker = o),
    (n.exports.characters = a),
    (n.exports.isValid = r)
})(gm)
var J0 = gm.exports,
  ex = J0
const dr = h.getDefaultExportFromCjs(ex)
var vm = { exports: {} }
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ ;(function (n) {
  ;(function () {
    var e = {}.hasOwnProperty
    function t() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var s = arguments[i]
        if (s) {
          var o = typeof s
          if (o === 'string' || o === 'number') r.push(s)
          else if (Array.isArray(s)) {
            if (s.length) {
              var a = t.apply(null, s)
              a && r.push(a)
            }
          } else if (o === 'object') {
            if (
              s.toString !== Object.prototype.toString &&
              !s.toString.toString().includes('[native code]')
            ) {
              r.push(s.toString())
              continue
            }
            for (var l in s) e.call(s, l) && s[l] && r.push(l)
          }
        }
      }
      return r.join(' ')
    }
    n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t)
  })()
})(vm)
var tx = vm.exports
const se = h.getDefaultExportFromCjs(tx)
var nx = '[object AsyncFunction]',
  rx = '[object Function]',
  ix = '[object GeneratorFunction]',
  sx = '[object Null]',
  ox = '[object Proxy]',
  ax = '[object Undefined]',
  lx =
    typeof h.commonjsGlobal == 'object' &&
    h.commonjsGlobal &&
    h.commonjsGlobal.Object === Object &&
    h.commonjsGlobal,
  cx = typeof self == 'object' && self && self.Object === Object && self,
  ux = lx || cx || Function('return this')(),
  Sm = Object.prototype,
  fx = Sm.hasOwnProperty,
  xm = Sm.toString,
  Zh = ux.Symbol,
  lr = Zh ? Zh.toStringTag : void 0
function hx(n) {
  return n == null
    ? n === void 0
      ? ax
      : sx
    : lr && lr in Object(n)
      ? px(n)
      : dx(n)
}
function px(n) {
  var e = fx.call(n, lr),
    t = n[lr]
  try {
    n[lr] = void 0
    var r = !0
  } catch {}
  var i = xm.call(n)
  return r && (e ? (n[lr] = t) : delete n[lr]), i
}
function dx(n) {
  return xm.call(n)
}
function Ox(n) {
  if (!mx(n)) return !1
  var e = hx(n)
  return e == rx || e == ix || e == nx || e == ox
}
function mx(n) {
  var e = typeof n
  return n != null && (e == 'object' || e == 'function')
}
var gx = Ox
const wm = h.getDefaultExportFromCjs(gx)
var Pm = 'SLDSAlert',
  yx = 'SLDSAlertContainer',
  ff = 'SLDSButton',
  bx = 'SLDSButtonGroup',
  vx = 'SLDSButtonStateful',
  Tm = 'SLDSButtonIcon',
  Sx = 'SLDSDatePicker',
  xx = 'SLDSDialog',
  wx = 'SLDSExpandableSection',
  Px = 'SLDSCheckbox',
  Ka = 'SLDSInput',
  $m = 'SLDSTextarea',
  Tx = 'SLDSSearch',
  Qm = 'SLDSIcon',
  $x = 'SLDSIconSettings',
  Qx = 'SLDSIconInput',
  kx = 'SLDSLookup',
  Cx = 'SLDSMenuDropdown',
  km = 'SLDSPopoverTooltip',
  Cm = 'SLDSSpinner',
  _x = 'SLDSTab',
  Rx = 'SLDSTabPanel',
  Zx = 'SLDSTabs',
  Ax = 'SLDSTabsList',
  Ex = 'SLDSTabsPanel',
  Dx = 'SLDSTimepicker',
  _m = 'SLDSToast',
  Xx = 'SLDSToastContainer',
  hf = function (e) {
    var t = e.id,
      r = e.className,
      i = e.children,
      s = e.variant
    return h.React.createElement(
      'ul',
      {
        id: ''.concat(t, '-slds-tabs__nav'),
        className: se(r, {
          'slds-tabs_default__nav': s === 'default',
          'slds-tabs_scoped__nav': s === 'scoped',
          'slds-vertical-tabs__nav': s === 'vertical'
        }),
        role: 'tablist',
        'aria-orientation': s === 'vertical' ? 'vertical' : void 0
      },
      i
    )
  }
hf.displayName = Ax
hf.propTypes = {
  id: h.PropTypes.string,
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  children: h.PropTypes.oneOfType([h.PropTypes.object, h.PropTypes.array]),
  variant: h.PropTypes.oneOf(['default', 'scoped', 'vertical'])
}
const Yx = hf
var Ix = process.env.NODE_ENV !== 'production',
  Rm = function () {}
if (Ix) {
  var jx = function (e, t) {
    var r = arguments.length
    t = new Array(r > 1 ? r - 1 : 0)
    for (var i = 1; i < r; i++) t[i - 1] = arguments[i]
    var s = 0,
      o =
        'Warning: ' +
        e.replace(/%s/g, function () {
          return t[s++]
        })
    typeof console < 'u' && console.error(o)
    try {
      throw new Error(o)
    } catch {}
  }
  Rm = function (n, e, t) {
    var r = arguments.length
    t = new Array(r > 2 ? r - 2 : 0)
    for (var i = 2; i < r; i++) t[i - 2] = arguments[i]
    if (e === void 0)
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning message argument'
      )
    n || jx.apply(null, [e].concat(t))
  }
}
var Nx = Rm
const yr = h.getDefaultExportFromCjs(Nx)
var Zm = function () {}
if (process.env.NODE_ENV !== 'production') {
  var Ah = {}
  Zm = function (e, t, r, i) {
    var s = i ? ' '.concat(i) : ''
    Ah[e + r] ||
      (yr(
        !t,
        '[Design System React] `'
          .concat(
            r,
            '` has reached End-of-Life and has been removed from the API of '
          )
          .concat(e, '. Please update your API.')
          .concat(s)
      ),
      (Ah[e + r] = !!t))
  }
}
const Qe = Zm
var Am = function () {},
  Mx = 'https://react.lightningdesignsystem.com'
process.env.NODE_ENV !== 'production' &&
  (Am = function (e) {
    var t = ''.concat(
      Mx + (e && e['url-slug'] ? '/components/'.concat(e['url-slug']) : '')
    )
    return function (r) {
      return 'Please check the current documentation at: '.concat(
        r ? ''.concat(t, '#prop-').concat(r) : t
      )
    }
  })
const Fn = Am
var Em = function () {}
process.env.NODE_ENV !== 'production' &&
  (Em = function (e, t, r) {
    if (typeof t.assistiveText == 'string') {
      var i = Fn(r)
      Qe(
        e,
        t.assistiveText,
        'assistiveText',
        '`assistiveText` as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use `assistiveText.label` instead. '.concat(
          i('assistiveText')
        )
      )
    }
  })
const Vx = Em,
  Wx = 'icon',
  Lx = 'prod',
  Bx = 'Icon',
  Ux = {
    component: Wx,
    status: Lx,
    'display-name': 'Icons',
    classKey: Bx,
    'last-accessibility-review': {
      'date-iso-8601': '2018/01/18',
      'commit-sha': 'ad6b6c6523ee21cada11be5f7ea4d99abc530726'
    },
    'SLDS-component-path': '/components/icons',
    'site-stories': [
      { heading: 'Category Options', path: '/__examples__/categories.jsx' },
      { heading: 'Color Options', path: '/__examples__/colors.jsx' },
      { heading: 'Size Options', path: '/__examples__/sizes.jsx' }
    ],
    'url-slug': 'icons'
  }
var qx = function () {
  var e = se.apply(void 0, arguments)
  return e === '' ? void 0 : e
}
const Br = qx
var Ec = function () {}
if (process.env.NODE_ENV !== 'production') {
  var Eh = {},
    Dh,
    Xh = function (e, t, r) {
      return function (i) {
        if (((Dh = !0), i.status === 404)) {
          var s = r ? ' '.concat(r) : ''
          yr(
            !t,
            'The icon asset was not found at '
              .concat(
                t,
                '. Make sure the path to the icon asset is correct. You can set the icon path by importing the IconSettings component, `<IconSettings iconPath=[/assets/icons]>` from `components/iconSettings`, and wrap that component around your entire app or around individual components using icons. If you are using the `<Icon>` component, you can also pass the url to `this.props.path`.'
              )
              .concat(s)
          ),
            (Eh[''.concat(e, '-path')] = !!t)
        }
      }
    },
    Yh = function (e) {
      return (
        !Dh &&
        !Eh[''.concat(e, '-path')] &&
        typeof window < 'u' &&
        process.env.NODE_ENV !== 'test'
      )
    }
  typeof fetch == 'function'
    ? (Ec = function (e, t, r) {
        Yh(e) && fetch(t).then(Xh(e, t, r))
      })
    : (Ec = function (e, t, r) {
        if (Yh(e) && XMLHttpRequest) {
          var i = new XMLHttpRequest()
          i.open('GET', t, !1), i.send(), Xh(e, t, r)(i)
        }
      })
}
const zx = Ec
var Mn = {}
Mn.LTR = 'ltr'
Mn.RTL = 'rtl'
var Dm = h.React.createContext('ltr'),
  Xm = function () {}
process.env.NODE_ENV !== 'production' &&
  (Xm = function (e, t) {
    if (
      !t.context[''.concat(t.category, 'Sprite')] &&
      !t.context.onRequestIconPath
    ) {
      var r = t.path || t.context.iconPath,
        i = t.direction === Mn.RTL ? 'symbols-rtl.svg' : 'symbols.svg'
      zx(
        e,
        ''
          .concat(r, '/')
          .concat(t.category, '-sprite/svg/')
          .concat(i, '#')
          .concat(t.name)
      )
    }
  })
const Fx = Xm
function po(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (po = function (t) {
          return typeof t
        })
      : (po = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    po(n)
  )
}
function Ih(n, e) {
  if (n == null) return {}
  var t = Gx(n, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, r) &&
          (t[r] = n[r])
  }
  return t
}
function Gx(n, e) {
  if (n == null) return {}
  var t = {},
    r = Object.keys(n),
    i,
    s
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i])
  return t
}
function Zr() {
  return (
    (Zr =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Zr.apply(this, arguments)
  )
}
function Hx(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function jh(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function Kx(n, e, t) {
  return e && jh(n.prototype, e), t && jh(n, t), n
}
function Jx(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Dc(n, e)
}
function Dc(n, e) {
  return (
    (Dc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Dc(n, e)
  )
}
function ew(n) {
  var e = nw()
  return function () {
    var r = zo(n),
      i
    if (e) {
      var s = zo(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return tw(this, i)
  }
}
function tw(n, e) {
  return e && (po(e) === 'object' || typeof e == 'function') ? e : ir(n)
}
function ir(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function nw() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function zo(n) {
  return (
    (zo = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    zo(n)
  )
}
function sr(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var Ym = (function (n) {
  Jx(t, n)
  var e = ew(t)
  function t() {
    var r
    Hx(this, t)
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o]
    return (
      (r = e.call.apply(e, [this].concat(s))),
      sr(ir(r), 'getPaths', function (a) {
        return a instanceof Array
          ? a.map(function (l, c) {
              return h.React.createElement('path', Zr({ key: c }, l))
            })
          : h.React.createElement('path', Zr({ key: 'pathSVG' }, a))
      }),
      sr(ir(r), 'getCircles', function (a) {
        return a instanceof Array
          ? a.map(function (l) {
              return h.React.createElement('circle', l)
            })
          : h.React.createElement('circle', Zr({ key: 'circleSVG' }, a))
      }),
      sr(ir(r), 'getEllipses', function (a) {
        return a instanceof Array
          ? a.map(function (l) {
              return h.React.createElement('ellipse', l)
            })
          : h.React.createElement('ellipse', Zr({ key: 'ellipseSVG' }, a))
      }),
      sr(ir(r), 'getGroups', function (a) {
        return a instanceof Array
          ? a.map(function (l) {
              return h.React.createElement('g', null, r.getShapes(l))
            })
          : h.React.createElement('g', { key: 'groupsSVG' }, r.getShapes(a))
      }),
      sr(ir(r), 'getShapes', function (a) {
        var l = []
        return (
          a &&
            (a.g && l.push(r.getGroups(a.g)),
            a.ellipse && l.push(r.getEllipses(a.ellipse)),
            a.circle && l.push(r.getCircles(a.circle)),
            a.path && l.push(r.getPaths(a.path))),
          l
        )
      }),
      sr(ir(r), 'getSVG', function (a, l) {
        var c = a.viewBox,
          u = Ih(a, ['viewBox'])
        return h.React.createElement(
          'svg',
          {
            'aria-hidden': l['aria-hidden'],
            className: l.className,
            viewBox: c,
            name: l.name,
            style: l.style
          },
          r.getShapes(u)
        )
      }),
      r
    )
  }
  return (
    Kx(t, [
      {
        key: 'render',
        value: function () {
          var i = this.props,
            s = i.data,
            o = Ih(i, ['data'])
          return s ? this.getSVG(s, o) : null
        }
      }
    ]),
    t
  )
})(h.React.Component)
sr(Ym, 'displayName', 'Svg')
const rw = Ym
var iw = {}
const sw = iw
var ow = {}
const aw = ow
var lw = {}
const cw = lw
var uw = {}
const fw = uw
var hw = {}
const pw = hw
function Oo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Oo = function (t) {
          return typeof t
        })
      : (Oo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Oo(n)
  )
}
function Xc() {
  return (
    (Xc =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Xc.apply(this, arguments)
  )
}
function dw(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Nh(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function Ow(n, e, t) {
  return e && Nh(n.prototype, e), t && Nh(n, t), n
}
function mw(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Yc(n, e)
}
function Yc(n, e) {
  return (
    (Yc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Yc(n, e)
  )
}
function gw(n) {
  var e = bw()
  return function () {
    var r = Fo(n),
      i
    if (e) {
      var s = Fo(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return yw(this, i)
  }
}
function yw(n, e) {
  return e && (Oo(e) === 'object' || typeof e == 'function') ? e : Im(n)
}
function Im(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function bw() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Fo(n) {
  return (
    (Fo = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    Fo(n)
  )
}
function Mh(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var vw = function (e) {
  var t,
    r,
    i = e.displayName || e.name || 'Component'
  return (
    (r = t =
      (function (s) {
        mw(a, s)
        var o = gw(a)
        function a() {
          var l
          dw(this, a)
          for (var c = arguments.length, u = new Array(c), f = 0; f < c; f++)
            u[f] = arguments[f]
          return (
            (l = o.call.apply(o, [this].concat(u))),
            Mh(Im(l), 'getWrappedComponent', function (p) {
              return h.React.createElement(e, Xc({}, l.props, { direction: p }))
            }),
            l
          )
        }
        return (
          Ow(a, [
            {
              key: 'render',
              value: function () {
                return h.React.createElement(
                  Dm.Consumer,
                  null,
                  this.getWrappedComponent
                )
              }
            }
          ]),
          a
        )
      })(h.reactExports.Component)),
    Mh(t, 'displayName', 'LanguageDirection('.concat(i, ')')),
    r
  )
}
const jm = vw
var Ja = function (e) {
  var t = e.iconPath,
    r = e.onRequestIconPath,
    i = e.actionSprite,
    s = e.customSprite,
    o = e.doctypeSprite,
    a = e.standardSprite,
    l = e.utilitySprite,
    c = e.children
  return h.React.createElement(
    el.Provider,
    {
      value: {
        iconPath: t,
        onRequestIconPath: r,
        actionSprite: i,
        customSprite: s,
        doctypeSprite: o,
        standardSprite: a,
        utilitySprite: l
      }
    },
    c
  )
}
Ja.displayName = $x
Ja.propTypes = {
  iconPath: h.PropTypes.string,
  onRequestIconPath: h.PropTypes.func,
  actionSprite: h.PropTypes.string,
  customSprite: h.PropTypes.string,
  doctypeSprite: h.PropTypes.string,
  standardSprite: h.PropTypes.string,
  utilitySprite: h.PropTypes.string
}
var el = h.React.createContext({})
function Go() {
  return (
    (Go =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Go.apply(this, arguments)
  )
}
function Sw(n, e) {
  if (n == null) return {}
  var t = xw(n, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, r) &&
          (t[r] = n[r])
  }
  return t
}
function xw(n, e) {
  if (n == null) return {}
  var t = {},
    r = Object.keys(n),
    i,
    s
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i])
  return t
}
var tl = function (e) {
  var t = e.name,
    r = t === void 0 ? '' : t
  e.assistiveText
  var i = e.category,
    s = e.icon,
    o = e.path,
    a = e.direction,
    l = Sw(e, [
      'name',
      'assistiveText',
      'category',
      'icon',
      'path',
      'direction'
    ]),
    c = h.reactExports.useContext(el)
  Fx('UtilityIcon', { name: r, category: i, path: o, context: c })
  var u = { action: aw, custom: cw, doctype: fw, standard: pw, utility: sw },
    f
  s
    ? (f = s)
    : Object.keys(u[i]).length &&
      ((f = u[i][r.toLowerCase()]), (f.viewBox = u[i].viewBox))
  var p
  if (o) p = o
  else if (c.onRequestIconPath)
    p = c.onRequestIconPath({ category: i, name: r })
  else if (c[''.concat(i, 'Sprite')])
    p = ''.concat(c[''.concat(i, 'Sprite')], '#').concat(r)
  else {
    var d = a === Mn.RTL ? 'symbols-rtl.svg' : 'symbols.svg'
    p =
      c.iconPath &&
      ''
        .concat(c.iconPath, '/')
        .concat(i, '-sprite/svg/')
        .concat(d, '#')
        .concat(r)
  }
  return f
    ? h.React.createElement(rw, Go({ data: f, name: r }, l))
    : h.React.createElement(
        'svg',
        Go({ key: ''.concat(r, '_').concat(i) }, l),
        h.React.createElement('use', { href: p })
      )
}
tl.displayName = 'UtilityIcon'
tl.propTypes = {
  assistiveText: h.PropTypes.object,
  category: h.PropTypes.oneOf([
    'action',
    'custom',
    'doctype',
    'standard',
    'utility'
  ]),
  icon: h.PropTypes.object,
  name: h.PropTypes.string,
  path: h.PropTypes.string
}
tl.defaultProps = { category: 'utility' }
const Ho = jm(tl)
var ww = {
  'global-setup': '#2A739E',
  'service-cloud': '#7f2443',
  'industry-cloud': '#4c2248',
  'sales-cloud': '#00857d',
  'commerce-cloud': '#41693d',
  'community-cloud': '#ffc20e',
  'marketing-cloud': '#ea7600',
  quip: '#cf451d'
}
const Pw = h.getDefaultExportFromCjs(ww)
function Vh(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function jl(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? Vh(Object(t), !0).forEach(function (r) {
          Nm(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : Vh(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function Nm(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var Mm = {
    assistiveText: {},
    category: 'standard',
    colorVariant: 'default',
    size: 'medium'
  },
  Ie = function (e) {
    Vx(Qm, e, Ux)
    var t = e.category,
      r = e.className,
      i = e.colorVariant,
      s = e.containerClassName,
      o = e.containerStyle,
      a = e.icon,
      l = e.inverse,
      c = e.name,
      u = e.path,
      f = e.size,
      p = e.title,
      d = e.productTheme,
      O = e.style
    d && (O = jl({ backgroundColor: Pw[d] }, O))
    var g =
        typeof e.assistiveText == 'string'
          ? e.assistiveText
          : jl(jl({}, Mm.assistiveText), e.assistiveText).label,
      b = c ? c.replace(/_/g, '-') : ''
    return h.React.createElement(
      'span',
      {
        className: Br(
          Nm(
            {
              'slds-icon_container': t !== 'utility',
              'slds-icon_container_circle': t === 'action'
            },
            'slds-icon-'.concat(t, '-').concat(b),
            t !== 'utility' && t !== 'doctype' && !u
          ),
          s
        ),
        style: o,
        title: p
      },
      h.React.createElement(Ho, {
        'aria-hidden': 'true',
        category: t,
        className: Br(r, 'slds-icon', {
          'slds-icon_xx-small': f === 'xx-small',
          'slds-icon_x-small': f === 'x-small',
          'slds-icon_small': f === 'small',
          'slds-icon_large': f === 'large',
          'slds-icon-text-default': i === 'default' && t === 'utility' ? !l : l,
          'slds-icon-text-success': i === 'success',
          'slds-icon-text-warning': i === 'warning',
          'slds-icon-text-error': i === 'error',
          'slds-icon-text-light': i === 'light'
        }),
        icon: a,
        name: c,
        path: u,
        style: O
      }),
      g
        ? h.React.createElement('span', { className: 'slds-assistive-text' }, g)
        : ''
    )
  }
Ie.displayName = Qm
Ie.propTypes = {
  assistiveText: h.PropTypes.shape({ label: h.PropTypes.string }),
  category: h.PropTypes.oneOf([
    'action',
    'custom',
    'doctype',
    'standard',
    'utility'
  ]).isRequired,
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  containerClassName: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  containerStyle: h.PropTypes.object,
  colorVariant: h.PropTypes.oneOf([
    'base',
    'default',
    'error',
    'light',
    'warning',
    'success'
  ]),
  icon: h.PropTypes.object,
  inverse: h.PropTypes.bool,
  name: h.PropTypes.string,
  path: h.PropTypes.string,
  productTheme: h.PropTypes.oneOf([
    'global-setup',
    'service-cloud',
    'industry-cloud',
    'sales-cloud',
    'commerce-cloud',
    'community-cloud',
    'marketing-cloud',
    'quip'
  ]),
  size: h.PropTypes.oneOf(['xx-small', 'x-small', 'small', 'medium', 'large']),
  style: h.PropTypes.object,
  title: h.PropTypes.string
}
Ie.defaultProps = Mm
function mo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (mo = function (t) {
          return typeof t
        })
      : (mo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    mo(n)
  )
}
function Tw(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Wh(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function $w(n, e, t) {
  return e && Wh(n.prototype, e), t && Wh(n, t), n
}
function Qw(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Ic(n, e)
}
function Ic(n, e) {
  return (
    (Ic =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Ic(n, e)
  )
}
function kw(n) {
  var e = _w()
  return function () {
    var r = Ko(n),
      i
    if (e) {
      var s = Ko(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return Cw(this, i)
  }
}
function Cw(n, e) {
  return e && (mo(e) === 'object' || typeof e == 'function') ? e : Vm(n)
}
function Vm(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function _w() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Ko(n) {
  return (
    (Ko = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    Ko(n)
  )
}
function st(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var nl = (function (n) {
  Qw(t, n)
  var e = kw(t)
  function t() {
    var r
    Tw(this, t)
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o]
    return (
      (r = e.call.apply(e, [this].concat(s))),
      st(Vm(r), 'checkFocus', function () {
        r.props.selected && r.props.focus && r.node && r.node.focus()
      }),
      r
    )
  }
  return (
    $w(t, [
      {
        key: 'componentDidMount',
        value: function () {
          this.checkFocus()
        }
      },
      {
        key: 'componentDidUpdate',
        value: function () {
          this.checkFocus()
        }
      },
      {
        key: 'render',
        value: function () {
          var i,
            s,
            o = this,
            a = this.props,
            l = a.selected,
            c = a.disabled,
            u = a.panelId,
            f = a.activeTabClassName,
            p = a.disabledTabClassName,
            d = a.className,
            O = a.children,
            g = a.id,
            b = a.variant,
            x = a.hasError,
            w
          return (
            l ? (w = '0') : (w = '-1'),
            h.React.createElement(
              'li',
              {
                className: se(
                  d,
                  ((i = {}),
                  st(i, f, l),
                  st(i, p, c),
                  st(i, 'slds-tabs_default__item', b === 'default'),
                  st(i, 'slds-tabs_scoped__item', b === 'scoped'),
                  st(i, 'slds-vertical-tabs__nav-item', b === 'vertical'),
                  i)
                ),
                role: 'presentation',
                id: g,
                title: typeof O == 'string' ? O : null
              },
              h.React.createElement(
                'a',
                {
                  className: se(
                    ((s = {}),
                    st(s, f, l),
                    st(s, p, c),
                    st(s, 'slds-tabs_default__link', b === 'default'),
                    st(s, 'slds-tabs_scoped__link', b === 'scoped'),
                    st(s, 'slds-vertical-tabs__link', b === 'vertical'),
                    s)
                  ),
                  href: '#',
                  role: 'tab',
                  ref: function (T) {
                    o.node = T
                  },
                  tabIndex: w,
                  'aria-controls': u,
                  'aria-disabled': c,
                  'aria-selected': l ? 'true' : 'false',
                  onClick: function (T) {
                    return T.preventDefault()
                  }
                },
                O,
                x &&
                  h.React.createElement(
                    'span',
                    {
                      className: se({
                        'slds-tabs__right-icon': b !== 'vertical',
                        'slds-vertical-tabs__right-icon': b === 'vertical'
                      })
                    },
                    h.React.createElement(Ie, {
                      assistiveText: {
                        label: this.props.assistiveText.withErrorIcon
                      },
                      category: 'utility',
                      containerClassName:
                        'slds-icon_container slds-icon-utility-error',
                      size: 'x-small',
                      name: 'error',
                      colorVariant: 'error',
                      title: this.props.assistiveText.withErrorIcon
                    })
                  )
              )
            )
          )
        }
      }
    ]),
    t
  )
})(h.React.Component)
st(nl, 'displayName', _x)
st(nl, 'propTypes', {
  className: h.PropTypes.string,
  id: h.PropTypes.string,
  focus: h.PropTypes.bool,
  selected: h.PropTypes.bool,
  disabled: h.PropTypes.bool,
  activeTabClassName: h.PropTypes.string,
  disabledTabClassName: h.PropTypes.string,
  panelId: h.PropTypes.string,
  children: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.element]),
  variant: h.PropTypes.oneOf(['default', 'scoped', 'vertical']),
  hasError: h.PropTypes.bool,
  assistiveText: h.PropTypes.shape({ withErrorIcon: h.PropTypes.string })
})
st(nl, 'defaultProps', {
  focus: !1,
  selected: !1,
  activeTabClassName: 'slds-is-active',
  disabledTabClassName: 'slds-disabled',
  variant: 'default',
  hasError: !1,
  assistiveText: { withErrorIcon: 'This item has an error' }
})
const Rw = nl
function Zw(n, e) {
  if (n == null) return {}
  var t = Aw(n, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, r) &&
          (t[r] = n[r])
  }
  return t
}
function Aw(n, e) {
  if (n == null) return {}
  var t = {},
    r = Object.keys(n),
    i,
    s
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i])
  return t
}
var rl = function (e) {
  var t = e.className,
    r = e.children,
    i = e.variant,
    s = e.selected,
    o = e.id,
    a = e.tabId
  return (
    Zw(e, ['className', 'children', 'variant', 'selected', 'id', 'tabId']),
    h.React.createElement(
      'div',
      {
        'aria-labelledby': a,
        className: se(t, {
          'slds-show': s,
          'slds-hide': !s,
          'slds-tabs_default__content': i === 'default',
          'slds-tabs_scoped__content': i === 'scoped',
          'slds-vertical-tabs__content': i === 'vertical'
        }),
        id: o,
        role: 'tabpanel'
      },
      r.props.children
    )
  )
}
rl.displayName = Rx
rl.propTypes = {
  children: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  className: h.PropTypes.string,
  id: h.PropTypes.string,
  selected: h.PropTypes.bool,
  variant: h.PropTypes.oneOf(['default', 'scoped', 'vertical']),
  tabId: h.PropTypes.string
}
rl.defaultProps = { variant: 'default', selected: !1 }
const Ew = rl
var Dw = {
  ENTER: 13,
  ESCAPE: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  TAB: 9,
  DELETE: 46,
  BACKSPACE: 8
}
const Ar = Dw
var go = {
  trapEvent: function (e) {
    e &&
      (e.preventDefault(),
      e.stopPropagation(),
      e.nativeEvent &&
        e.nativeEvent.preventDefault &&
        e.nativeEvent.preventDefault(),
      e.nativeEvent &&
        e.nativeEvent.stopPropagation &&
        e.nativeEvent.stopPropagation())
  },
  trap: function (e) {
    return go.trapEvent(e)
  },
  trapImmediate: function (e) {
    e.stopImmediatePropagation && e.stopImmediatePropagation(),
      e.nativeEvent &&
        e.nativeEvent.stopImmediatePropagation &&
        e.nativeEvent.stopImmediatePropagation(),
      go.trap(e)
  },
  trappedHandler: function (e) {
    return function (t) {
      go.trap(t), e && e(t)
    }
  }
}
const fs = go
function yo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (yo = function (t) {
          return typeof t
        })
      : (yo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    yo(n)
  )
}
function Xw(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Lh(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function Yw(n, e, t) {
  return e && Lh(n.prototype, e), t && Lh(n, t), n
}
function Iw(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && jc(n, e)
}
function jc(n, e) {
  return (
    (jc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    jc(n, e)
  )
}
function jw(n) {
  var e = Mw()
  return function () {
    var r = Jo(n),
      i
    if (e) {
      var s = Jo(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return Nw(this, i)
  }
}
function Nw(n, e) {
  return e && (yo(e) === 'object' || typeof e == 'function') ? e : Nc(n)
}
function Nc(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function Mw() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Jo(n) {
  return (
    (Jo = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    Jo(n)
  )
}
function Bh(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
function Vw(n) {
  return (
    (n.nodeName === 'A' && n.getAttribute('role') === 'tab') ||
    (n.nodeName === 'LI' &&
      (n.classList.contains('slds-tabs_default__item') ||
        n.classList.contains('slds-tabs_scoped__item') ||
        n.classList.contains('slds-vertical-tabs__nav-item')))
  )
}
function vi(n) {
  return n.classList && n.classList.contains('slds-disabled')
    ? !0
    : n.getAttribute
      ? n.getAttribute('aria-disabled') === 'true'
      : !!n.props.disabled
}
var Ww = Zx,
  Lw = {
    id: h.PropTypes.string,
    children: h.PropTypes.oneOfType([
      h.PropTypes.arrayOf(h.PropTypes.node),
      h.PropTypes.node,
      h.PropTypes.element
    ]).isRequired,
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    defaultSelectedIndex: h.PropTypes.number,
    onSelect: h.PropTypes.func,
    variant: h.PropTypes.oneOf(['default', 'scoped', 'vertical']),
    selectedIndex: h.PropTypes.number
  },
  Bw = { defaultSelectedIndex: 0, variant: 'default' },
  hs = (function (n) {
    Iw(t, n)
    var e = jw(t)
    function t(r) {
      var i
      return (
        Xw(this, t),
        (i = e.call(this, r)),
        Bh(Nc(i), 'handleClick', function (s) {
          var o = s.target
          do
            if (i.isTabFromContainer(o)) {
              if (vi(o)) return
              var a = o.parentNode
              a.nodeName === 'LI' && ((o = o.parentNode), (a = o.parentNode))
              var l = [].slice.call(a.children).indexOf(o)
              i.setSelected(l)
              return
            }
          while ((o = o.parentNode) !== null)
        }),
        Bh(Nc(i), 'handleKeyDown', function (s) {
          if (i.isTabFromContainer(s.target)) {
            var o = i.getSelectedIndex(),
              a = !1
            s.keyCode === Ar.LEFT || s.keyCode === Ar.UP
              ? ((o = i.getPrevTab(o)), (a = !0))
              : (s.keyCode === Ar.RIGHT || s.keyCode === Ar.DOWN) &&
                ((o = i.getNextTab(o)), (a = !0)),
              a && fs.trap(s),
              i.setSelected(o, !0)
          }
        }),
        (i.tabs = []),
        (i.generatedId = dr.generate()),
        (i.flavor = i.getVariant()),
        (i.state = { selectedIndex: r.defaultSelectedIndex }),
        i
      )
    }
    return (
      Yw(t, [
        {
          key: 'getNextTab',
          value: function (i) {
            for (var s = this.getTabsCount(), o = i + 1; o < s; o++) {
              var a = this.getTab(o)
              if (!vi(a)) return o
            }
            for (var l = 0; l < i; l++) {
              var c = this.getTab(l)
              if (!vi(c)) return l
            }
            return i
          }
        },
        {
          key: 'getPanelsCount',
          value: function () {
            return this.props.children
              ? h.React.Children.count(this.props.children)
              : 0
          }
        },
        {
          key: 'getPrevTab',
          value: function (i) {
            for (var s = i; s--; ) {
              var o = this.getTab(s)
              if (!vi(o)) return s
            }
            for (s = this.getTabsCount(); s-- > i; ) {
              var a = this.getTab(s)
              if (!vi(a)) return s
            }
            return i
          }
        },
        {
          key: 'getSelectedIndex',
          value: function () {
            return Number.isInteger(this.props.selectedIndex)
              ? this.props.selectedIndex
              : this.state.selectedIndex
          }
        },
        {
          key: 'getTab',
          value: function (i) {
            return this.tabs[i].tab
          }
        },
        {
          key: 'getTabNode',
          value: function (i) {
            return this.tabs[i].node
          }
        },
        {
          key: 'getTabsCount',
          value: function () {
            return this.props.children
              ? h.React.Children.count(this.props.children)
              : 0
          }
        },
        {
          key: 'getVariant',
          value: function () {
            return this.props.variant || 'default'
          }
        },
        {
          key: 'setSelected',
          value: function (i, s) {
            if (!(i < 0 || i >= this.getTabsCount())) {
              var o = this.getSelectedIndex(),
                a
              wm(this.props.onSelect) && (a = this.props.onSelect(i, o)),
                a !== !1 &&
                  i !== this.state.selectedIndex &&
                  this.setState({ selectedIndex: i, focus: s === !0 })
            }
          }
        },
        {
          key: 'isTabFromContainer',
          value: function (i) {
            if (!Vw(i)) return !1
            var s = i.parentElement
            do {
              if (s === this.tabsNode) return !0
              if (s.getAttribute('data-tabs')) break
              s = s.parentElement
            } while (s)
            return !1
          }
        },
        {
          key: 'renderTabPanels',
          value: function (i) {
            var s = this,
              o = h.React.Children.toArray(this.props.children),
              a = this.getSelectedIndex(),
              l = null
            return (
              (l = o.map(function (c, u) {
                var f = ''.concat(i, '-slds-tabs_tab-').concat(u),
                  p = ''.concat(i, '-slds-tabs_panel-').concat(u),
                  d = a === u,
                  O = s.getVariant()
                return h.React.createElement(
                  Ew,
                  { key: c.key, selected: d, id: p, tabId: f, variant: O },
                  o[u]
                )
              })),
              l
            )
          }
        },
        {
          key: 'renderTabsList',
          value: function (i) {
            var s = this,
              o = h.React.Children.toArray(this.props.children)
            return h.React.createElement(
              Yx,
              { id: i, variant: this.getVariant() },
              o.map(function (a, l) {
                var c = ''.concat(i, '-slds-tabs_tab-').concat(l),
                  u = ''.concat(i, '-slds-tabs_panel-').concat(l),
                  f = s.getSelectedIndex() === l,
                  p = f && s.state.focus,
                  d = s.getVariant()
                return h.React.createElement(
                  Rw,
                  {
                    key: a.key,
                    ref: function (g) {
                      ;(s.tabs[l] = { tab: a, node: g }),
                        s.state.focus && s.setState({ focus: !1 })
                    },
                    focus: p,
                    selected: f,
                    id: c,
                    panelId: u,
                    disabled: a.props.disabled,
                    variant: d,
                    hasError: a.props.hasError,
                    assistiveText: a.props.assistiveText
                  },
                  a.props.label
                )
              })
            )
          }
        },
        {
          key: 'render',
          value: function () {
            var i = this,
              s = this.props,
              o = s.className,
              a = s.id,
              l = a === void 0 ? this.generatedId : a,
              c = s.variant,
              u = c === void 0 ? this.getVariant : c
            return h.React.createElement(
              'div',
              {
                id: l,
                className: se(
                  {
                    'slds-tabs_default': u === 'default',
                    'slds-tabs_scoped': u === 'scoped',
                    'slds-vertical-tabs': u === 'vertical'
                  },
                  o
                ),
                onClick: this.handleClick,
                onKeyDown: this.handleKeyDown,
                'data-tabs': !0,
                ref: function (p) {
                  i.tabsNode = p
                }
              },
              this.renderTabsList(l),
              this.renderTabPanels(l)
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
hs.displayName = Ww
hs.propTypes = Lw
hs.defaultProps = Bw
var Ur = function (e) {
  var t = e.children
  return h.React.createElement('div', null, h.React.Children.toArray(t))
}
Ur.displayName = Ex
Ur.propTypes = {
  label: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.element])
    .isRequired,
  children: h.PropTypes.oneOfType([
    h.PropTypes.arrayOf(h.PropTypes.node),
    h.PropTypes.node,
    h.PropTypes.element
  ]).isRequired,
  hasError: h.PropTypes.bool,
  assistiveText: h.PropTypes.shape({ withErrorIcon: h.PropTypes.string })
}
var ps = (n) => n.type === 'checkbox',
  Er = (n) => n instanceof Date,
  tt = (n) => n == null
const Wm = (n) => typeof n == 'object'
var De = (n) => !tt(n) && !Array.isArray(n) && Wm(n) && !Er(n),
  Lm = (n) =>
    De(n) && n.target ? (ps(n.target) ? n.target.checked : n.target.value) : n,
  Uw = (n) => n.substring(0, n.search(/\.\d+(\.|$)/)) || n,
  Bm = (n, e) => n.has(Uw(e)),
  qw = (n) => {
    const e = n.constructor && n.constructor.prototype
    return De(e) && e.hasOwnProperty('isPrototypeOf')
  },
  pf =
    typeof window < 'u' &&
    typeof window.HTMLElement < 'u' &&
    typeof document < 'u'
function Et(n) {
  let e
  const t = Array.isArray(n)
  if (n instanceof Date) e = new Date(n)
  else if (n instanceof Set) e = new Set(n)
  else if (
    !(pf && (n instanceof Blob || n instanceof FileList)) &&
    (t || De(n))
  )
    if (((e = t ? [] : {}), !t && !qw(n))) e = n
    else for (const r in n) n.hasOwnProperty(r) && (e[r] = Et(n[r]))
  else return n
  return e
}
var ds = (n) => (Array.isArray(n) ? n.filter(Boolean) : []),
  $e = (n) => n === void 0,
  N = (n, e, t) => {
    if (!e || !De(n)) return t
    const r = ds(e.split(/[,[\].]+?/)).reduce((i, s) => (tt(i) ? i : i[s]), n)
    return $e(r) || r === n ? ($e(n[e]) ? t : n[e]) : r
  },
  Ft = (n) => typeof n == 'boolean'
const ea = { BLUR: 'blur', FOCUS_OUT: 'focusout', CHANGE: 'change' },
  Dt = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
    onTouched: 'onTouched',
    all: 'all'
  },
  pn = {
    max: 'max',
    min: 'min',
    maxLength: 'maxLength',
    minLength: 'minLength',
    pattern: 'pattern',
    required: 'required',
    validate: 'validate'
  },
  zw = h.React.createContext(null),
  df = () => h.React.useContext(zw)
var Um = (n, e, t, r = !0) => {
    const i = { defaultValues: e._defaultValues }
    for (const s in n)
      Object.defineProperty(i, s, {
        get: () => {
          const o = s
          return (
            e._proxyFormState[o] !== Dt.all &&
              (e._proxyFormState[o] = !r || Dt.all),
            t && (t[o] = !0),
            n[o]
          )
        }
      })
    return i
  },
  Tt = (n) => De(n) && !Object.keys(n).length,
  qm = (n, e, t, r) => {
    t(n)
    const { name: i, ...s } = n
    return (
      Tt(s) ||
      Object.keys(s).length >= Object.keys(e).length ||
      Object.keys(s).find((o) => e[o] === (!r || Dt.all))
    )
  },
  bo = (n) => (Array.isArray(n) ? n : [n]),
  zm = (n, e, t) =>
    !n ||
    !e ||
    n === e ||
    bo(n).some((r) => r && (t ? r === e : r.startsWith(e) || e.startsWith(r)))
function Of(n) {
  const e = h.React.useRef(n)
  ;(e.current = n),
    h.React.useEffect(() => {
      const t =
        !n.disabled &&
        e.current.subject &&
        e.current.subject.subscribe({ next: e.current.next })
      return () => {
        t && t.unsubscribe()
      }
    }, [n.disabled])
}
function Fw(n) {
  const e = df(),
    { control: t = e.control, disabled: r, name: i, exact: s } = n || {},
    [o, a] = h.React.useState(t._formState),
    l = h.React.useRef(!0),
    c = h.React.useRef({
      isDirty: !1,
      isLoading: !1,
      dirtyFields: !1,
      touchedFields: !1,
      isValidating: !1,
      isValid: !1,
      errors: !1
    }),
    u = h.React.useRef(i)
  return (
    (u.current = i),
    Of({
      disabled: r,
      next: (f) =>
        l.current &&
        zm(u.current, f.name, s) &&
        qm(f, c.current, t._updateFormState) &&
        a({ ...t._formState, ...f }),
      subject: t._subjects.state
    }),
    h.React.useEffect(
      () => (
        (l.current = !0),
        c.current.isValid && t._updateValid(!0),
        () => {
          l.current = !1
        }
      ),
      [t]
    ),
    Um(o, t, c.current, !1)
  )
}
var Kt = (n) => typeof n == 'string',
  Fm = (n, e, t, r, i) =>
    Kt(n)
      ? (r && e.watch.add(n), N(t, n, i))
      : Array.isArray(n)
        ? n.map((s) => (r && e.watch.add(s), N(t, s)))
        : (r && (e.watchAll = !0), t)
function Gw(n) {
  const e = df(),
    {
      control: t = e.control,
      name: r,
      defaultValue: i,
      disabled: s,
      exact: o
    } = n || {},
    a = h.React.useRef(r)
  ;(a.current = r),
    Of({
      disabled: s,
      subject: t._subjects.values,
      next: (u) => {
        zm(a.current, u.name, o) &&
          c(Et(Fm(a.current, t._names, u.values || t._formValues, !1, i)))
      }
    })
  const [l, c] = h.React.useState(t._getWatch(r, i))
  return h.React.useEffect(() => t._removeUnmounted()), l
}
var mf = (n) => /^\w*$/.test(n),
  Gm = (n) => ds(n.replace(/["|']|\]/g, '').split(/\.|\[/))
function pe(n, e, t) {
  let r = -1
  const i = mf(e) ? [e] : Gm(e),
    s = i.length,
    o = s - 1
  for (; ++r < s; ) {
    const a = i[r]
    let l = t
    if (r !== o) {
      const c = n[a]
      l = De(c) || Array.isArray(c) ? c : isNaN(+i[r + 1]) ? {} : []
    }
    ;(n[a] = l), (n = n[a])
  }
  return n
}
function Hw(n) {
  const e = df(),
    { name: t, disabled: r, control: i = e.control, shouldUnregister: s } = n,
    o = Bm(i._names.array, t),
    a = Gw({
      control: i,
      name: t,
      defaultValue: N(i._formValues, t, N(i._defaultValues, t, n.defaultValue)),
      exact: !0
    }),
    l = Fw({ control: i, name: t }),
    c = h.React.useRef(i.register(t, { ...n.rules, value: a }))
  return (
    (c.current = i.register(t, n.rules)),
    h.React.useEffect(() => {
      const u = i._options.shouldUnregister || s,
        f = (p, d) => {
          const O = N(i._fields, p)
          O && (O._f.mount = d)
        }
      if ((f(t, !0), u)) {
        const p = Et(N(i._options.defaultValues, t))
        pe(i._defaultValues, t, p),
          $e(N(i._formValues, t)) && pe(i._formValues, t, p)
      }
      return () => {
        ;(o ? u && !i._state.action : u) ? i.unregister(t) : f(t, !1)
      }
    }, [t, i, o, s]),
    h.React.useEffect(() => {
      N(i._fields, t) &&
        i._updateDisabledField({
          disabled: r,
          fields: i._fields,
          name: t,
          value: N(i._fields, t)._f.value
        })
    }, [r, t, i]),
    {
      field: {
        name: t,
        value: a,
        ...(Ft(r) || Ft(l.disabled) ? { disabled: l.disabled || r } : {}),
        onChange: h.React.useCallback(
          (u) =>
            c.current.onChange({
              target: { value: Lm(u), name: t },
              type: ea.CHANGE
            }),
          [t]
        ),
        onBlur: h.React.useCallback(
          () =>
            c.current.onBlur({
              target: { value: N(i._formValues, t), name: t },
              type: ea.BLUR
            }),
          [t, i]
        ),
        ref: (u) => {
          const f = N(i._fields, t)
          f &&
            u &&
            (f._f.ref = {
              focus: () => u.focus(),
              select: () => u.select(),
              setCustomValidity: (p) => u.setCustomValidity(p),
              reportValidity: () => u.reportValidity()
            })
        }
      },
      formState: l,
      fieldState: Object.defineProperties(
        {},
        {
          invalid: { enumerable: !0, get: () => !!N(l.errors, t) },
          isDirty: { enumerable: !0, get: () => !!N(l.dirtyFields, t) },
          isTouched: { enumerable: !0, get: () => !!N(l.touchedFields, t) },
          error: { enumerable: !0, get: () => N(l.errors, t) }
        }
      )
    }
  )
}
const Uh = (n) => n.render(Hw(n))
var Kw = (n, e, t, r, i) =>
    e
      ? {
          ...t[n],
          types: { ...(t[n] && t[n].types ? t[n].types : {}), [r]: i || !0 }
        }
      : {},
  qh = (n) => ({
    isOnSubmit: !n || n === Dt.onSubmit,
    isOnBlur: n === Dt.onBlur,
    isOnChange: n === Dt.onChange,
    isOnAll: n === Dt.all,
    isOnTouch: n === Dt.onTouched
  }),
  zh = (n, e, t) =>
    !t &&
    (e.watchAll ||
      e.watch.has(n) ||
      [...e.watch].some(
        (r) => n.startsWith(r) && /^\.\w+/.test(n.slice(r.length))
      ))
const vo = (n, e, t, r) => {
  for (const i of t || Object.keys(n)) {
    const s = N(n, i)
    if (s) {
      const { _f: o, ...a } = s
      if (o) {
        if (o.refs && o.refs[0] && e(o.refs[0], i) && !r) break
        if (o.ref && e(o.ref, o.name) && !r) break
      } else De(a) && vo(a, e)
    }
  }
}
var Jw = (n, e, t) => {
    const r = ds(N(n, t))
    return pe(r, 'root', e[t]), pe(n, t, r), n
  },
  gf = (n) => n.type === 'file',
  En = (n) => typeof n == 'function',
  ta = (n) => {
    if (!pf) return !1
    const e = n ? n.ownerDocument : 0
    return (
      n instanceof
      (e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement)
    )
  },
  So = (n) => Kt(n),
  yf = (n) => n.type === 'radio',
  na = (n) => n instanceof RegExp
const Fh = { value: !1, isValid: !1 },
  Gh = { value: !0, isValid: !0 }
var Hm = (n) => {
  if (Array.isArray(n)) {
    if (n.length > 1) {
      const e = n
        .filter((t) => t && t.checked && !t.disabled)
        .map((t) => t.value)
      return { value: e, isValid: !!e.length }
    }
    return n[0].checked && !n[0].disabled
      ? n[0].attributes && !$e(n[0].attributes.value)
        ? $e(n[0].value) || n[0].value === ''
          ? Gh
          : { value: n[0].value, isValid: !0 }
        : Gh
      : Fh
  }
  return Fh
}
const Hh = { isValid: !1, value: null }
var Km = (n) =>
  Array.isArray(n)
    ? n.reduce(
        (e, t) =>
          t && t.checked && !t.disabled ? { isValid: !0, value: t.value } : e,
        Hh
      )
    : Hh
function Kh(n, e, t = 'validate') {
  if (So(n) || (Array.isArray(n) && n.every(So)) || (Ft(n) && !n))
    return { type: t, message: So(n) ? n : '', ref: e }
}
var Qr = (n) => (De(n) && !na(n) ? n : { value: n, message: '' }),
  Jh = async (n, e, t, r, i) => {
    const {
        ref: s,
        refs: o,
        required: a,
        maxLength: l,
        minLength: c,
        min: u,
        max: f,
        pattern: p,
        validate: d,
        name: O,
        valueAsNumber: g,
        mount: b,
        disabled: x
      } = n._f,
      w = N(e, O)
    if (!b || x) return {}
    const Q = o ? o[0] : s,
      T = (A) => {
        r &&
          Q.reportValidity &&
          (Q.setCustomValidity(Ft(A) ? '' : A || ''), Q.reportValidity())
      },
      P = {},
      k = yf(s),
      R = ps(s),
      V = k || R,
      D =
        ((g || gf(s)) && $e(s.value) && $e(w)) ||
        (ta(s) && s.value === '') ||
        w === '' ||
        (Array.isArray(w) && !w.length),
      L = Kw.bind(null, O, t, P),
      B = (A, Y, W, K = pn.maxLength, te = pn.minLength) => {
        const J = A ? Y : W
        P[O] = { type: A ? K : te, message: J, ref: s, ...L(A ? K : te, J) }
      }
    if (
      i
        ? !Array.isArray(w) || !w.length
        : a &&
          ((!V && (D || tt(w))) ||
            (Ft(w) && !w) ||
            (R && !Hm(o).isValid) ||
            (k && !Km(o).isValid))
    ) {
      const { value: A, message: Y } = So(a)
        ? { value: !!a, message: a }
        : Qr(a)
      if (
        A &&
        ((P[O] = {
          type: pn.required,
          message: Y,
          ref: Q,
          ...L(pn.required, Y)
        }),
        !t)
      )
        return T(Y), P
    }
    if (!D && (!tt(u) || !tt(f))) {
      let A, Y
      const W = Qr(f),
        K = Qr(u)
      if (!tt(w) && !isNaN(w)) {
        const te = s.valueAsNumber || (w && +w)
        tt(W.value) || (A = te > W.value), tt(K.value) || (Y = te < K.value)
      } else {
        const te = s.valueAsDate || new Date(w),
          J = (ue) => new Date(new Date().toDateString() + ' ' + ue),
          ae = s.type == 'time',
          me = s.type == 'week'
        Kt(W.value) &&
          w &&
          (A = ae
            ? J(w) > J(W.value)
            : me
              ? w > W.value
              : te > new Date(W.value)),
          Kt(K.value) &&
            w &&
            (Y = ae
              ? J(w) < J(K.value)
              : me
                ? w < K.value
                : te < new Date(K.value))
      }
      if ((A || Y) && (B(!!A, W.message, K.message, pn.max, pn.min), !t))
        return T(P[O].message), P
    }
    if ((l || c) && !D && (Kt(w) || (i && Array.isArray(w)))) {
      const A = Qr(l),
        Y = Qr(c),
        W = !tt(A.value) && w.length > +A.value,
        K = !tt(Y.value) && w.length < +Y.value
      if ((W || K) && (B(W, A.message, Y.message), !t))
        return T(P[O].message), P
    }
    if (p && !D && Kt(w)) {
      const { value: A, message: Y } = Qr(p)
      if (
        na(A) &&
        !w.match(A) &&
        ((P[O] = { type: pn.pattern, message: Y, ref: s, ...L(pn.pattern, Y) }),
        !t)
      )
        return T(Y), P
    }
    if (d) {
      if (En(d)) {
        const A = await d(w, e),
          Y = Kh(A, Q)
        if (Y && ((P[O] = { ...Y, ...L(pn.validate, Y.message) }), !t))
          return T(Y.message), P
      } else if (De(d)) {
        let A = {}
        for (const Y in d) {
          if (!Tt(A) && !t) break
          const W = Kh(await d[Y](w, e), Q, Y)
          W &&
            ((A = { ...W, ...L(Y, W.message) }), T(W.message), t && (P[O] = A))
        }
        if (!Tt(A) && ((P[O] = { ref: Q, ...A }), !t)) return P
      }
    }
    return T(!0), P
  }
function e1(n, e) {
  const t = e.slice(0, -1).length
  let r = 0
  for (; r < t; ) n = $e(n) ? r++ : n[e[r++]]
  return n
}
function t1(n) {
  for (const e in n) if (n.hasOwnProperty(e) && !$e(n[e])) return !1
  return !0
}
function Me(n, e) {
  const t = Array.isArray(e) ? e : mf(e) ? [e] : Gm(e),
    r = t.length === 1 ? n : e1(n, t),
    i = t.length - 1,
    s = t[i]
  return (
    r && delete r[s],
    i !== 0 &&
      ((De(r) && Tt(r)) || (Array.isArray(r) && t1(r))) &&
      Me(n, t.slice(0, -1)),
    n
  )
}
function Nl() {
  let n = []
  return {
    get observers() {
      return n
    },
    next: (i) => {
      for (const s of n) s.next && s.next(i)
    },
    subscribe: (i) => (
      n.push(i),
      {
        unsubscribe: () => {
          n = n.filter((s) => s !== i)
        }
      }
    ),
    unsubscribe: () => {
      n = []
    }
  }
}
var ra = (n) => tt(n) || !Wm(n)
function fr(n, e) {
  if (ra(n) || ra(e)) return n === e
  if (Er(n) && Er(e)) return n.getTime() === e.getTime()
  const t = Object.keys(n),
    r = Object.keys(e)
  if (t.length !== r.length) return !1
  for (const i of t) {
    const s = n[i]
    if (!r.includes(i)) return !1
    if (i !== 'ref') {
      const o = e[i]
      if (
        (Er(s) && Er(o)) ||
        (De(s) && De(o)) ||
        (Array.isArray(s) && Array.isArray(o))
          ? !fr(s, o)
          : s !== o
      )
        return !1
    }
  }
  return !0
}
var Jm = (n) => n.type === 'select-multiple',
  n1 = (n) => yf(n) || ps(n),
  Ml = (n) => ta(n) && n.isConnected,
  eg = (n) => {
    for (const e in n) if (En(n[e])) return !0
    return !1
  }
function ia(n, e = {}) {
  const t = Array.isArray(n)
  if (De(n) || t)
    for (const r in n)
      Array.isArray(n[r]) || (De(n[r]) && !eg(n[r]))
        ? ((e[r] = Array.isArray(n[r]) ? [] : {}), ia(n[r], e[r]))
        : tt(n[r]) || (e[r] = !0)
  return e
}
function tg(n, e, t) {
  const r = Array.isArray(n)
  if (De(n) || r)
    for (const i in n)
      Array.isArray(n[i]) || (De(n[i]) && !eg(n[i]))
        ? $e(e) || ra(t[i])
          ? (t[i] = Array.isArray(n[i]) ? ia(n[i], []) : { ...ia(n[i]) })
          : tg(n[i], tt(e) ? {} : e[i], t[i])
        : (t[i] = !fr(n[i], e[i]))
  return t
}
var Vl = (n, e) => tg(n, e, ia(e)),
  ng = (n, { valueAsNumber: e, valueAsDate: t, setValueAs: r }) =>
    $e(n)
      ? n
      : e
        ? n === ''
          ? NaN
          : n && +n
        : t && Kt(n)
          ? new Date(n)
          : r
            ? r(n)
            : n
function Wl(n) {
  const e = n.ref
  if (!(n.refs ? n.refs.every((t) => t.disabled) : e.disabled))
    return gf(e)
      ? e.files
      : yf(e)
        ? Km(n.refs).value
        : Jm(e)
          ? [...e.selectedOptions].map(({ value: t }) => t)
          : ps(e)
            ? Hm(n.refs).value
            : ng($e(e.value) ? n.ref.value : e.value, n)
}
var r1 = (n, e, t, r) => {
    const i = {}
    for (const s of n) {
      const o = N(e, s)
      o && pe(i, s, o._f)
    }
    return {
      criteriaMode: t,
      names: [...n],
      fields: i,
      shouldUseNativeValidation: r
    }
  },
  Si = (n) =>
    $e(n)
      ? n
      : na(n)
        ? n.source
        : De(n)
          ? na(n.value)
            ? n.value.source
            : n.value
          : n,
  i1 = (n) =>
    n.mount &&
    (n.required ||
      n.min ||
      n.max ||
      n.maxLength ||
      n.minLength ||
      n.pattern ||
      n.validate)
function ep(n, e, t) {
  const r = N(n, t)
  if (r || mf(t)) return { error: r, name: t }
  const i = t.split('.')
  for (; i.length; ) {
    const s = i.join('.'),
      o = N(e, s),
      a = N(n, s)
    if (o && !Array.isArray(o) && t !== s) return { name: t }
    if (a && a.type) return { name: s, error: a }
    i.pop()
  }
  return { name: t }
}
var s1 = (n, e, t, r, i) =>
    i.isOnAll
      ? !1
      : !t && i.isOnTouch
        ? !(e || n)
        : (t ? r.isOnBlur : i.isOnBlur)
          ? !n
          : (t ? r.isOnChange : i.isOnChange)
            ? n
            : !0,
  o1 = (n, e) => !ds(N(n, e)).length && Me(n, e)
const a1 = {
  mode: Dt.onSubmit,
  reValidateMode: Dt.onChange,
  shouldFocusError: !0
}
function l1(n = {}, e) {
  let t = { ...a1, ...n },
    r = {
      submitCount: 0,
      isDirty: !1,
      isLoading: En(t.defaultValues),
      isValidating: !1,
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      touchedFields: {},
      dirtyFields: {},
      errors: {},
      disabled: !1
    },
    i = {},
    s =
      De(t.defaultValues) || De(t.values)
        ? Et(t.defaultValues || t.values) || {}
        : {},
    o = t.shouldUnregister ? {} : Et(s),
    a = { action: !1, mount: !1, watch: !1 },
    l = {
      mount: new Set(),
      unMount: new Set(),
      array: new Set(),
      watch: new Set()
    },
    c,
    u = 0
  const f = {
      isDirty: !1,
      dirtyFields: !1,
      touchedFields: !1,
      isValidating: !1,
      isValid: !1,
      errors: !1
    },
    p = { values: Nl(), array: Nl(), state: Nl() },
    d = n.resetOptions && n.resetOptions.keepDirtyValues,
    O = qh(t.mode),
    g = qh(t.reValidateMode),
    b = t.criteriaMode === Dt.all,
    x = (v) => ($) => {
      clearTimeout(u), (u = setTimeout(v, $))
    },
    w = async (v) => {
      if (f.isValid || v) {
        const $ = t.resolver ? Tt((await D()).errors) : await B(i, !0)
        $ !== r.isValid && p.state.next({ isValid: $ })
      }
    },
    Q = (v) => f.isValidating && p.state.next({ isValidating: v }),
    T = (v, $ = [], _, q, I = !0, E = !0) => {
      if (q && _) {
        if (((a.action = !0), E && Array.isArray(N(i, v)))) {
          const H = _(N(i, v), q.argA, q.argB)
          I && pe(i, v, H)
        }
        if (E && Array.isArray(N(r.errors, v))) {
          const H = _(N(r.errors, v), q.argA, q.argB)
          I && pe(r.errors, v, H), o1(r.errors, v)
        }
        if (f.touchedFields && E && Array.isArray(N(r.touchedFields, v))) {
          const H = _(N(r.touchedFields, v), q.argA, q.argB)
          I && pe(r.touchedFields, v, H)
        }
        f.dirtyFields && (r.dirtyFields = Vl(s, o)),
          p.state.next({
            name: v,
            isDirty: Y(v, $),
            dirtyFields: r.dirtyFields,
            errors: r.errors,
            isValid: r.isValid
          })
      } else pe(o, v, $)
    },
    P = (v, $) => {
      pe(r.errors, v, $), p.state.next({ errors: r.errors })
    },
    k = (v, $, _, q) => {
      const I = N(i, v)
      if (I) {
        const E = N(o, v, $e(_) ? N(s, v) : _)
        $e(E) || (q && q.defaultChecked) || $
          ? pe(o, v, $ ? E : Wl(I._f))
          : te(v, E),
          a.mount && w()
      }
    },
    R = (v, $, _, q, I) => {
      let E = !1,
        H = !1
      const fe = { name: v }
      if (!_ || q) {
        f.isDirty &&
          ((H = r.isDirty),
          (r.isDirty = fe.isDirty = Y()),
          (E = H !== fe.isDirty))
        const ge = fr(N(s, v), $)
        ;(H = N(r.dirtyFields, v)),
          ge ? Me(r.dirtyFields, v) : pe(r.dirtyFields, v, !0),
          (fe.dirtyFields = r.dirtyFields),
          (E = E || (f.dirtyFields && H !== !ge))
      }
      if (_) {
        const ge = N(r.touchedFields, v)
        ge ||
          (pe(r.touchedFields, v, _),
          (fe.touchedFields = r.touchedFields),
          (E = E || (f.touchedFields && ge !== _)))
      }
      return E && I && p.state.next(fe), E ? fe : {}
    },
    V = (v, $, _, q) => {
      const I = N(r.errors, v),
        E = f.isValid && Ft($) && r.isValid !== $
      if (
        (n.delayError && _
          ? ((c = x(() => P(v, _))), c(n.delayError))
          : (clearTimeout(u),
            (c = null),
            _ ? pe(r.errors, v, _) : Me(r.errors, v)),
        (_ ? !fr(I, _) : I) || !Tt(q) || E)
      ) {
        const H = {
          ...q,
          ...(E && Ft($) ? { isValid: $ } : {}),
          errors: r.errors,
          name: v
        }
        ;(r = { ...r, ...H }), p.state.next(H)
      }
      Q(!1)
    },
    D = async (v) =>
      t.resolver(
        o,
        t.context,
        r1(v || l.mount, i, t.criteriaMode, t.shouldUseNativeValidation)
      ),
    L = async (v) => {
      const { errors: $ } = await D(v)
      if (v)
        for (const _ of v) {
          const q = N($, _)
          q ? pe(r.errors, _, q) : Me(r.errors, _)
        }
      else r.errors = $
      return $
    },
    B = async (v, $, _ = { valid: !0 }) => {
      for (const q in v) {
        const I = v[q]
        if (I) {
          const { _f: E, ...H } = I
          if (E) {
            const fe = l.array.has(E.name),
              ge = await Jh(I, o, b, t.shouldUseNativeValidation && !$, fe)
            if (ge[E.name] && ((_.valid = !1), $)) break
            !$ &&
              (N(ge, E.name)
                ? fe
                  ? Jw(r.errors, ge, E.name)
                  : pe(r.errors, E.name, ge[E.name])
                : Me(r.errors, E.name))
          }
          H && (await B(H, $, _))
        }
      }
      return _.valid
    },
    A = () => {
      for (const v of l.unMount) {
        const $ = N(i, v)
        $ &&
          ($._f.refs ? $._f.refs.every((_) => !Ml(_)) : !Ml($._f.ref)) &&
          fi(v)
      }
      l.unMount = new Set()
    },
    Y = (v, $) => (v && $ && pe(o, v, $), !fr(et(), s)),
    W = (v, $, _) =>
      Fm(v, l, { ...(a.mount ? o : $e($) ? s : Kt(v) ? { [v]: $ } : $) }, _, $),
    K = (v) => ds(N(a.mount ? o : s, v, n.shouldUnregister ? N(s, v, []) : [])),
    te = (v, $, _ = {}) => {
      const q = N(i, v)
      let I = $
      if (q) {
        const E = q._f
        E &&
          (!E.disabled && pe(o, v, ng($, E)),
          (I = ta(E.ref) && tt($) ? '' : $),
          Jm(E.ref)
            ? [...E.ref.options].forEach(
                (H) => (H.selected = I.includes(H.value))
              )
            : E.refs
              ? ps(E.ref)
                ? E.refs.length > 1
                  ? E.refs.forEach(
                      (H) =>
                        (!H.defaultChecked || !H.disabled) &&
                        (H.checked = Array.isArray(I)
                          ? !!I.find((fe) => fe === H.value)
                          : I === H.value)
                    )
                  : E.refs[0] && (E.refs[0].checked = !!I)
                : E.refs.forEach((H) => (H.checked = H.value === I))
              : gf(E.ref)
                ? (E.ref.value = '')
                : ((E.ref.value = I),
                  E.ref.type || p.values.next({ name: v, values: { ...o } })))
      }
      ;(_.shouldDirty || _.shouldTouch) &&
        R(v, I, _.shouldTouch, _.shouldDirty, !0),
        _.shouldValidate && Xe(v)
    },
    J = (v, $, _) => {
      for (const q in $) {
        const I = $[q],
          E = `${v}.${q}`,
          H = N(i, E)
        ;(l.array.has(v) || !ra(I) || (H && !H._f)) && !Er(I)
          ? J(E, I, _)
          : te(E, I, _)
      }
    },
    ae = (v, $, _ = {}) => {
      const q = N(i, v),
        I = l.array.has(v),
        E = Et($)
      pe(o, v, E),
        I
          ? (p.array.next({ name: v, values: { ...o } }),
            (f.isDirty || f.dirtyFields) &&
              _.shouldDirty &&
              p.state.next({
                name: v,
                dirtyFields: Vl(s, o),
                isDirty: Y(v, E)
              }))
          : q && !q._f && !tt(E)
            ? J(v, E, _)
            : te(v, E, _),
        zh(v, l) && p.state.next({ ...r }),
        p.values.next({ name: v, values: { ...o } }),
        !a.mount && e()
    },
    me = async (v) => {
      const $ = v.target
      let _ = $.name,
        q = !0
      const I = N(i, _),
        E = () => ($.type ? Wl(I._f) : Lm(v)),
        H = (fe) => {
          q = Number.isNaN(fe) || fe === N(o, _, fe)
        }
      if (I) {
        let fe, ge
        const wn = E(),
          un = v.type === ea.BLUR || v.type === ea.FOCUS_OUT,
          St =
            (!i1(I._f) && !t.resolver && !N(r.errors, _) && !I._f.deps) ||
            s1(un, N(r.touchedFields, _), r.isSubmitted, g, O),
          wr = zh(_, l, un)
        pe(o, _, wn),
          un
            ? (I._f.onBlur && I._f.onBlur(v), c && c(0))
            : I._f.onChange && I._f.onChange(v)
        const Pr = R(_, wn, un, !1),
          Rl = !Tt(Pr) || wr
        if (
          (!un && p.values.next({ name: _, type: v.type, values: { ...o } }),
          St)
        )
          return (
            f.isValid && w(), Rl && p.state.next({ name: _, ...(wr ? {} : Pr) })
          )
        if ((!un && wr && p.state.next({ ...r }), Q(!0), t.resolver)) {
          const { errors: di } = await D([_])
          if ((H(wn), q)) {
            const Tr = ep(r.errors, i, _),
              Oi = ep(di, i, Tr.name || _)
            ;(fe = Oi.error), (_ = Oi.name), (ge = Tt(di))
          }
        } else
          (fe = (await Jh(I, o, b, t.shouldUseNativeValidation))[_]),
            H(wn),
            q && (fe ? (ge = !1) : f.isValid && (ge = await B(i, !0)))
        q && (I._f.deps && Xe(I._f.deps), V(_, ge, fe, Pr))
      }
    },
    ue = (v, $) => {
      if (N(r.errors, $) && v.focus) return v.focus(), 1
    },
    Xe = async (v, $ = {}) => {
      let _, q
      const I = bo(v)
      if ((Q(!0), t.resolver)) {
        const E = await L($e(v) ? v : I)
        ;(_ = Tt(E)), (q = v ? !I.some((H) => N(E, H)) : _)
      } else
        v
          ? ((q = (
              await Promise.all(
                I.map(async (E) => {
                  const H = N(i, E)
                  return await B(H && H._f ? { [E]: H } : H)
                })
              )
            ).every(Boolean)),
            !(!q && !r.isValid) && w())
          : (q = _ = await B(i))
      return (
        p.state.next({
          ...(!Kt(v) || (f.isValid && _ !== r.isValid) ? {} : { name: v }),
          ...(t.resolver || !v ? { isValid: _ } : {}),
          errors: r.errors,
          isValidating: !1
        }),
        $.shouldFocus && !q && vo(i, ue, v ? I : l.mount),
        q
      )
    },
    et = (v) => {
      const $ = { ...s, ...(a.mount ? o : {}) }
      return $e(v) ? $ : Kt(v) ? N($, v) : v.map((_) => N($, _))
    },
    bt = (v, $) => ({
      invalid: !!N(($ || r).errors, v),
      isDirty: !!N(($ || r).dirtyFields, v),
      isTouched: !!N(($ || r).touchedFields, v),
      error: N(($ || r).errors, v)
    }),
    Nt = (v) => {
      v && bo(v).forEach(($) => Me(r.errors, $)),
        p.state.next({ errors: v ? r.errors : {} })
    },
    oe = (v, $, _) => {
      const q = (N(i, v, { _f: {} })._f || {}).ref
      pe(r.errors, v, { ...$, ref: q }),
        p.state.next({ name: v, errors: r.errors, isValid: !1 }),
        _ && _.shouldFocus && q && q.focus && q.focus()
    },
    Hn = (v, $) =>
      En(v)
        ? p.values.subscribe({ next: (_) => v(W(void 0, $), _) })
        : W(v, $, !0),
    fi = (v, $ = {}) => {
      for (const _ of v ? bo(v) : l.mount)
        l.mount.delete(_),
          l.array.delete(_),
          $.keepValue || (Me(i, _), Me(o, _)),
          !$.keepError && Me(r.errors, _),
          !$.keepDirty && Me(r.dirtyFields, _),
          !$.keepTouched && Me(r.touchedFields, _),
          !t.shouldUnregister && !$.keepDefaultValue && Me(s, _)
      p.values.next({ values: { ...o } }),
        p.state.next({ ...r, ...($.keepDirty ? { isDirty: Y() } : {}) }),
        !$.keepIsValid && w()
    },
    vt = ({ disabled: v, name: $, field: _, fields: q, value: I }) => {
      if (Ft(v)) {
        const E = v ? void 0 : $e(I) ? Wl(_ ? _._f : N(q, $)._f) : I
        pe(o, $, E), R($, E, !1, !1, !0)
      }
    },
    Sr = (v, $ = {}) => {
      let _ = N(i, v)
      const q = Ft($.disabled)
      return (
        pe(i, v, {
          ...(_ || {}),
          _f: {
            ...(_ && _._f ? _._f : { ref: { name: v } }),
            name: v,
            mount: !0,
            ...$
          }
        }),
        l.mount.add(v),
        _ ? vt({ field: _, disabled: $.disabled, name: v }) : k(v, !0, $.value),
        {
          ...(q ? { disabled: $.disabled } : {}),
          ...(t.progressive
            ? {
                required: !!$.required,
                min: Si($.min),
                max: Si($.max),
                minLength: Si($.minLength),
                maxLength: Si($.maxLength),
                pattern: Si($.pattern)
              }
            : {}),
          name: v,
          onChange: me,
          onBlur: me,
          ref: (I) => {
            if (I) {
              Sr(v, $), (_ = N(i, v))
              const E =
                  ($e(I.value) &&
                    I.querySelectorAll &&
                    I.querySelectorAll('input,select,textarea')[0]) ||
                  I,
                H = n1(E),
                fe = _._f.refs || []
              if (H ? fe.find((ge) => ge === E) : E === _._f.ref) return
              pe(i, v, {
                _f: {
                  ..._._f,
                  ...(H
                    ? {
                        refs: [
                          ...fe.filter(Ml),
                          E,
                          ...(Array.isArray(N(s, v)) ? [{}] : [])
                        ],
                        ref: { type: E.type, name: v }
                      }
                    : { ref: E })
                }
              }),
                k(v, !1, void 0, E)
            } else
              (_ = N(i, v, {})),
                _._f && (_._f.mount = !1),
                (t.shouldUnregister || $.shouldUnregister) &&
                  !(Bm(l.array, v) && a.action) &&
                  l.unMount.add(v)
          }
        }
      )
    },
    hi = () => t.shouldFocusError && vo(i, ue, l.mount),
    Rs = (v) => {
      Ft(v) &&
        (p.state.next({ disabled: v }),
        vo(
          i,
          ($) => {
            $.disabled = v
          },
          0,
          !1
        ))
    },
    xr = (v, $) => async (_) => {
      _ && (_.preventDefault && _.preventDefault(), _.persist && _.persist())
      let q = Et(o)
      if ((p.state.next({ isSubmitting: !0 }), t.resolver)) {
        const { errors: I, values: E } = await D()
        ;(r.errors = I), (q = E)
      } else await B(i)
      Me(r.errors, 'root'),
        Tt(r.errors)
          ? (p.state.next({ errors: {} }), await v(q, _))
          : ($ && (await $({ ...r.errors }, _)), hi(), setTimeout(hi)),
        p.state.next({
          isSubmitted: !0,
          isSubmitting: !1,
          isSubmitSuccessful: Tt(r.errors),
          submitCount: r.submitCount + 1,
          errors: r.errors
        })
    },
    Zs = (v, $ = {}) => {
      N(i, v) &&
        ($e($.defaultValue)
          ? ae(v, N(s, v))
          : (ae(v, $.defaultValue), pe(s, v, $.defaultValue)),
        $.keepTouched || Me(r.touchedFields, v),
        $.keepDirty ||
          (Me(r.dirtyFields, v),
          (r.isDirty = $.defaultValue ? Y(v, N(s, v)) : Y())),
        $.keepError || (Me(r.errors, v), f.isValid && w()),
        p.state.next({ ...r }))
    },
    pi = (v, $ = {}) => {
      const _ = v ? Et(v) : s,
        q = Et(_),
        I = v && !Tt(v) ? q : s
      if (($.keepDefaultValues || (s = _), !$.keepValues)) {
        if ($.keepDirtyValues || d)
          for (const E of l.mount)
            N(r.dirtyFields, E) ? pe(I, E, N(o, E)) : ae(E, N(I, E))
        else {
          if (pf && $e(v))
            for (const E of l.mount) {
              const H = N(i, E)
              if (H && H._f) {
                const fe = Array.isArray(H._f.refs) ? H._f.refs[0] : H._f.ref
                if (ta(fe)) {
                  const ge = fe.closest('form')
                  if (ge) {
                    ge.reset()
                    break
                  }
                }
              }
            }
          i = {}
        }
        ;(o = n.shouldUnregister ? ($.keepDefaultValues ? Et(s) : {}) : Et(I)),
          p.array.next({ values: { ...I } }),
          p.values.next({ values: { ...I } })
      }
      ;(l = {
        mount: new Set(),
        unMount: new Set(),
        array: new Set(),
        watch: new Set(),
        watchAll: !1,
        focus: ''
      }),
        !a.mount && e(),
        (a.mount = !f.isValid || !!$.keepIsValid),
        (a.watch = !!n.shouldUnregister),
        p.state.next({
          submitCount: $.keepSubmitCount ? r.submitCount : 0,
          isDirty: $.keepDirty
            ? r.isDirty
            : !!($.keepDefaultValues && !fr(v, s)),
          isSubmitted: $.keepIsSubmitted ? r.isSubmitted : !1,
          dirtyFields: $.keepDirtyValues
            ? r.dirtyFields
            : $.keepDefaultValues && v
              ? Vl(s, v)
              : {},
          touchedFields: $.keepTouched ? r.touchedFields : {},
          errors: $.keepErrors ? r.errors : {},
          isSubmitSuccessful: $.keepIsSubmitSuccessful
            ? r.isSubmitSuccessful
            : !1,
          isSubmitting: !1
        })
    },
    As = (v, $) => pi(En(v) ? v(o) : v, $)
  return {
    control: {
      register: Sr,
      unregister: fi,
      getFieldState: bt,
      handleSubmit: xr,
      setError: oe,
      _executeSchema: D,
      _getWatch: W,
      _getDirty: Y,
      _updateValid: w,
      _removeUnmounted: A,
      _updateFieldArray: T,
      _updateDisabledField: vt,
      _getFieldArray: K,
      _reset: pi,
      _resetDefaultValues: () =>
        En(t.defaultValues) &&
        t.defaultValues().then((v) => {
          As(v, t.resetOptions), p.state.next({ isLoading: !1 })
        }),
      _updateFormState: (v) => {
        r = { ...r, ...v }
      },
      _disableForm: Rs,
      _subjects: p,
      _proxyFormState: f,
      get _fields() {
        return i
      },
      get _formValues() {
        return o
      },
      get _state() {
        return a
      },
      set _state(v) {
        a = v
      },
      get _defaultValues() {
        return s
      },
      get _names() {
        return l
      },
      set _names(v) {
        l = v
      },
      get _formState() {
        return r
      },
      set _formState(v) {
        r = v
      },
      get _options() {
        return t
      },
      set _options(v) {
        t = { ...t, ...v }
      }
    },
    trigger: Xe,
    register: Sr,
    handleSubmit: xr,
    watch: Hn,
    setValue: ae,
    getValues: et,
    reset: As,
    resetField: Zs,
    clearErrors: Nt,
    unregister: fi,
    setError: oe,
    setFocus: (v, $ = {}) => {
      const _ = N(i, v),
        q = _ && _._f
      if (q) {
        const I = q.refs ? q.refs[0] : q.ref
        I.focus && (I.focus(), $.shouldSelect && I.select())
      }
    },
    getFieldState: bt
  }
}
function c1(n = {}) {
  const e = h.React.useRef(),
    t = h.React.useRef(),
    [r, i] = h.React.useState({
      isDirty: !1,
      isValidating: !1,
      isLoading: En(n.defaultValues),
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      submitCount: 0,
      dirtyFields: {},
      touchedFields: {},
      errors: {},
      disabled: !1,
      defaultValues: En(n.defaultValues) ? void 0 : n.defaultValues
    })
  e.current ||
    (e.current = { ...l1(n, () => i((o) => ({ ...o }))), formState: r })
  const s = e.current.control
  return (
    (s._options = n),
    Of({
      subject: s._subjects.state,
      next: (o) => {
        qm(o, s._proxyFormState, s._updateFormState, !0) &&
          i({ ...s._formState })
      }
    }),
    h.React.useEffect(() => s._disableForm(n.disabled), [s, n.disabled]),
    h.React.useEffect(() => {
      if (s._proxyFormState.isDirty) {
        const o = s._getDirty()
        o !== r.isDirty && s._subjects.state.next({ isDirty: o })
      }
    }, [s, r.isDirty]),
    h.React.useEffect(() => {
      n.values && !fr(n.values, t.current)
        ? (s._reset(n.values, s._options.resetOptions), (t.current = n.values))
        : s._resetDefaultValues()
    }, [n.values, s]),
    h.React.useEffect(() => {
      s._state.mount || (s._updateValid(), (s._state.mount = !0)),
        s._state.watch &&
          ((s._state.watch = !1), s._subjects.state.next({ ...s._formState })),
        s._removeUnmounted()
    }),
    (e.current.formState = Um(r, s)),
    e.current
  )
}
var u1 = function (e, t) {
  return function (r, i, s) {
    if (typeof e != 'function')
      return new Error(
        'Invalid react-required-if prop type supplied to ' +
          s +
          '. Validation failed.'
      )
    if (typeof t != 'function')
      return new Error(
        'Invalid react-required-if condition supplied to ' +
          s +
          '. Validation failed.'
      )
    var o = t(r) ? e.isRequired : e
    return o.apply(this, arguments)
  }
}
const f1 = h.getDefaultExportFromCjs(u1)
var rg = function () {}
process.env.NODE_ENV !== 'production' &&
  (rg = function (e, t) {
    Qe(
      e,
      t.assistiveText,
      'assistiveText',
      'The wrapping span and assistive text has been removed from this component in order to make it a more pure "higher-level component" of `UtilityIcon`.'
    )
  })
const h1 = rg
function Vs(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var il = function (e) {
    var t
    return (
      h1(Tm, e),
      h.React.createElement(Ho, {
        'aria-hidden': 'true',
        category: e.category,
        className: se(
          'slds-button__icon',
          ((t = {}),
          Vs(
            t,
            'slds-button__icon_'.concat(e.size),
            e.size && e.size !== 'medium'
          ),
          Vs(t, 'slds-button__icon_inverse-hint', e.inverse && e.hint),
          Vs(t, 'slds-button__icon_hint', e.hint && !e.inverse),
          Vs(t, 'slds-button__icon_'.concat(e.position), e.position),
          t),
          e.className
        ),
        icon: e.icon,
        name: e.name,
        path: e.path
      })
    )
  },
  p1 = {
    category: h.PropTypes.oneOf([
      'action',
      'custom',
      'doctype',
      'standard',
      'utility'
    ]).isRequired,
    hint: h.PropTypes.bool,
    icon: h.PropTypes.object,
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    inverse: h.PropTypes.bool,
    name: h.PropTypes.string,
    path: h.PropTypes.string,
    position: h.PropTypes.oneOf(['left', 'right']),
    size: h.PropTypes.oneOf(['x-small', 'small', 'medium', 'large'])
  },
  d1 = { category: 'utility', size: 'medium' }
il.displayName = Tm
il.propTypes = p1
il.defaultProps = d1
const tp = il
var Mc
if (process.env.NODE_ENV !== 'production') {
  var np = {}
  Mc = function (e, t, r, i) {
    var s = i ? ' '.concat(i) : '',
      o = !1,
      a = Object.keys(r),
      l = a.map(function (f) {
        return r[f]
      }),
      c = l.every(function (f) {
        return !!f
      }),
      u = l.every(function (f) {
        return !f
      })
    ;(o = c || u),
      np[e] ||
        (yr(
          o,
          '[Design System React] If one of the following props are used, then both of the following properties are required by '
            .concat(e, ': [')
            .concat(a.join(), '].')
            .concat(s)
        ),
        (np[e] = !!r))
  }
} else Mc = function () {}
const O1 = Mc
var ig = function () {}
process.env.NODE_ENV !== 'production' &&
  (ig = function (e, t, r) {
    var i = Fn(r)
    O1(
      e,
      t,
      { iconName: t.iconName, iconCategory: t.iconCategory },
      i('iconCategory')
    ),
      typeof t.assistiveText == 'string' &&
        Qe(
          e,
          t.assistiveText,
          'assistiveText',
          '`assistiveText` as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use `assistiveText.icon` instead. '.concat(
            i('assistiveText')
          )
        )
  })
const m1 = ig,
  g1 = 'button',
  y1 = 'prod',
  b1 = 'Button',
  v1 = {
    component: g1,
    status: y1,
    'display-name': 'Buttons',
    classKey: b1,
    'last-accessibility-review': {
      'date-iso-8601': '2018/01/18',
      'commit-sha': 'ad6b6c6523ee21cada11be5f7ea4d99abc530726'
    },
    'SLDS-component-path': '/components/buttons',
    'site-stories': [
      { heading: 'Base Neutral', path: '/__examples__/base-neutral.jsx' },
      {
        heading: 'Variants',
        path: '/__examples__/brand-disabled-destructive-inverse.jsx'
      },
      { heading: 'Button Icons', path: '/__examples__/button-icons.jsx' }
    ],
    'url-slug': 'buttons'
  }
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ var Os =
    typeof window < 'u' && typeof document < 'u' && typeof navigator < 'u',
  S1 = (function () {
    for (var n = ['Edge', 'Trident', 'Firefox'], e = 0; e < n.length; e += 1)
      if (Os && navigator.userAgent.indexOf(n[e]) >= 0) return 1
    return 0
  })()
function x1(n) {
  var e = !1
  return function () {
    e ||
      ((e = !0),
      window.Promise.resolve().then(function () {
        ;(e = !1), n()
      }))
  }
}
function w1(n) {
  var e = !1
  return function () {
    e ||
      ((e = !0),
      setTimeout(function () {
        ;(e = !1), n()
      }, S1))
  }
}
var P1 = Os && window.Promise,
  T1 = P1 ? x1 : w1
function sg(n) {
  var e = {}
  return n && e.toString.call(n) === '[object Function]'
}
function br(n, e) {
  if (n.nodeType !== 1) return []
  var t = n.ownerDocument.defaultView,
    r = t.getComputedStyle(n, null)
  return e ? r[e] : r
}
function bf(n) {
  return n.nodeName === 'HTML' ? n : n.parentNode || n.host
}
function ms(n) {
  if (!n) return document.body
  switch (n.nodeName) {
    case 'HTML':
    case 'BODY':
      return n.ownerDocument.body
    case '#document':
      return n.body
  }
  var e = br(n),
    t = e.overflow,
    r = e.overflowX,
    i = e.overflowY
  return /(auto|scroll|overlay)/.test(t + i + r) ? n : ms(bf(n))
}
function og(n) {
  return n && n.referenceNode ? n.referenceNode : n
}
var rp = Os && !!(window.MSInputMethodContext && document.documentMode),
  ip = Os && /MSIE 10/.test(navigator.userAgent)
function si(n) {
  return n === 11 ? rp : n === 10 ? ip : rp || ip
}
function qr(n) {
  if (!n) return document.documentElement
  for (
    var e = si(10) ? document.body : null, t = n.offsetParent || null;
    t === e && n.nextElementSibling;

  )
    t = (n = n.nextElementSibling).offsetParent
  var r = t && t.nodeName
  return !r || r === 'BODY' || r === 'HTML'
    ? n
      ? n.ownerDocument.documentElement
      : document.documentElement
    : ['TH', 'TD', 'TABLE'].indexOf(t.nodeName) !== -1 &&
        br(t, 'position') === 'static'
      ? qr(t)
      : t
}
function $1(n) {
  var e = n.nodeName
  return e === 'BODY' ? !1 : e === 'HTML' || qr(n.firstElementChild) === n
}
function Vc(n) {
  return n.parentNode !== null ? Vc(n.parentNode) : n
}
function sa(n, e) {
  if (!n || !n.nodeType || !e || !e.nodeType) return document.documentElement
  var t = n.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING,
    r = t ? n : e,
    i = t ? e : n,
    s = document.createRange()
  s.setStart(r, 0), s.setEnd(i, 0)
  var o = s.commonAncestorContainer
  if ((n !== o && e !== o) || r.contains(i)) return $1(o) ? o : qr(o)
  var a = Vc(n)
  return a.host ? sa(a.host, e) : sa(n, Vc(e).host)
}
function zr(n) {
  var e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'top',
    t = e === 'top' ? 'scrollTop' : 'scrollLeft',
    r = n.nodeName
  if (r === 'BODY' || r === 'HTML') {
    var i = n.ownerDocument.documentElement,
      s = n.ownerDocument.scrollingElement || i
    return s[t]
  }
  return n[t]
}
function Q1(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = zr(e, 'top'),
    i = zr(e, 'left'),
    s = t ? -1 : 1
  return (
    (n.top += r * s),
    (n.bottom += r * s),
    (n.left += i * s),
    (n.right += i * s),
    n
  )
}
function sp(n, e) {
  var t = e === 'x' ? 'Left' : 'Top',
    r = t === 'Left' ? 'Right' : 'Bottom'
  return (
    parseFloat(n['border' + t + 'Width']) +
    parseFloat(n['border' + r + 'Width'])
  )
}
function op(n, e, t, r) {
  return Math.max(
    e['offset' + n],
    e['scroll' + n],
    t['client' + n],
    t['offset' + n],
    t['scroll' + n],
    si(10)
      ? parseInt(t['offset' + n]) +
          parseInt(r['margin' + (n === 'Height' ? 'Top' : 'Left')]) +
          parseInt(r['margin' + (n === 'Height' ? 'Bottom' : 'Right')])
      : 0
  )
}
function ag(n) {
  var e = n.body,
    t = n.documentElement,
    r = si(10) && getComputedStyle(t)
  return { height: op('Height', e, t, r), width: op('Width', e, t, r) }
}
var k1 = function (n, e) {
    if (!(n instanceof e))
      throw new TypeError('Cannot call a class as a function')
  },
  C1 = (function () {
    function n(e, t) {
      for (var r = 0; r < t.length; r++) {
        var i = t[r]
        ;(i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          'value' in i && (i.writable = !0),
          Object.defineProperty(e, i.key, i)
      }
    }
    return function (e, t, r) {
      return t && n(e.prototype, t), r && n(e, r), e
    }
  })(),
  Fr = function (n, e, t) {
    return (
      e in n
        ? Object.defineProperty(n, e, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
          })
        : (n[e] = t),
      n
    )
  },
  Qt =
    Object.assign ||
    function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e]
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
      }
      return n
    }
function Vn(n) {
  return Qt({}, n, { right: n.left + n.width, bottom: n.top + n.height })
}
function Wc(n) {
  var e = {}
  try {
    if (si(10)) {
      e = n.getBoundingClientRect()
      var t = zr(n, 'top'),
        r = zr(n, 'left')
      ;(e.top += t), (e.left += r), (e.bottom += t), (e.right += r)
    } else e = n.getBoundingClientRect()
  } catch {}
  var i = {
      left: e.left,
      top: e.top,
      width: e.right - e.left,
      height: e.bottom - e.top
    },
    s = n.nodeName === 'HTML' ? ag(n.ownerDocument) : {},
    o = s.width || n.clientWidth || i.width,
    a = s.height || n.clientHeight || i.height,
    l = n.offsetWidth - o,
    c = n.offsetHeight - a
  if (l || c) {
    var u = br(n)
    ;(l -= sp(u, 'x')), (c -= sp(u, 'y')), (i.width -= l), (i.height -= c)
  }
  return Vn(i)
}
function vf(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = si(10),
    i = e.nodeName === 'HTML',
    s = Wc(n),
    o = Wc(e),
    a = ms(n),
    l = br(e),
    c = parseFloat(l.borderTopWidth),
    u = parseFloat(l.borderLeftWidth)
  t && i && ((o.top = Math.max(o.top, 0)), (o.left = Math.max(o.left, 0)))
  var f = Vn({
    top: s.top - o.top - c,
    left: s.left - o.left - u,
    width: s.width,
    height: s.height
  })
  if (((f.marginTop = 0), (f.marginLeft = 0), !r && i)) {
    var p = parseFloat(l.marginTop),
      d = parseFloat(l.marginLeft)
    ;(f.top -= c - p),
      (f.bottom -= c - p),
      (f.left -= u - d),
      (f.right -= u - d),
      (f.marginTop = p),
      (f.marginLeft = d)
  }
  return (
    (r && !t ? e.contains(a) : e === a && a.nodeName !== 'BODY') &&
      (f = Q1(f, e)),
    f
  )
}
function _1(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t = n.ownerDocument.documentElement,
    r = vf(n, t),
    i = Math.max(t.clientWidth, window.innerWidth || 0),
    s = Math.max(t.clientHeight, window.innerHeight || 0),
    o = e ? 0 : zr(t),
    a = e ? 0 : zr(t, 'left'),
    l = {
      top: o - r.top + r.marginTop,
      left: a - r.left + r.marginLeft,
      width: i,
      height: s
    }
  return Vn(l)
}
function lg(n) {
  var e = n.nodeName
  if (e === 'BODY' || e === 'HTML') return !1
  if (br(n, 'position') === 'fixed') return !0
  var t = bf(n)
  return t ? lg(t) : !1
}
function cg(n) {
  if (!n || !n.parentElement || si()) return document.documentElement
  for (var e = n.parentElement; e && br(e, 'transform') === 'none'; )
    e = e.parentElement
  return e || document.documentElement
}
function Sf(n, e, t, r) {
  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1,
    s = { top: 0, left: 0 },
    o = i ? cg(n) : sa(n, og(e))
  if (r === 'viewport') s = _1(o, i)
  else {
    var a = void 0
    r === 'scrollParent'
      ? ((a = ms(bf(e))),
        a.nodeName === 'BODY' && (a = n.ownerDocument.documentElement))
      : r === 'window'
        ? (a = n.ownerDocument.documentElement)
        : (a = r)
    var l = vf(a, o, i)
    if (a.nodeName === 'HTML' && !lg(o)) {
      var c = ag(n.ownerDocument),
        u = c.height,
        f = c.width
      ;(s.top += l.top - l.marginTop),
        (s.bottom = u + l.top),
        (s.left += l.left - l.marginLeft),
        (s.right = f + l.left)
    } else s = l
  }
  t = t || 0
  var p = typeof t == 'number'
  return (
    (s.left += p ? t : t.left || 0),
    (s.top += p ? t : t.top || 0),
    (s.right -= p ? t : t.right || 0),
    (s.bottom -= p ? t : t.bottom || 0),
    s
  )
}
function R1(n) {
  var e = n.width,
    t = n.height
  return e * t
}
function ug(n, e, t, r, i) {
  var s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0
  if (n.indexOf('auto') === -1) return n
  var o = Sf(t, r, s, i),
    a = {
      top: { width: o.width, height: e.top - o.top },
      right: { width: o.right - e.right, height: o.height },
      bottom: { width: o.width, height: o.bottom - e.bottom },
      left: { width: e.left - o.left, height: o.height }
    },
    l = Object.keys(a)
      .map(function (p) {
        return Qt({ key: p }, a[p], { area: R1(a[p]) })
      })
      .sort(function (p, d) {
        return d.area - p.area
      }),
    c = l.filter(function (p) {
      var d = p.width,
        O = p.height
      return d >= t.clientWidth && O >= t.clientHeight
    }),
    u = c.length > 0 ? c[0].key : l[0].key,
    f = n.split('-')[1]
  return u + (f ? '-' + f : '')
}
function fg(n, e, t) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null,
    i = r ? cg(e) : sa(e, og(t))
  return vf(t, i, r)
}
function hg(n) {
  var e = n.ownerDocument.defaultView,
    t = e.getComputedStyle(n),
    r = parseFloat(t.marginTop || 0) + parseFloat(t.marginBottom || 0),
    i = parseFloat(t.marginLeft || 0) + parseFloat(t.marginRight || 0),
    s = { width: n.offsetWidth + i, height: n.offsetHeight + r }
  return s
}
function oa(n) {
  var e = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
  return n.replace(/left|right|bottom|top/g, function (t) {
    return e[t]
  })
}
function pg(n, e, t) {
  t = t.split('-')[0]
  var r = hg(n),
    i = { width: r.width, height: r.height },
    s = ['right', 'left'].indexOf(t) !== -1,
    o = s ? 'top' : 'left',
    a = s ? 'left' : 'top',
    l = s ? 'height' : 'width',
    c = s ? 'width' : 'height'
  return (
    (i[o] = e[o] + e[l] / 2 - r[l] / 2),
    t === a ? (i[a] = e[a] - r[c]) : (i[a] = e[oa(a)]),
    i
  )
}
function gs(n, e) {
  return Array.prototype.find ? n.find(e) : n.filter(e)[0]
}
function Z1(n, e, t) {
  if (Array.prototype.findIndex)
    return n.findIndex(function (i) {
      return i[e] === t
    })
  var r = gs(n, function (i) {
    return i[e] === t
  })
  return n.indexOf(r)
}
function dg(n, e, t) {
  var r = t === void 0 ? n : n.slice(0, Z1(n, 'name', t))
  return (
    r.forEach(function (i) {
      i.function &&
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!')
      var s = i.function || i.fn
      i.enabled &&
        sg(s) &&
        ((e.offsets.popper = Vn(e.offsets.popper)),
        (e.offsets.reference = Vn(e.offsets.reference)),
        (e = s(e, i)))
    }),
    e
  )
}
function A1() {
  if (!this.state.isDestroyed) {
    var n = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: !1,
      offsets: {}
    }
    ;(n.offsets.reference = fg(
      this.state,
      this.popper,
      this.reference,
      this.options.positionFixed
    )),
      (n.placement = ug(
        this.options.placement,
        n.offsets.reference,
        this.popper,
        this.reference,
        this.options.modifiers.flip.boundariesElement,
        this.options.modifiers.flip.padding
      )),
      (n.originalPlacement = n.placement),
      (n.positionFixed = this.options.positionFixed),
      (n.offsets.popper = pg(this.popper, n.offsets.reference, n.placement)),
      (n.offsets.popper.position = this.options.positionFixed
        ? 'fixed'
        : 'absolute'),
      (n = dg(this.modifiers, n)),
      this.state.isCreated
        ? this.options.onUpdate(n)
        : ((this.state.isCreated = !0), this.options.onCreate(n))
  }
}
function Og(n, e) {
  return n.some(function (t) {
    var r = t.name,
      i = t.enabled
    return i && r === e
  })
}
function xf(n) {
  for (
    var e = [!1, 'ms', 'Webkit', 'Moz', 'O'],
      t = n.charAt(0).toUpperCase() + n.slice(1),
      r = 0;
    r < e.length;
    r++
  ) {
    var i = e[r],
      s = i ? '' + i + t : n
    if (typeof document.body.style[s] < 'u') return s
  }
  return null
}
function E1() {
  return (
    (this.state.isDestroyed = !0),
    Og(this.modifiers, 'applyStyle') &&
      (this.popper.removeAttribute('x-placement'),
      (this.popper.style.position = ''),
      (this.popper.style.top = ''),
      (this.popper.style.left = ''),
      (this.popper.style.right = ''),
      (this.popper.style.bottom = ''),
      (this.popper.style.willChange = ''),
      (this.popper.style[xf('transform')] = '')),
    this.disableEventListeners(),
    this.options.removeOnDestroy &&
      this.popper.parentNode.removeChild(this.popper),
    this
  )
}
function mg(n) {
  var e = n.ownerDocument
  return e ? e.defaultView : window
}
function gg(n, e, t, r) {
  var i = n.nodeName === 'BODY',
    s = i ? n.ownerDocument.defaultView : n
  s.addEventListener(e, t, { passive: !0 }),
    i || gg(ms(s.parentNode), e, t, r),
    r.push(s)
}
function D1(n, e, t, r) {
  ;(t.updateBound = r),
    mg(n).addEventListener('resize', t.updateBound, { passive: !0 })
  var i = ms(n)
  return (
    gg(i, 'scroll', t.updateBound, t.scrollParents),
    (t.scrollElement = i),
    (t.eventsEnabled = !0),
    t
  )
}
function X1() {
  this.state.eventsEnabled ||
    (this.state = D1(
      this.reference,
      this.options,
      this.state,
      this.scheduleUpdate
    ))
}
function Y1(n, e) {
  return (
    mg(n).removeEventListener('resize', e.updateBound),
    e.scrollParents.forEach(function (t) {
      t.removeEventListener('scroll', e.updateBound)
    }),
    (e.updateBound = null),
    (e.scrollParents = []),
    (e.scrollElement = null),
    (e.eventsEnabled = !1),
    e
  )
}
function I1() {
  this.state.eventsEnabled &&
    (cancelAnimationFrame(this.scheduleUpdate),
    (this.state = Y1(this.reference, this.state)))
}
function wf(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n)
}
function Lc(n, e) {
  Object.keys(e).forEach(function (t) {
    var r = ''
    ;['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(t) !== -1 &&
      wf(e[t]) &&
      (r = 'px'),
      (n.style[t] = e[t] + r)
  })
}
function j1(n, e) {
  Object.keys(e).forEach(function (t) {
    var r = e[t]
    r !== !1 ? n.setAttribute(t, e[t]) : n.removeAttribute(t)
  })
}
function N1(n) {
  return (
    Lc(n.instance.popper, n.styles),
    j1(n.instance.popper, n.attributes),
    n.arrowElement &&
      Object.keys(n.arrowStyles).length &&
      Lc(n.arrowElement, n.arrowStyles),
    n
  )
}
function M1(n, e, t, r, i) {
  var s = fg(i, e, n, t.positionFixed),
    o = ug(
      t.placement,
      s,
      e,
      n,
      t.modifiers.flip.boundariesElement,
      t.modifiers.flip.padding
    )
  return (
    e.setAttribute('x-placement', o),
    Lc(e, { position: t.positionFixed ? 'fixed' : 'absolute' }),
    t
  )
}
function V1(n, e) {
  var t = n.offsets,
    r = t.popper,
    i = t.reference,
    s = Math.round,
    o = Math.floor,
    a = function (x) {
      return x
    },
    l = s(i.width),
    c = s(r.width),
    u = ['left', 'right'].indexOf(n.placement) !== -1,
    f = n.placement.indexOf('-') !== -1,
    p = l % 2 === c % 2,
    d = l % 2 === 1 && c % 2 === 1,
    O = e ? (u || f || p ? s : o) : a,
    g = e ? s : a
  return {
    left: O(d && !f && e ? r.left - 1 : r.left),
    top: g(r.top),
    bottom: g(r.bottom),
    right: O(r.right)
  }
}
var W1 = Os && /Firefox/i.test(navigator.userAgent)
function L1(n, e) {
  var t = e.x,
    r = e.y,
    i = n.offsets.popper,
    s = gs(n.instance.modifiers, function (Q) {
      return Q.name === 'applyStyle'
    }).gpuAcceleration
  s !== void 0 &&
    console.warn(
      'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'
    )
  var o = s !== void 0 ? s : e.gpuAcceleration,
    a = qr(n.instance.popper),
    l = Wc(a),
    c = { position: i.position },
    u = V1(n, window.devicePixelRatio < 2 || !W1),
    f = t === 'bottom' ? 'top' : 'bottom',
    p = r === 'right' ? 'left' : 'right',
    d = xf('transform'),
    O = void 0,
    g = void 0
  if (
    (f === 'bottom'
      ? a.nodeName === 'HTML'
        ? (g = -a.clientHeight + u.bottom)
        : (g = -l.height + u.bottom)
      : (g = u.top),
    p === 'right'
      ? a.nodeName === 'HTML'
        ? (O = -a.clientWidth + u.right)
        : (O = -l.width + u.right)
      : (O = u.left),
    o && d)
  )
    (c[d] = 'translate3d(' + O + 'px, ' + g + 'px, 0)'),
      (c[f] = 0),
      (c[p] = 0),
      (c.willChange = 'transform')
  else {
    var b = f === 'bottom' ? -1 : 1,
      x = p === 'right' ? -1 : 1
    ;(c[f] = g * b), (c[p] = O * x), (c.willChange = f + ', ' + p)
  }
  var w = { 'x-placement': n.placement }
  return (
    (n.attributes = Qt({}, w, n.attributes)),
    (n.styles = Qt({}, c, n.styles)),
    (n.arrowStyles = Qt({}, n.offsets.arrow, n.arrowStyles)),
    n
  )
}
function yg(n, e, t) {
  var r = gs(n, function (a) {
      var l = a.name
      return l === e
    }),
    i =
      !!r &&
      n.some(function (a) {
        return a.name === t && a.enabled && a.order < r.order
      })
  if (!i) {
    var s = '`' + e + '`',
      o = '`' + t + '`'
    console.warn(
      o +
        ' modifier is required by ' +
        s +
        ' modifier in order to work, be sure to include it before ' +
        s +
        '!'
    )
  }
  return i
}
function B1(n, e) {
  var t
  if (!yg(n.instance.modifiers, 'arrow', 'keepTogether')) return n
  var r = e.element
  if (typeof r == 'string') {
    if (((r = n.instance.popper.querySelector(r)), !r)) return n
  } else if (!n.instance.popper.contains(r))
    return (
      console.warn(
        'WARNING: `arrow.element` must be child of its popper element!'
      ),
      n
    )
  var i = n.placement.split('-')[0],
    s = n.offsets,
    o = s.popper,
    a = s.reference,
    l = ['left', 'right'].indexOf(i) !== -1,
    c = l ? 'height' : 'width',
    u = l ? 'Top' : 'Left',
    f = u.toLowerCase(),
    p = l ? 'left' : 'top',
    d = l ? 'bottom' : 'right',
    O = hg(r)[c]
  a[d] - O < o[f] && (n.offsets.popper[f] -= o[f] - (a[d] - O)),
    a[f] + O > o[d] && (n.offsets.popper[f] += a[f] + O - o[d]),
    (n.offsets.popper = Vn(n.offsets.popper))
  var g = a[f] + a[c] / 2 - O / 2,
    b = br(n.instance.popper),
    x = parseFloat(b['margin' + u]),
    w = parseFloat(b['border' + u + 'Width']),
    Q = g - n.offsets.popper[f] - x - w
  return (
    (Q = Math.max(Math.min(o[c] - O, Q), 0)),
    (n.arrowElement = r),
    (n.offsets.arrow = ((t = {}), Fr(t, f, Math.round(Q)), Fr(t, p, ''), t)),
    n
  )
}
function U1(n) {
  return n === 'end' ? 'start' : n === 'start' ? 'end' : n
}
var bg = [
    'auto-start',
    'auto',
    'auto-end',
    'top-start',
    'top',
    'top-end',
    'right-start',
    'right',
    'right-end',
    'bottom-end',
    'bottom',
    'bottom-start',
    'left-end',
    'left',
    'left-start'
  ],
  Ll = bg.slice(3)
function ap(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t = Ll.indexOf(n),
    r = Ll.slice(t + 1).concat(Ll.slice(0, t))
  return e ? r.reverse() : r
}
var Bl = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
}
function q1(n, e) {
  if (
    Og(n.instance.modifiers, 'inner') ||
    (n.flipped && n.placement === n.originalPlacement)
  )
    return n
  var t = Sf(
      n.instance.popper,
      n.instance.reference,
      e.padding,
      e.boundariesElement,
      n.positionFixed
    ),
    r = n.placement.split('-')[0],
    i = oa(r),
    s = n.placement.split('-')[1] || '',
    o = []
  switch (e.behavior) {
    case Bl.FLIP:
      o = [r, i]
      break
    case Bl.CLOCKWISE:
      o = ap(r)
      break
    case Bl.COUNTERCLOCKWISE:
      o = ap(r, !0)
      break
    default:
      o = e.behavior
  }
  return (
    o.forEach(function (a, l) {
      if (r !== a || o.length === l + 1) return n
      ;(r = n.placement.split('-')[0]), (i = oa(r))
      var c = n.offsets.popper,
        u = n.offsets.reference,
        f = Math.floor,
        p =
          (r === 'left' && f(c.right) > f(u.left)) ||
          (r === 'right' && f(c.left) < f(u.right)) ||
          (r === 'top' && f(c.bottom) > f(u.top)) ||
          (r === 'bottom' && f(c.top) < f(u.bottom)),
        d = f(c.left) < f(t.left),
        O = f(c.right) > f(t.right),
        g = f(c.top) < f(t.top),
        b = f(c.bottom) > f(t.bottom),
        x =
          (r === 'left' && d) ||
          (r === 'right' && O) ||
          (r === 'top' && g) ||
          (r === 'bottom' && b),
        w = ['top', 'bottom'].indexOf(r) !== -1,
        Q =
          !!e.flipVariations &&
          ((w && s === 'start' && d) ||
            (w && s === 'end' && O) ||
            (!w && s === 'start' && g) ||
            (!w && s === 'end' && b)),
        T =
          !!e.flipVariationsByContent &&
          ((w && s === 'start' && O) ||
            (w && s === 'end' && d) ||
            (!w && s === 'start' && b) ||
            (!w && s === 'end' && g)),
        P = Q || T
      ;(p || x || P) &&
        ((n.flipped = !0),
        (p || x) && (r = o[l + 1]),
        P && (s = U1(s)),
        (n.placement = r + (s ? '-' + s : '')),
        (n.offsets.popper = Qt(
          {},
          n.offsets.popper,
          pg(n.instance.popper, n.offsets.reference, n.placement)
        )),
        (n = dg(n.instance.modifiers, n, 'flip')))
    }),
    n
  )
}
function z1(n) {
  var e = n.offsets,
    t = e.popper,
    r = e.reference,
    i = n.placement.split('-')[0],
    s = Math.floor,
    o = ['top', 'bottom'].indexOf(i) !== -1,
    a = o ? 'right' : 'bottom',
    l = o ? 'left' : 'top',
    c = o ? 'width' : 'height'
  return (
    t[a] < s(r[l]) && (n.offsets.popper[l] = s(r[l]) - t[c]),
    t[l] > s(r[a]) && (n.offsets.popper[l] = s(r[a])),
    n
  )
}
function F1(n, e, t, r) {
  var i = n.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
    s = +i[1],
    o = i[2]
  if (!s) return n
  if (o.indexOf('%') === 0) {
    var a = void 0
    switch (o) {
      case '%p':
        a = t
        break
      case '%':
      case '%r':
      default:
        a = r
    }
    var l = Vn(a)
    return (l[e] / 100) * s
  } else if (o === 'vh' || o === 'vw') {
    var c = void 0
    return (
      o === 'vh'
        ? (c = Math.max(
            document.documentElement.clientHeight,
            window.innerHeight || 0
          ))
        : (c = Math.max(
            document.documentElement.clientWidth,
            window.innerWidth || 0
          )),
      (c / 100) * s
    )
  } else return s
}
function G1(n, e, t, r) {
  var i = [0, 0],
    s = ['right', 'left'].indexOf(r) !== -1,
    o = n.split(/(\+|\-)/).map(function (u) {
      return u.trim()
    }),
    a = o.indexOf(
      gs(o, function (u) {
        return u.search(/,|\s/) !== -1
      })
    )
  o[a] &&
    o[a].indexOf(',') === -1 &&
    console.warn(
      'Offsets separated by white space(s) are deprecated, use a comma (,) instead.'
    )
  var l = /\s*,\s*|\s+/,
    c =
      a !== -1
        ? [
            o.slice(0, a).concat([o[a].split(l)[0]]),
            [o[a].split(l)[1]].concat(o.slice(a + 1))
          ]
        : [o]
  return (
    (c = c.map(function (u, f) {
      var p = (f === 1 ? !s : s) ? 'height' : 'width',
        d = !1
      return u
        .reduce(function (O, g) {
          return O[O.length - 1] === '' && ['+', '-'].indexOf(g) !== -1
            ? ((O[O.length - 1] = g), (d = !0), O)
            : d
              ? ((O[O.length - 1] += g), (d = !1), O)
              : O.concat(g)
        }, [])
        .map(function (O) {
          return F1(O, p, e, t)
        })
    })),
    c.forEach(function (u, f) {
      u.forEach(function (p, d) {
        wf(p) && (i[f] += p * (u[d - 1] === '-' ? -1 : 1))
      })
    }),
    i
  )
}
function H1(n, e) {
  var t = e.offset,
    r = n.placement,
    i = n.offsets,
    s = i.popper,
    o = i.reference,
    a = r.split('-')[0],
    l = void 0
  return (
    wf(+t) ? (l = [+t, 0]) : (l = G1(t, s, o, a)),
    a === 'left'
      ? ((s.top += l[0]), (s.left -= l[1]))
      : a === 'right'
        ? ((s.top += l[0]), (s.left += l[1]))
        : a === 'top'
          ? ((s.left += l[0]), (s.top -= l[1]))
          : a === 'bottom' && ((s.left += l[0]), (s.top += l[1])),
    (n.popper = s),
    n
  )
}
function K1(n, e) {
  var t = e.boundariesElement || qr(n.instance.popper)
  n.instance.reference === t && (t = qr(t))
  var r = xf('transform'),
    i = n.instance.popper.style,
    s = i.top,
    o = i.left,
    a = i[r]
  ;(i.top = ''), (i.left = ''), (i[r] = '')
  var l = Sf(
    n.instance.popper,
    n.instance.reference,
    e.padding,
    t,
    n.positionFixed
  )
  ;(i.top = s), (i.left = o), (i[r] = a), (e.boundaries = l)
  var c = e.priority,
    u = n.offsets.popper,
    f = {
      primary: function (d) {
        var O = u[d]
        return (
          u[d] < l[d] && !e.escapeWithReference && (O = Math.max(u[d], l[d])),
          Fr({}, d, O)
        )
      },
      secondary: function (d) {
        var O = d === 'right' ? 'left' : 'top',
          g = u[O]
        return (
          u[d] > l[d] &&
            !e.escapeWithReference &&
            (g = Math.min(u[O], l[d] - (d === 'right' ? u.width : u.height))),
          Fr({}, O, g)
        )
      }
    }
  return (
    c.forEach(function (p) {
      var d = ['left', 'top'].indexOf(p) !== -1 ? 'primary' : 'secondary'
      u = Qt({}, u, f[d](p))
    }),
    (n.offsets.popper = u),
    n
  )
}
function J1(n) {
  var e = n.placement,
    t = e.split('-')[0],
    r = e.split('-')[1]
  if (r) {
    var i = n.offsets,
      s = i.reference,
      o = i.popper,
      a = ['bottom', 'top'].indexOf(t) !== -1,
      l = a ? 'left' : 'top',
      c = a ? 'width' : 'height',
      u = { start: Fr({}, l, s[l]), end: Fr({}, l, s[l] + s[c] - o[c]) }
    n.offsets.popper = Qt({}, o, u[r])
  }
  return n
}
function eP(n) {
  if (!yg(n.instance.modifiers, 'hide', 'preventOverflow')) return n
  var e = n.offsets.reference,
    t = gs(n.instance.modifiers, function (r) {
      return r.name === 'preventOverflow'
    }).boundaries
  if (
    e.bottom < t.top ||
    e.left > t.right ||
    e.top > t.bottom ||
    e.right < t.left
  ) {
    if (n.hide === !0) return n
    ;(n.hide = !0), (n.attributes['x-out-of-boundaries'] = '')
  } else {
    if (n.hide === !1) return n
    ;(n.hide = !1), (n.attributes['x-out-of-boundaries'] = !1)
  }
  return n
}
function tP(n) {
  var e = n.placement,
    t = e.split('-')[0],
    r = n.offsets,
    i = r.popper,
    s = r.reference,
    o = ['left', 'right'].indexOf(t) !== -1,
    a = ['top', 'left'].indexOf(t) === -1
  return (
    (i[o ? 'left' : 'top'] = s[t] - (a ? i[o ? 'width' : 'height'] : 0)),
    (n.placement = oa(e)),
    (n.offsets.popper = Vn(i)),
    n
  )
}
var nP = {
    shift: { order: 100, enabled: !0, fn: J1 },
    offset: { order: 200, enabled: !0, fn: H1, offset: 0 },
    preventOverflow: {
      order: 300,
      enabled: !0,
      fn: K1,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: { order: 400, enabled: !0, fn: z1 },
    arrow: { order: 500, enabled: !0, fn: B1, element: '[x-arrow]' },
    flip: {
      order: 600,
      enabled: !0,
      fn: q1,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: !1,
      flipVariationsByContent: !1
    },
    inner: { order: 700, enabled: !1, fn: tP },
    hide: { order: 800, enabled: !0, fn: eP },
    computeStyle: {
      order: 850,
      enabled: !0,
      fn: L1,
      gpuAcceleration: !0,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: !0,
      fn: N1,
      onLoad: M1,
      gpuAcceleration: void 0
    }
  },
  rP = {
    placement: 'bottom',
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate: function () {},
    onUpdate: function () {},
    modifiers: nP
  },
  sl = (function () {
    function n(e, t) {
      var r = this,
        i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      k1(this, n),
        (this.scheduleUpdate = function () {
          return requestAnimationFrame(r.update)
        }),
        (this.update = T1(this.update.bind(this))),
        (this.options = Qt({}, n.Defaults, i)),
        (this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }),
        (this.reference = e && e.jquery ? e[0] : e),
        (this.popper = t && t.jquery ? t[0] : t),
        (this.options.modifiers = {}),
        Object.keys(Qt({}, n.Defaults.modifiers, i.modifiers)).forEach(
          function (o) {
            r.options.modifiers[o] = Qt(
              {},
              n.Defaults.modifiers[o] || {},
              i.modifiers ? i.modifiers[o] : {}
            )
          }
        ),
        (this.modifiers = Object.keys(this.options.modifiers)
          .map(function (o) {
            return Qt({ name: o }, r.options.modifiers[o])
          })
          .sort(function (o, a) {
            return o.order - a.order
          })),
        this.modifiers.forEach(function (o) {
          o.enabled &&
            sg(o.onLoad) &&
            o.onLoad(r.reference, r.popper, r.options, o, r.state)
        }),
        this.update()
      var s = this.options.eventsEnabled
      s && this.enableEventListeners(), (this.state.eventsEnabled = s)
    }
    return (
      C1(n, [
        {
          key: 'update',
          value: function () {
            return A1.call(this)
          }
        },
        {
          key: 'destroy',
          value: function () {
            return E1.call(this)
          }
        },
        {
          key: 'enableEventListeners',
          value: function () {
            return X1.call(this)
          }
        },
        {
          key: 'disableEventListeners',
          value: function () {
            return I1.call(this)
          }
        }
      ]),
      n
    )
  })()
sl.Utils = (typeof window < 'u' ? window : global).PopperUtils
sl.placements = bg
sl.Defaults = rP
const iP = sl
var aa = { exports: {} }
aa.exports
;(function (n, e) {
  var t = 200,
    r = '__lodash_hash_undefined__',
    i = 1,
    s = 2,
    o = 9007199254740991,
    a = '[object Arguments]',
    l = '[object Array]',
    c = '[object AsyncFunction]',
    u = '[object Boolean]',
    f = '[object Date]',
    p = '[object Error]',
    d = '[object Function]',
    O = '[object GeneratorFunction]',
    g = '[object Map]',
    b = '[object Number]',
    x = '[object Null]',
    w = '[object Object]',
    Q = '[object Promise]',
    T = '[object Proxy]',
    P = '[object RegExp]',
    k = '[object Set]',
    R = '[object String]',
    V = '[object Symbol]',
    D = '[object Undefined]',
    L = '[object WeakMap]',
    B = '[object ArrayBuffer]',
    A = '[object DataView]',
    Y = '[object Float32Array]',
    W = '[object Float64Array]',
    K = '[object Int8Array]',
    te = '[object Int16Array]',
    J = '[object Int32Array]',
    ae = '[object Uint8Array]',
    me = '[object Uint8ClampedArray]',
    ue = '[object Uint16Array]',
    Xe = '[object Uint32Array]',
    et = /[\\^$.*+?()[\]{}|]/g,
    bt = /^\[object .+?Constructor\]$/,
    Nt = /^(?:0|[1-9]\d*)$/,
    oe = {}
  ;(oe[Y] =
    oe[W] =
    oe[K] =
    oe[te] =
    oe[J] =
    oe[ae] =
    oe[me] =
    oe[ue] =
    oe[Xe] =
      !0),
    (oe[a] =
      oe[l] =
      oe[B] =
      oe[u] =
      oe[A] =
      oe[f] =
      oe[p] =
      oe[d] =
      oe[g] =
      oe[b] =
      oe[w] =
      oe[P] =
      oe[k] =
      oe[R] =
      oe[L] =
        !1)
  var Hn =
      typeof h.commonjsGlobal == 'object' &&
      h.commonjsGlobal &&
      h.commonjsGlobal.Object === Object &&
      h.commonjsGlobal,
    fi = typeof self == 'object' && self && self.Object === Object && self,
    vt = Hn || fi || Function('return this')(),
    Sr = e && !e.nodeType && e,
    hi = Sr && !0 && n && !n.nodeType && n,
    Rs = hi && hi.exports === Sr,
    xr = Rs && Hn.process,
    Zs = (function () {
      try {
        return xr && xr.binding && xr.binding('util')
      } catch {}
    })(),
    pi = Zs && Zs.isTypedArray
  function As(y, S) {
    for (var Z = -1, M = y == null ? 0 : y.length, ye = 0, ne = []; ++Z < M; ) {
      var Te = y[Z]
      S(Te, Z, y) && (ne[ye++] = Te)
    }
    return ne
  }
  function dh(y, S) {
    for (var Z = -1, M = S.length, ye = y.length; ++Z < M; ) y[ye + Z] = S[Z]
    return y
  }
  function Oh(y, S) {
    for (var Z = -1, M = y == null ? 0 : y.length; ++Z < M; )
      if (S(y[Z], Z, y)) return !0
    return !1
  }
  function mh(y, S) {
    for (var Z = -1, M = Array(y); ++Z < y; ) M[Z] = S(Z)
    return M
  }
  function v(y) {
    return function (S) {
      return y(S)
    }
  }
  function $(y, S) {
    return y.has(S)
  }
  function _(y, S) {
    return y == null ? void 0 : y[S]
  }
  function q(y) {
    var S = -1,
      Z = Array(y.size)
    return (
      y.forEach(function (M, ye) {
        Z[++S] = [ye, M]
      }),
      Z
    )
  }
  function I(y, S) {
    return function (Z) {
      return y(S(Z))
    }
  }
  function E(y) {
    var S = -1,
      Z = Array(y.size)
    return (
      y.forEach(function (M) {
        Z[++S] = M
      }),
      Z
    )
  }
  var H = Array.prototype,
    fe = Function.prototype,
    ge = Object.prototype,
    wn = vt['__core-js_shared__'],
    un = fe.toString,
    St = ge.hasOwnProperty,
    wr = (function () {
      var y = /[^.]+$/.exec((wn && wn.keys && wn.keys.IE_PROTO) || '')
      return y ? 'Symbol(src)_1.' + y : ''
    })(),
    Pr = ge.toString,
    Rl = RegExp(
      '^' +
        un
          .call(St)
          .replace(et, '\\$&')
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            '$1.*?'
          ) +
        '$'
    ),
    di = Rs ? vt.Buffer : void 0,
    Tr = vt.Symbol,
    Oi = vt.Uint8Array,
    gh = ge.propertyIsEnumerable,
    ZS = H.splice,
    Kn = Tr ? Tr.toStringTag : void 0,
    yh = Object.getOwnPropertySymbols,
    AS = di ? di.isBuffer : void 0,
    ES = I(Object.keys, Object),
    Zl = $r(vt, 'DataView'),
    mi = $r(vt, 'Map'),
    Al = $r(vt, 'Promise'),
    El = $r(vt, 'Set'),
    Dl = $r(vt, 'WeakMap'),
    gi = $r(Object, 'create'),
    DS = tr(Zl),
    XS = tr(mi),
    YS = tr(Al),
    IS = tr(El),
    jS = tr(Dl),
    bh = Tr ? Tr.prototype : void 0,
    Xl = bh ? bh.valueOf : void 0
  function Jn(y) {
    var S = -1,
      Z = y == null ? 0 : y.length
    for (this.clear(); ++S < Z; ) {
      var M = y[S]
      this.set(M[0], M[1])
    }
  }
  function NS() {
    ;(this.__data__ = gi ? gi(null) : {}), (this.size = 0)
  }
  function MS(y) {
    var S = this.has(y) && delete this.__data__[y]
    return (this.size -= S ? 1 : 0), S
  }
  function VS(y) {
    var S = this.__data__
    if (gi) {
      var Z = S[y]
      return Z === r ? void 0 : Z
    }
    return St.call(S, y) ? S[y] : void 0
  }
  function WS(y) {
    var S = this.__data__
    return gi ? S[y] !== void 0 : St.call(S, y)
  }
  function LS(y, S) {
    var Z = this.__data__
    return (
      (this.size += this.has(y) ? 0 : 1),
      (Z[y] = gi && S === void 0 ? r : S),
      this
    )
  }
  ;(Jn.prototype.clear = NS),
    (Jn.prototype.delete = MS),
    (Jn.prototype.get = VS),
    (Jn.prototype.has = WS),
    (Jn.prototype.set = LS)
  function fn(y) {
    var S = -1,
      Z = y == null ? 0 : y.length
    for (this.clear(); ++S < Z; ) {
      var M = y[S]
      this.set(M[0], M[1])
    }
  }
  function BS() {
    ;(this.__data__ = []), (this.size = 0)
  }
  function US(y) {
    var S = this.__data__,
      Z = Ds(S, y)
    if (Z < 0) return !1
    var M = S.length - 1
    return Z == M ? S.pop() : ZS.call(S, Z, 1), --this.size, !0
  }
  function qS(y) {
    var S = this.__data__,
      Z = Ds(S, y)
    return Z < 0 ? void 0 : S[Z][1]
  }
  function zS(y) {
    return Ds(this.__data__, y) > -1
  }
  function FS(y, S) {
    var Z = this.__data__,
      M = Ds(Z, y)
    return M < 0 ? (++this.size, Z.push([y, S])) : (Z[M][1] = S), this
  }
  ;(fn.prototype.clear = BS),
    (fn.prototype.delete = US),
    (fn.prototype.get = qS),
    (fn.prototype.has = zS),
    (fn.prototype.set = FS)
  function er(y) {
    var S = -1,
      Z = y == null ? 0 : y.length
    for (this.clear(); ++S < Z; ) {
      var M = y[S]
      this.set(M[0], M[1])
    }
  }
  function GS() {
    ;(this.size = 0),
      (this.__data__ = {
        hash: new Jn(),
        map: new (mi || fn)(),
        string: new Jn()
      })
  }
  function HS(y) {
    var S = Xs(this, y).delete(y)
    return (this.size -= S ? 1 : 0), S
  }
  function KS(y) {
    return Xs(this, y).get(y)
  }
  function JS(y) {
    return Xs(this, y).has(y)
  }
  function e0(y, S) {
    var Z = Xs(this, y),
      M = Z.size
    return Z.set(y, S), (this.size += Z.size == M ? 0 : 1), this
  }
  ;(er.prototype.clear = GS),
    (er.prototype.delete = HS),
    (er.prototype.get = KS),
    (er.prototype.has = JS),
    (er.prototype.set = e0)
  function Es(y) {
    var S = -1,
      Z = y == null ? 0 : y.length
    for (this.__data__ = new er(); ++S < Z; ) this.add(y[S])
  }
  function t0(y) {
    return this.__data__.set(y, r), this
  }
  function n0(y) {
    return this.__data__.has(y)
  }
  ;(Es.prototype.add = Es.prototype.push = t0), (Es.prototype.has = n0)
  function Pn(y) {
    var S = (this.__data__ = new fn(y))
    this.size = S.size
  }
  function r0() {
    ;(this.__data__ = new fn()), (this.size = 0)
  }
  function i0(y) {
    var S = this.__data__,
      Z = S.delete(y)
    return (this.size = S.size), Z
  }
  function s0(y) {
    return this.__data__.get(y)
  }
  function o0(y) {
    return this.__data__.has(y)
  }
  function a0(y, S) {
    var Z = this.__data__
    if (Z instanceof fn) {
      var M = Z.__data__
      if (!mi || M.length < t - 1)
        return M.push([y, S]), (this.size = ++Z.size), this
      Z = this.__data__ = new er(M)
    }
    return Z.set(y, S), (this.size = Z.size), this
  }
  ;(Pn.prototype.clear = r0),
    (Pn.prototype.delete = i0),
    (Pn.prototype.get = s0),
    (Pn.prototype.has = o0),
    (Pn.prototype.set = a0)
  function l0(y, S) {
    var Z = Ys(y),
      M = !Z && w0(y),
      ye = !Z && !M && Yl(y),
      ne = !Z && !M && !ye && kh(y),
      Te = Z || M || ye || ne,
      Ye = Te ? mh(y.length, String) : [],
      Ne = Ye.length
    for (var xe in y)
      (S || St.call(y, xe)) &&
        !(
          Te &&
          (xe == 'length' ||
            (ye && (xe == 'offset' || xe == 'parent')) ||
            (ne &&
              (xe == 'buffer' || xe == 'byteLength' || xe == 'byteOffset')) ||
            y0(xe, Ne))
        ) &&
        Ye.push(xe)
    return Ye
  }
  function Ds(y, S) {
    for (var Z = y.length; Z--; ) if (Ph(y[Z][0], S)) return Z
    return -1
  }
  function c0(y, S, Z) {
    var M = S(y)
    return Ys(y) ? M : dh(M, Z(y))
  }
  function yi(y) {
    return y == null
      ? y === void 0
        ? D
        : x
      : Kn && Kn in Object(y)
        ? m0(y)
        : x0(y)
  }
  function vh(y) {
    return bi(y) && yi(y) == a
  }
  function Sh(y, S, Z, M, ye) {
    return y === S
      ? !0
      : y == null || S == null || (!bi(y) && !bi(S))
        ? y !== y && S !== S
        : u0(y, S, Z, M, Sh, ye)
  }
  function u0(y, S, Z, M, ye, ne) {
    var Te = Ys(y),
      Ye = Ys(S),
      Ne = Te ? l : Tn(y),
      xe = Ye ? l : Tn(S)
    ;(Ne = Ne == a ? w : Ne), (xe = xe == a ? w : xe)
    var ut = Ne == w,
      At = xe == w,
      qe = Ne == xe
    if (qe && Yl(y)) {
      if (!Yl(S)) return !1
      ;(Te = !0), (ut = !1)
    }
    if (qe && !ut)
      return (
        ne || (ne = new Pn()),
        Te || kh(y) ? xh(y, S, Z, M, ye, ne) : d0(y, S, Ne, Z, M, ye, ne)
      )
    if (!(Z & i)) {
      var xt = ut && St.call(y, '__wrapped__'),
        wt = At && St.call(S, '__wrapped__')
      if (xt || wt) {
        var $n = xt ? y.value() : y,
          hn = wt ? S.value() : S
        return ne || (ne = new Pn()), ye($n, hn, Z, M, ne)
      }
    }
    return qe ? (ne || (ne = new Pn()), O0(y, S, Z, M, ye, ne)) : !1
  }
  function f0(y) {
    if (!Qh(y) || v0(y)) return !1
    var S = Th(y) ? Rl : bt
    return S.test(tr(y))
  }
  function h0(y) {
    return bi(y) && $h(y.length) && !!oe[yi(y)]
  }
  function p0(y) {
    if (!S0(y)) return ES(y)
    var S = []
    for (var Z in Object(y)) St.call(y, Z) && Z != 'constructor' && S.push(Z)
    return S
  }
  function xh(y, S, Z, M, ye, ne) {
    var Te = Z & i,
      Ye = y.length,
      Ne = S.length
    if (Ye != Ne && !(Te && Ne > Ye)) return !1
    var xe = ne.get(y)
    if (xe && ne.get(S)) return xe == S
    var ut = -1,
      At = !0,
      qe = Z & s ? new Es() : void 0
    for (ne.set(y, S), ne.set(S, y); ++ut < Ye; ) {
      var xt = y[ut],
        wt = S[ut]
      if (M) var $n = Te ? M(wt, xt, ut, S, y, ne) : M(xt, wt, ut, y, S, ne)
      if ($n !== void 0) {
        if ($n) continue
        At = !1
        break
      }
      if (qe) {
        if (
          !Oh(S, function (hn, nr) {
            if (!$(qe, nr) && (xt === hn || ye(xt, hn, Z, M, ne)))
              return qe.push(nr)
          })
        ) {
          At = !1
          break
        }
      } else if (!(xt === wt || ye(xt, wt, Z, M, ne))) {
        At = !1
        break
      }
    }
    return ne.delete(y), ne.delete(S), At
  }
  function d0(y, S, Z, M, ye, ne, Te) {
    switch (Z) {
      case A:
        if (y.byteLength != S.byteLength || y.byteOffset != S.byteOffset)
          return !1
        ;(y = y.buffer), (S = S.buffer)
      case B:
        return !(y.byteLength != S.byteLength || !ne(new Oi(y), new Oi(S)))
      case u:
      case f:
      case b:
        return Ph(+y, +S)
      case p:
        return y.name == S.name && y.message == S.message
      case P:
      case R:
        return y == S + ''
      case g:
        var Ye = q
      case k:
        var Ne = M & i
        if ((Ye || (Ye = E), y.size != S.size && !Ne)) return !1
        var xe = Te.get(y)
        if (xe) return xe == S
        ;(M |= s), Te.set(y, S)
        var ut = xh(Ye(y), Ye(S), M, ye, ne, Te)
        return Te.delete(y), ut
      case V:
        if (Xl) return Xl.call(y) == Xl.call(S)
    }
    return !1
  }
  function O0(y, S, Z, M, ye, ne) {
    var Te = Z & i,
      Ye = wh(y),
      Ne = Ye.length,
      xe = wh(S),
      ut = xe.length
    if (Ne != ut && !Te) return !1
    for (var At = Ne; At--; ) {
      var qe = Ye[At]
      if (!(Te ? qe in S : St.call(S, qe))) return !1
    }
    var xt = ne.get(y)
    if (xt && ne.get(S)) return xt == S
    var wt = !0
    ne.set(y, S), ne.set(S, y)
    for (var $n = Te; ++At < Ne; ) {
      qe = Ye[At]
      var hn = y[qe],
        nr = S[qe]
      if (M) var Ch = Te ? M(nr, hn, qe, S, y, ne) : M(hn, nr, qe, y, S, ne)
      if (!(Ch === void 0 ? hn === nr || ye(hn, nr, Z, M, ne) : Ch)) {
        wt = !1
        break
      }
      $n || ($n = qe == 'constructor')
    }
    if (wt && !$n) {
      var Is = y.constructor,
        js = S.constructor
      Is != js &&
        'constructor' in y &&
        'constructor' in S &&
        !(
          typeof Is == 'function' &&
          Is instanceof Is &&
          typeof js == 'function' &&
          js instanceof js
        ) &&
        (wt = !1)
    }
    return ne.delete(y), ne.delete(S), wt
  }
  function wh(y) {
    return c0(y, $0, g0)
  }
  function Xs(y, S) {
    var Z = y.__data__
    return b0(S) ? Z[typeof S == 'string' ? 'string' : 'hash'] : Z.map
  }
  function $r(y, S) {
    var Z = _(y, S)
    return f0(Z) ? Z : void 0
  }
  function m0(y) {
    var S = St.call(y, Kn),
      Z = y[Kn]
    try {
      y[Kn] = void 0
      var M = !0
    } catch {}
    var ye = Pr.call(y)
    return M && (S ? (y[Kn] = Z) : delete y[Kn]), ye
  }
  var g0 = yh
      ? function (y) {
          return y == null
            ? []
            : ((y = Object(y)),
              As(yh(y), function (S) {
                return gh.call(y, S)
              }))
        }
      : Q0,
    Tn = yi
  ;((Zl && Tn(new Zl(new ArrayBuffer(1))) != A) ||
    (mi && Tn(new mi()) != g) ||
    (Al && Tn(Al.resolve()) != Q) ||
    (El && Tn(new El()) != k) ||
    (Dl && Tn(new Dl()) != L)) &&
    (Tn = function (y) {
      var S = yi(y),
        Z = S == w ? y.constructor : void 0,
        M = Z ? tr(Z) : ''
      if (M)
        switch (M) {
          case DS:
            return A
          case XS:
            return g
          case YS:
            return Q
          case IS:
            return k
          case jS:
            return L
        }
      return S
    })
  function y0(y, S) {
    return (
      (S = S ?? o),
      !!S &&
        (typeof y == 'number' || Nt.test(y)) &&
        y > -1 &&
        y % 1 == 0 &&
        y < S
    )
  }
  function b0(y) {
    var S = typeof y
    return S == 'string' || S == 'number' || S == 'symbol' || S == 'boolean'
      ? y !== '__proto__'
      : y === null
  }
  function v0(y) {
    return !!wr && wr in y
  }
  function S0(y) {
    var S = y && y.constructor,
      Z = (typeof S == 'function' && S.prototype) || ge
    return y === Z
  }
  function x0(y) {
    return Pr.call(y)
  }
  function tr(y) {
    if (y != null) {
      try {
        return un.call(y)
      } catch {}
      try {
        return y + ''
      } catch {}
    }
    return ''
  }
  function Ph(y, S) {
    return y === S || (y !== y && S !== S)
  }
  var w0 = vh(
      (function () {
        return arguments
      })()
    )
      ? vh
      : function (y) {
          return bi(y) && St.call(y, 'callee') && !gh.call(y, 'callee')
        },
    Ys = Array.isArray
  function P0(y) {
    return y != null && $h(y.length) && !Th(y)
  }
  var Yl = AS || k0
  function T0(y, S) {
    return Sh(y, S)
  }
  function Th(y) {
    if (!Qh(y)) return !1
    var S = yi(y)
    return S == d || S == O || S == c || S == T
  }
  function $h(y) {
    return typeof y == 'number' && y > -1 && y % 1 == 0 && y <= o
  }
  function Qh(y) {
    var S = typeof y
    return y != null && (S == 'object' || S == 'function')
  }
  function bi(y) {
    return y != null && typeof y == 'object'
  }
  var kh = pi ? v(pi) : h0
  function $0(y) {
    return P0(y) ? l0(y) : p0(y)
  }
  function Q0() {
    return []
  }
  function k0() {
    return !1
  }
  n.exports = T0
})(aa, aa.exports)
var sP = aa.exports
const oP = h.getDefaultExportFromCjs(sP)
h.PropTypes.string
var aP = h.React.createContext({})
function xo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (xo = function (t) {
          return typeof t
        })
      : (xo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    xo(n)
  )
}
function lP(n, e) {
  return hP(n) || fP(n, e) || uP(n, e) || cP()
}
function cP() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function uP(n, e) {
  if (n) {
    if (typeof n == 'string') return lp(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === 'Object' && n.constructor && (t = n.constructor.name),
      t === 'Map' || t === 'Set')
    )
      return Array.from(n)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return lp(n, e)
  }
}
function lp(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = n[t]
  return r
}
function fP(n, e) {
  var t = n && ((typeof Symbol < 'u' && n[Symbol.iterator]) || n['@@iterator'])
  if (t != null) {
    var r = [],
      i = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(i = (o = t.next()).done) && (r.push(o.value), !(e && r.length === e));
        i = !0
      );
    } catch (l) {
      ;(s = !0), (a = l)
    } finally {
      try {
        !i && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return r
  }
}
function hP(n) {
  if (Array.isArray(n)) return n
}
function pP(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function cp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function dP(n, e, t) {
  return e && cp(n.prototype, e), t && cp(n, t), n
}
function OP(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Bc(n, e)
}
function Bc(n, e) {
  return (
    (Bc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Bc(n, e)
  )
}
function mP(n) {
  var e = bP()
  return function () {
    var r = la(n),
      i
    if (e) {
      var s = la(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return gP(this, i)
  }
}
function gP(n, e) {
  return e && (xo(e) === 'object' || typeof e == 'function') ? e : yP(n)
}
function yP(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function bP() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function la(n) {
  return (
    (la = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    la(n)
  )
}
var Ul = typeof document < 'u',
  ys = (function (n) {
    OP(t, n)
    var e = mP(t)
    function t(r) {
      var i
      return (
        pP(this, t),
        (i = e.call(this, r)),
        (i.portalNode = null),
        (i.state = { isOpen: !1 }),
        i
      )
    }
    return (
      dP(t, [
        {
          key: 'componentDidMount',
          value: function () {
            this.renderPortal()
          }
        },
        {
          key: 'componentDidUpdate',
          value: function () {
            this.renderPortal()
          }
        },
        {
          key: 'componentWillUnmount',
          value: function () {
            this.unmountPortal()
          }
        },
        {
          key: 'getChildren',
          value: function () {
            return h.reactExports.Children.only(this.props.children)
          }
        },
        {
          key: 'getPortalParentNode',
          value: function () {
            var i
            if (typeof this.props.renderTo == 'string')
              i = document.querySelector(this.props.renderTo)
            else if (
              this.context &&
              typeof this.context.renderTo == 'string' &&
              document.querySelectorAll(this.context.renderTo) &&
              document.querySelectorAll(this.context.renderTo)[0]
            ) {
              var s = document.querySelectorAll(this.context.renderTo),
                o = lP(s, 1)
              i = o[0]
            } else i = this.props.renderTo || (Ul && document.body)
            return i
          }
        },
        {
          key: 'setupPortalNode',
          value: function () {
            var i = this.getPortalParentNode()
            ;(this.portalNode = {}),
              Ul &&
                ((this.portalNode = document.createElement(
                  this.props.renderTag
                )),
                this.portalNode.setAttribute(
                  'style',
                  'display: block; height: 0px; width: 0px;'
                ),
                this.portalNode.setAttribute(
                  'className',
                  'design-system-react-portal'
                ),
                i.appendChild(this.portalNode),
                (this.portalNodeInstance = this.props.onMount
                  ? this.props.onMount(void 0, { portal: this.portalNode })
                  : this.portalNode))
          }
        },
        {
          key: 'unmountPortal',
          value: function () {
            this.portalNode &&
              (h.ReactDOM.unmountComponentAtNode(this.portalNode),
              this.portalNode.parentNode.removeChild(this.portalNode)),
              (this.portalNode = null)
          }
        },
        {
          key: 'updatePortal',
          value: function () {
            var i = this
            this.props.id && (this.portalNode.id = this.props.id),
              this.props.className &&
                (this.portalNode.className = this.props.className),
              this.props.style &&
                Object.keys(this.props.style).forEach(function (s) {
                  i.portalNode.style[s] = i.props.style[s]
                }),
              this.props.onUpdate &&
                (this.portalNodeInstance = this.props.onUpdate(
                  this.portalNodeInstance
                ))
          }
        },
        {
          key: 'renderPortal',
          value: function () {
            var i = this
            if (!this.getChildren() || !Ul) {
              this.unmountPortal()
              return
            }
            this.portalNode || this.setupPortalNode(),
              this.props.portalMount
                ? this.props.portalMount({
                    instance: this,
                    reactElement: this.getChildren(),
                    domContainerNode: this.portalNode,
                    updateCallback: function () {
                      i.updatePortal()
                    }
                  })
                : h.ReactDOM.unstable_renderSubtreeIntoContainer(
                    this,
                    this.getChildren(),
                    this.portalNode,
                    function () {
                      i.updatePortal(),
                        i.state.isOpen === !1 &&
                          (i.props.onOpen &&
                            i.props.onOpen(void 0, { portal: i.getChildren() }),
                          i.setState({ isOpen: !0 }))
                    }
                  )
          }
        },
        {
          key: 'render',
          value: function () {
            return null
          }
        }
      ]),
      t
    )
  })(h.reactExports.Component)
ys.displayName = 'Portal'
ys.propTypes = {
  renderTag: h.PropTypes.string,
  renderTo: h.PropTypes.any,
  id: h.PropTypes.string,
  children: h.PropTypes.node,
  className: h.PropTypes.any,
  style: h.PropTypes.object,
  onMount: h.PropTypes.func,
  onOpen: h.PropTypes.func,
  onUpdate: h.PropTypes.func,
  portalMount: h.PropTypes.func
}
ys.defaultProps = {
  renderTag: 'span',
  renderTo: null,
  onMount: function () {
    return null
  },
  onOpen: function () {
    return null
  },
  onUpdate: function () {
    return null
  },
  onUnmount: function () {
    return null
  }
}
ys.contextType = aP
const vP = ys
/*!
 * Adapted from jQuery UI core
 *
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */ function SP(n, e) {
  var t = n.nodeName.toLowerCase()
  return /input|select|textarea|button|object/.test(t)
    ? !n.disabled
    : (t === 'a' && n.href) || e
}
function xP(n) {
  var e = n.getAttribute('tabindex')
  e === null && (e = void 0)
  var t = isNaN(e)
  return (t || e >= 0) && SP(n, !t)
}
function wP(n) {
  return [].slice.call(n.querySelectorAll('*'), 0).filter(function (e) {
    return xP(e)
  })
}
var Cr = !!(
    typeof window < 'u' &&
    window.document &&
    window.document.createElement
  ),
  On = null,
  Ws = null,
  up = function (e) {
    if (!(!Cr || !On || e.keyCode !== Ar.TAB)) {
      var t = wP(On),
        r = t[e.shiftKey ? 0 : t.length - 1],
        i = r === document.activeElement || On === document.activeElement
      if (i) {
        e.preventDefault()
        var s = t[e.shiftKey ? t.length - 1 : 0]
        s.focus()
      }
    }
  },
  PP = {
    focusAncestor: function (e) {
      var t = e.isPortal
      if (Cr)
        if (t) {
          var r = window.pageYOffset
          On.focus({ preventScroll: !0 }),
            window.scrollTo(window.pageXOffset, r)
        } else On.focus()
    },
    hasOrAncestorHasFocus: function () {
      return (
        Cr &&
        (document.activeElement === On || On.contains(document.activeElement))
      )
    },
    returnFocusToStoredElement: function () {
      if (Cr) {
        try {
          Ws.focus()
        } catch {
          console.warn(
            'You tried to return focus to '.concat(
              Ws,
              ' but it is not in the DOM anymore'
            )
          )
        }
        Ws = null
      }
    },
    setupScopedFocus: function (e) {
      var t = e.ancestorElement
      ;(On = t), window.addEventListener('keydown', up, !1)
    },
    storeActiveElement: function () {
      Ws = Cr ? document.activeElement : null
    },
    teardownScopedFocus: function () {
      ;(On = null), Cr && window.removeEventListener('keydown', up)
    }
  }
const qt = PP
var TP = function (e, t) {
    var r
    switch (e) {
      case 'top left':
        r = 'top-start'
        break
      case 'top right':
        r = 'top-end'
        break
      case 'right top':
        r = 'right-start'
        break
      case 'right bottom':
        r = 'right-end'
        break
      case 'bottom left':
        r = 'bottom-start'
        break
      case 'bottom right':
        r = 'bottom-end'
        break
      case 'left top':
        r = 'left-start'
        break
      case 'left bottom':
        r = 'left-end'
        break
      default:
        r = e
    }
    return (
      t === Mn.RTL &&
        (r.indexOf('left') > -1
          ? (r = r.replace('left', 'right'))
          : r.indexOf('right') > -1
            ? (r = r.replace('right', 'left'))
            : r.indexOf('start') > -1
              ? (r = r.replace('start', 'end'))
              : r.indexOf('end') > -1 && (r = r.replace('end', 'start'))),
      r
    )
  },
  $P = function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    return t.flipped
      ? se({
          'slds-nubbin_top': e === 'top',
          'slds-nubbin_top-left': e === 'top left',
          'slds-nubbin_top-right': e === 'top right',
          'slds-nubbin_bottom': e === 'bottom',
          'slds-nubbin_bottom-left': e === 'bottom left',
          'slds-nubbin_bottom-right': e === 'bottom right',
          'slds-nubbin_left': e === 'left',
          'slds-nubbin_left-bottom': e === 'left bottom',
          'slds-nubbin_left-top': e === 'left top',
          'slds-nubbin_right': e === 'right',
          'slds-nubbin_right-bottom': e === 'right bottom',
          'slds-nubbin_right-top': e === 'right top'
        })
      : se({
          'slds-nubbin_top': e === 'bottom',
          'slds-nubbin_top-left': e === 'bottom left',
          'slds-nubbin_top-right': e === 'bottom right',
          'slds-nubbin_bottom': e === 'top',
          'slds-nubbin_bottom-left': e === 'top left',
          'slds-nubbin_bottom-right': e === 'top right',
          'slds-nubbin_left': e === 'right',
          'slds-nubbin_left-bottom': e === 'right bottom',
          'slds-nubbin_left-top': e === 'right top',
          'slds-nubbin_right': e === 'left',
          'slds-nubbin_right-bottom': e === 'left bottom',
          'slds-nubbin_right-top': e === 'left top'
        })
  },
  QP = 1.5,
  kP = 1,
  CP = kP / Math.sqrt(2),
  _P = function () {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      t = e.placement,
      r = 0,
      i = 0,
      s = 16 * QP,
      o = 16 * CP,
      a = e.offsets.reference.width * 0.5,
      l = e.offsets.reference.height * 0.5
    return (
      t === 'top'
        ? (r = o * -1)
        : t === 'top-end'
          ? ((r = o * -1), (i = s - a))
          : t === 'top-start' && ((r = o * -1), (i = a - s)),
      t === 'bottom'
        ? (r = o)
        : t === 'bottom-end'
          ? ((r = o), (i = s - a))
          : t === 'bottom-start' && ((r = o), (i = a - s)),
      t === 'right'
        ? (i = o)
        : t === 'right-end'
          ? ((i = o), (r = s - l))
          : t === 'right-start' && ((i = o), (r = l - s)),
      t === 'left'
        ? (i = o * -1)
        : t === 'left-end'
          ? ((i = o * -1), (r = s - l))
          : t === 'left-start' && ((i = o * -1), (r = l - s)),
      { left: i, top: r }
    )
  }
function wo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (wo = function (t) {
          return typeof t
        })
      : (wo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    wo(n)
  )
}
function fp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function dn(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? fp(Object(t), !0).forEach(function (r) {
          Ve(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : fp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function RP(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function hp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function ZP(n, e, t) {
  return e && hp(n.prototype, e), t && hp(n, t), n
}
function AP(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Uc(n, e)
}
function Uc(n, e) {
  return (
    (Uc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Uc(n, e)
  )
}
function EP(n) {
  var e = XP()
  return function () {
    var r = ca(n),
      i
    if (e) {
      var s = ca(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return DP(this, i)
  }
}
function DP(n, e) {
  return e && (wo(e) === 'object' || typeof e == 'function') ? e : Pt(n)
}
function Pt(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function XP() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ca(n) {
  return (
    (ca = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    ca(n)
  )
}
function Ve(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var bs = (function (n) {
  AP(t, n)
  var e = EP(t)
  function t() {
    var r
    RP(this, t)
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o]
    return (
      (r = e.call.apply(e, [this].concat(s))),
      Ve(Pt(r), 'state', { triggerPopperJS: !1, isOpen: !1 }),
      Ve(Pt(r), 'getPropOffsetsInPixels', function (a) {
        var l = a.split(' ')
        return { vertical: parseInt(l[0], 10), horizontal: parseInt(l[1], 10) }
      }),
      Ve(Pt(r), 'getPopperStyles', function () {
        var a = r.state.popperData
        if (!r.popper || !a)
          return { position: 'absolute', pointerEvents: 'none' }
        var l = a.offsets.popper.position,
          c = r.getPropOffsetsInPixels(r.props.offset),
          u = r.props.hasNubbin ? _P(r.state.popperData) : { left: 0, top: 0 },
          f = a.offsets.popper.left + u.left + c.horizontal,
          p = a.offsets.popper.top + u.top + c.vertical,
          d = 'inherit'
        return dn(
          dn({}, a.style),
          {},
          {
            left: isNaN(f) ? 0 : f,
            top: isNaN(p) ? 0 : p,
            right: d,
            position: l
          }
        )
      }),
      Ve(Pt(r), 'setDialogContent', function (a) {
        ;(r.dialogContent = a),
          r.state.triggerPopperJS || r.setState({ triggerPopperJS: !0 })
      }),
      Ve(Pt(r), 'handleClickOutside', function () {
        r.handleClose()
      }),
      Ve(Pt(r), 'handleClose', function (a) {
        var l =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
        l.componentWillUnmount || r.setState({ triggerPopperJS: !0 }),
          r.props.onClose && r.props.onClose(a, l)
      }),
      Ve(Pt(r), 'handleClick', function (a) {
        a.nativeEvent &&
          (a.nativeEvent.preventDefault(), a.nativeEvent.stopPropagation())
      }),
      Ve(Pt(r), 'handleKeyDown', function (a) {
        a.keyCode === Ar.TAB &&
          r.props.closeOnTabKey &&
          (fs.trap(a), r.handleClose(a)),
          r.props.onKeyDown && r.props.onKeyDown(a)
      }),
      Ve(Pt(r), 'handleOpen', function () {
        r.props.variant === 'popover' &&
          r.dialogContent &&
          (qt.storeActiveElement(),
          qt.setupScopedFocus({ ancestorElement: r.dialogContent }),
          qt.hasOrAncestorHasFocus() ||
            qt.focusAncestor({
              isPortal: r.props.position === 'overflowBoundaryElement'
            })),
          r.props.onOpen && r.props.onOpen(void 0, { portal: r.dialogContent })
      }),
      Ve(Pt(r), 'createPopper', function () {
        var a = r.props.onRequestTargetElement(),
          l = r.dialogContent,
          c = TP(r.props.align, r.props.direction),
          u = !0,
          f = {
            applyStyle: { enabled: !1 },
            preventOverflow: {
              enabled: !r.props.hasStaticAlignment,
              boundariesElement:
                r.props.position === 'absolute' ? 'scrollParent' : 'viewport'
            },
            hide: { enabled: !1 },
            flip: { enabled: !r.props.hasStaticAlignment },
            removeOnDestroy: !0,
            updateState: {
              enabled: !0,
              order: 900,
              fn: function (d) {
                return (
                  ((r.state.popperData &&
                    !oP(d.offsets, r.state.popperData.offsets)) ||
                    !r.state.popperData) &&
                    r.setState({ popperData: d }),
                  d
                )
              }
            }
          }
        a || console.error('Target node not found!', a),
          l || console.error('Popper node not found!', l),
          (r.popper = new iP(a, l, {
            placement: c,
            eventsEnabled: u,
            modifiers: f
          })),
          r.popper.scheduleUpdate()
      }),
      Ve(Pt(r), 'destroyPopper', function () {
        r.popper && r.popper.destroy()
      }),
      r
    )
  }
  return (
    ZP(t, [
      {
        key: 'componentDidMount',
        value: function () {
          ;(this.props.position === 'absolute' ||
            this.props.position === 'relative') &&
            this.handleOpen()
        }
      },
      {
        key: 'componentDidUpdate',
        value: function (i, s) {
          this.popper && this.popper.scheduleUpdate(),
            this.state.triggerPopperJS === !0 &&
              s.triggerPopperJS === !1 &&
              (this.props.position === 'absolute' ||
                this.props.position === 'overflowBoundaryElement') &&
              this.dialogContent &&
              this.props.onRequestTargetElement() &&
              this.createPopper()
        }
      },
      {
        key: 'componentWillUnmount',
        value: function () {
          this.props.variant === 'popover' &&
            (qt.teardownScopedFocus(), qt.returnFocusToStoredElement()),
            (this.props.position === 'absolute' ||
              this.props.position === 'overflowBoundaryElement') &&
              this.destroyPopper(),
            this.handleClose(void 0, { componentWillUnmount: !0 })
        }
      },
      {
        key: 'render',
        value: function () {
          var i = this,
            s = {},
            o = this.props.variant === 'popover' ? 'dialog' : this.props.variant
          ;(this.props.position === 'absolute' ||
            this.props.position === 'overflowBoundaryElement') &&
            (s = dn(dn({}, s), {}, { outline: 0 }, this.getPopperStyles())),
            this.props.inheritWidthOf === 'target' &&
            this.props.onRequestTargetElement()
              ? (s.width = this.props
                  .onRequestTargetElement()
                  .getBoundingClientRect().width)
              : this.props.inheritWidthOf === 'menu' &&
                this.dialogContent &&
                this.dialogContent.querySelector('.slds-listbox') &&
                (s.width = this.dialogContent
                  .querySelector('.slds-listbox')
                  .getBoundingClientRect().width),
            (s = dn(dn({}, s), this.props.style))
          var a = this.props.variant === 'popover' ? 'section' : 'div',
            l = h.React.createElement(
              a,
              dn(
                {
                  className:
                    se(
                      Ve(
                        {
                          'absolute-positioned':
                            this.props.position === 'absolute',
                          'portal-positioned':
                            this.props.position === 'overflowBoundaryElement'
                        },
                        ''.concat(this.props.outsideClickIgnoreClass),
                        this.props.position === 'overflowBoundaryElement'
                      ),
                      this.props.hasNubbin &&
                        $P(this.props.align, this.state.popperData),
                      this.props.contentsClassName
                    ) || void 0,
                  style: s,
                  onMouseDown: this.props.onMouseDown,
                  onKeyDown: this.handleKeyDown,
                  onMouseEnter: this.props.onMouseEnter,
                  onMouseLeave: this.props.onMouseLeave,
                  ref: this.setDialogContent,
                  role: o,
                  tabIndex: this.props.variant === 'popover' ? '-1' : void 0
                },
                this.props.containerProps
              ),
              this.props.children
            ),
            c = {
              absolute: function () {
                return l
              },
              relative: function () {
                return l
              },
              overflowBoundaryElement: function () {
                var f = Object.keys(i.context)
                    .filter(function (d) {
                      return !!i.context[d]
                    })
                    .reduce(function (d, O) {
                      return dn(dn({}, d), Ve({}, O, i.context[O]))
                    }, {}),
                  p = h.React.createElement(
                    Dm.Provider,
                    { value: i.props.direction },
                    h.React.createElement(Ja, f, l)
                  )
                return h.React.createElement(
                  vP,
                  { onOpen: i.handleOpen, portalMount: i.props.portalMount },
                  p
                )
              }
            }
          return c[this.props.position] && c[this.props.position]()
        }
      }
    ]),
    t
  )
})(h.React.Component)
Ve(bs, 'displayName', xx)
Ve(bs, 'propTypes', {
  align: h.PropTypes.oneOf([
    'top',
    'top left',
    'top right',
    'right',
    'right top',
    'right bottom',
    'bottom',
    'bottom left',
    'bottom right',
    'left',
    'left top',
    'left bottom'
  ]),
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  contentsClassName: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  children: h.PropTypes.node.isRequired,
  closeOnTabKey: h.PropTypes.bool,
  containerProps: h.PropTypes.object,
  direction: h.PropTypes.oneOf([Mn.LTR, Mn.RTL]),
  hasNubbin: h.PropTypes.bool,
  hasStaticAlignment: h.PropTypes.bool,
  inheritWidthOf: h.PropTypes.oneOf(['target', 'menu', 'none']),
  offset: h.PropTypes.string,
  onClose: h.PropTypes.func,
  onKeyDown: h.PropTypes.func,
  onMouseEnter: h.PropTypes.func,
  onMouseLeave: h.PropTypes.func,
  onOpen: h.PropTypes.func,
  onRequestTargetElement: h.PropTypes.func.isRequired,
  outsideClickIgnoreClass: h.PropTypes.string,
  portalMount: h.PropTypes.func,
  position: h.PropTypes.oneOf([
    'absolute',
    'overflowBoundaryElement',
    'relative'
  ]).isRequired,
  style: h.PropTypes.object,
  variant: h.PropTypes.oneOf(['dropdown', 'popover', 'tooltip'])
})
Ve(bs, 'defaultProps', {
  align: 'bottom left',
  direction: Mn.LTR,
  offset: '0px 0px',
  outsideClickIgnoreClass: 'ignore-react-onclickoutside'
})
bs.contextType = el
const YP = jm(bs)
var vg = function () {}
if (process.env.NODE_ENV !== 'production') {
  var pp = {}
  vg = function (e, t, r, i, s, o) {
    var a = s ? ' '.concat(s) : '',
      l = i ? 'Use `'.concat(i, '`') : '',
      c = i ? ' '.concat(l, ' instead.') : ''
    !o &&
      !pp[e + r] &&
      (yr(
        t === void 0,
        '[Design System React] `'
          .concat(r, '` will be removed in the next major version of ')
          .concat(e, '.')
          .concat(c)
          .concat(a)
      ),
      (pp[e + r] = t !== void 0))
  }
}
const mn = vg
var Sg = function () {}
if (process.env.NODE_ENV !== 'production') {
  var dp = {}
  Sg = function (e, t, r) {
    var i = t.propAsString,
      s = t.propValue,
      o = t.deprecatedPropValue,
      a = t.replacementPropAsString,
      l = t.replacementPropAsValue,
      c = t.log,
      u = r ? ' '.concat(r) : '',
      f = e + i + o,
      p = s === o,
      d =
        o && a && l
          ? ' Replace `'
              .concat(i, '="')
              .concat(o, '"` with `')
              .concat(a, '="')
              .concat(l, '"`.')
          : ''
    if (!dp[f]) {
      var O = '[Design System React] The value of `'
        .concat(o, '`, for prop `')
        .concat(i, '` will be removed in the next major version of ')
        .concat(e, '. Please update your props.')
        .concat(d)
        .concat(u)
      p && c ? c({ message: O }) : yr(!p, O), (dp[f] = p)
    }
  }
}
const Op = Sg
var xg = function () {}
if (process.env.NODE_ENV !== 'production') {
  var mp = {}
  xg = function (e, t, r, i) {
    var s = r ? ' '.concat(r) : '',
      o = t.props.tabIndex,
      a = !0
    !i &&
      t.type !== 'button' &&
      t.type !== 'input' &&
      t.type !== 'select' &&
      t.type !== 'textarea' &&
      t.type !== 'a' &&
      t.type.displayName !== ff &&
      t.type.displayName !== vx &&
      t.type.displayName !== bx &&
      t.type.displayName !== Px &&
      t.type.displayName !== Sx &&
      t.type.displayName !== Ka &&
      t.type.displayName !== kx &&
      t.type.displayName !== Cx &&
      t.type.displayName !== Dx &&
      (o === '-1' || o === void 0) &&
      ((a = !1),
      mp[e] ||
        (yr(
          a,
          '[Design System React] The element that triggers '
            .concat(
              e,
              ' must be tabbable for keyboard users. Elements such as anchor, button, input or a DOM element with tabIndex="0" specified are tabbable. '
            )
            .concat(s)
        ),
        (mp[e] = !!a)))
  }
}
const IP = xg
var wg = function () {}
process.env.NODE_ENV !== 'production' &&
  (wg = function (e, t, r) {
    var i = Fn(r)
    t.variant === 'base' &&
      h.React.Children.count(t.children) !== 0 &&
      IP(e, t.children, i(), t.silenceTriggerTabbableWarning),
      Op(
        e,
        {
          propAsString: 'variant',
          propValue: t.variant,
          deprecatedPropValue: 'info',
          replacementPropAsString: 'theme',
          replacementPropAsValue: 'info'
        },
        i('theme')
      ),
      Op(
        e,
        {
          propAsString: 'variant',
          propValue: t.variant,
          deprecatedPropValue: 'error',
          replacementPropAsString: 'theme',
          replacementPropAsValue: 'error'
        },
        i('theme')
      ),
      mn(e, t.openByDefault, 'openByDefault', 'isOpen', i('isOpen')),
      mn(
        e,
        t.target,
        'target',
        void 0,
        'A new positioning library is being implmented under the hood. Please trigger tooltips to appear on their triggers with `isOpen` and not on other DOM elements. '.concat(
          i('isOpen')
        )
      ),
      mn(e, t.isInline, 'isInline', 'position="relative"', i('position'))
  })
const jP = wg,
  NP = 'tooltip',
  MP = 'prod',
  VP = 'Tooltip',
  WP = {
    component: NP,
    status: MP,
    'display-name': 'Tooltips',
    classKey: VP,
    'SLDS-component-path': '/components/tooltips',
    'site-stories': [
      { heading: 'Base', path: '/__examples__/base.jsx' },
      { heading: 'Button Trigger', path: '/__examples__/button.jsx' },
      {
        heading: 'Button Group Trigger',
        path: '/__examples__/button-group.jsx'
      },
      { heading: 'Learn more', path: '/__examples__/learn-more.jsx' }
    ],
    'url-slug': 'tooltips'
  }
function Po(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Po = function (t) {
          return typeof t
        })
      : (Po = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Po(n)
  )
}
function gp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function LP(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? gp(Object(t), !0).forEach(function (r) {
          Ai(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : gp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function BP(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function yp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function UP(n, e, t) {
  return e && yp(n.prototype, e), t && yp(n, t), n
}
function qP(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && qc(n, e)
}
function qc(n, e) {
  return (
    (qc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    qc(n, e)
  )
}
function zP(n) {
  var e = GP()
  return function () {
    var r = ua(n),
      i
    if (e) {
      var s = ua(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return FP(this, i)
  }
}
function FP(n, e) {
  return e && (Po(e) === 'object' || typeof e == 'function') ? e : Zi(n)
}
function Zi(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function GP() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ua(n) {
  return (
    (ua = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    ua(n)
  )
}
function Ai(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var HP = km,
  KP = {
    align: h.PropTypes.oneOf([
      'top',
      'top left',
      'top right',
      'right',
      'right top',
      'right bottom',
      'bottom',
      'bottom left',
      'bottom right',
      'left',
      'left top',
      'left bottom'
    ]).isRequired,
    assistiveText: h.PropTypes.shape({
      tooltipTipLearnMoreIcon: h.PropTypes.string,
      triggerLearnMoreIcon: h.PropTypes.string
    }),
    children: h.PropTypes.node,
    content: h.PropTypes.node.isRequired,
    dialogClassName: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    hasAnchoredNubbin: h.PropTypes.bool,
    hasStaticAlignment: h.PropTypes.bool,
    hoverCloseDelay: h.PropTypes.number,
    hoverOpenDelay: h.PropTypes.number,
    id: h.PropTypes.string,
    labels: h.PropTypes.shape({
      learnMoreAfter: h.PropTypes.string,
      learnMoreBefore: h.PropTypes.string
    }),
    isOpen: h.PropTypes.bool,
    onRequestTargetElement: h.PropTypes.func,
    triggerClassName: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    position: h.PropTypes.oneOf([
      'absolute',
      'overflowBoundaryElement',
      'relative'
    ]),
    triggerStyle: h.PropTypes.object,
    theme: h.PropTypes.oneOf(['info', 'error']),
    variant: h.PropTypes.oneOf(['base', 'learnMore', 'list-item'])
  },
  JP = {
    assistiveText: {
      tooltipTipLearnMoreIcon: 'this link',
      triggerLearnMoreIcon: 'Help'
    },
    align: 'top',
    content: h.React.createElement('span', null, 'Tooltip'),
    labels: { learnMoreAfter: 'to learn more.', learnMoreBefore: 'Click' },
    hoverCloseDelay: 50,
    hoverOpenDelay: 0,
    position: 'absolute',
    theme: 'info',
    variant: 'base'
  },
  vs = (function (n) {
    qP(t, n)
    var e = zP(t)
    function t(r) {
      var i
      return (
        BP(this, t),
        (i = e.call(this, r)),
        Ai(Zi(i), 'handleCancel', function () {
          clearTimeout(i.tooltipTimeout), i.setState({ isOpen: !1 })
        }),
        Ai(Zi(i), 'handleMouseEnter', function () {
          clearTimeout(i.tooltipTimeout),
            (i.tooltipTimeout = setTimeout(function () {
              i.isUnmounting || i.setState({ isOpen: !0 })
            }, i.props.hoverOpenDelay))
        }),
        Ai(Zi(i), 'handleMouseLeave', function () {
          clearTimeout(i.tooltipTimeout),
            (i.tooltipTimeout = setTimeout(function () {
              i.isUnmounting || i.setState({ isOpen: !1 })
            }, i.props.hoverCloseDelay))
        }),
        Ai(Zi(i), 'saveTriggerRef', function (s) {
          ;(i.trigger = s),
            i.state.triggerRendered || i.setState({ triggerRendered: !0 })
        }),
        (i.state = { isOpen: !1 }),
        (i.tooltipTimeout = {}),
        jP(km, r, WP),
        (i.generatedId = dr.generate()),
        i
      )
    }
    return (
      UP(t, [
        {
          key: 'componentWillUnmount',
          value: function () {
            this.isUnmounting = !0
          }
        },
        {
          key: 'getAnchoredNubbinStyles',
          value: function () {
            if (this.props.hasAnchoredNubbin) {
              var i = this.props.align.split(' ')[0],
                s = { height: '0', position: 'relative', width: '0' },
                o = {
                  backgroundColor: '#16325c',
                  content: '',
                  height: '1rem',
                  position: 'absolute',
                  transform: 'rotate(45deg)',
                  width: '1rem'
                },
                a = {
                  height: this.trigger
                    ? this.trigger.getBoundingClientRect().height
                    : 0,
                  width: this.trigger
                    ? this.trigger.getBoundingClientRect().width
                    : 0
                }
              switch (i) {
                case 'bottom': {
                  ;(s.left = ''.concat(a.width / 2, 'px')),
                    (s.top = ''.concat(a.height, 'px')),
                    (o.left = '-8px'),
                    (o.top = '3px')
                  break
                }
                case 'left': {
                  ;(s.left = '0'),
                    (s.top = ''.concat(a.height / 2, 'px')),
                    (o.left = '-19px'),
                    (o.top = '-9px')
                  break
                }
                case 'right': {
                  ;(s.left = ''.concat(a.width, 'px')),
                    (s.top = ''.concat(a.height / 2, 'px')),
                    (o.left = '3px'),
                    (o.top = '-9px')
                  break
                }
                default:
                  ;(s.left = ''.concat(a.width / 2, 'px')),
                    (s.top = '0'),
                    (o.left = '-8px'),
                    (o.top = '-19px')
              }
              return h.React.createElement(
                h.React.Fragment,
                null,
                h.React.createElement(
                  'style',
                  null,
                  '#'.concat(this.getId(), ':after, #').concat(
                    this.getId(),
                    `:before {
	display: none;
}`
                  )
                ),
                this.getIsOpen()
                  ? h.React.createElement(
                      'div',
                      { style: s },
                      h.React.createElement('div', { style: o })
                    )
                  : null
              )
            }
            return null
          }
        },
        {
          key: 'getContent',
          value: function () {
            var i = this,
              s,
              o = h.React.Children.count(this.props.children) === 0
            return (
              o && this.props.onClickTrigger
                ? (s = [
                    h.React.createElement(
                      'a',
                      {
                        href: '#',
                        onClick: fs.trappedHandler(this.props.onClickTrigger)
                      },
                      h.React.createElement(Ie, {
                        category: 'utility',
                        name: 'info',
                        assistiveText: {
                          label: this.props.assistiveText.triggerLearnMoreIcon
                        },
                        size: 'x-small'
                      })
                    )
                  ])
                : o
                  ? (s = [
                      h.React.createElement(lt, {
                        'aria-disabled': !0,
                        assistiveText: {
                          icon: this.props.assistiveText.triggerLearnMoreIcon
                        },
                        iconCategory: 'utility',
                        iconName: 'info',
                        variant: 'icon'
                      })
                    ])
                  : (s = this.props.children),
              h.React.Children.map(s, function (a, l) {
                return h.React.cloneElement(a, {
                  key: l,
                  'aria-describedby': i.getIsOpen() ? i.getId() : void 0,
                  onBlur: i.handleMouseLeave,
                  onFocus: i.handleMouseEnter,
                  onMouseEnter: i.handleMouseEnter,
                  onMouseLeave: i.handleMouseLeave
                })
              })
            )
          }
        },
        {
          key: 'getId',
          value: function () {
            return this.props.id || this.generatedId
          }
        },
        {
          key: 'getIsOpen',
          value: function () {
            return this.props.isOpen === void 0
              ? this.state.isOpen
              : this.props.isOpen
          }
        },
        {
          key: 'getTooltip',
          value: function () {
            var i = this,
              s = this.getIsOpen(),
              o = this.props.align,
              a = this.props.variant === 'error'
            return s
              ? h.React.createElement(
                  YP,
                  {
                    closeOnTabKey: !0,
                    hasNubbin: !0,
                    contentsClassName: se(
                      'slds-popover',
                      'slds-popover_tooltip',
                      { 'slds-theme_error': this.props.theme === 'error' || a },
                      this.props.dialogClassName
                    ),
                    align: o,
                    context: this.context,
                    hasStaticAlignment: this.props.hasStaticAlignment,
                    onClose: this.handleCancel,
                    onRequestTargetElement: function () {
                      return i.getTooltipTarget()
                    },
                    position: this.props.position,
                    variant: 'tooltip',
                    containerProps: { id: this.getId() }
                  },
                  this.getTooltipContent()
                )
              : h.React.createElement('span', null)
          }
        },
        {
          key: 'getTooltipContent',
          value: function () {
            return h.React.createElement(
              'div',
              { className: 'slds-popover__body' },
              this.props.content,
              this.props.variant === 'learnMore' && this.props.onClickTrigger
                ? h.React.createElement(
                    'div',
                    { className: 'slds-m-top_x-small', 'aria-hidden': 'true' },
                    this.props.labels.learnMoreBefore,
                    ' ',
                    h.React.createElement(Ie, {
                      assistiveText: {
                        label: this.props.assistiveText.tooltipTipLearnMoreIcon
                      },
                      category: 'utility',
                      inverse: !0,
                      name: 'info',
                      size: 'x-small'
                    }),
                    ' ',
                    this.props.labels.learnMoreAfter,
                    ' '
                  )
                : null
            )
          }
        },
        {
          key: 'getTooltipTarget',
          value: function () {
            return this.props.onRequestTargetElement
              ? this.props.onRequestTargetElement()
              : this.props.target
                ? this.props.target
                : this.trigger
          }
        },
        {
          key: 'render',
          value: function () {
            var i = LP(
              { display: 'inline-block', lineHeight: '1' },
              this.props.triggerStyle
            )
            return h.React.createElement(
              'div',
              {
                className: se(
                  'slds-tooltip-trigger',
                  this.props.triggerClassName
                ),
                style: i,
                ref: this.saveTriggerRef
              },
              this.getAnchoredNubbinStyles(),
              this.getContent(),
              this.getTooltip()
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
vs.contextType = el
vs.displayName = HP
vs.propTypes = KP
vs.defaultProps = JP
const Pg = vs
function Pf(n) {
  return Object.keys(n).reduce(function (e, t) {
    return t.substr(0, 5) === 'aria-' && (e[t] = n[t]), e
  }, {})
}
function eT(n) {
  return Object.keys(n).reduce(function (e, t) {
    return t.substr(0, 5) === 'data-' && (e[t] = n[t]), e
  }, {})
}
var tT = new Set([
  'form',
  'formAction',
  'formEncType',
  'formMethod',
  'formNoValidate',
  'formTarget'
])
function nT(n) {
  return Object.keys(n).reduce(function (e, t) {
    return tT.has(t) && (e[t] = n[t]), e
  }, {})
}
function To(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (To = function (t) {
          return typeof t
        })
      : (To = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    To(n)
  )
}
function zc() {
  return (
    (zc =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    zc.apply(this, arguments)
  )
}
function bp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function vp(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? bp(Object(t), !0).forEach(function (r) {
          Re(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : bp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function rT(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Sp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function iT(n, e, t) {
  return e && Sp(n.prototype, e), t && Sp(n, t), n
}
function sT(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Fc(n, e)
}
function Fc(n, e) {
  return (
    (Fc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Fc(n, e)
  )
}
function oT(n) {
  var e = lT()
  return function () {
    var r = fa(n),
      i
    if (e) {
      var s = fa(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return aT(this, i)
  }
}
function aT(n, e) {
  return e && (To(e) === 'object' || typeof e == 'function') ? e : or(n)
}
function or(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function lT() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function fa(n) {
  return (
    (fa = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    fa(n)
  )
}
function Re(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var Tg = {
    assistiveText: { icon: '' },
    disabled: !1,
    hint: !1,
    iconSize: 'medium',
    responsive: !1,
    type: 'button',
    variant: 'neutral'
  },
  lt = (function (n) {
    sT(t, n)
    var e = oT(t)
    function t(r) {
      var i
      return (
        rT(this, t),
        (i = e.call(this, r)),
        Re(or(i), 'getClassName', function () {
          var s,
            o = i.props.variant === 'icon',
            a = i.props.iconVariant,
            l = a === 'more',
            c = a === 'border',
            u = a === 'global-header',
            f =
              (i.props.variant !== 'base' &&
                !a &&
                !i.props.inverse &&
                i.props.variant !== 'link') ||
              a === 'bare',
            p = i.props.inverse && !o,
            d = i.props.inverse && o && !l && !c,
            O = i.props.inverse && l,
            g = i.props.inverse && c
          return (
            a === 'global-header' && (a = 'container'),
            se(
              ((s = { 'slds-button': i.props.variant !== 'link' }),
              Re(s, 'slds-button_'.concat(i.props.variant), f),
              Re(s, 'slds-button_inverse', p),
              Re(s, 'slds-button_icon-inverse', d || O),
              Re(s, 'slds-button_icon-border-inverse', g),
              Re(s, 'slds-button_icon-'.concat(a), a && !g),
              Re(s, 'slds-global-header__button_icon', u),
              Re(
                s,
                'slds-button_icon-'.concat(i.props.iconSize),
                a && i.props.iconSize !== 'medium'
              ),
              Re(s, 'slds-button_reset', i.props.variant === 'link'),
              Re(s, 'slds-text-link', i.props.variant === 'link'),
              s),
              i.props.className
            )
          )
        }),
        Re(or(i), 'handleClick', function (s) {
          i.props.onClick && i.props.onClick(s, {})
        }),
        Re(or(i), 'renderIcon', function (s) {
          var o =
            !i.props.iconSize || i.props.iconVariant ? null : i.props.iconSize
          return h.React.createElement(tp, {
            category: i.props.iconCategory || 'utility',
            className: se(
              {
                'slds-global-header__icon':
                  i.props.iconVariant === 'global-header'
              },
              i.props.iconClassName
            ),
            hint: i.props.hint,
            inverse: i.props.inverse,
            name: s,
            path: i.props.iconPath,
            position: i.props.iconPosition,
            size: o
          })
        }),
        Re(or(i), 'renderLabel', function () {
          var s = i.props.iconName || i.props.iconPath,
            o =
              typeof i.props.assistiveText == 'string'
                ? i.props.assistiveText
                : vp(vp({}, Tg.assistiveText), i.props.assistiveText).icon
          return s && o
            ? h.React.createElement(
                'span',
                { className: 'slds-assistive-text' },
                o
              )
            : i.props.label
        }),
        Re(or(i), 'renderButton', function () {
          var s = Pf(i.props),
            o = eT(i.props),
            a = nT(i.props)
          return h.React.createElement(
            'button',
            zc(
              {
                className: i.getClassName(),
                disabled: i.props.disabled,
                id: i.props.id,
                onBlur: i.props.onBlur,
                onClick: i.handleClick,
                onFocus: i.props.onFocus,
                onKeyDown: i.props.onKeyDown,
                onKeyPress: i.props.onKeyPress,
                onKeyUp: i.props.onKeyUp,
                onMouseDown: i.props.onMouseDown,
                onMouseEnter: i.props.onMouseEnter,
                onMouseLeave: i.props.onMouseLeave,
                onMouseUp: i.props.onMouseUp,
                ref: function (c) {
                  i.props.buttonRef && i.props.buttonRef(c),
                    c &&
                      i.props.requestFocus &&
                      i.props.onRequestFocus &&
                      i.props.onRequestFocus(c)
                },
                tabIndex: i.props.tabIndex,
                title: i.props.title,
                type: i.props.type || 'button',
                style: i.props.style
              },
              s,
              o,
              a
            ),
            i.props.iconPosition === 'right' ? i.renderLabel() : null,
            i.props.iconName || i.props.iconPath
              ? i.renderIcon(i.props.iconName)
              : null,
            i.props.iconVariant === 'more'
              ? h.React.createElement(tp, {
                  category: 'utility',
                  name: 'down',
                  size: 'x-small',
                  className: i.props.iconClassName
                })
              : null,
            i.props.iconPosition === 'left' || !i.props.iconPosition
              ? i.renderLabel()
              : null,
            i.props.children
          )
        }),
        Re(or(i), 'renderTooltip', function () {
          return h.React.createElement(
            Pg,
            { content: i.props.tooltip },
            i.renderButton
          )
        }),
        m1(ff, r, v1),
        i
      )
    }
    return (
      iT(t, [
        {
          key: 'render',
          value: function () {
            return this.props.tooltip
              ? this.renderTooltip()
              : this.renderButton()
          }
        }
      ]),
      t
    )
  })(h.React.Component)
Re(lt, 'displayName', ff)
Re(lt, 'propTypes', {
  assistiveText: h.PropTypes.shape({ icon: h.PropTypes.string }),
  buttonRef: h.PropTypes.func,
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  disabled: h.PropTypes.bool,
  hint: h.PropTypes.bool,
  iconCategory: f1(
    h.PropTypes.oneOf(['action', 'custom', 'doctype', 'standard', 'utility']),
    function (n) {
      return !!n.iconName
    }
  ),
  iconClassName: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  iconName: h.PropTypes.string,
  iconPath: h.PropTypes.string,
  iconPosition: h.PropTypes.oneOf(['left', 'right']),
  iconSize: h.PropTypes.oneOf(['x-small', 'small', 'medium', 'large']),
  iconVariant: h.PropTypes.oneOf([
    'bare',
    'container',
    'border',
    'border-filled',
    'brand',
    'more',
    'global-header'
  ]),
  id: h.PropTypes.string,
  inverse: h.PropTypes.bool,
  label: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node]),
  onBlur: h.PropTypes.func,
  onClick: h.PropTypes.func,
  onFocus: h.PropTypes.func,
  onKeyDown: h.PropTypes.func,
  onKeyPress: h.PropTypes.func,
  onKeyUp: h.PropTypes.func,
  onMouseDown: h.PropTypes.func,
  onMouseEnter: h.PropTypes.func,
  onMouseLeave: h.PropTypes.func,
  onMouseUp: h.PropTypes.func,
  onRequestFocus: h.PropTypes.func,
  requestFocus: h.PropTypes.bool,
  responsive: h.PropTypes.bool,
  tabIndex: h.PropTypes.string,
  type: h.PropTypes.oneOf(['reset', 'submit', 'button']),
  title: h.PropTypes.string,
  tooltip: h.PropTypes.node,
  variant: h.PropTypes.oneOf([
    'base',
    'link',
    'neutral',
    'brand',
    'outline-brand',
    'destructive',
    'success',
    'text-destructive',
    'icon'
  ]),
  style: h.PropTypes.object
})
Re(lt, 'defaultProps', Tg)
function xp(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
function Vi() {
  return (
    (Vi =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Vi.apply(this, arguments)
  )
}
function cT(n, e) {
  if (n == null) return {}
  var t = uT(n, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, r) &&
          (t[r] = n[r])
  }
  return t
}
function uT(n, e) {
  if (n == null) return {}
  var t = {},
    r = Object.keys(n),
    i,
    s
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i])
  return t
}
var ol = function (e) {
  var t = e.category,
    r = e.iconPosition,
    i = e.name,
    s = e.path,
    o = e.onClick,
    a = e.variant,
    l = cT(e, [
      'category',
      'iconPosition',
      'name',
      'path',
      'onClick',
      'variant'
    ]),
    c = {
      combobox: h.React.createElement(
        'span',
        {
          className:
            'slds-icon_container slds-input__icon slds-input__icon_right'
        },
        h.React.createElement(
          Ho,
          Vi(
            {
              'aria-hidden': !0,
              category: t,
              className: se(
                'slds-icon slds-icon_x-small slds-icon-text-default'
              ),
              name: i,
              path: s
            },
            l
          )
        )
      ),
      base: h.React.createElement(
        Ho,
        Vi(
          {
            'aria-hidden': !0,
            category: t,
            className: se(
              'slds-input__icon slds-icon-text-default',
              xp({}, 'slds-input__icon_'.concat(r), r)
            ),
            name: i,
            path: s
          },
          l
        )
      )
    }
  return wm(o)
    ? h.React.createElement(
        lt,
        Vi(
          {
            className: se(
              'slds-input__icon',
              xp({}, 'slds-input__icon_'.concat(r), r)
            ),
            iconCategory: t,
            iconName: i,
            iconPath: s,
            onClick: o,
            variant: 'icon'
          },
          l
        )
      )
    : c[a]
}
ol.displayName = Qx
ol.propTypes = {
  category: h.PropTypes.string,
  iconPosition: h.PropTypes.oneOf(['left', 'right']),
  name: h.PropTypes.string,
  path: h.PropTypes.string,
  onClick: h.PropTypes.func,
  variant: h.PropTypes.oneOf(['base', 'combobox'])
}
ol.defaultProps = { category: 'utility', variant: 'base' }
const fT = ol
var $g = function () {}
process.env.NODE_ENV !== 'production' &&
  ($g = function (e, t, r) {
    var i = Fn(r)
    typeof t.assistiveText == 'string' &&
      Qe(
        e,
        t.assistiveText,
        'assistiveText',
        '`assistiveText` as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use `assistiveText.label` instead. '.concat(
          i('assistiveText')
        )
      )
  })
const hT = $g,
  pT = 'spinner',
  dT = 'prod',
  OT = 'Spinner',
  mT = {
    component: pT,
    status: dT,
    'display-name': 'Spinners',
    classKey: OT,
    'SLDS-component-path': '/components/spinner',
    'site-stories': [{ heading: 'Default', path: '/__examples__/default.jsx' }],
    'url-slug': 'spinners'
  }
function wp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function Pp(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? wp(Object(t), !0).forEach(function (r) {
          Qg(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : wp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function Qg(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var gT = {
    assistiveText: h.PropTypes.shape({ label: h.PropTypes.string }),
    containerClassName: h.PropTypes.string,
    containerStyle: h.PropTypes.object,
    hasContainer: h.PropTypes.bool,
    id: h.PropTypes.string,
    isDelayed: h.PropTypes.bool,
    isInput: h.PropTypes.bool,
    isInline: h.PropTypes.bool,
    size: h.PropTypes.oneOf([
      'xx-small',
      'x-small',
      'small',
      'medium',
      'large'
    ]),
    variant: h.PropTypes.oneOf(['base', 'brand', 'inverse'])
  },
  kg = {
    assistiveText: { label: 'Loading...' },
    isDelayed: !1,
    isInline: !1,
    isInput: !1,
    hasContainer: !0,
    size: 'medium',
    variant: 'base'
  },
  al = function (e) {
    hT(Cm, e, mT)
    var t = e.containerClassName,
      r = e.containerStyle,
      i = e.id,
      s = e.isDelayed,
      o = e.isInline,
      a = e.isInput,
      l = e.hasContainer,
      c = e.size,
      u = e.variant,
      f =
        typeof e.assistiveText == 'string'
          ? e.assistiveText
          : Pp(Pp({}, kg.assistiveText), e.assistiveText).label,
      p = se(
        'slds-spinner',
        Qg(
          {
            'slds-spinner_inline': o,
            'slds-input__spinner': a,
            'slds-spinner_brand': u === 'brand',
            'slds-spinner_inverse': u === 'inverse',
            'slds-spinner_delayed': s
          },
          'slds-spinner_'.concat(c),
          c
        )
      ),
      d = h.React.createElement(
        'div',
        { 'aria-hidden': 'false', className: p, id: i, role: 'status' },
        f &&
          h.React.createElement(
            'span',
            { className: 'slds-assistive-text' },
            f
          ),
        h.React.createElement('div', { className: 'slds-spinner__dot-a' }),
        h.React.createElement('div', { className: 'slds-spinner__dot-b' })
      )
    return l
      ? h.React.createElement(
          'div',
          { className: se(t, 'slds-spinner_container'), style: r },
          d
        )
      : d
  }
al.displayName = Cm
al.propTypes = gT
al.defaultProps = kg
const yT = al
function ha() {
  return (
    (ha =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    ha.apply(this, arguments)
  )
}
function Tp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function $p(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? Tp(Object(t), !0).forEach(function (r) {
          bT(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : Tp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function bT(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
function vT(n, e) {
  if (n == null) return {}
  var t = ST(n, e),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (i = 0; i < s.length; i++)
      (r = s[i]),
        !(e.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(n, r) &&
          (t[r] = n[r])
  }
  return t
}
function ST(n, e) {
  if (n == null) return {}
  var t = {},
    r = Object.keys(n),
    i,
    s
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i])
  return t
}
var Ei = 'counter',
  xT = {
    'aria-activedescendant': h.PropTypes.string,
    'aria-autocomplete': h.PropTypes.string,
    'aria-controls': h.PropTypes.string,
    'aria-describedby': h.PropTypes.string,
    'aria-expanded': h.PropTypes.bool,
    'aria-haspopup': h.PropTypes.oneOfType([
      h.PropTypes.bool,
      h.PropTypes.string
    ]),
    'aria-labelledby': h.PropTypes.string,
    'aria-owns': h.PropTypes.string,
    'aria-required': h.PropTypes.bool,
    assistiveText: h.PropTypes.shape({ spinner: h.PropTypes.string }),
    autoComplete: h.PropTypes.string,
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    containerClassName: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    containerProps: h.PropTypes.object,
    disabled: h.PropTypes.bool,
    fixedTextLeft: h.PropTypes.oneOfType([
      h.PropTypes.node,
      h.PropTypes.string
    ]),
    fixedTextRight: h.PropTypes.oneOfType([
      h.PropTypes.node,
      h.PropTypes.string
    ]),
    hasSpinner: h.PropTypes.bool,
    iconLeft: h.PropTypes.node,
    iconRight: h.PropTypes.node,
    id: h.PropTypes.string.isRequired,
    inputRef: h.PropTypes.func,
    isStatic: h.PropTypes.bool,
    label: h.PropTypes.string,
    onBlur: h.PropTypes.func,
    onChange: h.PropTypes.func,
    onClick: h.PropTypes.func,
    onFocus: h.PropTypes.func,
    onInput: h.PropTypes.func,
    onInvalid: h.PropTypes.func,
    onKeyDown: h.PropTypes.func,
    onKeyPress: h.PropTypes.func,
    onKeyUp: h.PropTypes.func,
    onSelect: h.PropTypes.func,
    onSubmit: h.PropTypes.func,
    placeholder: h.PropTypes.string,
    minLength: h.PropTypes.string,
    minValue: h.PropTypes.number,
    maxLength: h.PropTypes.string,
    maxValue: h.PropTypes.number,
    name: h.PropTypes.string,
    readOnly: h.PropTypes.bool,
    required: h.PropTypes.bool,
    role: h.PropTypes.string,
    step: h.PropTypes.number,
    style: h.PropTypes.object,
    tabIndex: h.PropTypes.string,
    type: h.PropTypes.oneOf([
      'text',
      'password',
      'datetime',
      'datetime-local',
      'date',
      'month',
      'time',
      'week',
      'number',
      'email',
      'url',
      'search',
      'tel',
      'color'
    ]),
    value: h.PropTypes.oneOfType([h.PropTypes.number, h.PropTypes.string]),
    variant: h.PropTypes.oneOf(['base', Ei]),
    defaultValue: h.PropTypes.oneOfType([
      h.PropTypes.number,
      h.PropTypes.string
    ])
  },
  Cg = { assistiveText: { spinner: 'Loading ...' }, type: 'text' },
  ll = function (e) {
    var t = Pf(e)
    t['aria-describedby'] = e.hasSpinner
      ? 'loading-status-icon '.concat(e['aria-describedby'])
      : e['aria-describedby']
    var r = e.containerProps,
      i = r.className,
      s = vT(r, ['className']),
      o = $p($p({}, Cg.assistiveText), e.assistiveText)
    return h.React.createElement(
      'div',
      ha(
        {
          className: se(i, {
            'slds-input-has-icon':
              e.variant !== Ei && (e.iconLeft || e.iconRight),
            'slds-input-has-icon_left': e.iconLeft && !e.iconRight,
            'slds-input-has-icon_right': !e.iconLeft && e.iconRight,
            'slds-input-has-icon_left-right':
              e.variant !== Ei && e.iconLeft && e.iconRight,
            'slds-input-has-fixed-addon': e.fixedTextLeft || e.fixedTextRight,
            'slds-has-divider_bottom': e.isStatic
          })
        },
        s
      ),
      e.iconLeft && e.iconLeft,
      e.fixedTextLeft &&
        h.React.createElement(
          'span',
          { className: 'slds-form-element__addon' },
          e.fixedTextLeft
        ),
      !e.isStatic &&
        h.React.createElement(
          'input',
          ha(
            {
              autoComplete: e.autoComplete,
              className: se(
                'slds-input',
                { 'slds-text-align_left': e.variant === Ei && e.readOnly },
                e.className
              ),
              disabled: e.disabled,
              id: e.id,
              min: e.minValue,
              minLength: e.minLength,
              max: e.maxValue,
              maxLength: e.maxLength,
              name: e.name,
              onBlur: e.onBlur,
              onChange: e.onChange,
              onClick: e.onClick,
              onFocus: e.onFocus,
              onInput: e.onInput,
              onInvalid: e.onInvalid,
              onKeyDown: e.onKeyDown,
              onKeyPress: e.onKeyPress,
              onKeyUp: e.onKeyUp,
              onSelect: e.onSelect,
              onSubmit: e.onSubmit,
              placeholder: e.placeholder,
              readOnly: e.readOnly,
              ref: e.inputRef,
              required: e.required,
              role: e.role,
              step: e.step,
              style: e.style,
              tabIndex: e.tabIndex,
              type: e.type
            },
            t,
            e.value !== void 0
              ? { value: e.value }
              : { defaultValue: e.defaultValue }
          )
        ),
      e.hasSpinner
        ? h.React.createElement(
            'div',
            {
              className: 'slds-input__icon-group slds-input__icon-group_right'
            },
            h.React.createElement(yT, {
              assistiveText: { label: o.spinner },
              id: 'loading-status-icon',
              isInput: !0,
              size: 'x-small',
              variant: 'brand'
            }),
            e.iconRight && e.iconRight
          )
        : e.iconRight && e.iconRight,
      e.fixedTextRight &&
        h.React.createElement(
          'span',
          { className: 'slds-form-element__addon' },
          e.fixedTextRight
        ),
      e.isStatic &&
        h.React.createElement(
          'span',
          {
            className: se('slds-form-element__static', 'slds-grid', {
              'slds-grid_align-spread': e.variant !== Ei
            }),
            onClick: e.onClick
          },
          e.value,
          e.inlineEditTrigger
        )
    )
  }
ll.displayName = 'SLDSInnerInput'
ll.propTypes = xT
ll.defaultProps = Cg
const wT = ll
var PT = {
    assistiveText: h.PropTypes.object,
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    htmlFor: h.PropTypes.string,
    label: h.PropTypes.string,
    required: h.PropTypes.bool,
    variant: h.PropTypes.oneOf(['base', 'static'])
  },
  TT = { variant: 'base' },
  cl = function (e) {
    var t = e.label || (e.assistiveText && e.assistiveText.label),
      r = {
        base: h.React.createElement(
          'label',
          {
            className: se(
              'slds-form-element__label',
              { 'slds-assistive-text': e.assistiveText && !e.label },
              e.className
            ),
            htmlFor: e.htmlFor
          },
          e.required &&
            h.React.createElement(
              'abbr',
              { className: 'slds-required', title: 'required' },
              '*'
            ),
          t
        ),
        static: h.React.createElement(
          'span',
          { className: se('slds-form-element__label', e.className) },
          t
        )
      }
    return t ? r[e.variant] : null
  }
cl.displayName = 'Label'
cl.propTypes = PT
cl.defaultProps = TT
const $T = cl
var _g = function () {}
if (process.env.NODE_ENV !== 'production') {
  var Qp = {}
  _g = function (e, t, r) {
    var i = r ? ' '.concat(r) : '',
      s = Object.keys(t)
    ;(s = s.filter(function (o) {
      return t[o]
    })),
      Qp[e] ||
        (yr(
          s.length <= 1,
          '[Design System React] Only one of the following props is needed by '
            .concat(e, ': [')
            .concat(s.join(), '].')
            .concat(i)
        ),
        (Qp[e] = !!t))
  }
}
const Gc = _g
var Rg = function () {}
process.env.NODE_ENV !== 'production' &&
  (Rg = function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      r = arguments.length > 2 ? arguments[2] : void 0,
      i = Fn(r)
    if (e === Ka) {
      var s =
        'Please use `iconLeft` and `iconRight` to pass in a customized <Icon> component. '.concat(
          i()
        )
      mn(
        e,
        t.assistiveText && t.assistiveText.fieldLevelHelpButton,
        'assistiveText.fieldLevelHelpButton',
        void 0,
        'Please pass a `Tooltip` component into `fieldLevelHelpTooltip` with `assistiveText.triggerLearnMoreIcon`.'
      ),
        mn(e, t.iconCategory, 'iconCategory', void 0, s),
        mn(e, t.iconName, 'iconName', void 0, s),
        mn(e, t.iconPosition, 'iconPosition', void 0, s),
        mn(e, t.iconAssistiveText, 'iconAssistiveText', void 0, s),
        mn(e, t.onIconClick, 'onIconClick', void 0, s),
        typeof t.assistiveText == 'string' &&
          Qe(
            e,
            t.assistiveText,
            'assistiveText',
            'AssistiveText as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use either assistiveText.label or assistiveText.spinner. '.concat(
              i('assistiveText')
            )
          ),
        Gc(
          e,
          {
            'assistiveText.label': t.assistiveText && t.assistiveText.label,
            label: t.label
          },
          i('assistiveText')
        ),
        Gc(
          e,
          { fixedTextLeft: t.fixedTextLeft, fixedTextRight: t.fixedTextRight },
          i('assistiveText')
        )
    } else
      e === Tx &&
        typeof t.assistiveText == 'string' &&
        Qe(
          e,
          t.assistiveText,
          'assistiveText',
          '`assistiveText` as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use `assistiveText.label` instead. '.concat(
            i('assistiveText')
          )
        )
  })
const QT = Rg,
  kT = 'input',
  CT = 'prod',
  _T = 'Input',
  RT = [{ component: 'search', classKey: 'InputSearch' }],
  ZT = {
    component: kT,
    status: CT,
    'display-name': 'Inputs',
    classKey: _T,
    'last-accessibility-review': {
      'date-iso-8601': '2017/09/22',
      'commit-sha': 'ad6b6c6523ee21cada11be5f7ea4d99abc530726'
    },
    dependencies: RT,
    'SLDS-component-path': '/components/input',
    'site-stories': [
      { heading: 'Default', path: '/__examples__/default.jsx' },
      { heading: 'With Icons', path: '/__examples__/icons.jsx' },
      { heading: 'Error State', path: '/__examples__/error.jsx' },
      { heading: 'Disabled', path: '/__examples__/inactiveInputs.jsx' },
      { heading: 'With Inline Help', path: '/__examples__/inline-help.jsx' },
      {
        heading: 'With Field Level Help',
        path: '/__examples__/field-level-help.jsx'
      },
      { heading: 'Counter', path: '/__examples__/counter-input.jsx' }
    ],
    'url-slug': 'inputs'
  }
var AT = function (e) {
    var t = {}
    return (
      Object.keys(e).forEach(function (r) {
        typeof e[r] < 'u' && (t[r] = e[r])
      }),
      t
    )
  },
  ET = { removeUndefined: AT }
const DT = ET
function kp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function xi(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? kp(Object(t), !0).forEach(function (r) {
          XT(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : kp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function XT(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var YT = {
    assistiveText: h.PropTypes.shape({
      triggerLearnMoreIcon: h.PropTypes.string
    }),
    fieldLevelHelpTooltip: h.PropTypes.node.isRequired
  },
  IT = {
    triggerClassName: 'slds-form-element__icon',
    triggerStyle: { position: 'static' },
    variant: 'learnMore'
  },
  Tf = function (e) {
    var t = e.fieldLevelHelpTooltip,
      r = e.assistiveText,
      i = r === void 0 ? {} : r
    return t
      ? h.React.createElement(
          Pg,
          xi(
            xi(xi({}, IT), t.props),
            {},
            {
              assistiveText: xi(
                xi({}, t.props.assistiveText),
                DT.removeUndefined(i)
              )
            }
          )
        )
      : null
  }
Tf.propTypes = YT
Tf.displayName = 'FieldLevelHelpTooltip'
const jT = Tf
function $o(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? ($o = function (t) {
          return typeof t
        })
      : ($o = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    $o(n)
  )
}
function Cp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function _p(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? Cp(Object(t), !0).forEach(function (r) {
          dt(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : Cp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function Hc() {
  return (
    (Hc =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Hc.apply(this, arguments)
  )
}
function NT(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Rp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function MT(n, e, t) {
  return e && Rp(n.prototype, e), t && Rp(n, t), n
}
function VT(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && Kc(n, e)
}
function Kc(n, e) {
  return (
    (Kc =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    Kc(n, e)
  )
}
function WT(n) {
  var e = BT()
  return function () {
    var r = pa(n),
      i
    if (e) {
      var s = pa(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return LT(this, i)
  }
}
function LT(n, e) {
  return e && ($o(e) === 'object' || typeof e == 'function') ? e : Lt(n)
}
function Lt(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function BT() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function pa(n) {
  return (
    (pa = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    pa(n)
  )
}
function dt(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var Ut = 'counter',
  Cn = 'Decrement',
  Di = 'Increment',
  Zg = {
    assistiveText: {
      decrement: ''.concat(Cn, ' ').concat(Ut),
      increment: ''.concat(Di, ' ').concat(Ut)
    },
    type: 'text'
  },
  ul = (function (n) {
    VT(t, n)
    var e = WT(t)
    function t(r) {
      var i
      return (
        NT(this, t),
        (i = e.call(this, r)),
        dt(Lt(i), 'getId', function () {
          return i.props.id || i.generatedId
        }),
        dt(Lt(i), 'getErrorId', function () {
          return i.props['aria-describedby'] || i.generatedErrorId
        }),
        dt(Lt(i), 'getValueAsNumber', function () {
          var s = 0
          return (
            i.props.value !== void 0
              ? (s = Number(i.props.value))
              : i.inputRef && (s = Number(i.inputRef.value)),
            s
          )
        }),
        dt(Lt(i), 'getCounterButtonIcon', function (s) {
          var o = i.getValueAsNumber(),
            a = !1
          return (
            (i.props.disabled ||
              (s === Di &&
                i.props.maxValue !== void 0 &&
                o >= i.props.maxValue) ||
              (s === Cn &&
                i.props.minValue !== void 0 &&
                o <= i.props.minValue)) &&
              (a = !0),
            h.React.createElement(lt, {
              assistiveText: { icon: i.props.assistiveText[s.toLowerCase()] },
              className: se(
                'slds-button_icon-small',
                'slds-input__button_'.concat(s.toLowerCase())
              ),
              disabled: a,
              iconCategory: 'utility',
              iconName: s === Cn ? 'ban' : 'new',
              onKeyDown: function (c) {
                c.keyCode === 13 && i.performStep(s, c)
              },
              onKeyUp: i.stopStepping,
              onMouseDown: function (c) {
                i.performStep(s, c)
              },
              onMouseLeave: i.stopStepping,
              onMouseUp: i.stopStepping,
              variant: 'icon'
            })
          )
        }),
        dt(Lt(i), 'getIconRender', function (s, o) {
          var a,
            l = {
              assistiveText: {
                icon:
                  (i.props[o] && i.props[o].props.assistiveText) ||
                  i.props.iconAssistiveText
              },
              category:
                (i.props[o] && i.props[o].props.category) ||
                i.props.iconCategory,
              name: (i.props[o] && i.props[o].props.name) || i.props.iconName,
              onClick:
                (i.props[o] && i.props[o].props.onClick) || i.props.onIconClick
            }
          return (
            i.props[o] && s && i.props[o]
              ? (a = h.React.cloneElement(i.props[o], {
                  iconPosition: ''.concat(s)
                }))
              : l.name &&
                (a = h.React.createElement(fT, Hc({ iconPosition: s }, l))),
            a
          )
        }),
        dt(Lt(i), 'setInputRef', function (s) {
          ;(i.inputRef = s), i.props.inputRef && i.props.inputRef(s)
        }),
        dt(Lt(i), 'handleChange', function (s) {
          if (i.props.onChange) {
            var o = { value: s.target.value }
            i.props.variant === Ut && (o.number = Number(o.value)),
              i.props.onChange(s, o)
          }
        }),
        dt(Lt(i), 'performStep', function (s, o) {
          clearTimeout(i.stepping.timeout)
          var a = i.props.maxValue,
            l = i.props.minValue,
            c = i.props.step !== void 0 ? Number(i.props.step) : 1,
            u = i.getValueAsNumber(),
            f = !1
          if (s === Cn && a !== void 0 && u > a) (u = Number(a)), (f = !0)
          else if (s === Di && l !== void 0 && u < l) (u = Number(l)), (f = !0)
          else {
            var p =
                String(c).search(/\./) >= 0
                  ? String(c).split('.')[1].length
                  : 0,
              d = 0
            l !== void 0 && (d = (u - l) % c),
              d > 0
                ? (u = s === Cn ? u - d : u + (c - d))
                : (u = s === Cn ? u - c : u + c),
              (u = Number(u.toFixed(p))),
              !(a !== void 0 && u > a) && !(l !== void 0 && u < l) && (f = !0)
          }
          f &&
            (i.props.value === void 0 && i.inputRef
              ? ((i.inputRef.value = String(u)), i.forceUpdate())
              : i.props.onChange &&
                i.props.onChange(o, { number: u, value: String(u) })),
            (s === Di && a !== void 0 && u >= a) ||
            (s === Cn && l !== void 0 && u <= l)
              ? i.stopStepping()
              : (i.stepping.timeout = setTimeout(function () {
                  ;(i.stepping.currentDelay = i.stepping.speedDelay),
                    i.performStep(s)
                }, i.stepping.currentDelay))
        }),
        dt(Lt(i), 'stopStepping', function () {
          clearTimeout(i.stepping.timeout),
            (i.stepping.currentDelay = i.stepping.initialDelay)
        }),
        (i.inputRef = null),
        (i.stepping = {
          currentDelay: 500,
          initialDelay: 500,
          speedDelay: 75,
          timeout: {}
        }),
        QT(Ka, r, ZT),
        (i.generatedId = dr.generate()),
        r.errorText && (i.generatedErrorId = dr.generate()),
        i
      )
    }
    return (
      MT(t, [
        {
          key: 'render',
          value: function () {
            var i = _p(_p({}, Zg.assistiveText), this.props.assistiveText),
              s =
                this.props.variant === Ut
                  ? this.setInputRef
                  : this.props.inputRef,
              o = null,
              a = null,
              l = this.props.label || (i && i.label)
            return (
              this.props.iconLeft ||
              ((this.props.iconPosition === 'left' ||
                this.props.iconPosition === void 0) &&
                this.props.iconName)
                ? (o = this.getIconRender('left', 'iconLeft'))
                : this.props.variant === Ut &&
                  !this.props.isStatic &&
                  !this.props.readOnly &&
                  (o = this.getCounterButtonIcon(Cn)),
              this.props.iconRight ||
              (this.props.iconPosition === 'right' && this.props.iconName)
                ? (a = this.getIconRender('right', 'iconRight'))
                : this.props.variant === Ut &&
                  !this.props.isStatic &&
                  !this.props.readOnly &&
                  (a = this.getCounterButtonIcon(Di)),
              h.React.createElement(
                'div',
                {
                  className: se(
                    'slds-form-element',
                    { 'slds-has-error': this.props.errorText },
                    this.props.className
                  ),
                  style: this.props.styleContainer
                },
                h.React.createElement($T, {
                  assistiveText: i,
                  htmlFor: this.props.isStatic ? void 0 : this.getId(),
                  label: this.props.label,
                  required: this.props.required,
                  variant: this.props.isStatic ? 'static' : 'base'
                }),
                this.props.fieldLevelHelpTooltip && l
                  ? h.React.createElement(jT, {
                      assistiveText: {
                        triggerLearnMoreIcon: i.fieldLevelHelpButton
                      },
                      fieldLevelHelpTooltip: this.props.fieldLevelHelpTooltip
                    })
                  : null,
                h.React.createElement(wT, {
                  'aria-activedescendant': this.props['aria-activedescendant'],
                  'aria-autocomplete': this.props['aria-autocomplete'],
                  'aria-controls': this.props['aria-controls'],
                  'aria-labelledby': this.props['aria-labelledby'],
                  'aria-describedby': this.getErrorId(),
                  'aria-expanded': this.props['aria-expanded'],
                  'aria-owns': this.props['aria-owns'],
                  'aria-required': this.props['aria-required'],
                  autoComplete: this.props.autoComplete,
                  className: se({
                    'slds-input_counter': this.props.variant === Ut,
                    'slds-p-horizontal_none':
                      this.props.variant === Ut && this.props.readOnly
                  }),
                  containerProps: { className: 'slds-form-element__control' },
                  defaultValue: this.props.defaultValue,
                  disabled: this.props.disabled,
                  fixedTextLeft: this.props.fixedTextLeft,
                  fixedTextRight: this.props.fixedTextRight,
                  hasSpinner: this.props.hasSpinner,
                  id: this.getId(),
                  iconLeft: o,
                  iconRight: a,
                  inlineEditTrigger: this.props.inlineEditTrigger,
                  isStatic: this.props.isStatic,
                  minLength: this.props.minLength,
                  minValue: this.props.minValue,
                  maxLength: this.props.maxLength,
                  maxValue: this.props.maxValue,
                  name: this.props.name,
                  onBlur: this.props.onBlur,
                  onChange: this.handleChange,
                  onClick: this.props.onClick,
                  onFocus: this.props.onFocus,
                  onInput: this.props.onInput,
                  onInvalid: this.props.onInvalid,
                  onKeyDown: this.props.onKeyDown,
                  onKeyPress: this.props.onKeyPress,
                  onKeyUp: this.props.onKeyUp,
                  onSelect: this.props.onSelect,
                  onSubmit: this.props.onSubmit,
                  placeholder: this.props.placeholder,
                  inputRef: s,
                  readOnly: this.props.readOnly,
                  required: this.props.required,
                  role: this.props.role,
                  assistiveText: this.props.assistiveText,
                  type: this.props.variant === Ut ? 'number' : this.props.type,
                  value: this.props.value,
                  variant: this.props.variant,
                  step: this.props.step,
                  style: this.props.styleInput
                }),
                this.props.inlineHelpText &&
                  h.React.createElement(
                    'div',
                    { className: 'slds-form-element__help' },
                    this.props.inlineHelpText
                  ),
                this.props.errorText &&
                  h.React.createElement(
                    'div',
                    {
                      id: this.getErrorId(),
                      className: 'slds-form-element__help'
                    },
                    this.props.errorText
                  ),
                this.props.children
              )
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
dt(ul, 'displayName', Ka)
dt(ul, 'propTypes', {
  'aria-activedescendant': h.PropTypes.string,
  'aria-autocomplete': h.PropTypes.string,
  'aria-controls': h.PropTypes.string,
  'aria-describedby': h.PropTypes.string,
  'aria-expanded': h.PropTypes.bool,
  'aria-haspopup': h.PropTypes.bool,
  'aria-labelledby': h.PropTypes.string,
  'aria-owns': h.PropTypes.string,
  'aria-required': h.PropTypes.bool,
  assistiveText: h.PropTypes.shape({
    label: h.PropTypes.string,
    spinner: h.PropTypes.string
  }),
  autoComplete: h.PropTypes.string,
  children: h.PropTypes.node,
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  defaultValue: h.PropTypes.oneOfType([h.PropTypes.number, h.PropTypes.string]),
  disabled: h.PropTypes.bool,
  errorText: h.PropTypes.oneOfType([h.PropTypes.node, h.PropTypes.string]),
  fieldLevelHelpTooltip: h.PropTypes.node,
  fixedTextLeft: h.PropTypes.oneOfType([h.PropTypes.node, h.PropTypes.string]),
  fixedTextRight: h.PropTypes.oneOfType([h.PropTypes.node, h.PropTypes.string]),
  hasSpinner: h.PropTypes.bool,
  iconLeft: h.PropTypes.node,
  iconRight: h.PropTypes.node,
  id: h.PropTypes.string,
  inlineHelpText: h.PropTypes.oneOfType([h.PropTypes.node, h.PropTypes.string]),
  inputRef: h.PropTypes.func,
  isStatic: h.PropTypes.bool,
  label: h.PropTypes.string,
  onBlur: h.PropTypes.func,
  onChange: h.PropTypes.func,
  onClick: h.PropTypes.func,
  onFocus: h.PropTypes.func,
  onInput: h.PropTypes.func,
  onInvalid: h.PropTypes.func,
  onKeyDown: h.PropTypes.func,
  onKeyPress: h.PropTypes.func,
  onKeyUp: h.PropTypes.func,
  onSelect: h.PropTypes.func,
  onSubmit: h.PropTypes.func,
  placeholder: h.PropTypes.string,
  minLength: h.PropTypes.string,
  minValue: h.PropTypes.number,
  maxLength: h.PropTypes.string,
  maxValue: h.PropTypes.number,
  name: h.PropTypes.string,
  readOnly: h.PropTypes.bool,
  required: h.PropTypes.bool,
  role: h.PropTypes.string,
  step: h.PropTypes.number,
  styleInput: h.PropTypes.object,
  styleContainer: h.PropTypes.object,
  type: h.PropTypes.oneOf([
    'text',
    'password',
    'datetime',
    'datetime-local',
    'date',
    'month',
    'time',
    'week',
    'number',
    'email',
    'url',
    'search',
    'tel',
    'color'
  ]),
  value: h.PropTypes.oneOfType([h.PropTypes.number, h.PropTypes.string]),
  variant: h.PropTypes.oneOf(['base', Ut])
})
dt(ul, 'defaultProps', Zg)
var Ag = function () {}
process.env.NODE_ENV !== 'production' &&
  (Ag = function (e, t, r) {
    var i = Fn(r)
    Gc(e, { assistiveText: t.assistiveText, label: t.label }, i()),
      typeof t.assistiveText == 'string' &&
        Qe(
          e,
          t.assistiveText,
          'assistiveText',
          '`assistiveText` as a string has been deprecated and is now an object to allow for multiple uses in the component. Please use `assistiveText.label` instead. '.concat(
            i('assistiveText')
          )
        )
  })
const UT = Ag,
  qT = 'textarea',
  zT = 'prod',
  FT = 'Textarea',
  GT = {
    component: qT,
    status: zT,
    'display-name': 'Textareas',
    classKey: FT,
    'SLDS-component-path': '/components/forms#flavor-textarea',
    'site-stories': [
      { heading: 'Default', path: '/__examples__/default.jsx' },
      { heading: 'Error', path: '/__examples__/error.jsx' },
      { heading: 'Disabled', path: '/__examples__/disabled.jsx' }
    ],
    'url-slug': 'textareas'
  }
function Qo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Qo = function (t) {
          return typeof t
        })
      : (Qo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Qo(n)
  )
}
function Jc() {
  return (
    (Jc =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    Jc.apply(this, arguments)
  )
}
function Zp(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n)
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function HT(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? Zp(Object(t), !0).forEach(function (r) {
          qi(n, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : Zp(Object(t)).forEach(function (r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
          })
  }
  return n
}
function KT(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Ap(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function JT(n, e, t) {
  return e && Ap(n.prototype, e), t && Ap(n, t), n
}
function e$(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && eu(n, e)
}
function eu(n, e) {
  return (
    (eu =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    eu(n, e)
  )
}
function t$(n) {
  var e = r$()
  return function () {
    var r = da(n),
      i
    if (e) {
      var s = da(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return n$(this, i)
  }
}
function n$(n, e) {
  return e && (Qo(e) === 'object' || typeof e == 'function') ? e : tu(n)
}
function tu(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function r$() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function da(n) {
  return (
    (da = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    da(n)
  )
}
function qi(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var $f = (function (n) {
  e$(t, n)
  var e = t$(t)
  function t(r) {
    var i
    return (
      KT(this, t),
      (i = e.call(this, r)),
      qi(tu(i), 'getId', function () {
        return i.props.id || i.generatedId
      }),
      qi(tu(i), 'getErrorId', function () {
        return i.props['aria-describedby'] || i.generatedErrorId
      }),
      UT($m, r, GT),
      (i.generatedId = dr.generate()),
      r.errorText && (i.generatedErrorId = dr.generate()),
      i
    )
  }
  return (
    JT(t, [
      {
        key: 'render',
        value: function () {
          var i = this.props,
            s = i.autoFocus,
            o = i.children,
            a = i.className,
            l = i.classNameContainer,
            c = i.disabled,
            u = i.errorText,
            f = i.textareaRef,
            p = i.label,
            d = i.onBlur,
            O = i.onChange,
            g = i.onClick,
            b = i.onFocus,
            x = i.onInput,
            w = i.onInvalid,
            Q = i.onKeyDown,
            T = i.onKeyPress,
            P = i.onKeyUp,
            k = i.onSelect,
            R = i.onSubmit,
            V = i.maxLength,
            D = i.name,
            L = i.placeholder,
            B = i.required,
            A = i.role,
            Y = i.value,
            W = i.defaultValue,
            K = i.wrap,
            te = Pf(this.props),
            J =
              typeof this.props.assistiveText == 'string'
                ? this.props.assistiveText
                : HT({}, this.props.assistiveText).label,
            ae = p || J
          return h.React.createElement(
            'div',
            { className: se('slds-form-element', { 'slds-has-error': u }, l) },
            ae &&
              h.React.createElement(
                'label',
                {
                  className: se('slds-form-element__label', {
                    'slds-assistive-text': J && !p
                  }),
                  htmlFor: this.getId()
                },
                B &&
                  h.React.createElement(
                    'abbr',
                    { className: 'slds-required', title: 'required' },
                    '*'
                  ),
                ae
              ),
            h.React.createElement(
              'div',
              { className: se('slds-form-element__control') },
              h.React.createElement(
                'textarea',
                Jc(
                  {
                    className: se('slds-textarea', a),
                    autoFocus: s,
                    disabled: c,
                    id: this.getId(),
                    maxLength: V,
                    name: D,
                    onBlur: d,
                    onChange: O,
                    onClick: g,
                    onFocus: b,
                    onInput: x,
                    onInvalid: w,
                    onKeyDown: Q,
                    onKeyPress: T,
                    onKeyUp: P,
                    onSelect: k,
                    onSubmit: R,
                    placeholder: L,
                    ref: f,
                    role: A,
                    required: B,
                    wrap: K,
                    value: Y,
                    defaultValue: W
                  },
                  te
                )
              )
            ),
            u &&
              h.React.createElement(
                'div',
                { id: this.getErrorId(), className: 'slds-form-element__help' },
                u
              ),
            o
          )
        }
      }
    ]),
    t
  )
})(h.React.Component)
qi($f, 'displayName', $m)
qi($f, 'propTypes', {
  assistiveText: h.PropTypes.shape({ label: h.PropTypes.string }),
  'aria-activedescendant': h.PropTypes.string,
  'aria-autocomplete': h.PropTypes.string,
  'aria-controls': h.PropTypes.string,
  'aria-describedby': h.PropTypes.string,
  'aria-expanded': h.PropTypes.bool,
  'aria-haspopup': h.PropTypes.bool,
  'aria-labelledby': h.PropTypes.string,
  'aria-owns': h.PropTypes.string,
  'aria-required': h.PropTypes.bool,
  autoFocus: h.PropTypes.bool,
  children: h.PropTypes.node,
  className: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  classNameContainer: h.PropTypes.oneOfType([
    h.PropTypes.array,
    h.PropTypes.object,
    h.PropTypes.string
  ]),
  disabled: h.PropTypes.bool,
  errorText: h.PropTypes.string,
  id: h.PropTypes.string,
  textareaRef: h.PropTypes.func,
  label: h.PropTypes.string,
  onBlur: h.PropTypes.func,
  onChange: h.PropTypes.func,
  onClick: h.PropTypes.func,
  onFocus: h.PropTypes.func,
  onInput: h.PropTypes.func,
  onInvalid: h.PropTypes.func,
  onKeyDown: h.PropTypes.func,
  onKeyPress: h.PropTypes.func,
  onKeyUp: h.PropTypes.func,
  onSelect: h.PropTypes.func,
  onSubmit: h.PropTypes.func,
  maxLength: h.PropTypes.string,
  name: h.PropTypes.string,
  placeholder: h.PropTypes.string,
  required: h.PropTypes.bool,
  value: h.PropTypes.string,
  defaultValue: h.PropTypes.string,
  wrap: h.PropTypes.oneOf(['soft', 'hard'])
})
const Ep = (n) => {
    let e
    const t = new Set(),
      r = (l, c) => {
        const u = typeof l == 'function' ? l(e) : l
        if (!Object.is(u, e)) {
          const f = e
          ;(e = c ?? typeof u != 'object' ? u : Object.assign({}, e, u)),
            t.forEach((p) => p(e, f))
        }
      },
      i = () => e,
      a = {
        setState: r,
        getState: i,
        subscribe: (l) => (t.add(l), () => t.delete(l)),
        destroy: () => {
          t.clear()
        }
      }
    return (e = n(r, i, a)), a
  },
  i$ = (n) => (n ? Ep(n) : Ep)
var nu = { exports: {} },
  ql = {},
  Ls = { exports: {} },
  zl = {}
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Dp
function s$() {
  if (Dp) return zl
  Dp = 1
  var n = h.reactExports
  function e(f, p) {
    return (f === p && (f !== 0 || 1 / f === 1 / p)) || (f !== f && p !== p)
  }
  var t = typeof Object.is == 'function' ? Object.is : e,
    r = n.useState,
    i = n.useEffect,
    s = n.useLayoutEffect,
    o = n.useDebugValue
  function a(f, p) {
    var d = p(),
      O = r({ inst: { value: d, getSnapshot: p } }),
      g = O[0].inst,
      b = O[1]
    return (
      s(
        function () {
          ;(g.value = d), (g.getSnapshot = p), l(g) && b({ inst: g })
        },
        [f, d, p]
      ),
      i(
        function () {
          return (
            l(g) && b({ inst: g }),
            f(function () {
              l(g) && b({ inst: g })
            })
          )
        },
        [f]
      ),
      o(d),
      d
    )
  }
  function l(f) {
    var p = f.getSnapshot
    f = f.value
    try {
      var d = p()
      return !t(f, d)
    } catch {
      return !0
    }
  }
  function c(f, p) {
    return p()
  }
  var u =
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
      ? c
      : a
  return (
    (zl.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : u),
    zl
  )
}
var Fl = {}
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Xp
function o$() {
  return (
    Xp ||
      ((Xp = 1),
      process.env.NODE_ENV !== 'production' &&
        (function () {
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ==
              'function' &&
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(
              new Error()
            )
          var n = h.reactExports,
            e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
          function t(Q) {
            {
              for (
                var T = arguments.length,
                  P = new Array(T > 1 ? T - 1 : 0),
                  k = 1;
                k < T;
                k++
              )
                P[k - 1] = arguments[k]
              r('error', Q, P)
            }
          }
          function r(Q, T, P) {
            {
              var k = e.ReactDebugCurrentFrame,
                R = k.getStackAddendum()
              R !== '' && ((T += '%s'), (P = P.concat([R])))
              var V = P.map(function (D) {
                return String(D)
              })
              V.unshift('Warning: ' + T),
                Function.prototype.apply.call(console[Q], console, V)
            }
          }
          function i(Q, T) {
            return (
              (Q === T && (Q !== 0 || 1 / Q === 1 / T)) || (Q !== Q && T !== T)
            )
          }
          var s = typeof Object.is == 'function' ? Object.is : i,
            o = n.useState,
            a = n.useEffect,
            l = n.useLayoutEffect,
            c = n.useDebugValue,
            u = !1,
            f = !1
          function p(Q, T, P) {
            u ||
              (n.startTransition !== void 0 &&
                ((u = !0),
                t(
                  'You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.'
                )))
            var k = T()
            if (!f) {
              var R = T()
              s(k, R) ||
                (t(
                  'The result of getSnapshot should be cached to avoid an infinite loop'
                ),
                (f = !0))
            }
            var V = o({ inst: { value: k, getSnapshot: T } }),
              D = V[0].inst,
              L = V[1]
            return (
              l(
                function () {
                  ;(D.value = k), (D.getSnapshot = T), d(D) && L({ inst: D })
                },
                [Q, k, T]
              ),
              a(
                function () {
                  d(D) && L({ inst: D })
                  var B = function () {
                    d(D) && L({ inst: D })
                  }
                  return Q(B)
                },
                [Q]
              ),
              c(k),
              k
            )
          }
          function d(Q) {
            var T = Q.getSnapshot,
              P = Q.value
            try {
              var k = T()
              return !s(P, k)
            } catch {
              return !0
            }
          }
          function O(Q, T, P) {
            return T()
          }
          var g =
              typeof window < 'u' &&
              typeof window.document < 'u' &&
              typeof window.document.createElement < 'u',
            b = !g,
            x = b ? O : p,
            w = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : x
          ;(Fl.useSyncExternalStore = w),
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ==
                'function' &&
              __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(
                new Error()
              )
        })()),
    Fl
  )
}
var Yp
function Eg() {
  return (
    Yp ||
      ((Yp = 1),
      process.env.NODE_ENV === 'production'
        ? (Ls.exports = s$())
        : (Ls.exports = o$())),
    Ls.exports
  )
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ip
function a$() {
  if (Ip) return ql
  Ip = 1
  var n = h.reactExports,
    e = Eg()
  function t(c, u) {
    return (c === u && (c !== 0 || 1 / c === 1 / u)) || (c !== c && u !== u)
  }
  var r = typeof Object.is == 'function' ? Object.is : t,
    i = e.useSyncExternalStore,
    s = n.useRef,
    o = n.useEffect,
    a = n.useMemo,
    l = n.useDebugValue
  return (
    (ql.useSyncExternalStoreWithSelector = function (c, u, f, p, d) {
      var O = s(null)
      if (O.current === null) {
        var g = { hasValue: !1, value: null }
        O.current = g
      } else g = O.current
      O = a(
        function () {
          function x(k) {
            if (!w) {
              if (((w = !0), (Q = k), (k = p(k)), d !== void 0 && g.hasValue)) {
                var R = g.value
                if (d(R, k)) return (T = R)
              }
              return (T = k)
            }
            if (((R = T), r(Q, k))) return R
            var V = p(k)
            return d !== void 0 && d(R, V) ? R : ((Q = k), (T = V))
          }
          var w = !1,
            Q,
            T,
            P = f === void 0 ? null : f
          return [
            function () {
              return x(u())
            },
            P === null
              ? void 0
              : function () {
                  return x(P())
                }
          ]
        },
        [u, f, p, d]
      )
      var b = i(c, O[0], O[1])
      return (
        o(
          function () {
            ;(g.hasValue = !0), (g.value = b)
          },
          [b]
        ),
        l(b),
        b
      )
    }),
    ql
  )
}
var Gl = {}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var jp
function l$() {
  return (
    jp ||
      ((jp = 1),
      process.env.NODE_ENV !== 'production' &&
        (function () {
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ==
              'function' &&
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(
              new Error()
            )
          var n = h.reactExports,
            e = Eg()
          function t(u, f) {
            return (
              (u === f && (u !== 0 || 1 / u === 1 / f)) || (u !== u && f !== f)
            )
          }
          var r = typeof Object.is == 'function' ? Object.is : t,
            i = e.useSyncExternalStore,
            s = n.useRef,
            o = n.useEffect,
            a = n.useMemo,
            l = n.useDebugValue
          function c(u, f, p, d, O) {
            var g = s(null),
              b
            g.current === null
              ? ((b = { hasValue: !1, value: null }), (g.current = b))
              : (b = g.current)
            var x = a(
                function () {
                  var P = !1,
                    k,
                    R,
                    V = function (A) {
                      if (!P) {
                        ;(P = !0), (k = A)
                        var Y = d(A)
                        if (O !== void 0 && b.hasValue) {
                          var W = b.value
                          if (O(W, Y)) return (R = W), W
                        }
                        return (R = Y), Y
                      }
                      var K = k,
                        te = R
                      if (r(K, A)) return te
                      var J = d(A)
                      return O !== void 0 && O(te, J)
                        ? te
                        : ((k = A), (R = J), J)
                    },
                    D = p === void 0 ? null : p,
                    L = function () {
                      return V(f())
                    },
                    B =
                      D === null
                        ? void 0
                        : function () {
                            return V(D())
                          }
                  return [L, B]
                },
                [f, p, d, O]
              ),
              w = x[0],
              Q = x[1],
              T = i(u, w, Q)
            return (
              o(
                function () {
                  ;(b.hasValue = !0), (b.value = T)
                },
                [T]
              ),
              l(T),
              T
            )
          }
          ;(Gl.useSyncExternalStoreWithSelector = c),
            typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u' &&
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ==
                'function' &&
              __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(
                new Error()
              )
        })()),
    Gl
  )
}
process.env.NODE_ENV === 'production'
  ? (nu.exports = a$())
  : (nu.exports = l$())
var c$ = nu.exports
const u$ = h.getDefaultExportFromCjs(c$),
  { useDebugValue: f$ } = h.React,
  { useSyncExternalStoreWithSelector: h$ } = u$
function p$(n, e = n.getState, t) {
  const r = h$(n.subscribe, n.getState, n.getServerState || n.getState, e, t)
  return f$(r), r
}
const Np = (n) => {
    const e = typeof n == 'function' ? i$(n) : n,
      t = (r, i) => p$(e, r, i)
    return Object.assign(t, e), t
  },
  Qf = (n) => (n ? Np(n) : Np),
  zi = Qf()((n) => ({
    prompt: '',
    componentName: '',
    setPrompt: (e) => n(() => ({ prompt: e })),
    setComponentName: (e) => n(() => ({ componentName: e })),
    setInstruction: (e) =>
      n(() => ({ prompt: e.prompt, componentName: e.componentName }))
  })),
  Oa = Qf()((n) => ({
    html: '',
    react: '',
    setGeneratedCode: (e, t) => n(() => ({ [t]: e }))
  })),
  Dg = Qf()((n) => ({
    selectedIndex: 0,
    setSelectedIndex: (e) => n(() => ({ selectedIndex: e }))
  }))
function d$(n) {
  const { control: e, handleSubmit: t } = c1(),
    r = (c) => {
      console.log('submit', c)
    },
    i = n.onSubmit || r,
    { prompt: s, componentName: o, setComponentName: a, setPrompt: l } = zi()
  return h.jsxRuntimeExports.jsxs('form', {
    onSubmit: t(i),
    className: 'slds-m-bottom_xx-large',
    children: [
      h.jsxRuntimeExports.jsx(Uh, {
        name: 'componentName',
        control: e,
        defaultValue: o,
        rules: { required: !0 },
        render: ({ field: c }) =>
          h.jsxRuntimeExports.jsx(ul, {
            label: 'Component Name',
            placeholder: 'Banner',
            ...c,
            required: !0,
            onChange: (u) => {
              c.onChange(u)
              const f = u.target.value
              a(f)
            }
          })
      }),
      h.jsxRuntimeExports.jsx(Uh, {
        name: 'prompt',
        control: e,
        defaultValue: s,
        rules: { required: !0 },
        render: ({ field: c }) =>
          h.jsxRuntimeExports.jsx($f, {
            ...c,
            label: 'Instruction',
            placeholder: 'Create a banner with centered text Hello World!',
            required: !0,
            value: s,
            onChange: (u) => {
              c.onChange(u)
              const f = u.target.value
              l(f)
            }
          })
      }),
      h.jsxRuntimeExports.jsx(lt, {
        type: 'submit',
        label: 'Create component',
        variant: 'brand',
        iconCategory: 'utility',
        iconName: 'sparkles',
        iconPosition: 'left'
      })
    ]
  })
}
function ko(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (ko = function (t) {
          return typeof t
        })
      : (ko = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    ko(n)
  )
}
function ru() {
  return (
    (ru =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
      }),
    ru.apply(this, arguments)
  )
}
function O$(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Mp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function m$(n, e, t) {
  return e && Mp(n.prototype, e), t && Mp(n, t), n
}
function g$(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && iu(n, e)
}
function iu(n, e) {
  return (
    (iu =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    iu(n, e)
  )
}
function y$(n) {
  var e = v$()
  return function () {
    var r = ma(n),
      i
    if (e) {
      var s = ma(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return b$(this, i)
  }
}
function b$(n, e) {
  return e && (ko(e) === 'object' || typeof e == 'function') ? e : su(n)
}
function su(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function v$() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ma(n) {
  return (
    (ma = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    ma(n)
  )
}
function Vp(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var S$ = {
    assistiveText: h.PropTypes.shape({ toggleSection: h.PropTypes.string }),
    children: h.PropTypes.node,
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    id: h.PropTypes.string,
    isOpen: h.PropTypes.bool,
    nonCollapsible: h.PropTypes.bool,
    onToggleOpen: h.PropTypes.func,
    title: h.PropTypes.string.isRequired
  },
  x$ = {
    assistiveText: { toggleSection: 'Toggle visibility of section' },
    nonCollapsible: !1
  },
  fl = (function (n) {
    g$(t, n)
    var e = y$(t)
    function t(r) {
      var i
      return (
        O$(this, t),
        (i = e.call(this, r)),
        Vp(su(i), 'getId', function () {
          return i.props.id || i.generatedId
        }),
        Vp(su(i), 'toggleOpen', function (s) {
          i.props.onToggleOpen
            ? i.props.onToggleOpen(s, { isOpen: i.props.isOpen })
            : i.setState(function (o) {
                return { isOpen: !o.isOpen }
              })
        }),
        (i.generatedId = dr.generate()),
        (i.state = { isOpen: !0 }),
        i
      )
    }
    return (
      m$(t, [
        {
          key: 'render',
          value: function () {
            var i = ''.concat(this.getId(), '-expanded-section-content'),
              s =
                this.props.isOpen !== void 0
                  ? this.props.isOpen
                  : this.state.isOpen,
              o = { 'aria-controls': i, 'aria-expanded': !!s },
              a = h.React.createElement(
                'span',
                {
                  className: se('slds-truncate', {
                    'slds-p-horizontal_small': !!this.props.nonCollapsible
                  }),
                  title: this.props.title
                },
                this.props.title
              )
            return h.React.createElement(
              'div',
              {
                className: se(
                  'slds-section',
                  { 'slds-is-open': s },
                  this.props.className
                )
              },
              h.React.createElement(
                'h3',
                {
                  className: se('slds-section__title', {
                    'slds-theme_shade': !!this.props.nonCollapsible
                  })
                },
                this.props.nonCollapsible
                  ? a
                  : h.React.createElement(
                      lt,
                      ru(
                        {
                          assistiveText: {
                            icon: this.props.assistiveText.toggleSection
                          },
                          iconCategory: 'utility',
                          iconClassName:
                            'slds-section__title-action-icon slds-button__icon_left',
                          iconName: 'switch',
                          onClick: this.toggleOpen,
                          className: 'slds-section__title-action',
                          variant: 'base'
                        },
                        o
                      ),
                      a
                    )
              ),
              h.React.createElement(
                'div',
                {
                  'aria-hidden': !s,
                  className: 'slds-section__content',
                  id: i
                },
                this.props.children
              )
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
fl.displayName = wx
fl.propTypes = S$
fl.defaultProps = x$
function Co(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Co = function (t) {
          return typeof t
        })
      : (Co = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Co(n)
  )
}
function w$(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Wp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function P$(n, e, t) {
  return e && Wp(n.prototype, e), t && Wp(n, t), n
}
function T$(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && ou(n, e)
}
function ou(n, e) {
  return (
    (ou =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    ou(n, e)
  )
}
function $$(n) {
  var e = C$()
  return function () {
    var r = ga(n),
      i
    if (e) {
      var s = ga(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return Q$(this, i)
  }
}
function Q$(n, e) {
  return e && (Co(e) === 'object' || typeof e == 'function') ? e : k$(n)
}
function k$(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function C$() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ga(n) {
  return (
    (ga = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    ga(n)
  )
}
var _$ = {
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    children: h.PropTypes.node
  },
  kf = (function (n) {
    T$(t, n)
    var e = $$(t)
    function t() {
      return w$(this, t), e.apply(this, arguments)
    }
    return (
      P$(t, [
        {
          key: 'render',
          value: function () {
            return h.React.createElement(
              'div',
              { className: Br('slds-notify-container', this.props.className) },
              this.props.children
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
kf.displayName = Xx
kf.propTypes = _$
var Xg = 9007199254740991,
  R$ = '[object Arguments]',
  Z$ = '[object Function]',
  A$ = '[object GeneratorFunction]',
  E$ = /^(?:0|[1-9]\d*)$/
function D$(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e)
    case 1:
      return n.call(e, t[0])
    case 2:
      return n.call(e, t[0], t[1])
    case 3:
      return n.call(e, t[0], t[1], t[2])
  }
  return n.apply(e, t)
}
function X$(n, e) {
  for (var t = -1, r = Array(n); ++t < n; ) r[t] = e(t)
  return r
}
function Y$(n, e) {
  return function (t) {
    return n(e(t))
  }
}
var hl = Object.prototype,
  Ss = hl.hasOwnProperty,
  Yg = hl.toString,
  Ig = hl.propertyIsEnumerable,
  I$ = Y$(Object.keys, Object),
  Lp = Math.max,
  j$ = !Ig.call({ valueOf: 1 }, 'valueOf')
function N$(n, e) {
  var t = q$(n) || U$(n) ? X$(n.length, String) : [],
    r = t.length,
    i = !!r
  for (var s in n)
    (e || Ss.call(n, s)) && !(i && (s == 'length' || Ng(s, r))) && t.push(s)
  return t
}
function jg(n, e, t) {
  var r = n[e]
  ;(!(Ss.call(n, e) && Vg(r, t)) || (t === void 0 && !(e in n))) && (n[e] = t)
}
function M$(n) {
  if (!Mg(n)) return I$(n)
  var e = []
  for (var t in Object(n)) Ss.call(n, t) && t != 'constructor' && e.push(t)
  return e
}
function V$(n, e) {
  return (
    (e = Lp(e === void 0 ? n.length - 1 : e, 0)),
    function () {
      for (
        var t = arguments, r = -1, i = Lp(t.length - e, 0), s = Array(i);
        ++r < i;

      )
        s[r] = t[e + r]
      r = -1
      for (var o = Array(e + 1); ++r < e; ) o[r] = t[r]
      return (o[e] = s), D$(n, this, o)
    }
  )
}
function W$(n, e, t, r) {
  t || (t = {})
  for (var i = -1, s = e.length; ++i < s; ) {
    var o = e[i],
      a = r ? r(t[o], n[o], o, t, n) : void 0
    jg(t, o, a === void 0 ? n[o] : a)
  }
  return t
}
function L$(n) {
  return V$(function (e, t) {
    var r = -1,
      i = t.length,
      s = i > 1 ? t[i - 1] : void 0,
      o = i > 2 ? t[2] : void 0
    for (
      s = n.length > 3 && typeof s == 'function' ? (i--, s) : void 0,
        o && B$(t[0], t[1], o) && ((s = i < 3 ? void 0 : s), (i = 1)),
        e = Object(e);
      ++r < i;

    ) {
      var a = t[r]
      a && n(e, a, r, s)
    }
    return e
  })
}
function Ng(n, e) {
  return (
    (e = e ?? Xg),
    !!e && (typeof n == 'number' || E$.test(n)) && n > -1 && n % 1 == 0 && n < e
  )
}
function B$(n, e, t) {
  if (!Wg(t)) return !1
  var r = typeof e
  return (r == 'number' ? pl(t) && Ng(e, t.length) : r == 'string' && e in t)
    ? Vg(t[e], n)
    : !1
}
function Mg(n) {
  var e = n && n.constructor,
    t = (typeof e == 'function' && e.prototype) || hl
  return n === t
}
function Vg(n, e) {
  return n === e || (n !== n && e !== e)
}
function U$(n) {
  return (
    z$(n) && Ss.call(n, 'callee') && (!Ig.call(n, 'callee') || Yg.call(n) == R$)
  )
}
var q$ = Array.isArray
function pl(n) {
  return n != null && G$(n.length) && !F$(n)
}
function z$(n) {
  return H$(n) && pl(n)
}
function F$(n) {
  var e = Wg(n) ? Yg.call(n) : ''
  return e == Z$ || e == A$
}
function G$(n) {
  return typeof n == 'number' && n > -1 && n % 1 == 0 && n <= Xg
}
function Wg(n) {
  var e = typeof n
  return !!n && (e == 'object' || e == 'function')
}
function H$(n) {
  return !!n && typeof n == 'object'
}
var K$ = L$(function (n, e) {
  if (j$ || Mg(e) || pl(e)) {
    W$(e, J$(e), n)
    return
  }
  for (var t in e) Ss.call(e, t) && jg(n, t, e[t])
})
function J$(n) {
  return pl(n) ? N$(n) : M$(n)
}
var eQ = K$
const ya = h.getDefaultExportFromCjs(eQ)
var Lg = function () {}
process.env.NODE_ENV !== 'production' &&
  (Lg = function (e, t, r) {
    var i = Fn(r)
    Qe(
      e,
      t.iconCategory,
      'iconCategory',
      'Use `Icon` instead. '.concat(i('icon'))
    ),
      Qe(e, t.iconName, 'iconName', 'Use `Icon` instead. '.concat(i('icon'))),
      Qe(
        e,
        t.content,
        'content',
        'Use `labels.heading` and `labels.headingLink` instead. '.concat(
          i('labels')
        )
      ),
      Qe(
        e,
        t.isOpen,
        'isOpen',
        'Use a conditional outside of alert. '.concat(i())
      ),
      Qe(
        e,
        t.isOpen,
        'onDismiss',
        'Use `onRequestClose` instead. '.concat(i('onRequestClose'))
      ),
      Qe(e, t.texture, 'texture', i()),
      Qe(e, t.theme, 'theme', 'Use `variant` instead. '.concat(i('variant')))
  })
const tQ = Lg,
  nQ = 'toast',
  rQ = 'prod',
  iQ = 'Toast',
  sQ = [{ component: 'container', classKey: 'ToastContainer' }],
  oQ = {
    component: nQ,
    status: rQ,
    'display-name': 'Toasts',
    classKey: iQ,
    'last-accessibility-review': {
      'date-iso-8601': '2018/01/18',
      'commit-sha': 'ad6b6c6523ee21cada11be5f7ea4d99abc530726'
    },
    'SLDS-component-path': '/components/toast',
    dependencies: sQ,
    'site-stories': [
      { heading: 'Informational', path: '/__examples__/info.jsx' },
      { heading: 'Success', path: '/__examples__/success.jsx' },
      { heading: 'Warning', path: '/__examples__/warning.jsx' },
      { heading: 'Error', path: '/__examples__/error.jsx' },
      {
        heading: 'Error with Details',
        path: '/__examples__/error-with-details.jsx'
      }
    ],
    'url-slug': 'toasts'
  }
function _o(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (_o = function (t) {
          return typeof t
        })
      : (_o = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    _o(n)
  )
}
function aQ(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Bp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function lQ(n, e, t) {
  return e && Bp(n.prototype, e), t && Bp(n, t), n
}
function cQ(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && au(n, e)
}
function au(n, e) {
  return (
    (au =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    au(n, e)
  )
}
function uQ(n) {
  var e = hQ()
  return function () {
    var r = ba(n),
      i
    if (e) {
      var s = ba(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return fQ(this, i)
  }
}
function fQ(n, e) {
  return e && (_o(e) === 'object' || typeof e == 'function') ? e : Ro(n)
}
function Ro(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function hQ() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ba(n) {
  return (
    (ba = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    ba(n)
  )
}
function Hl(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var pQ = {
    assistiveText: h.PropTypes.shape({
      closeButton: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node])
    }),
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    duration: h.PropTypes.number,
    labels: h.PropTypes.shape({
      details: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node]),
      heading: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node]),
      headingLink: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node])
    }),
    onClickHeadingLink: h.PropTypes.func,
    icon: h.PropTypes.node,
    onRequestClose: h.PropTypes.func,
    style: h.PropTypes.object,
    variant: h.PropTypes.oneOf(['error', 'info', 'success', 'warning'])
      .isRequired
  },
  lu = {
    assistiveText: {
      closeButton: 'Close',
      error: 'error',
      info: 'info',
      success: 'success',
      warning: 'warning'
    },
    variant: 'info'
  },
  dl = (function (n) {
    cQ(t, n)
    var e = uQ(t)
    function t(r) {
      var i
      return (
        aQ(this, t),
        (i = e.call(this, r)),
        Hl(Ro(i), 'onClose', function () {
          i.clearTimeout(), i.props.onRequestClose && i.props.onRequestClose()
        }),
        Hl(Ro(i), 'clearTimeout', function () {
          i.timeout && (clearTimeout(i.timeout), (i.timeout = null))
        }),
        Hl(Ro(i), 'saveToastRef', function (s) {
          ;(i.toast = s),
            i.state.isInitialRender &&
              (qt.storeActiveElement(),
              i.toast && i.toast.focus(),
              i.setState({ isInitialRender: !1 }))
        }),
        (i.state = { isInitialRender: !0 }),
        (i.timeout = null),
        (i.toast = null),
        tQ(_m, r, oQ),
        i
      )
    }
    return (
      lQ(t, [
        {
          key: 'componentDidMount',
          value: function () {
            var i = this
            this.props.duration &&
              (this.timeout = setTimeout(function () {
                i.onClose()
              }, this.props.duration))
          }
        },
        {
          key: 'componentWillUnmount',
          value: function () {
            this.clearTimeout(), qt.returnFocusToStoredElement()
          }
        },
        {
          key: 'render',
          value: function () {
            var i = ya({}, lu.assistiveText, this.props.assistiveText),
              s = ya({}, lu.labels, this.props.labels),
              o = s.heading || this.props.content,
              a = {
                info: i.info,
                success: i.success,
                warning: i.warning,
                error: i.error
              },
              l = {
                info: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'info'
                }),
                success: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'success'
                }),
                warning: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'warning'
                }),
                error: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'error'
                })
              },
              c = this.props.icon ? this.props.icon : l[this.props.variant],
              u = h.React.cloneElement(c, {
                containerClassName:
                  'slds-m-right_small slds-no-flex slds-align-top',
                inverse: !0,
                size: 'small'
              })
            return h.React.createElement(
              'div',
              {
                className: Br(
                  'slds-notify slds-notify_toast',
                  {
                    'slds-theme_info': this.props.variant === 'info',
                    'slds-theme_success': this.props.variant === 'success',
                    'slds-theme_warning': this.props.variant === 'warning',
                    'slds-theme_error': this.props.variant === 'error'
                  },
                  this.props.className
                ),
                ref: this.saveToastRef,
                role: 'status',
                style: this.props.style,
                tabIndex: 0
              },
              h.React.createElement(
                'span',
                { className: 'slds-assistive-text' },
                a[this.props.variant]
              ),
              u,
              h.React.createElement(
                'div',
                { className: 'slds-notify__content' },
                h.React.createElement(
                  'h2',
                  { className: 'slds-text-heading_small' },
                  o,
                  ' ',
                  s.headingLink
                    ? h.React.createElement(
                        'a',
                        {
                          onClick: fs.trappedHandler(
                            this.props.onClickHeadingLink
                          ),
                          href: '#'
                        },
                        s.headingLink
                      )
                    : null
                ),
                s.details ? h.React.createElement('p', null, s.details) : null
              ),
              h.React.createElement(lt, {
                assistiveText: { icon: i.closeButton },
                className: 'slds-notify__close',
                iconCategory: 'utility',
                iconName: 'close',
                iconSize: 'large',
                inverse: !0,
                onClick: this.props.onRequestClose,
                title: i.closeButton,
                variant: 'icon'
              })
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
dl.defaultProps = lu
dl.displayName = _m
dl.propTypes = pQ
const dQ = [
  {
    element: [
      'Create a ',
      h.jsxRuntimeExports.jsx('b', { children: 'banner component' }),
      ' with centered text Hello World!'
    ],
    text: 'Create a banner component with centered text Hello World!'
  },
  {
    element: [
      'Create a ',
      h.jsxRuntimeExports.jsx('b', { children: 'product tile component' }),
      ' with image, title, and price'
    ],
    text: 'Create a product tile component with image, title, and price'
  },
  {
    element: [
      'Create a ',
      h.jsxRuntimeExports.jsx('b', { children: 'three column layout' }),
      ', each column contains a product image'
    ],
    text: 'Create a three column layout, each column contains a product image'
  }
]
function OQ() {
  const [n, e] = h.reactExports.useState(!1),
    { prompt: t, setPrompt: r } = zi(),
    [i, s] = h.reactExports.useState(!1),
    o = async (a) => {
      try {
        await navigator.clipboard.writeText(a), s(!0), t || r(a)
      } finally {
        setTimeout(() => {
          s(!1)
        }, 1500)
      }
    }
  return h.jsxRuntimeExports.jsxs(fl, {
    isOpen: n,
    onToggleOpen: () => e(!n),
    title: 'See Example Instructions',
    children: [
      h.jsxRuntimeExports.jsx(kf, {
        children:
          i &&
          h.jsxRuntimeExports.jsx(dl, {
            variant: 'success',
            labels: { heading: 'Copied' },
            onRequestClose: () => s(!1)
          })
      }),
      h.jsxRuntimeExports.jsx('p', {
        className: 'slds-m-bottom_xx-small',
        style: { fontStyle: 'italic' },
        children: 'Click text to copy sample instruction into prompt.'
      }),
      h.jsxRuntimeExports.jsx('ul', {
        children: dQ.map((a, l) =>
          h.jsxRuntimeExports.jsx(
            'li',
            {
              onClick: () => o(a.text),
              style: { cursor: 'pointer' },
              className: 'slds-card',
              children: h.jsxRuntimeExports.jsx('div', {
                className: 'slds-p-around_small',
                children: h.jsxRuntimeExports.jsxs('div', {
                  className: 'slds-grid slds-gutters',
                  children: [
                    h.jsxRuntimeExports.jsx('div', {
                      className: 'slds-col slds-size_10-of-12',
                      children: h.jsxRuntimeExports.jsx('p', {
                        children: a.element.map((c, u) =>
                          h.jsxRuntimeExports.jsx('span', { children: c }, u)
                        )
                      })
                    }),
                    h.jsxRuntimeExports.jsx('div', {
                      className: 'slds-col slds-size_2-of-12',
                      children: h.jsxRuntimeExports.jsx(Ie, {
                        assistiveText: { label: 'copy' },
                        category: 'utility',
                        name: 'copy',
                        size: 'x-small'
                      })
                    })
                  ]
                })
              })
            },
            l
          )
        )
      })
    ]
  })
}
function mQ() {
  return h.jsxRuntimeExports.jsxs('div', {
    className: 'slds-tabs_scoped__content-container',
    children: [h.jsxRuntimeExports.jsx(d$, {}), h.jsxRuntimeExports.jsx(OQ, {})]
  })
}
var Bg = function () {}
process.env.NODE_ENV !== 'production' &&
  (Bg = function (e, t, r) {
    var i = Fn(r)
    Qe(
      e,
      t.iconCategory,
      'iconCategory',
      'Use `Icon` instead. '.concat(i('icon'))
    ),
      Qe(e, t.iconName, 'iconName', 'Use `Icon` instead. '.concat(i('icon'))),
      Qe(
        e,
        t.content,
        'content',
        'Use `labels.heading` and `labels.headingLink` instead.'.concat(
          i('labels')
        )
      ),
      Qe(e, t.duration, 'duration', 'Only Toasts can auto-hide. '.concat(i())),
      Qe(
        e,
        t.isOpen,
        'isOpen',
        'Use a conditional outside of alert. '.concat(i())
      ),
      Qe(
        e,
        t.isOpen,
        'onDismiss',
        'Use `onRequestClose` instead. '.concat(i('onRequestClose'))
      ),
      Qe(e, t.texture, 'texture', i()),
      Qe(e, t.theme, 'theme', 'Use `variant` instead. '.concat(i('variant')))
  })
const gQ = Bg,
  yQ = 'alert',
  bQ = 'prod',
  vQ = 'Alert',
  SQ = [{ component: 'container', classKey: 'AlertContainer' }],
  xQ = {
    component: yQ,
    status: bQ,
    'display-name': 'Alerts',
    classKey: vQ,
    'last-accessibility-review': {
      'date-iso-8601': '2018/01/18',
      'commit-sha': 'ad6b6c6523ee21cada11be5f7ea4d99abc530726'
    },
    'SLDS-component-path': '/components/alert',
    dependencies: SQ,
    'site-stories': [
      { heading: 'Informational', path: '/__examples__/info.jsx' },
      { heading: 'Warning', path: '/__examples__/warning.jsx' },
      { heading: 'System Status', path: '/__examples__/offline.jsx' },
      { heading: 'Error', path: '/__examples__/error.jsx' },
      { heading: 'Dismissable', path: '/__examples__/dismissable.jsx' }
    ],
    'url-slug': 'alerts'
  }
function Zo(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Zo = function (t) {
          return typeof t
        })
      : (Zo = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Zo(n)
  )
}
function wQ(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function Up(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function PQ(n, e, t) {
  return e && Up(n.prototype, e), t && Up(n, t), n
}
function TQ(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && cu(n, e)
}
function cu(n, e) {
  return (
    (cu =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    cu(n, e)
  )
}
function $Q(n) {
  var e = kQ()
  return function () {
    var r = va(n),
      i
    if (e) {
      var s = va(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return QQ(this, i)
  }
}
function QQ(n, e) {
  return e && (Zo(e) === 'object' || typeof e == 'function') ? e : Ug(n)
}
function Ug(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function kQ() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function va(n) {
  return (
    (va = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    va(n)
  )
}
function CQ(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (n[e] = t),
    n
  )
}
var _Q = {
    assistiveText: h.PropTypes.shape({
      closeButton: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node])
    }),
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    dismissible: h.PropTypes.bool,
    icon: h.PropTypes.node,
    labels: h.PropTypes.shape({
      heading: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node]),
      headingLink: h.PropTypes.oneOfType([h.PropTypes.string, h.PropTypes.node])
    }),
    onClickHeadingLink: h.PropTypes.func,
    onRequestClose: h.PropTypes.func,
    style: h.PropTypes.object,
    variant: h.PropTypes.oneOf(['error', 'info', 'offline', 'warning'])
      .isRequired
  },
  uu = { assistiveText: { closeButton: 'Close' }, labels: {}, variant: 'info' },
  Ol = (function (n) {
    TQ(t, n)
    var e = $Q(t)
    function t(r) {
      var i
      return (
        wQ(this, t),
        (i = e.call(this, r)),
        CQ(Ug(i), 'saveButtonRef', function (s) {
          ;(i.closeButton = s),
            i.state.isInitialRender &&
              (qt.storeActiveElement(),
              i.closeButton && i.closeButton.focus(),
              i.setState({ isInitialRender: !1 }))
        }),
        (i.state = { isInitialRender: !0 }),
        gQ(Pm, r, xQ),
        i
      )
    }
    return (
      PQ(t, [
        {
          key: 'componentWillUnmount',
          value: function () {
            qt.returnFocusToStoredElement()
          }
        },
        {
          key: 'render',
          value: function () {
            var i = ya({}, uu.assistiveText, this.props.assistiveText),
              s = ya({}, uu.labels, this.props.labels),
              o = s.heading || this.props.content,
              a = this.props.onRequestClose || this.props.onDismiss,
              l = {
                info: 'info',
                warning: 'warning',
                error: 'error',
                offline: 'offline'
              },
              c = {
                info: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'info'
                }),
                offline: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'offline'
                }),
                warning: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'warning'
                }),
                error: h.React.createElement(Ie, {
                  category: 'utility',
                  name: 'error'
                })
              },
              u = this.props.icon ? this.props.icon : c[this.props.variant]
            this.props.iconName &&
              this.props.iconCategory &&
              (u = h.React.createElement(Ie, {
                category: this.props.iconCategory,
                name: this.props.iconName
              }))
            var f = h.React.cloneElement(u, {
              containerClassName: 'slds-m-right_x-small',
              inverse: !0,
              size: 'x-small'
            })
            return h.React.createElement(
              'div',
              {
                className: Br(
                  'slds-notify slds-notify_alert slds-theme_alert-texture',
                  {
                    'slds-theme_info': this.props.variant === 'info',
                    'slds-theme_warning': this.props.variant === 'warning',
                    'slds-theme_error': this.props.variant === 'error',
                    'slds-theme_offline': this.props.variant === 'offline'
                  },
                  this.props.className
                ),
                role: 'alert',
                style: this.props.style
              },
              h.React.createElement(
                'span',
                { className: 'slds-assistive-text' },
                l[this.props.variant]
              ),
              f,
              h.React.createElement(
                'h2',
                null,
                o,
                ' ',
                s.headingLink
                  ? h.React.createElement(
                      'a',
                      {
                        onClick: fs.trappedHandler(
                          this.props.onClickHeadingLink
                        ),
                        href: '#'
                      },
                      s.headingLink
                    )
                  : null
              ),
              this.props.dismissible
                ? h.React.createElement(lt, {
                    assistiveText: { icon: i.closeButton },
                    buttonRef: this.saveButtonRef,
                    className: 'slds-notify__close',
                    iconCategory: 'utility',
                    iconName: 'close',
                    iconSize: 'medium',
                    inverse: !0,
                    onClick: a,
                    title: i.closeButton,
                    variant: 'icon'
                  })
                : null
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
Ol.defaultProps = uu
Ol.displayName = Pm
Ol.propTypes = _Q
function Ao(n) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Ao = function (t) {
          return typeof t
        })
      : (Ao = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Ao(n)
  )
}
function RQ(n, e) {
  if (!(n instanceof e))
    throw new TypeError('Cannot call a class as a function')
}
function qp(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r)
  }
}
function ZQ(n, e, t) {
  return e && qp(n.prototype, e), t && qp(n, t), n
}
function AQ(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 }
  })),
    e && fu(n, e)
}
function fu(n, e) {
  return (
    (fu =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r
      }),
    fu(n, e)
  )
}
function EQ(n) {
  var e = YQ()
  return function () {
    var r = Sa(n),
      i
    if (e) {
      var s = Sa(this).constructor
      i = Reflect.construct(r, arguments, s)
    } else i = r.apply(this, arguments)
    return DQ(this, i)
  }
}
function DQ(n, e) {
  return e && (Ao(e) === 'object' || typeof e == 'function') ? e : XQ(n)
}
function XQ(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function YQ() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Sa(n) {
  return (
    (Sa = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    Sa(n)
  )
}
var IQ = {
    className: h.PropTypes.oneOfType([
      h.PropTypes.array,
      h.PropTypes.object,
      h.PropTypes.string
    ]),
    children: h.PropTypes.node
  },
  Cf = (function (n) {
    AQ(t, n)
    var e = EQ(t)
    function t() {
      return RQ(this, t), e.apply(this, arguments)
    }
    return (
      ZQ(t, [
        {
          key: 'render',
          value: function () {
            return h.React.createElement(
              'div',
              { className: Br('slds-notify-container', this.props.className) },
              this.props.children
            )
          }
        }
      ]),
      t
    )
  })(h.React.Component)
Cf.displayName = yx
Cf.propTypes = IQ
function jQ() {
  return h.jsxRuntimeExports.jsx('div', {
    className: 'inline-alert',
    children: h.jsxRuntimeExports.jsx(Cf, {
      children: h.jsxRuntimeExports.jsx(Ol, {
        variant: 'info',
        icon: h.jsxRuntimeExports.jsx(Ie, {
          category: 'utility',
          name: 'warning'
        }),
        labels: {
          heading:
            'Please review the information in this AI generated preview, as it may contain errors. You may edit code through the input below. If you want to generate a different output, go back to the Instructions tab.'
        }
      })
    })
  })
}
class le {
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(
        `Invalid position ${e} in document of length ${this.length}`
      )
    return this.lineInner(e, !1, 1, 0)
  }
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(
        `Invalid line number ${e} in ${this.lines}-line document`
      )
    return this.lineInner(e, !0, 1, 0)
  }
  replace(e, t, r) {
    let i = []
    return (
      this.decompose(0, e, i, 2),
      r.length && r.decompose(0, r.length, i, 3),
      this.decompose(t, this.length, i, 1),
      Gt.from(i, this.length - (t - e) + r.length)
    )
  }
  append(e) {
    return this.replace(this.length, this.length, e)
  }
  slice(e, t = this.length) {
    let r = []
    return this.decompose(e, t, r, 0), Gt.from(r, t - e)
  }
  eq(e) {
    if (e == this) return !0
    if (e.length != this.length || e.lines != this.lines) return !1
    let t = this.scanIdentical(e, 1),
      r = this.length - this.scanIdentical(e, -1),
      i = new Wi(this),
      s = new Wi(e)
    for (let o = t, a = t; ; ) {
      if (
        (i.next(o),
        s.next(o),
        (o = 0),
        i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
      )
        return !1
      if (((a += i.value.length), i.done || a >= r)) return !0
    }
  }
  iter(e = 1) {
    return new Wi(this, e)
  }
  iterRange(e, t = this.length) {
    return new qg(this, e, t)
  }
  iterLines(e, t) {
    let r
    if (e == null) r = this.iter()
    else {
      t == null && (t = this.lines + 1)
      let i = this.line(e).from
      r = this.iterRange(
        i,
        Math.max(
          i,
          t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to
        )
      )
    }
    return new zg(r)
  }
  toString() {
    return this.sliceString(0)
  }
  toJSON() {
    let e = []
    return this.flatten(e), e
  }
  constructor() {}
  static of(e) {
    if (e.length == 0)
      throw new RangeError('A document must have at least one line')
    return e.length == 1 && !e[0]
      ? le.empty
      : e.length <= 32
        ? new Ce(e)
        : Gt.from(Ce.split(e, []))
  }
}
class Ce extends le {
  constructor(e, t = NQ(e)) {
    super(), (this.text = e), (this.length = t)
  }
  get lines() {
    return this.text.length
  }
  get children() {
    return null
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s],
        a = i + o.length
      if ((t ? r : a) >= e) return new MQ(i, a, r, o)
      ;(i = a + 1), r++
    }
  }
  decompose(e, t, r, i) {
    let s =
      e <= 0 && t >= this.length
        ? this
        : new Ce(zp(this.text, e, t), Math.min(t, this.length) - Math.max(0, e))
    if (i & 1) {
      let o = r.pop(),
        a = Eo(s.text, o.text.slice(), 0, s.length)
      if (a.length <= 32) r.push(new Ce(a, o.length + s.length))
      else {
        let l = a.length >> 1
        r.push(new Ce(a.slice(0, l)), new Ce(a.slice(l)))
      }
    } else r.push(s)
  }
  replace(e, t, r) {
    if (!(r instanceof Ce)) return super.replace(e, t, r)
    let i = Eo(this.text, Eo(r.text, zp(this.text, 0, e)), t),
      s = this.length + r.length - (t - e)
    return i.length <= 32 ? new Ce(i, s) : Gt.from(Ce.split(i, []), s)
  }
  sliceString(
    e,
    t = this.length,
    r = `
`
  ) {
    let i = ''
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let a = this.text[o],
        l = s + a.length
      s > e && o && (i += r),
        e < l && t > s && (i += a.slice(Math.max(0, e - s), t - s)),
        (s = l + 1)
    }
    return i
  }
  flatten(e) {
    for (let t of this.text) e.push(t)
  }
  scanIdentical() {
    return 0
  }
  static split(e, t) {
    let r = [],
      i = -1
    for (let s of e)
      r.push(s),
        (i += s.length + 1),
        r.length == 32 && (t.push(new Ce(r, i)), (r = []), (i = -1))
    return i > -1 && t.push(new Ce(r, i)), t
  }
}
class Gt extends le {
  constructor(e, t) {
    super(), (this.children = e), (this.length = t), (this.lines = 0)
    for (let r of e) this.lines += r.lines
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s],
        a = i + o.length,
        l = r + o.lines - 1
      if ((t ? l : a) >= e) return o.lineInner(e, t, r, i)
      ;(i = a + 1), (r = l + 1)
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let a = this.children[s],
        l = o + a.length
      if (e <= l && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0))
        o >= e && l <= t && !c ? r.push(a) : a.decompose(e - o, t - o, r, c)
      }
      o = l + 1
    }
  }
  replace(e, t, r) {
    if (r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i],
          a = s + o.length
        if (e >= s && t <= a) {
          let l = o.replace(e - s, t - s, r),
            c = this.lines - o.lines + l.lines
          if (l.lines < c >> (5 - 1) && l.lines > c >> (5 + 1)) {
            let u = this.children.slice()
            return (u[i] = l), new Gt(u, this.length - (t - e) + r.length)
          }
          return super.replace(s, a, l)
        }
        s = a + 1
      }
    return super.replace(e, t, r)
  }
  sliceString(
    e,
    t = this.length,
    r = `
`
  ) {
    let i = ''
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let a = this.children[s],
        l = o + a.length
      o > e && s && (i += r),
        e < l && t > o && (i += a.sliceString(e - o, t - o, r)),
        (o = l + 1)
    }
    return i
  }
  flatten(e) {
    for (let t of this.children) t.flatten(e)
  }
  scanIdentical(e, t) {
    if (!(e instanceof Gt)) return 0
    let r = 0,
      [i, s, o, a] =
        t > 0
          ? [0, 0, this.children.length, e.children.length]
          : [this.children.length - 1, e.children.length - 1, -1, -1]
    for (; ; i += t, s += t) {
      if (i == o || s == a) return r
      let l = this.children[i],
        c = e.children[s]
      if (l != c) return r + l.scanIdentical(c, t)
      r += l.length + 1
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0
    for (let d of e) r += d.lines
    if (r < 32) {
      let d = []
      for (let O of e) O.flatten(d)
      return new Ce(d, t)
    }
    let i = Math.max(32, r >> 5),
      s = i << 1,
      o = i >> 1,
      a = [],
      l = 0,
      c = -1,
      u = []
    function f(d) {
      let O
      if (d.lines > s && d instanceof Gt) for (let g of d.children) f(g)
      else
        d.lines > o && (l > o || !l)
          ? (p(), a.push(d))
          : d instanceof Ce &&
              l &&
              (O = u[u.length - 1]) instanceof Ce &&
              d.lines + O.lines <= 32
            ? ((l += d.lines),
              (c += d.length + 1),
              (u[u.length - 1] = new Ce(
                O.text.concat(d.text),
                O.length + 1 + d.length
              )))
            : (l + d.lines > i && p(),
              (l += d.lines),
              (c += d.length + 1),
              u.push(d))
    }
    function p() {
      l != 0 &&
        (a.push(u.length == 1 ? u[0] : Gt.from(u, c)),
        (c = -1),
        (l = u.length = 0))
    }
    for (let d of e) f(d)
    return p(), a.length == 1 ? a[0] : new Gt(a, t)
  }
}
le.empty = new Ce([''], 0)
function NQ(n) {
  let e = -1
  for (let t of n) e += t.length + 1
  return e
}
function Eo(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let a = n[s],
      l = i + a.length
    l >= t &&
      (l > r && (a = a.slice(0, r - i)),
      i < t && (a = a.slice(t - i)),
      o ? ((e[e.length - 1] += a), (o = !1)) : e.push(a)),
      (i = l + 1)
  }
  return e
}
function zp(n, e, t) {
  return Eo(n, [''], e, t)
}
class Wi {
  constructor(e, t = 1) {
    ;(this.dir = t),
      (this.done = !1),
      (this.lineBreak = !1),
      (this.value = ''),
      (this.nodes = [e]),
      (this.offsets = [
        t > 0 ? 1 : (e instanceof Ce ? e.text.length : e.children.length) << 1
      ])
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1,
        i = this.nodes[r],
        s = this.offsets[r],
        o = s >> 1,
        a = i instanceof Ce ? i.text.length : i.children.length
      if (o == (t > 0 ? a : 0)) {
        if (r == 0) return (this.done = !0), (this.value = ''), this
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop()
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (((this.offsets[r] += t), e == 0))
          return (
            (this.lineBreak = !0),
            (this.value = `
`),
            this
          )
        e--
      } else if (i instanceof Ce) {
        let l = i.text[o + (t < 0 ? -1 : 0)]
        if (((this.offsets[r] += t), l.length > Math.max(0, e)))
          return (
            (this.value =
              e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e)),
            this
          )
        e -= l.length
      } else {
        let l = i.children[o + (t < 0 ? -1 : 0)]
        e > l.length
          ? ((e -= l.length), (this.offsets[r] += t))
          : (t < 0 && this.offsets[r]--,
            this.nodes.push(l),
            this.offsets.push(
              t > 0
                ? 1
                : (l instanceof Ce ? l.text.length : l.children.length) << 1
            ))
      }
    }
  }
  next(e = 0) {
    return (
      e < 0 && (this.nextInner(-e, -this.dir), (e = this.value.length)),
      this.nextInner(e, this.dir)
    )
  }
}
class qg {
  constructor(e, t, r) {
    ;(this.value = ''),
      (this.done = !1),
      (this.cursor = new Wi(e, t > r ? -1 : 1)),
      (this.pos = t > r ? e.length : 0),
      (this.from = Math.min(t, r)),
      (this.to = Math.max(t, r))
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return (this.value = ''), (this.done = !0), this
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos)
    let r = t < 0 ? this.pos - this.from : this.to - this.pos
    e > r && (e = r), (r -= e)
    let { value: i } = this.cursor.next(e)
    return (
      (this.pos += (i.length + e) * t),
      (this.value =
        i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r)),
      (this.done = !this.value),
      this
    )
  }
  next(e = 0) {
    return (
      e < 0
        ? (e = Math.max(e, this.from - this.pos))
        : e > 0 && (e = Math.min(e, this.to - this.pos)),
      this.nextInner(e, this.cursor.dir)
    )
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != ''
  }
}
class zg {
  constructor(e) {
    ;(this.inner = e),
      (this.afterBreak = !0),
      (this.value = ''),
      (this.done = !1)
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e)
    return (
      t
        ? ((this.done = !0), (this.value = ''))
        : r
          ? this.afterBreak
            ? (this.value = '')
            : ((this.afterBreak = !0), this.next())
          : ((this.value = i), (this.afterBreak = !1)),
      this
    )
  }
  get lineBreak() {
    return !1
  }
}
typeof Symbol < 'u' &&
  ((le.prototype[Symbol.iterator] = function () {
    return this.iter()
  }),
  (Wi.prototype[Symbol.iterator] =
    qg.prototype[Symbol.iterator] =
    zg.prototype[Symbol.iterator] =
      function () {
        return this
      }))
class MQ {
  constructor(e, t, r, i) {
    ;(this.from = e), (this.to = t), (this.number = r), (this.text = i)
  }
  get length() {
    return this.to - this.from
  }
}
let Ir =
  'lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o'
    .split(',')
    .map((n) => (n ? parseInt(n, 36) : 1))
for (let n = 1; n < Ir.length; n++) Ir[n] += Ir[n - 1]
function VQ(n) {
  for (let e = 1; e < Ir.length; e += 2) if (Ir[e] > n) return Ir[e - 1] <= n
  return !1
}
function Fp(n) {
  return n >= 127462 && n <= 127487
}
const Gp = 8205
function He(n, e, t = !0, r = !0) {
  return (t ? Fg : WQ)(n, e, r)
}
function Fg(n, e, t) {
  if (e == n.length) return e
  e && Gg(n.charCodeAt(e)) && Hg(n.charCodeAt(e - 1)) && e--
  let r = Le(n, e)
  for (e += $t(r); e < n.length; ) {
    let i = Le(n, e)
    if (r == Gp || i == Gp || (t && VQ(i))) (e += $t(i)), (r = i)
    else if (Fp(i)) {
      let s = 0,
        o = e - 2
      for (; o >= 0 && Fp(Le(n, o)); ) s++, (o -= 2)
      if (s % 2 == 0) break
      e += 2
    } else break
  }
  return e
}
function WQ(n, e, t) {
  for (; e > 0; ) {
    let r = Fg(n, e - 2, t)
    if (r < e) return r
    e--
  }
  return 0
}
function Gg(n) {
  return n >= 56320 && n < 57344
}
function Hg(n) {
  return n >= 55296 && n < 56320
}
function Le(n, e) {
  let t = n.charCodeAt(e)
  if (!Hg(t) || e + 1 == n.length) return t
  let r = n.charCodeAt(e + 1)
  return Gg(r) ? ((t - 55296) << 10) + (r - 56320) + 65536 : t
}
function _f(n) {
  return n <= 65535
    ? String.fromCharCode(n)
    : ((n -= 65536), String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320))
}
function $t(n) {
  return n < 65536 ? 1 : 2
}
const hu = /\r\n?|\n/
var Ue = (function (n) {
  return (
    (n[(n.Simple = 0)] = 'Simple'),
    (n[(n.TrackDel = 1)] = 'TrackDel'),
    (n[(n.TrackBefore = 2)] = 'TrackBefore'),
    (n[(n.TrackAfter = 3)] = 'TrackAfter'),
    n
  )
})(Ue || (Ue = {}))
class nn {
  constructor(e) {
    this.sections = e
  }
  get length() {
    let e = 0
    for (let t = 0; t < this.sections.length; t += 2) e += this.sections[t]
    return e
  }
  get newLength() {
    let e = 0
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1]
      e += r < 0 ? this.sections[t] : r
    }
    return e
  }
  get empty() {
    return (
      this.sections.length == 0 ||
      (this.sections.length == 2 && this.sections[1] < 0)
    )
  }
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++],
        o = this.sections[t++]
      o < 0 ? (e(r, i, s), (i += s)) : (i += o), (r += s)
    }
  }
  iterChangedRanges(e, t = !1) {
    pu(this, e, t)
  }
  get invertedDesc() {
    let e = []
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++],
        i = this.sections[t++]
      i < 0 ? e.push(r, i) : e.push(i, r)
    }
    return new nn(e)
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Kg(this, e)
  }
  mapDesc(e, t = !1) {
    return e.empty ? this : du(this, e, t)
  }
  mapPos(e, t = -1, r = Ue.Simple) {
    let i = 0,
      s = 0
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++],
        l = this.sections[o++],
        c = i + a
      if (l < 0) {
        if (c > e) return s + (e - i)
        s += a
      } else {
        if (
          r != Ue.Simple &&
          c >= e &&
          ((r == Ue.TrackDel && i < e && c > e) ||
            (r == Ue.TrackBefore && i < e) ||
            (r == Ue.TrackAfter && c > e))
        )
          return null
        if (c > e || (c == e && t < 0 && !a)) return e == i || t < 0 ? s : s + l
        s += l
      }
      i = c
    }
    if (e > i)
      throw new RangeError(
        `Position ${e} is out of range for changeset of length ${i}`
      )
    return s
  }
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++],
        o = this.sections[r++],
        a = i + s
      if (o >= 0 && i <= t && a >= e) return i < e && a > t ? 'cover' : !0
      i = a
    }
    return !1
  }
  toString() {
    let e = ''
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++],
        i = this.sections[t++]
      e += (e ? ' ' : '') + r + (i >= 0 ? ':' + i : '')
    }
    return e
  }
  toJSON() {
    return this.sections
  }
  static fromJSON(e) {
    if (
      !Array.isArray(e) ||
      e.length % 2 ||
      e.some((t) => typeof t != 'number')
    )
      throw new RangeError('Invalid JSON representation of ChangeDesc')
    return new nn(e)
  }
  static create(e) {
    return new nn(e)
  }
}
class Ae extends nn {
  constructor(e, t) {
    super(e), (this.inserted = t)
  }
  apply(e) {
    if (this.length != e.length)
      throw new RangeError(
        'Applying change set to a document with the wrong length'
      )
    return (
      pu(this, (t, r, i, s, o) => (e = e.replace(i, i + (r - t), o)), !1), e
    )
  }
  mapDesc(e, t = !1) {
    return du(this, e, t, !0)
  }
  invert(e) {
    let t = this.sections.slice(),
      r = []
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i],
        a = t[i + 1]
      if (a >= 0) {
        ;(t[i] = a), (t[i + 1] = o)
        let l = i >> 1
        for (; r.length < l; ) r.push(le.empty)
        r.push(o ? e.slice(s, s + o) : le.empty)
      }
      s += o
    }
    return new Ae(t, r)
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : Kg(this, e, !0)
  }
  map(e, t = !1) {
    return e.empty ? this : du(this, e, t, !0)
  }
  iterChanges(e, t = !1) {
    pu(this, e, t)
  }
  get desc() {
    return nn.create(this.sections)
  }
  filter(e) {
    let t = [],
      r = [],
      i = [],
      s = new Fi(this)
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++]
      for (; a < l || (a == l && s.len == 0); ) {
        if (s.done) break e
        let u = Math.min(s.len, l - a)
        ze(i, u, -1)
        let f = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0
        ze(t, u, f), f > 0 && Dn(r, t, s.text), s.forward(u), (a += u)
      }
      let c = e[o++]
      for (; a < c; ) {
        if (s.done) break e
        let u = Math.min(s.len, c - a)
        ze(t, u, -1),
          ze(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0),
          s.forward(u),
          (a += u)
      }
    }
    return { changes: new Ae(t, r), filtered: nn.create(i) }
  }
  toJSON() {
    let e = []
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t],
        i = this.sections[t + 1]
      i < 0
        ? e.push(r)
        : i == 0
          ? e.push([r])
          : e.push([r].concat(this.inserted[t >> 1].toJSON()))
    }
    return e
  }
  static of(e, t, r) {
    let i = [],
      s = [],
      o = 0,
      a = null
    function l(u = !1) {
      if (!u && !i.length) return
      o < t && ze(i, t - o, -1)
      let f = new Ae(i, s)
      ;(a = a ? a.compose(f.map(a)) : f), (i = []), (s = []), (o = 0)
    }
    function c(u) {
      if (Array.isArray(u)) for (let f of u) c(f)
      else if (u instanceof Ae) {
        if (u.length != t)
          throw new RangeError(
            `Mismatched change set length (got ${u.length}, expected ${t})`
          )
        l(), (a = a ? a.compose(u.map(a)) : u)
      } else {
        let { from: f, to: p = f, insert: d } = u
        if (f > p || f < 0 || p > t)
          throw new RangeError(
            `Invalid change range ${f} to ${p} (in doc of length ${t})`
          )
        let O = d
            ? typeof d == 'string'
              ? le.of(d.split(r || hu))
              : d
            : le.empty,
          g = O.length
        if (f == p && g == 0) return
        f < o && l(),
          f > o && ze(i, f - o, -1),
          ze(i, p - f, g),
          Dn(s, i, O),
          (o = p)
      }
    }
    return c(e), l(!a), a
  }
  static empty(e) {
    return new Ae(e ? [e, -1] : [], [])
  }
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError('Invalid JSON representation of ChangeSet')
    let t = [],
      r = []
    for (let i = 0; i < e.length; i++) {
      let s = e[i]
      if (typeof s == 'number') t.push(s, -1)
      else {
        if (
          !Array.isArray(s) ||
          typeof s[0] != 'number' ||
          s.some((o, a) => a && typeof o != 'string')
        )
          throw new RangeError('Invalid JSON representation of ChangeSet')
        if (s.length == 1) t.push(s[0], 0)
        else {
          for (; r.length < i; ) r.push(le.empty)
          ;(r[i] = le.of(s.slice(1))), t.push(s[0], r[i].length)
        }
      }
    }
    return new Ae(t, r)
  }
  static createSet(e, t) {
    return new Ae(e, t)
  }
}
function ze(n, e, t, r = !1) {
  if (e == 0 && t <= 0) return
  let i = n.length - 2
  i >= 0 && t <= 0 && t == n[i + 1]
    ? (n[i] += e)
    : e == 0 && n[i] == 0
      ? (n[i + 1] += t)
      : r
        ? ((n[i] += e), (n[i + 1] += t))
        : n.push(e, t)
}
function Dn(n, e, t) {
  if (t.length == 0) return
  let r = (e.length - 2) >> 1
  if (r < n.length) n[n.length - 1] = n[n.length - 1].append(t)
  else {
    for (; n.length < r; ) n.push(le.empty)
    n.push(t)
  }
}
function pu(n, e, t) {
  let r = n.inserted
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let a = n.sections[o++],
      l = n.sections[o++]
    if (l < 0) (i += a), (s += a)
    else {
      let c = i,
        u = s,
        f = le.empty
      for (
        ;
        (c += a),
          (u += l),
          l && r && (f = f.append(r[(o - 2) >> 1])),
          !(t || o == n.sections.length || n.sections[o + 1] < 0);

      )
        (a = n.sections[o++]), (l = n.sections[o++])
      e(i, c, s, u, f), (i = c), (s = u)
    }
  }
}
function du(n, e, t, r = !1) {
  let i = [],
    s = r ? [] : null,
    o = new Fi(n),
    a = new Fi(e)
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len)
      ze(i, c, -1), o.forward(c), a.forward(c)
    } else if (
      a.ins >= 0 &&
      (o.ins < 0 ||
        l == o.i ||
        (o.off == 0 && (a.len < o.len || (a.len == o.len && !t))))
    ) {
      let c = a.len
      for (ze(i, a.ins, -1); c; ) {
        let u = Math.min(o.len, c)
        o.ins >= 0 &&
          l < o.i &&
          o.len <= u &&
          (ze(i, 0, o.ins), s && Dn(s, i, o.text), (l = o.i)),
          o.forward(u),
          (c -= u)
      }
      a.next()
    } else if (o.ins >= 0) {
      let c = 0,
        u = o.len
      for (; u; )
        if (a.ins == -1) {
          let f = Math.min(u, a.len)
          ;(c += f), (u -= f), a.forward(f)
        } else if (a.ins == 0 && a.len < u) (u -= a.len), a.next()
        else break
      ze(i, c, l < o.i ? o.ins : 0),
        s && l < o.i && Dn(s, i, o.text),
        (l = o.i),
        o.forward(o.len - u)
    } else {
      if (o.done && a.done) return s ? Ae.createSet(i, s) : nn.create(i)
      throw new Error('Mismatched change set lengths')
    }
}
function Kg(n, e, t = !1) {
  let r = [],
    i = t ? [] : null,
    s = new Fi(n),
    o = new Fi(e)
  for (let a = !1; ; ) {
    if (s.done && o.done) return i ? Ae.createSet(r, i) : nn.create(r)
    if (s.ins == 0) ze(r, s.len, 0, a), s.next()
    else if (o.len == 0 && !o.done)
      ze(r, 0, o.ins, a), i && Dn(i, r, o.text), o.next()
    else {
      if (s.done || o.done) throw new Error('Mismatched change set lengths')
      {
        let l = Math.min(s.len2, o.len),
          c = r.length
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins
          ze(r, l, u, a), i && u && Dn(i, r, o.text)
        } else
          o.ins == -1
            ? (ze(r, s.off ? 0 : s.len, l, a), i && Dn(i, r, s.textBit(l)))
            : (ze(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a),
              i && !o.off && Dn(i, r, o.text))
        ;(a = (s.ins > l || (o.ins >= 0 && o.len > l)) && (a || r.length > c)),
          s.forward2(l),
          o.forward(l)
      }
    }
  }
}
class Fi {
  constructor(e) {
    ;(this.set = e), (this.i = 0), this.next()
  }
  next() {
    let { sections: e } = this.set
    this.i < e.length
      ? ((this.len = e[this.i++]), (this.ins = e[this.i++]))
      : ((this.len = 0), (this.ins = -2)),
      (this.off = 0)
  }
  get done() {
    return this.ins == -2
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins
  }
  get text() {
    let { inserted: e } = this.set,
      t = (this.i - 2) >> 1
    return t >= e.length ? le.empty : e[t]
  }
  textBit(e) {
    let { inserted: t } = this.set,
      r = (this.i - 2) >> 1
    return r >= t.length && !e
      ? le.empty
      : t[r].slice(this.off, e == null ? void 0 : this.off + e)
  }
  forward(e) {
    e == this.len ? this.next() : ((this.len -= e), (this.off += e))
  }
  forward2(e) {
    this.ins == -1
      ? this.forward(e)
      : e == this.ins
        ? this.next()
        : ((this.ins -= e), (this.off += e))
  }
}
class hr {
  constructor(e, t, r) {
    ;(this.from = e), (this.to = t), (this.flags = r)
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from
  }
  get head() {
    return this.flags & 32 ? this.from : this.to
  }
  get empty() {
    return this.from == this.to
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0
  }
  get bidiLevel() {
    let e = this.flags & 7
    return e == 7 ? null : e
  }
  get goalColumn() {
    let e = this.flags >> 6
    return e == 16777215 ? void 0 : e
  }
  map(e, t = -1) {
    let r, i
    return (
      this.empty
        ? (r = i = e.mapPos(this.from, t))
        : ((r = e.mapPos(this.from, 1)), (i = e.mapPos(this.to, -1))),
      r == this.from && i == this.to ? this : new hr(r, i, this.flags)
    )
  }
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor) return C.range(e, t)
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t
    return C.range(this.anchor, r)
  }
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head }
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != 'number' || typeof e.head != 'number')
      throw new RangeError('Invalid JSON representation for SelectionRange')
    return C.range(e.anchor, e.head)
  }
  static create(e, t, r) {
    return new hr(e, t, r)
  }
}
class C {
  constructor(e, t) {
    ;(this.ranges = e), (this.mainIndex = t)
  }
  map(e, t = -1) {
    return e.empty
      ? this
      : C.create(
          this.ranges.map((r) => r.map(e, t)),
          this.mainIndex
        )
  }
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t])) return !1
    return !0
  }
  get main() {
    return this.ranges[this.mainIndex]
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new C([this.main], 0)
  }
  addRange(e, t = !0) {
    return C.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1)
  }
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice()
    return (r[t] = e), C.create(r, this.mainIndex)
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex }
  }
  static fromJSON(e) {
    if (
      !e ||
      !Array.isArray(e.ranges) ||
      typeof e.main != 'number' ||
      e.main >= e.ranges.length
    )
      throw new RangeError('Invalid JSON representation for EditorSelection')
    return new C(
      e.ranges.map((t) => hr.fromJSON(t)),
      e.main
    )
  }
  static single(e, t = e) {
    return new C([C.range(e, t)], 0)
  }
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError('A selection needs at least one range')
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i]
      if (s.empty ? s.from <= r : s.from < r) return C.normalized(e.slice(), t)
      r = s.to
    }
    return new C(e, t)
  }
  static cursor(e, t = 0, r, i) {
    return hr.create(
      e,
      e,
      (t == 0 ? 0 : t < 0 ? 8 : 16) |
        (r == null ? 7 : Math.min(6, r)) |
        ((i ?? 16777215) << 6)
    )
  }
  static range(e, t, r, i) {
    let s = ((r ?? 16777215) << 6) | (i == null ? 7 : Math.min(6, i))
    return t < e
      ? hr.create(t, e, 48 | s)
      : hr.create(e, t, (t > e ? 8 : 0) | s)
  }
  static normalized(e, t = 0) {
    let r = e[t]
    e.sort((i, s) => i.from - s.from), (t = e.indexOf(r))
    for (let i = 1; i < e.length; i++) {
      let s = e[i],
        o = e[i - 1]
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from,
          l = Math.max(s.to, o.to)
        i <= t && t--,
          e.splice(--i, 2, s.anchor > s.head ? C.range(l, a) : C.range(a, l))
      }
    }
    return new C(e, t)
  }
}
function Jg(n, e) {
  for (let t of n.ranges)
    if (t.to > e) throw new RangeError('Selection points outside of document')
}
let Rf = 0
class U {
  constructor(e, t, r, i, s) {
    ;(this.combine = e),
      (this.compareInput = t),
      (this.compare = r),
      (this.isStatic = i),
      (this.id = Rf++),
      (this.default = e([])),
      (this.extensions = typeof s == 'function' ? s(this) : s)
  }
  get reader() {
    return this
  }
  static define(e = {}) {
    return new U(
      e.combine || ((t) => t),
      e.compareInput || ((t, r) => t === r),
      e.compare || (e.combine ? (t, r) => t === r : Zf),
      !!e.static,
      e.enables
    )
  }
  of(e) {
    return new Do([], this, 0, e)
  }
  compute(e, t) {
    if (this.isStatic) throw new Error("Can't compute a static facet")
    return new Do(e, this, 1, t)
  }
  computeN(e, t) {
    if (this.isStatic) throw new Error("Can't compute a static facet")
    return new Do(e, this, 2, t)
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)))
  }
}
function Zf(n, e) {
  return n == e || (n.length == e.length && n.every((t, r) => t === e[r]))
}
class Do {
  constructor(e, t, r, i) {
    ;(this.dependencies = e),
      (this.facet = t),
      (this.type = r),
      (this.value = i),
      (this.id = Rf++)
  }
  dynamicSlot(e) {
    var t
    let r = this.value,
      i = this.facet.compareInput,
      s = this.id,
      o = e[s] >> 1,
      a = this.type == 2,
      l = !1,
      c = !1,
      u = []
    for (let f of this.dependencies)
      f == 'doc'
        ? (l = !0)
        : f == 'selection'
          ? (c = !0)
          : ((t = e[f.id]) !== null && t !== void 0 ? t : 1) & 1 ||
            u.push(e[f.id])
    return {
      create(f) {
        return (f.values[o] = r(f)), 1
      },
      update(f, p) {
        if (
          (l && p.docChanged) ||
          (c && (p.docChanged || p.selection)) ||
          Ou(f, u)
        ) {
          let d = r(f)
          if (a ? !Hp(d, f.values[o], i) : !i(d, f.values[o]))
            return (f.values[o] = d), 1
        }
        return 0
      },
      reconfigure: (f, p) => {
        let d,
          O = p.config.address[s]
        if (O != null) {
          let g = wa(p, O)
          if (
            this.dependencies.every((b) =>
              b instanceof U
                ? p.facet(b) === f.facet(b)
                : b instanceof je
                  ? p.field(b, !1) == f.field(b, !1)
                  : !0
            ) ||
            (a ? Hp((d = r(f)), g, i) : i((d = r(f)), g))
          )
            return (f.values[o] = g), 0
        } else d = r(f)
        return (f.values[o] = d), 1
      }
    }
  }
}
function Hp(n, e, t) {
  if (n.length != e.length) return !1
  for (let r = 0; r < n.length; r++) if (!t(n[r], e[r])) return !1
  return !0
}
function Ou(n, e) {
  let t = !1
  for (let r of e) Li(n, r) & 1 && (t = !0)
  return t
}
function LQ(n, e, t) {
  let r = t.map((l) => n[l.id]),
    i = t.map((l) => l.type),
    s = r.filter((l) => !(l & 1)),
    o = n[e.id] >> 1
  function a(l) {
    let c = []
    for (let u = 0; u < r.length; u++) {
      let f = wa(l, r[u])
      if (i[u] == 2) for (let p of f) c.push(p)
      else c.push(f)
    }
    return e.combine(c)
  }
  return {
    create(l) {
      for (let c of r) Li(l, c)
      return (l.values[o] = a(l)), 1
    },
    update(l, c) {
      if (!Ou(l, s)) return 0
      let u = a(l)
      return e.compare(u, l.values[o]) ? 0 : ((l.values[o] = u), 1)
    },
    reconfigure(l, c) {
      let u = Ou(l, r),
        f = c.config.facets[e.id],
        p = c.facet(e)
      if (f && !u && Zf(t, f)) return (l.values[o] = p), 0
      let d = a(l)
      return e.compare(d, p) ? ((l.values[o] = p), 0) : ((l.values[o] = d), 1)
    }
  }
}
const Kp = U.define({ static: !0 })
class je {
  constructor(e, t, r, i, s) {
    ;(this.id = e),
      (this.createF = t),
      (this.updateF = r),
      (this.compareF = i),
      (this.spec = s),
      (this.provides = void 0)
  }
  static define(e) {
    let t = new je(
      Rf++,
      e.create,
      e.update,
      e.compare || ((r, i) => r === i),
      e
    )
    return e.provide && (t.provides = e.provide(t)), t
  }
  create(e) {
    let t = e.facet(Kp).find((r) => r.field == this)
    return ((t == null ? void 0 : t.create) || this.createF)(e)
  }
  slot(e) {
    let t = e[this.id] >> 1
    return {
      create: (r) => ((r.values[t] = this.create(r)), 1),
      update: (r, i) => {
        let s = r.values[t],
          o = this.updateF(s, i)
        return this.compareF(s, o) ? 0 : ((r.values[t] = o), 1)
      },
      reconfigure: (r, i) =>
        i.config.address[this.id] != null
          ? ((r.values[t] = i.field(this)), 0)
          : ((r.values[t] = this.create(r)), 1)
    }
  }
  init(e) {
    return [this, Kp.of({ field: this, create: e })]
  }
  get extension() {
    return this
  }
}
const cr = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 }
function wi(n) {
  return (e) => new ey(e, n)
}
const vr = {
  highest: wi(cr.highest),
  high: wi(cr.high),
  default: wi(cr.default),
  low: wi(cr.low),
  lowest: wi(cr.lowest)
}
class ey {
  constructor(e, t) {
    ;(this.inner = e), (this.prec = t)
  }
}
class ml {
  of(e) {
    return new mu(this, e)
  }
  reconfigure(e) {
    return ml.reconfigure.of({ compartment: this, extension: e })
  }
  get(e) {
    return e.config.compartments.get(this)
  }
}
class mu {
  constructor(e, t) {
    ;(this.compartment = e), (this.inner = t)
  }
}
class xa {
  constructor(e, t, r, i, s, o) {
    for (
      this.base = e,
        this.compartments = t,
        this.dynamicSlots = r,
        this.address = i,
        this.staticValues = s,
        this.facets = o,
        this.statusTemplate = [];
      this.statusTemplate.length < r.length;

    )
      this.statusTemplate.push(0)
  }
  staticFacet(e) {
    let t = this.address[e.id]
    return t == null ? e.default : this.staticValues[t >> 1]
  }
  static resolve(e, t, r) {
    let i = [],
      s = Object.create(null),
      o = new Map()
    for (let p of BQ(e, t, o))
      p instanceof je
        ? i.push(p)
        : (s[p.facet.id] || (s[p.facet.id] = [])).push(p)
    let a = Object.create(null),
      l = [],
      c = []
    for (let p of i) (a[p.id] = c.length << 1), c.push((d) => p.slot(d))
    let u = r == null ? void 0 : r.config.facets
    for (let p in s) {
      let d = s[p],
        O = d[0].facet,
        g = (u && u[p]) || []
      if (d.every((b) => b.type == 0))
        if (((a[O.id] = (l.length << 1) | 1), Zf(g, d))) l.push(r.facet(O))
        else {
          let b = O.combine(d.map((x) => x.value))
          l.push(r && O.compare(b, r.facet(O)) ? r.facet(O) : b)
        }
      else {
        for (let b of d)
          b.type == 0
            ? ((a[b.id] = (l.length << 1) | 1), l.push(b.value))
            : ((a[b.id] = c.length << 1), c.push((x) => b.dynamicSlot(x)))
        ;(a[O.id] = c.length << 1), c.push((b) => LQ(b, O, d))
      }
    }
    let f = c.map((p) => p(a))
    return new xa(e, o, f, a, l, s)
  }
}
function BQ(n, e, t) {
  let r = [[], [], [], [], []],
    i = new Map()
  function s(o, a) {
    let l = i.get(o)
    if (l != null) {
      if (l <= a) return
      let c = r[l].indexOf(o)
      c > -1 && r[l].splice(c, 1), o instanceof mu && t.delete(o.compartment)
    }
    if ((i.set(o, a), Array.isArray(o))) for (let c of o) s(c, a)
    else if (o instanceof mu) {
      if (t.has(o.compartment))
        throw new RangeError('Duplicate use of compartment in extensions')
      let c = e.get(o.compartment) || o.inner
      t.set(o.compartment, c), s(c, a)
    } else if (o instanceof ey) s(o.inner, o.prec)
    else if (o instanceof je) r[a].push(o), o.provides && s(o.provides, a)
    else if (o instanceof Do)
      r[a].push(o), o.facet.extensions && s(o.facet.extensions, cr.default)
    else {
      let c = o.extension
      if (!c)
        throw new Error(
          `Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`
        )
      s(c, a)
    }
  }
  return s(n, cr.default), r.reduce((o, a) => o.concat(a))
}
function Li(n, e) {
  if (e & 1) return 2
  let t = e >> 1,
    r = n.status[t]
  if (r == 4) throw new Error('Cyclic dependency between fields and/or facets')
  if (r & 2) return r
  n.status[t] = 4
  let i = n.computeSlot(n, n.config.dynamicSlots[t])
  return (n.status[t] = 2 | i)
}
function wa(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1]
}
const ty = U.define(),
  ny = U.define({ combine: (n) => n.some((e) => e), static: !0 }),
  ry = U.define({ combine: (n) => (n.length ? n[0] : void 0), static: !0 }),
  iy = U.define(),
  sy = U.define(),
  oy = U.define(),
  ay = U.define({ combine: (n) => (n.length ? n[0] : !1) })
class sn {
  constructor(e, t) {
    ;(this.type = e), (this.value = t)
  }
  static define() {
    return new UQ()
  }
}
class UQ {
  of(e) {
    return new sn(this, e)
  }
}
class qQ {
  constructor(e) {
    this.map = e
  }
  of(e) {
    return new ee(this, e)
  }
}
class ee {
  constructor(e, t) {
    ;(this.type = e), (this.value = t)
  }
  map(e) {
    let t = this.type.map(this.value, e)
    return t === void 0 ? void 0 : t == this.value ? this : new ee(this.type, t)
  }
  is(e) {
    return this.type == e
  }
  static define(e = {}) {
    return new qQ(e.map || ((t) => t))
  }
  static mapEffects(e, t) {
    if (!e.length) return e
    let r = []
    for (let i of e) {
      let s = i.map(t)
      s && r.push(s)
    }
    return r
  }
}
ee.reconfigure = ee.define()
ee.appendConfig = ee.define()
class Ee {
  constructor(e, t, r, i, s, o) {
    ;(this.startState = e),
      (this.changes = t),
      (this.selection = r),
      (this.effects = i),
      (this.annotations = s),
      (this.scrollIntoView = o),
      (this._doc = null),
      (this._state = null),
      r && Jg(r, t.newLength),
      s.some((a) => a.type == Ee.time) ||
        (this.annotations = s.concat(Ee.time.of(Date.now())))
  }
  static create(e, t, r, i, s, o) {
    return new Ee(e, t, r, i, s, o)
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc))
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes)
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state
  }
  annotation(e) {
    for (let t of this.annotations) if (t.type == e) return t.value
  }
  get docChanged() {
    return !this.changes.empty
  }
  get reconfigured() {
    return this.startState.config != this.state.config
  }
  isUserEvent(e) {
    let t = this.annotation(Ee.userEvent)
    return !!(
      t &&
      (t == e ||
        (t.length > e.length &&
          t.slice(0, e.length) == e &&
          t[e.length] == '.'))
    )
  }
}
Ee.time = sn.define()
Ee.userEvent = sn.define()
Ee.addToHistory = sn.define()
Ee.remote = sn.define()
function zQ(n, e) {
  let t = []
  for (let r = 0, i = 0; ; ) {
    let s, o
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      (s = n[r++]), (o = n[r++])
    else if (i < e.length) (s = e[i++]), (o = e[i++])
    else return t
    !t.length || t[t.length - 1] < s
      ? t.push(s, o)
      : t[t.length - 1] < o && (t[t.length - 1] = o)
  }
}
function ly(n, e, t) {
  var r
  let i, s, o
  return (
    t
      ? ((i = e.changes),
        (s = Ae.empty(e.changes.length)),
        (o = n.changes.compose(e.changes)))
      : ((i = e.changes.map(n.changes)),
        (s = n.changes.mapDesc(e.changes, !0)),
        (o = n.changes.compose(i))),
    {
      changes: o,
      selection: e.selection
        ? e.selection.map(s)
        : (r = n.selection) === null || r === void 0
          ? void 0
          : r.map(i),
      effects: ee.mapEffects(n.effects, i).concat(ee.mapEffects(e.effects, s)),
      annotations: n.annotations.length
        ? n.annotations.concat(e.annotations)
        : e.annotations,
      scrollIntoView: n.scrollIntoView || e.scrollIntoView
    }
  )
}
function gu(n, e, t) {
  let r = e.selection,
    i = jr(e.annotations)
  return (
    e.userEvent && (i = i.concat(Ee.userEvent.of(e.userEvent))),
    {
      changes:
        e.changes instanceof Ae
          ? e.changes
          : Ae.of(e.changes || [], t, n.facet(ry)),
      selection: r && (r instanceof C ? r : C.single(r.anchor, r.head)),
      effects: jr(e.effects),
      annotations: i,
      scrollIntoView: !!e.scrollIntoView
    }
  )
}
function cy(n, e, t) {
  let r = gu(n, e.length ? e[0] : {}, n.doc.length)
  e.length && e[0].filter === !1 && (t = !1)
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1)
    let o = !!e[s].sequential
    r = ly(r, gu(n, e[s], o ? r.changes.newLength : n.doc.length), o)
  }
  let i = Ee.create(
    n,
    r.changes,
    r.selection,
    r.effects,
    r.annotations,
    r.scrollIntoView
  )
  return GQ(t ? FQ(i) : i)
}
function FQ(n) {
  let e = n.startState,
    t = !0
  for (let i of e.facet(iy)) {
    let s = i(n)
    if (s === !1) {
      t = !1
      break
    }
    Array.isArray(s) && (t = t === !0 ? s : zQ(t, s))
  }
  if (t !== !0) {
    let i, s
    if (t === !1) (s = n.changes.invertedDesc), (i = Ae.empty(e.doc.length))
    else {
      let o = n.changes.filter(t)
      ;(i = o.changes), (s = o.filtered.mapDesc(o.changes).invertedDesc)
    }
    n = Ee.create(
      e,
      i,
      n.selection && n.selection.map(s),
      ee.mapEffects(n.effects, s),
      n.annotations,
      n.scrollIntoView
    )
  }
  let r = e.facet(sy)
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n)
    s instanceof Ee
      ? (n = s)
      : Array.isArray(s) && s.length == 1 && s[0] instanceof Ee
        ? (n = s[0])
        : (n = cy(e, jr(s), !1))
  }
  return n
}
function GQ(n) {
  let e = n.startState,
    t = e.facet(oy),
    r = n
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n)
    s && Object.keys(s).length && (r = ly(r, gu(e, s, n.changes.newLength), !0))
  }
  return r == n
    ? n
    : Ee.create(
        e,
        n.changes,
        n.selection,
        r.effects,
        r.annotations,
        r.scrollIntoView
      )
}
const HQ = []
function jr(n) {
  return n == null ? HQ : Array.isArray(n) ? n : [n]
}
var Se = (function (n) {
  return (
    (n[(n.Word = 0)] = 'Word'),
    (n[(n.Space = 1)] = 'Space'),
    (n[(n.Other = 2)] = 'Other'),
    n
  )
})(Se || (Se = {}))
const KQ =
  /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
let yu
try {
  yu = new RegExp('[\\p{Alphabetic}\\p{Number}_]', 'u')
} catch {}
function JQ(n) {
  if (yu) return yu.test(n)
  for (let e = 0; e < n.length; e++) {
    let t = n[e]
    if (
      /\w/.test(t) ||
      (t > '' && (t.toUpperCase() != t.toLowerCase() || KQ.test(t)))
    )
      return !0
  }
  return !1
}
function ek(n) {
  return (e) => {
    if (!/\S/.test(e)) return Se.Space
    if (JQ(e)) return Se.Word
    for (let t = 0; t < n.length; t++) if (e.indexOf(n[t]) > -1) return Se.Word
    return Se.Other
  }
}
class ie {
  constructor(e, t, r, i, s, o) {
    ;(this.config = e),
      (this.doc = t),
      (this.selection = r),
      (this.values = i),
      (this.status = e.statusTemplate.slice()),
      (this.computeSlot = s),
      o && (o._state = this)
    for (let a = 0; a < this.config.dynamicSlots.length; a++) Li(this, a << 1)
    this.computeSlot = null
  }
  field(e, t = !0) {
    let r = this.config.address[e.id]
    if (r == null) {
      if (t) throw new RangeError('Field is not present in this state')
      return
    }
    return Li(this, r), wa(this, r)
  }
  update(...e) {
    return cy(this, e, !0)
  }
  applyTransaction(e) {
    let t = this.config,
      { base: r, compartments: i } = t
    for (let o of e.effects)
      o.is(ml.reconfigure)
        ? (t &&
            ((i = new Map()),
            t.compartments.forEach((a, l) => i.set(l, a)),
            (t = null)),
          i.set(o.value.compartment, o.value.extension))
        : o.is(ee.reconfigure)
          ? ((t = null), (r = o.value))
          : o.is(ee.appendConfig) && ((t = null), (r = jr(r).concat(o.value)))
    let s
    t
      ? (s = e.startState.values.slice())
      : ((t = xa.resolve(r, i, this)),
        (s = new ie(
          t,
          this.doc,
          this.selection,
          t.dynamicSlots.map(() => null),
          (a, l) => l.reconfigure(a, this),
          null
        ).values)),
      new ie(t, e.newDoc, e.newSelection, s, (o, a) => a.update(o, e), e)
  }
  replaceSelection(e) {
    return (
      typeof e == 'string' && (e = this.toText(e)),
      this.changeByRange((t) => ({
        changes: { from: t.from, to: t.to, insert: e },
        range: C.cursor(t.from + e.length)
      }))
    )
  }
  changeByRange(e) {
    let t = this.selection,
      r = e(t.ranges[0]),
      i = this.changes(r.changes),
      s = [r.range],
      o = jr(r.effects)
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]),
        c = this.changes(l.changes),
        u = c.map(i)
      for (let p = 0; p < a; p++) s[p] = s[p].map(u)
      let f = i.mapDesc(c, !0)
      s.push(l.range.map(f)),
        (i = i.compose(u)),
        (o = ee.mapEffects(o, u).concat(ee.mapEffects(jr(l.effects), f)))
    }
    return { changes: i, selection: C.create(s, t.mainIndex), effects: o }
  }
  changes(e = []) {
    return e instanceof Ae
      ? e
      : Ae.of(e, this.doc.length, this.facet(ie.lineSeparator))
  }
  toText(e) {
    return le.of(e.split(this.facet(ie.lineSeparator) || hu))
  }
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak)
  }
  facet(e) {
    let t = this.config.address[e.id]
    return t == null ? e.default : (Li(this, t), wa(this, t))
  }
  toJSON(e) {
    let t = { doc: this.sliceDoc(), selection: this.selection.toJSON() }
    if (e)
      for (let r in e) {
        let i = e[r]
        i instanceof je &&
          this.config.address[i.id] != null &&
          (t[r] = i.spec.toJSON(this.field(e[r]), this))
      }
    return t
  }
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != 'string')
      throw new RangeError('Invalid JSON representation for EditorState')
    let i = []
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s],
            a = e[s]
          i.push(o.init((l) => o.spec.fromJSON(a, l)))
        }
    }
    return ie.create({
      doc: e.doc,
      selection: C.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    })
  }
  static create(e = {}) {
    let t = xa.resolve(e.extensions || [], new Map()),
      r =
        e.doc instanceof le
          ? e.doc
          : le.of((e.doc || '').split(t.staticFacet(ie.lineSeparator) || hu)),
      i = e.selection
        ? e.selection instanceof C
          ? e.selection
          : C.single(e.selection.anchor, e.selection.head)
        : C.single(0)
    return (
      Jg(i, r.length),
      t.staticFacet(ny) || (i = i.asSingle()),
      new ie(
        t,
        r,
        i,
        t.dynamicSlots.map(() => null),
        (s, o) => o.create(s),
        null
      )
    )
  }
  get tabSize() {
    return this.facet(ie.tabSize)
  }
  get lineBreak() {
    return (
      this.facet(ie.lineSeparator) ||
      `
`
    )
  }
  get readOnly() {
    return this.facet(ay)
  }
  phrase(e, ...t) {
    for (let r of this.facet(ie.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e]
        break
      }
    return (
      t.length &&
        (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
          if (i == '$') return '$'
          let s = +(i || 1)
          return !s || s > t.length ? r : t[s - 1]
        })),
      e
    )
  }
  languageDataAt(e, t, r = -1) {
    let i = []
    for (let s of this.facet(ty))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e])
    return i
  }
  charCategorizer(e) {
    return ek(this.languageDataAt('wordChars', e).join(''))
  }
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e),
      s = this.charCategorizer(e),
      o = e - r,
      a = e - r
    for (; o > 0; ) {
      let l = He(t, o, !1)
      if (s(t.slice(l, o)) != Se.Word) break
      o = l
    }
    for (; a < i; ) {
      let l = He(t, a)
      if (s(t.slice(a, l)) != Se.Word) break
      a = l
    }
    return o == a ? null : C.range(o + r, a + r)
  }
}
ie.allowMultipleSelections = ny
ie.tabSize = U.define({ combine: (n) => (n.length ? n[0] : 4) })
ie.lineSeparator = ry
ie.readOnly = ay
ie.phrases = U.define({
  compare(n, e) {
    let t = Object.keys(n),
      r = Object.keys(e)
    return t.length == r.length && t.every((i) => n[i] == e[i])
  }
})
ie.languageData = ty
ie.changeFilter = iy
ie.transactionFilter = sy
ie.transactionExtender = oy
ml.reconfigure = ee.define()
function on(n, e, t = {}) {
  let r = {}
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s],
        a = r[s]
      if (a === void 0) r[s] = o
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(t, s)) r[s] = t[s](a, o)
        else throw new Error('Config merge conflict for field ' + s)
    }
  for (let i in e) r[i] === void 0 && (r[i] = e[i])
  return r
}
class Or {
  eq(e) {
    return this == e
  }
  range(e, t = e) {
    return bu.create(e, t, this)
  }
}
Or.prototype.startSide = Or.prototype.endSide = 0
Or.prototype.point = !1
Or.prototype.mapMode = Ue.TrackDel
let bu = class uy {
  constructor(e, t, r) {
    ;(this.from = e), (this.to = t), (this.value = r)
  }
  static create(e, t, r) {
    return new uy(e, t, r)
  }
}
function vu(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide
}
class Af {
  constructor(e, t, r, i) {
    ;(this.from = e), (this.to = t), (this.value = r), (this.maxPoint = i)
  }
  get length() {
    return this.to[this.to.length - 1]
  }
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from
    for (let o = i, a = s.length; ; ) {
      if (o == a) return o
      let l = (o + a) >> 1,
        c =
          s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t
      if (l == o) return c >= 0 ? o : a
      c >= 0 ? (a = l) : (o = l + 1)
    }
  }
  between(e, t, r, i) {
    for (
      let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s);
      s < o;
      s++
    )
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1) return !1
  }
  map(e, t) {
    let r = [],
      i = [],
      s = [],
      o = -1,
      a = -1
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l],
        u = this.from[l] + e,
        f = this.to[l] + e,
        p,
        d
      if (u == f) {
        let O = t.mapPos(u, c.startSide, c.mapMode)
        if (
          O == null ||
          ((p = d = O),
          c.startSide != c.endSide && ((d = t.mapPos(u, c.endSide)), d < p))
        )
          continue
      } else if (
        ((p = t.mapPos(u, c.startSide)),
        (d = t.mapPos(f, c.endSide)),
        p > d || (p == d && c.startSide > 0 && c.endSide <= 0))
      )
        continue
      ;(d - p || c.endSide - c.startSide) < 0 ||
        (o < 0 && (o = p),
        c.point && (a = Math.max(a, d - p)),
        r.push(c),
        i.push(p - o),
        s.push(d - o))
    }
    return { mapped: r.length ? new Af(i, s, r, a) : null, pos: o }
  }
}
class ce {
  constructor(e, t, r, i) {
    ;(this.chunkPos = e),
      (this.chunk = t),
      (this.nextLayer = r),
      (this.maxPoint = i)
  }
  static create(e, t, r, i) {
    return new ce(e, t, r, i)
  }
  get length() {
    let e = this.chunk.length - 1
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length)
  }
  get size() {
    if (this.isEmpty) return 0
    let e = this.nextLayer.size
    for (let t of this.chunk) e += t.value.length
    return e
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length
  }
  update(e) {
    let {
        add: t = [],
        sort: r = !1,
        filterFrom: i = 0,
        filterTo: s = this.length
      } = e,
      o = e.filter
    if (t.length == 0 && !o) return this
    if ((r && (t = t.slice().sort(vu)), this.isEmpty))
      return t.length ? ce.of(t) : this
    let a = new fy(this, null, -1).goto(0),
      l = 0,
      c = [],
      u = new Wn()
    for (; a.value || l < t.length; )
      if (
        l < t.length &&
        (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0
      ) {
        let f = t[l++]
        u.addInner(f.from, f.to, f.value) || c.push(f)
      } else
        a.rangeIndex == 1 &&
        a.chunkIndex < this.chunk.length &&
        (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) &&
        (!o ||
          i > this.chunkEnd(a.chunkIndex) ||
          s < this.chunkPos[a.chunkIndex]) &&
        u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex])
          ? a.nextChunk()
          : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) &&
              (u.addInner(a.from, a.to, a.value) ||
                c.push(bu.create(a.from, a.to, a.value))),
            a.next())
    return u.finishInner(
      this.nextLayer.isEmpty && !c.length
        ? ce.empty
        : this.nextLayer.update({
            add: c,
            filter: o,
            filterFrom: i,
            filterTo: s
          })
    )
  }
  map(e) {
    if (e.empty || this.isEmpty) return this
    let t = [],
      r = [],
      i = -1
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o],
        l = this.chunk[o],
        c = e.touchesRange(a, a + l.length)
      if (c === !1)
        (i = Math.max(i, l.maxPoint)), t.push(l), r.push(e.mapPos(a))
      else if (c === !0) {
        let { mapped: u, pos: f } = l.map(a, e)
        u && ((i = Math.max(i, u.maxPoint)), t.push(u), r.push(f))
      }
    }
    let s = this.nextLayer.map(e)
    return t.length == 0 ? s : new ce(r, t, s || ce.empty, i)
  }
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i],
          o = this.chunk[i]
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return
      }
      this.nextLayer.between(e, t, r)
    }
  }
  iter(e = 0) {
    return Gi.from([this]).goto(e)
  }
  get isEmpty() {
    return this.nextLayer == this
  }
  static iter(e, t = 0) {
    return Gi.from(e).goto(t)
  }
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((f) => f.maxPoint > 0 || (!f.isEmpty && f.maxPoint >= s)),
      a = t.filter((f) => f.maxPoint > 0 || (!f.isEmpty && f.maxPoint >= s)),
      l = Jp(o, a, r),
      c = new Pi(o, l, s),
      u = new Pi(a, l, s)
    r.iterGaps((f, p, d) => ed(c, f, u, p, d, i)),
      r.empty && r.length == 0 && ed(c, 0, u, 0, 0, i)
  }
  static eq(e, t, r = 0, i) {
    i == null && (i = 1e9 - 1)
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0),
      o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0)
    if (s.length != o.length) return !1
    if (!s.length) return !0
    let a = Jp(s, o),
      l = new Pi(s, a, 0).goto(r),
      c = new Pi(o, a, 0).goto(r)
    for (;;) {
      if (
        l.to != c.to ||
        !Su(l.active, c.active) ||
        (l.point && (!c.point || !l.point.eq(c.point)))
      )
        return !1
      if (l.to > i) return !0
      l.next(), c.next()
    }
  }
  static spans(e, t, r, i, s = -1) {
    let o = new Pi(e, null, s).goto(t),
      a = t,
      l = o.openStart
    for (;;) {
      let c = Math.min(o.to, r)
      if (o.point) {
        let u = o.activeForPoint(o.to),
          f = o.pointFrom < t ? u.length + 1 : Math.min(u.length, l)
        i.point(a, c, o.point, u, f, o.pointRank),
          (l = Math.min(o.openEnd(c), u.length))
      } else c > a && (i.span(a, c, o.active, l), (l = o.openEnd(c)))
      if (o.to > r) return l + (o.point && o.to > r ? 1 : 0)
      ;(a = o.to), o.next()
    }
  }
  static of(e, t = !1) {
    let r = new Wn()
    for (let i of e instanceof bu ? [e] : t ? tk(e) : e)
      r.add(i.from, i.to, i.value)
    return r.finish()
  }
}
ce.empty = new ce([], [], null, -1)
function tk(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t]
      if (vu(e, r) > 0) return n.slice().sort(vu)
      e = r
    }
  return n
}
ce.empty.nextLayer = ce.empty
class Wn {
  finishChunk(e) {
    this.chunks.push(new Af(this.from, this.to, this.value, this.maxPoint)),
      this.chunkPos.push(this.chunkStart),
      (this.chunkStart = -1),
      (this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)),
      (this.maxPoint = -1),
      e && ((this.from = []), (this.to = []), (this.value = []))
  }
  constructor() {
    ;(this.chunks = []),
      (this.chunkPos = []),
      (this.chunkStart = -1),
      (this.last = null),
      (this.lastFrom = -1e9),
      (this.lastTo = -1e9),
      (this.from = []),
      (this.to = []),
      (this.value = []),
      (this.maxPoint = -1),
      (this.setMaxPoint = -1),
      (this.nextLayer = null)
  }
  add(e, t, r) {
    this.addInner(e, t, r) ||
      (this.nextLayer || (this.nextLayer = new Wn())).add(e, t, r)
  }
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error(
        'Ranges must be added sorted by `from` position and `startSide`'
      )
    return i < 0
      ? !1
      : (this.from.length == 250 && this.finishChunk(!0),
        this.chunkStart < 0 && (this.chunkStart = e),
        this.from.push(e - this.chunkStart),
        this.to.push(t - this.chunkStart),
        (this.last = r),
        (this.lastFrom = e),
        (this.lastTo = t),
        this.value.push(r),
        r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)),
        !0)
  }
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1
    this.from.length && this.finishChunk(!0),
      (this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint)),
      this.chunks.push(t),
      this.chunkPos.push(e)
    let r = t.value.length - 1
    return (
      (this.last = t.value[r]),
      (this.lastFrom = t.from[r] + e),
      (this.lastTo = t.to[r] + e),
      !0
    )
  }
  finish() {
    return this.finishInner(ce.empty)
  }
  finishInner(e) {
    if ((this.from.length && this.finishChunk(!1), this.chunks.length == 0))
      return e
    let t = ce.create(
      this.chunkPos,
      this.chunks,
      this.nextLayer ? this.nextLayer.finishInner(e) : e,
      this.setMaxPoint
    )
    return (this.from = null), t
  }
}
function Jp(n, e, t) {
  let r = new Map()
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o])
  let i = new Set()
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = r.get(s.chunk[o])
      a != null &&
        (t ? t.mapPos(a) : a) == s.chunkPos[o] &&
        !(t != null && t.touchesRange(a, a + s.chunk[o].length)) &&
        i.add(s.chunk[o])
    }
  return i
}
class fy {
  constructor(e, t, r, i = 0) {
    ;(this.layer = e), (this.skip = t), (this.minPoint = r), (this.rank = i)
  }
  get startSide() {
    return this.value ? this.value.startSide : 0
  }
  get endSide() {
    return this.value ? this.value.endSide : 0
  }
  goto(e, t = -1e9) {
    return (
      (this.chunkIndex = this.rangeIndex = 0), this.gotoInner(e, t, !1), this
    )
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex]
      if (
        !(
          (this.skip && this.skip.has(i)) ||
          this.layer.chunkEnd(this.chunkIndex) < e ||
          i.maxPoint < this.minPoint
        )
      )
        break
      this.chunkIndex++, (r = !1)
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(
        e - this.layer.chunkPos[this.chunkIndex],
        t,
        !0
      )
      ;(!r || this.rangeIndex < i) && this.setRangeIndex(i)
    }
    this.next()
  }
  forward(e, t) {
    ;(this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0)
  }
  next() {
    for (;;)
      if (this.chunkIndex == this.layer.chunk.length) {
        ;(this.from = this.to = 1e9), (this.value = null)
        break
      } else {
        let e = this.layer.chunkPos[this.chunkIndex],
          t = this.layer.chunk[this.chunkIndex],
          r = e + t.from[this.rangeIndex]
        if (
          ((this.from = r),
          (this.to = e + t.to[this.rangeIndex]),
          (this.value = t.value[this.rangeIndex]),
          this.setRangeIndex(this.rangeIndex + 1),
          this.minPoint < 0 ||
            (this.value.point && this.to - this.from >= this.minPoint))
        )
          break
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if ((this.chunkIndex++, this.skip))
        for (
          ;
          this.chunkIndex < this.layer.chunk.length &&
          this.skip.has(this.layer.chunk[this.chunkIndex]);

        )
          this.chunkIndex++
      this.rangeIndex = 0
    } else this.rangeIndex = e
  }
  nextChunk() {
    this.chunkIndex++, (this.rangeIndex = 0), this.next()
  }
  compare(e) {
    return (
      this.from - e.from ||
      this.startSide - e.startSide ||
      this.rank - e.rank ||
      this.to - e.to ||
      this.endSide - e.endSide
    )
  }
}
class Gi {
  constructor(e) {
    this.heap = e
  }
  static from(e, t = null, r = -1) {
    let i = []
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new fy(o, t, r, s))
    return i.length == 1 ? i[0] : new Gi(i)
  }
  get startSide() {
    return this.value ? this.value.startSide : 0
  }
  goto(e, t = -1e9) {
    for (let r of this.heap) r.goto(e, t)
    for (let r = this.heap.length >> 1; r >= 0; r--) Kl(this.heap, r)
    return this.next(), this
  }
  forward(e, t) {
    for (let r of this.heap) r.forward(e, t)
    for (let r = this.heap.length >> 1; r >= 0; r--) Kl(this.heap, r)
    ;(this.to - e || this.value.endSide - t) < 0 && this.next()
  }
  next() {
    if (this.heap.length == 0)
      (this.from = this.to = 1e9), (this.value = null), (this.rank = -1)
    else {
      let e = this.heap[0]
      ;(this.from = e.from),
        (this.to = e.to),
        (this.value = e.value),
        (this.rank = e.rank),
        e.value && e.next(),
        Kl(this.heap, 0)
    }
  }
}
function Kl(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1
    if (r >= n.length) break
    let i = n[r]
    if (
      (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && ((i = n[r + 1]), r++),
      t.compare(i) < 0)
    )
      break
    ;(n[r] = t), (n[e] = i), (e = r)
  }
}
class Pi {
  constructor(e, t, r) {
    ;(this.minPoint = r),
      (this.active = []),
      (this.activeTo = []),
      (this.activeRank = []),
      (this.minActive = -1),
      (this.point = null),
      (this.pointFrom = 0),
      (this.pointRank = 0),
      (this.to = -1e9),
      (this.endSide = 0),
      (this.openStart = -1),
      (this.cursor = Gi.from(e, t, r))
  }
  goto(e, t = -1e9) {
    return (
      this.cursor.goto(e, t),
      (this.active.length = this.activeTo.length = this.activeRank.length = 0),
      (this.minActive = -1),
      (this.to = e),
      (this.endSide = t),
      (this.openStart = -1),
      this.next(),
      this
    )
  }
  forward(e, t) {
    for (
      ;
      this.minActive > -1 &&
      (this.activeTo[this.minActive] - e ||
        this.active[this.minActive].endSide - t) < 0;

    )
      this.removeActive(this.minActive)
    this.cursor.forward(e, t)
  }
  removeActive(e) {
    Bs(this.active, e),
      Bs(this.activeTo, e),
      Bs(this.activeRank, e),
      (this.minActive = td(this.active, this.activeTo))
  }
  addActive(e) {
    let t = 0,
      { value: r, to: i, rank: s } = this.cursor
    for (; t < this.activeRank.length && this.activeRank[t] <= s; ) t++
    Us(this.active, t, r),
      Us(this.activeTo, t, i),
      Us(this.activeRank, t, s),
      e && Us(e, t, this.cursor.from),
      (this.minActive = td(this.active, this.activeTo))
  }
  next() {
    let e = this.to,
      t = this.point
    this.point = null
    let r = this.openStart < 0 ? [] : null
    for (;;) {
      let i = this.minActive
      if (
        i > -1 &&
        (this.activeTo[i] - this.cursor.from ||
          this.active[i].endSide - this.cursor.startSide) < 0
      ) {
        if (this.activeTo[i] > e) {
          ;(this.to = this.activeTo[i]), (this.endSide = this.active[i].endSide)
          break
        }
        this.removeActive(i), r && Bs(r, i)
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          ;(this.to = this.cursor.from), (this.endSide = this.cursor.startSide)
          break
        } else {
          let s = this.cursor.value
          if (!s.point) this.addActive(r), this.cursor.next()
          else if (
            t &&
            this.cursor.to == this.to &&
            this.cursor.from < this.cursor.to
          )
            this.cursor.next()
          else {
            ;(this.point = s),
              (this.pointFrom = this.cursor.from),
              (this.pointRank = this.cursor.rank),
              (this.to = this.cursor.to),
              (this.endSide = s.endSide),
              this.cursor.next(),
              this.forward(this.to, this.endSide)
            break
          }
        }
      else {
        this.to = this.endSide = 1e9
        break
      }
    }
    if (r) {
      this.openStart = 0
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--) this.openStart++
    }
  }
  activeForPoint(e) {
    if (!this.active.length) return this.active
    let t = []
    for (
      let r = this.active.length - 1;
      r >= 0 && !(this.activeRank[r] < this.pointRank);
      r--
    )
      (this.activeTo[r] > e ||
        (this.activeTo[r] == e &&
          this.active[r].endSide >= this.point.endSide)) &&
        t.push(this.active[r])
    return t.reverse()
  }
  openEnd(e) {
    let t = 0
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++
    return t
  }
}
function ed(n, e, t, r, i, s) {
  n.goto(e), t.goto(r)
  let o = r + i,
    a = r,
    l = r - e
  for (;;) {
    let c = n.to + l - t.to || n.endSide - t.endSide,
      u = c < 0 ? n.to + l : t.to,
      f = Math.min(u, o)
    if (
      (n.point || t.point
        ? (n.point &&
            t.point &&
            (n.point == t.point || n.point.eq(t.point)) &&
            Su(n.activeForPoint(n.to), t.activeForPoint(t.to))) ||
          s.comparePoint(a, f, n.point, t.point)
        : f > a &&
          !Su(n.active, t.active) &&
          s.compareRange(a, f, n.active, t.active),
      u > o)
    )
      break
    ;(a = u), c <= 0 && n.next(), c >= 0 && t.next()
  }
}
function Su(n, e) {
  if (n.length != e.length) return !1
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t])) return !1
  return !0
}
function Bs(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++) n[t] = n[t + 1]
  n.pop()
}
function Us(n, e, t) {
  for (let r = n.length - 1; r >= e; r--) n[r + 1] = n[r]
  n[e] = t
}
function td(n, e) {
  let t = -1,
    r = 1e9
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && ((t = i), (r = e[i]))
  return t
}
function oi(n, e, t = n.length) {
  let r = 0
  for (let i = 0; i < t; )
    n.charCodeAt(i) == 9 ? ((r += e - (r % e)), i++) : (r++, (i = He(n, i)))
  return r
}
function xu(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e) return i
    if (i == n.length) break
    ;(s += n.charCodeAt(i) == 9 ? t - (s % t) : 1), (i = He(n, i))
  }
  return r === !0 ? -1 : n.length
}
const wu = '',
  nd = typeof Symbol > 'u' ? '__' + wu : Symbol.for(wu),
  Pu =
    typeof Symbol > 'u'
      ? '__styleSet' + Math.floor(Math.random() * 1e8)
      : Symbol('styleSet'),
  rd = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : {}
class Ln {
  constructor(e, t) {
    this.rules = []
    let { finish: r } = t || {}
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/)
    }
    function s(o, a, l, c) {
      let u = [],
        f = /^@(\w+)\b/.exec(o[0]),
        p = f && f[1] == 'keyframes'
      if (f && a == null) return l.push(o[0] + ';')
      for (let d in a) {
        let O = a[d]
        if (/&/.test(d))
          s(
            d
              .split(/,\s*/)
              .map((g) => o.map((b) => g.replace(/&/, b)))
              .reduce((g, b) => g.concat(b)),
            O,
            l
          )
        else if (O && typeof O == 'object') {
          if (!f)
            throw new RangeError(
              'The value of a property (' + d + ') should be a primitive value.'
            )
          s(i(d), O, u, p)
        } else
          O != null &&
            u.push(
              d
                .replace(/_.*/, '')
                .replace(/[A-Z]/g, (g) => '-' + g.toLowerCase()) +
                ': ' +
                O +
                ';'
            )
      }
      ;(u.length || p) &&
        l.push(
          (r && !f && !c ? o.map(r) : o).join(', ') + ' {' + u.join(' ') + '}'
        )
    }
    for (let o in e) s(i(o), e[o], this.rules)
  }
  getRules() {
    return this.rules.join(`
`)
  }
  static newName() {
    let e = rd[nd] || 1
    return (rd[nd] = e + 1), wu + e.toString(36)
  }
  static mount(e, t, r) {
    let i = e[Pu],
      s = r && r.nonce
    i ? s && i.setNonce(s) : (i = new nk(e, s)),
      i.mount(Array.isArray(t) ? t : [t])
  }
}
let id = new Map()
class nk {
  constructor(e, t) {
    let r = e.ownerDocument || e,
      i = r.defaultView
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = id.get(r)
      if (s)
        return (
          (e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets]),
          (e[Pu] = s)
        )
      ;(this.sheet = new i.CSSStyleSheet()),
        (e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets]),
        id.set(r, this)
    } else {
      ;(this.styleTag = r.createElement('style')),
        t && this.styleTag.setAttribute('nonce', t)
      let s = e.head || e
      s.insertBefore(this.styleTag, s.firstChild)
    }
    ;(this.modules = []), (e[Pu] = this)
  }
  mount(e) {
    let t = this.sheet,
      r = 0,
      i = 0
    for (let s = 0; s < e.length; s++) {
      let o = e[s],
        a = this.modules.indexOf(o)
      if (
        (a < i && a > -1 && (this.modules.splice(a, 1), i--, (a = -1)), a == -1)
      ) {
        if ((this.modules.splice(i++, 0, o), t))
          for (let l = 0; l < o.rules.length; l++) t.insertRule(o.rules[l], r++)
      } else {
        for (; i < a; ) r += this.modules[i++].rules.length
        ;(r += o.rules.length), i++
      }
    }
    if (!t) {
      let s = ''
      for (let o = 0; o < this.modules.length; o++)
        s +=
          this.modules[o].getRules() +
          `
`
      this.styleTag.textContent = s
    }
  }
  setNonce(e) {
    this.styleTag &&
      this.styleTag.getAttribute('nonce') != e &&
      this.styleTag.setAttribute('nonce', e)
  }
}
var Bn = {
    8: 'Backspace',
    9: 'Tab',
    10: 'Enter',
    12: 'NumLock',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    44: 'PrintScreen',
    45: 'Insert',
    46: 'Delete',
    59: ';',
    61: '=',
    91: 'Meta',
    92: 'Meta',
    106: '*',
    107: '+',
    108: ',',
    109: '-',
    110: '.',
    111: '/',
    144: 'NumLock',
    145: 'ScrollLock',
    160: 'Shift',
    161: 'Shift',
    162: 'Control',
    163: 'Control',
    164: 'Alt',
    165: 'Alt',
    173: '-',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: "'"
  },
  Hi = {
    48: ')',
    49: '!',
    50: '@',
    51: '#',
    52: '$',
    53: '%',
    54: '^',
    55: '&',
    56: '*',
    57: '(',
    59: ':',
    61: '+',
    173: '_',
    186: ':',
    187: '+',
    188: '<',
    189: '_',
    190: '>',
    191: '?',
    192: '~',
    219: '{',
    220: '|',
    221: '}',
    222: '"'
  },
  rk = typeof navigator < 'u' && /Mac/.test(navigator.platform),
  ik =
    typeof navigator < 'u' &&
    /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
for (var Be = 0; Be < 10; Be++) Bn[48 + Be] = Bn[96 + Be] = String(Be)
for (var Be = 1; Be <= 24; Be++) Bn[Be + 111] = 'F' + Be
for (var Be = 65; Be <= 90; Be++)
  (Bn[Be] = String.fromCharCode(Be + 32)), (Hi[Be] = String.fromCharCode(Be))
for (var Jl in Bn) Hi.hasOwnProperty(Jl) || (Hi[Jl] = Bn[Jl])
function sk(n) {
  var e =
      (rk && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey) ||
      (ik && n.shiftKey && n.key && n.key.length == 1) ||
      n.key == 'Unidentified',
    t =
      (!e && n.key) ||
      (n.shiftKey ? Hi : Bn)[n.keyCode] ||
      n.key ||
      'Unidentified'
  return (
    t == 'Esc' && (t = 'Escape'),
    t == 'Del' && (t = 'Delete'),
    t == 'Left' && (t = 'ArrowLeft'),
    t == 'Up' && (t = 'ArrowUp'),
    t == 'Right' && (t = 'ArrowRight'),
    t == 'Down' && (t = 'ArrowDown'),
    t
  )
}
function Pa(n) {
  let e
  return (
    n.nodeType == 11 ? (e = n.getSelection ? n : n.ownerDocument) : (e = n),
    e.getSelection()
  )
}
function Tu(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1
}
function ok(n) {
  let e = n.activeElement
  for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement
  return e
}
function Xo(n, e) {
  if (!e.anchorNode) return !1
  try {
    return Tu(n, e.anchorNode)
  } catch {
    return !1
  }
}
function Gr(n) {
  return n.nodeType == 3
    ? mr(n, 0, n.nodeValue.length).getClientRects()
    : n.nodeType == 1
      ? n.getClientRects()
      : []
}
function Ta(n, e, t, r) {
  return t ? sd(n, e, t, r, -1) || sd(n, e, t, r, 1) : !1
}
function Ki(n) {
  for (var e = 0; ; e++) if (((n = n.previousSibling), !n)) return e
}
function sd(n, e, t, r, i) {
  for (;;) {
    if (n == t && e == r) return !0
    if (e == (i < 0 ? 0 : bn(n))) {
      if (n.nodeName == 'DIV') return !1
      let s = n.parentNode
      if (!s || s.nodeType != 1) return !1
      ;(e = Ki(n) + (i < 0 ? 0 : 1)), (n = s)
    } else if (n.nodeType == 1) {
      if (
        ((n = n.childNodes[e + (i < 0 ? -1 : 0)]),
        n.nodeType == 1 && n.contentEditable == 'false')
      )
        return !1
      e = i < 0 ? bn(n) : 0
    } else return !1
  }
}
function bn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length
}
function gl(n, e) {
  let t = e ? n.left : n.right
  return { left: t, right: t, top: n.top, bottom: n.bottom }
}
function ak(n) {
  return { left: 0, right: n.innerWidth, top: 0, bottom: n.innerHeight }
}
function lk(n, e, t, r, i, s, o, a) {
  let l = n.ownerDocument,
    c = l.defaultView || window
  for (let u = n, f = !1; u && !f; )
    if (u.nodeType == 1) {
      let p,
        d = u == l.body,
        O = 1,
        g = 1
      if (d) p = ak(c)
      else {
        if (
          (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (f = !0),
          u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth)
        ) {
          u = u.assignedSlot || u.parentNode
          continue
        }
        let w = u.getBoundingClientRect()
        ;(O = w.width / u.offsetWidth),
          (g = w.height / u.offsetHeight),
          (p = {
            left: w.left,
            right: w.left + u.clientWidth * O,
            top: w.top,
            bottom: w.top + u.clientHeight * g
          })
      }
      let b = 0,
        x = 0
      if (i == 'nearest')
        e.top < p.top
          ? ((x = -(p.top - e.top + o)),
            t > 0 &&
              e.bottom > p.bottom + x &&
              (x = e.bottom - p.bottom + x + o))
          : e.bottom > p.bottom &&
            ((x = e.bottom - p.bottom + o),
            t < 0 && e.top - x < p.top && (x = -(p.top + x - e.top + o)))
      else {
        let w = e.bottom - e.top,
          Q = p.bottom - p.top
        x =
          (i == 'center' && w <= Q
            ? e.top + w / 2 - Q / 2
            : i == 'start' || (i == 'center' && t < 0)
              ? e.top - o
              : e.bottom - Q + o) - p.top
      }
      if (
        (r == 'nearest'
          ? e.left < p.left
            ? ((b = -(p.left - e.left + s)),
              t > 0 && e.right > p.right + b && (b = e.right - p.right + b + s))
            : e.right > p.right &&
              ((b = e.right - p.right + s),
              t < 0 && e.left < p.left + b && (b = -(p.left + b - e.left + s)))
          : (b =
              (r == 'center'
                ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2
                : (r == 'start') == a
                  ? e.left - s
                  : e.right - (p.right - p.left) + s) - p.left),
        b || x)
      )
        if (d) c.scrollBy(b, x)
        else {
          let w = 0,
            Q = 0
          if (x) {
            let T = u.scrollTop
            ;(u.scrollTop += x / g), (Q = (u.scrollTop - T) * g)
          }
          if (b) {
            let T = u.scrollLeft
            ;(u.scrollLeft += b / O), (w = (u.scrollLeft - T) * O)
          }
          ;(e = {
            left: e.left - w,
            top: e.top - Q,
            right: e.right - w,
            bottom: e.bottom - Q
          }),
            w && Math.abs(w - b) < 1 && (r = 'nearest'),
            Q && Math.abs(Q - x) < 1 && (i = 'nearest')
        }
      if (d) break
      u = u.assignedSlot || u.parentNode
    } else if (u.nodeType == 11) u = u.host
    else break
}
function ck(n) {
  let e = n.ownerDocument
  for (let t = n.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t
      t = t.assignedSlot || t.parentNode
    } else if (t.nodeType == 11) t = t.host
    else break
  return null
}
class uk {
  constructor() {
    ;(this.anchorNode = null),
      (this.anchorOffset = 0),
      (this.focusNode = null),
      (this.focusOffset = 0)
  }
  eq(e) {
    return (
      this.anchorNode == e.anchorNode &&
      this.anchorOffset == e.anchorOffset &&
      this.focusNode == e.focusNode &&
      this.focusOffset == e.focusOffset
    )
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e
    this.set(
      t,
      Math.min(e.anchorOffset, t ? bn(t) : 0),
      r,
      Math.min(e.focusOffset, r ? bn(r) : 0)
    )
  }
  set(e, t, r, i) {
    ;(this.anchorNode = e),
      (this.anchorOffset = t),
      (this.focusNode = r),
      (this.focusOffset = i)
  }
}
let kr = null
function hy(n) {
  if (n.setActive) return n.setActive()
  if (kr) return n.focus(kr)
  let e = []
  for (
    let t = n;
    t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument);
    t = t.parentNode
  );
  if (
    (n.focus(
      kr == null
        ? {
            get preventScroll() {
              return (kr = { preventScroll: !0 }), !0
            }
          }
        : void 0
    ),
    !kr)
  ) {
    kr = !1
    for (let t = 0; t < e.length; ) {
      let r = e[t++],
        i = e[t++],
        s = e[t++]
      r.scrollTop != i && (r.scrollTop = i),
        r.scrollLeft != s && (r.scrollLeft = s)
    }
  }
}
let od
function mr(n, e, t = e) {
  let r = od || (od = document.createRange())
  return r.setEnd(n, t), r.setStart(n, e), r
}
function Nr(n, e, t) {
  let r = { key: e, code: e, keyCode: t, which: t, cancelable: !0 },
    i = new KeyboardEvent('keydown', r)
  ;(i.synthetic = !0), n.dispatchEvent(i)
  let s = new KeyboardEvent('keyup', r)
  return (
    (s.synthetic = !0),
    n.dispatchEvent(s),
    i.defaultPrevented || s.defaultPrevented
  )
}
function fk(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || (n.nodeType == 11 && n.host))) return n
    n = n.assignedSlot || n.parentNode
  }
  return null
}
function py(n) {
  for (; n.attributes.length; ) n.removeAttributeNode(n.attributes[0])
}
function hk(n, e) {
  let t = e.focusNode,
    r = e.focusOffset
  if (!t || e.anchorNode != t || e.anchorOffset != r) return !1
  for (r = Math.min(r, bn(t)); ; )
    if (r) {
      if (t.nodeType != 1) return !1
      let i = t.childNodes[r - 1]
      i.contentEditable == 'false' ? r-- : ((t = i), (r = bn(t)))
    } else {
      if (t == n) return !0
      ;(r = Ki(t)), (t = t.parentNode)
    }
}
function dy(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4)
}
class Fe {
  constructor(e, t, r = !0) {
    ;(this.node = e), (this.offset = t), (this.precise = r)
  }
  static before(e, t) {
    return new Fe(e.parentNode, Ki(e), t)
  }
  static after(e, t) {
    return new Fe(e.parentNode, Ki(e) + 1, t)
  }
}
const Ef = []
class ve {
  constructor() {
    ;(this.parent = null), (this.dom = null), (this.flags = 2)
  }
  get overrideDOMText() {
    return null
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0
  }
  get posAtEnd() {
    return this.posAtStart + this.length
  }
  posBefore(e) {
    let t = this.posAtStart
    for (let r of this.children) {
      if (r == e) return t
      t += r.length + r.breakAfter
    }
    throw new RangeError('Invalid child in posBefore')
  }
  posAfter(e) {
    return this.posBefore(e) + e.length
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom,
        i = null,
        s
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let a = ve.get(s)
            ;(!a || (!a.parent && a.canReuseDOM(o))) && o.reuseDOM(s)
          }
          o.sync(e, t), (o.flags &= -8)
        }
        if (
          ((s = i ? i.nextSibling : r.firstChild),
          t && !t.written && t.node == r && s != o.dom && (t.written = !0),
          o.dom.parentNode == r)
        )
          for (; s && s != o.dom; ) s = ad(s)
        else r.insertBefore(o.dom, s)
        i = o.dom
      }
      for (
        s = i ? i.nextSibling : r.firstChild,
          s && t && t.node == r && (t.written = !0);
        s;

      )
        s = ad(s)
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), (r.flags &= -8))
  }
  reuseDOM(e) {}
  localPosFromDOM(e, t) {
    let r
    if (e == this.dom) r = this.dom.childNodes[t]
    else {
      let i = bn(e) == 0 ? 0 : t == 0 ? -1 : 1
      for (;;) {
        let s = e.parentNode
        if (s == this.dom) break
        i == 0 &&
          s.firstChild != s.lastChild &&
          (e == s.firstChild ? (i = -1) : (i = 1)),
          (e = s)
      }
      i < 0 ? (r = e) : (r = e.nextSibling)
    }
    if (r == this.dom.firstChild) return 0
    for (; r && !ve.get(r); ) r = r.nextSibling
    if (!r) return this.length
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i]
      if (o.dom == r) return s
      s += o.length + o.breakAfter
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1,
      s = -1,
      o = -1,
      a = -1
    for (let l = 0, c = r, u = r; l < this.children.length; l++) {
      let f = this.children[l],
        p = c + f.length
      if (c < e && p > t) return f.domBoundsAround(e, t, c)
      if (
        (p >= e && i == -1 && ((i = l), (s = c)),
        c > t && f.dom.parentNode == this.dom)
      ) {
        ;(o = l), (a = u)
        break
      }
      ;(u = p), (c = p + f.breakAfter)
    }
    return {
      from: s,
      to: a < 0 ? r + this.length : a,
      startDOM:
        (i ? this.children[i - 1].dom.nextSibling : null) ||
        this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    }
  }
  markDirty(e = !1) {
    ;(this.flags |= 2), this.markParentsDirty(e)
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if ((e && (t.flags |= 2), t.flags & 1)) return
      ;(t.flags |= 1), (e = !1)
    }
  }
  setParent(e) {
    this.parent != e &&
      ((this.parent = e), this.flags & 7 && this.markParentsDirty(!0))
  }
  setDOM(e) {
    this.dom != e &&
      (this.dom && (this.dom.cmView = null), (this.dom = e), (e.cmView = this))
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent
      if (!t) return e
      e = t
    }
  }
  replaceChildren(e, t, r = Ef) {
    this.markDirty()
    for (let i = e; i < t; i++) {
      let s = this.children[i]
      s.parent == this && s.destroy()
    }
    this.children.splice(e, t - e, ...r)
    for (let i = 0; i < r.length; i++) r[i].setParent(this)
  }
  ignoreMutation(e) {
    return !1
  }
  ignoreEvent(e) {
    return !1
  }
  childCursor(e = this.length) {
    return new Oy(this.children, e, this.children.length)
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t)
  }
  toString() {
    let e = this.constructor.name.replace('View', '')
    return (
      e +
      (this.children.length
        ? '(' + this.children.join() + ')'
        : this.length
          ? '[' + (e == 'Text' ? this.text : this.length) + ']'
          : '') +
      (this.breakAfter ? '#' : '')
    )
  }
  static get(e) {
    return e.cmView
  }
  get isEditable() {
    return !0
  }
  get isWidget() {
    return !1
  }
  get isHidden() {
    return !1
  }
  merge(e, t, r, i, s, o) {
    return !1
  }
  become(e) {
    return !1
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8)
  }
  getSide() {
    return 0
  }
  destroy() {
    this.parent = null
  }
}
ve.prototype.breakAfter = 0
function ad(n) {
  let e = n.nextSibling
  return n.parentNode.removeChild(n), e
}
class Oy {
  constructor(e, t, r) {
    ;(this.children = e), (this.pos = t), (this.i = r), (this.off = 0)
  }
  findPos(e, t = 1) {
    for (;;) {
      if (
        e > this.pos ||
        (e == this.pos &&
          (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
      )
        return (this.off = e - this.pos), this
      let r = this.children[--this.i]
      this.pos -= r.length + r.breakAfter
    }
  }
}
function my(n, e, t, r, i, s, o, a, l) {
  let { children: c } = n,
    u = c.length ? c[e] : null,
    f = s.length ? s[s.length - 1] : null,
    p = f ? f.breakAfter : o
  if (
    !(
      e == r &&
      u &&
      !o &&
      !p &&
      s.length < 2 &&
      u.merge(t, i, s.length ? f : null, t == 0, a, l)
    )
  ) {
    if (r < c.length) {
      let d = c[r]
      d && (i < d.length || (d.breakAfter && f != null && f.breakAfter))
        ? (e == r && ((d = d.split(i)), (i = 0)),
          !p && f && d.merge(0, i, f, !0, 0, l)
            ? (s[s.length - 1] = d)
            : ((i || (d.children.length && !d.children[0].length)) &&
                d.merge(0, i, null, !1, 0, l),
              s.push(d)))
        : d != null && d.breakAfter && (f ? (f.breakAfter = 1) : (o = 1)),
        r++
    }
    for (
      u &&
      ((u.breakAfter = o),
      t > 0 &&
        (!o && s.length && u.merge(t, u.length, s[0], !1, a, 0)
          ? (u.breakAfter = s.shift().breakAfter)
          : (t < u.length ||
              (u.children.length &&
                u.children[u.children.length - 1].length == 0)) &&
            u.merge(t, u.length, null, !1, a, 0),
        e++));
      e < r && s.length;

    )
      if (c[r - 1].become(s[s.length - 1])) r--, s.pop(), (l = s.length ? 0 : a)
      else if (c[e].become(s[0])) e++, s.shift(), (a = s.length ? 0 : l)
      else break
    !s.length &&
      e &&
      r < c.length &&
      !c[e - 1].breakAfter &&
      c[r].merge(0, 0, c[e - 1], !1, a, l) &&
      e--,
      (e < r || s.length) && n.replaceChildren(e, r, s)
  }
}
function gy(n, e, t, r, i, s) {
  let o = n.childCursor(),
    { i: a, off: l } = o.findPos(t, 1),
    { i: c, off: u } = o.findPos(e, -1),
    f = e - t
  for (let p of r) f += p.length
  ;(n.length += f), my(n, c, u, a, l, r, 0, i, s)
}
let gt =
    typeof navigator < 'u'
      ? navigator
      : { userAgent: '', vendor: '', platform: '' },
  $u = typeof document < 'u' ? document : { documentElement: { style: {} } }
const Qu = /Edge\/(\d+)/.exec(gt.userAgent),
  yy = /MSIE \d/.test(gt.userAgent),
  ku = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gt.userAgent),
  yl = !!(yy || ku || Qu),
  ld = !yl && /gecko\/(\d+)/i.test(gt.userAgent),
  ec = !yl && /Chrome\/(\d+)/.exec(gt.userAgent),
  cd = 'webkitFontSmoothing' in $u.documentElement.style,
  by = !yl && /Apple Computer/.test(gt.vendor),
  ud = by && (/Mobile\/\w+/.test(gt.userAgent) || gt.maxTouchPoints > 2)
var z = {
  mac: ud || /Mac/.test(gt.platform),
  windows: /Win/.test(gt.platform),
  linux: /Linux|X11/.test(gt.platform),
  ie: yl,
  ie_version: yy ? $u.documentMode || 6 : ku ? +ku[1] : Qu ? +Qu[1] : 0,
  gecko: ld,
  gecko_version: ld ? +(/Firefox\/(\d+)/.exec(gt.userAgent) || [0, 0])[1] : 0,
  chrome: !!ec,
  chrome_version: ec ? +ec[1] : 0,
  ios: ud,
  android: /Android\b/.test(gt.userAgent),
  webkit: cd,
  safari: by,
  webkit_version: cd
    ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
    : 0,
  tabSize:
    $u.documentElement.style.tabSize != null ? 'tab-size' : '-moz-tab-size'
}
const pk = 256
class vn extends ve {
  constructor(e) {
    super(), (this.text = e)
  }
  get length() {
    return this.text.length
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text))
  }
  sync(e, t) {
    this.dom || this.createDOM(),
      this.dom.nodeValue != this.text &&
        (t && t.node == this.dom && (t.written = !0),
        (this.dom.nodeValue = this.text))
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e)
  }
  merge(e, t, r) {
    return this.flags & 8 ||
      (r &&
        (!(r instanceof vn) ||
          this.length - (t - e) + r.length > pk ||
          r.flags & 8))
      ? !1
      : ((this.text =
          this.text.slice(0, e) + (r ? r.text : '') + this.text.slice(t)),
        this.markDirty(),
        !0)
  }
  split(e) {
    let t = new vn(this.text.slice(e))
    return (
      (this.text = this.text.slice(0, e)),
      this.markDirty(),
      (t.flags |= this.flags & 8),
      t
    )
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0
  }
  domAtPos(e) {
    return new Fe(this.dom, e)
  }
  domBoundsAround(e, t, r) {
    return {
      from: r,
      to: r + this.length,
      startDOM: this.dom,
      endDOM: this.dom.nextSibling
    }
  }
  coordsAt(e, t) {
    return dk(this.dom, e, t)
  }
}
class Sn extends ve {
  constructor(e, t = [], r = 0) {
    super(), (this.mark = e), (this.children = t), (this.length = r)
    for (let i of t) i.setParent(this)
  }
  setAttrs(e) {
    if (
      (py(e),
      this.mark.class && (e.className = this.mark.class),
      this.mark.attrs)
    )
      for (let t in this.mark.attrs) e.setAttribute(t, this.mark.attrs[t])
    return e
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8)
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() &&
      (this.setDOM(e), (this.flags |= 6))
  }
  sync(e, t) {
    this.dom
      ? this.flags & 4 && this.setAttrs(this.dom)
      : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
      super.sync(e, t)
  }
  merge(e, t, r, i, s, o) {
    return r &&
      (!(r instanceof Sn && r.mark.eq(this.mark)) ||
        (e && s <= 0) ||
        (t < this.length && o <= 0))
      ? !1
      : (gy(this, e, t, r ? r.children : [], s - 1, o - 1),
        this.markDirty(),
        !0)
  }
  split(e) {
    let t = [],
      r = 0,
      i = -1,
      s = 0
    for (let a of this.children) {
      let l = r + a.length
      l > e && t.push(r < e ? a.split(e - r) : a),
        i < 0 && r >= e && (i = s),
        (r = l),
        s++
    }
    let o = this.length - e
    return (
      (this.length = e),
      i > -1 && ((this.children.length = i), this.markDirty()),
      new Sn(this.mark, t, o)
    )
  }
  domAtPos(e) {
    return vy(this, e)
  }
  coordsAt(e, t) {
    return xy(this, e, t)
  }
}
function dk(n, e, t) {
  let r = n.nodeValue.length
  e > r && (e = r)
  let i = e,
    s = e,
    o = 0
  ;(e == 0 && t < 0) || (e == r && t >= 0)
    ? z.chrome || z.gecko || (e ? (i--, (o = 1)) : s < r && (s++, (o = -1)))
    : t < 0
      ? i--
      : s < r && s++
  let a = mr(n, i, s).getClientRects()
  if (!a.length) return null
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1]
  return (
    z.safari &&
      !o &&
      l.width == 0 &&
      (l = Array.prototype.find.call(a, (c) => c.width) || l),
    o ? gl(l, o < 0) : l || null
  )
}
class Xn extends ve {
  static create(e, t, r) {
    return new Xn(e, t, r)
  }
  constructor(e, t, r) {
    super(),
      (this.widget = e),
      (this.length = t),
      (this.side = r),
      (this.prevWidget = null)
  }
  split(e) {
    let t = Xn.create(this.widget, this.length - e, this.side)
    return (this.length -= e), t
  }
  sync(e) {
    ;(!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'))
  }
  getSide() {
    return this.side
  }
  merge(e, t, r, i, s, o) {
    return r &&
      (!(r instanceof Xn) ||
        !this.widget.compare(r.widget) ||
        (e > 0 && s <= 0) ||
        (t < this.length && o <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - t)), !0)
  }
  become(e) {
    return e instanceof Xn &&
      e.side == this.side &&
      this.widget.constructor == e.widget.constructor
      ? (this.widget.compare(e.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        !0)
      : !1
  }
  ignoreMutation() {
    return !0
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e)
  }
  get overrideDOMText() {
    if (this.length == 0) return le.empty
    let e = this
    for (; e.parent; ) e = e.parent
    let { view: t } = e,
      r = t && t.state.doc,
      i = this.posAtStart
    return r ? r.slice(i, i + this.length) : le.empty
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0)
      ? Fe.before(this.dom)
      : Fe.after(this.dom, e == this.length)
  }
  domBoundsAround() {
    return null
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t)
    if (r) return r
    let i = this.dom.getClientRects(),
      s = null
    if (!i.length) return null
    let o = this.side ? this.side < 0 : e > 0
    for (
      let a = o ? i.length - 1 : 0;
      (s = i[a]), !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom);
      a += o ? -1 : 1
    );
    return gl(s, !o)
  }
  get isEditable() {
    return !1
  }
  get isWidget() {
    return !0
  }
  get isHidden() {
    return this.widget.isHidden
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom)
  }
}
class Hr extends ve {
  constructor(e) {
    super(), (this.side = e)
  }
  get length() {
    return 0
  }
  merge() {
    return !1
  }
  become(e) {
    return e instanceof Hr && e.side == this.side
  }
  split() {
    return new Hr(this.side)
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement('img')
      ;(e.className = 'cm-widgetBuffer'),
        e.setAttribute('aria-hidden', 'true'),
        this.setDOM(e)
    }
  }
  getSide() {
    return this.side
  }
  domAtPos(e) {
    return this.side > 0 ? Fe.before(this.dom) : Fe.after(this.dom)
  }
  localPosFromDOM() {
    return 0
  }
  domBoundsAround() {
    return null
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect()
  }
  get overrideDOMText() {
    return le.empty
  }
  get isHidden() {
    return !0
  }
}
vn.prototype.children = Xn.prototype.children = Hr.prototype.children = Ef
function vy(n, e) {
  let t = n.dom,
    { children: r } = n,
    i = 0
  for (let s = 0; i < r.length; i++) {
    let o = r[i],
      a = s + o.length
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == t) return o.domAtPos(e - s)
      if (e <= s) break
      s = a
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1]
    if (o.dom.parentNode == t) return o.domAtPos(o.length)
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s]
    if (o.dom.parentNode == t) return o.domAtPos(0)
  }
  return new Fe(t, 0)
}
function Sy(n, e, t) {
  let r,
    { children: i } = n
  t > 0 &&
  e instanceof Sn &&
  i.length &&
  (r = i[i.length - 1]) instanceof Sn &&
  r.mark.eq(e.mark)
    ? Sy(r, e.children[0], t - 1)
    : (i.push(e), e.setParent(n)),
    (n.length += e.length)
}
function xy(n, e, t) {
  let r = null,
    i = -1,
    s = null,
    o = -1
  function a(c, u) {
    for (let f = 0, p = 0; f < c.children.length && p <= u; f++) {
      let d = c.children[f],
        O = p + d.length
      O >= u &&
        (d.children.length
          ? a(d, u - p)
          : (!s || (s.isHidden && t > 0)) &&
              (O > u || (p == O && d.getSide() > 0))
            ? ((s = d), (o = u - p))
            : (p < u || (p == O && d.getSide() < 0 && !d.isHidden)) &&
              ((r = d), (i = u - p))),
        (p = O)
    }
  }
  a(n, e)
  let l = (t < 0 ? r : s) || r || s
  return l ? l.coordsAt(Math.max(0, l == r ? i : o), t) : Ok(n)
}
function Ok(n) {
  let e = n.dom.lastChild
  if (!e) return n.dom.getBoundingClientRect()
  let t = Gr(e)
  return t[t.length - 1] || null
}
function Cu(n, e) {
  for (let t in n)
    t == 'class' && e.class
      ? (e.class += ' ' + n.class)
      : t == 'style' && e.style
        ? (e.style += ';' + n.style)
        : (e[t] = n[t])
  return e
}
const fd = Object.create(null)
function Df(n, e, t) {
  if (n == e) return !0
  n || (n = fd), e || (e = fd)
  let r = Object.keys(n),
    i = Object.keys(e)
  if (
    r.length - (t && r.indexOf(t) > -1 ? 1 : 0) !=
    i.length - (t && i.indexOf(t) > -1 ? 1 : 0)
  )
    return !1
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s])) return !1
  return !0
}
function _u(n, e, t) {
  let r = !1
  if (e)
    for (let i in e)
      (t && i in t) ||
        ((r = !0), i == 'style' ? (n.style.cssText = '') : n.removeAttribute(i))
  if (t)
    for (let i in t)
      (e && e[i] == t[i]) ||
        ((r = !0),
        i == 'style' ? (n.style.cssText = t[i]) : n.setAttribute(i, t[i]))
  return r
}
function mk(n) {
  let e = Object.create(null)
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t]
    e[r.name] = r.value
  }
  return e
}
class Ze extends ve {
  constructor() {
    super(...arguments),
      (this.children = []),
      (this.length = 0),
      (this.prevAttrs = void 0),
      (this.attrs = null),
      (this.breakAfter = 0)
  }
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof Ze)) return !1
      this.dom || r.transferDOM(this)
    }
    return (
      i && this.setDeco(r ? r.attrs : null),
      gy(this, e, t, r ? r.children : [], s, o),
      !0
    )
  }
  split(e) {
    let t = new Ze()
    if (((t.breakAfter = this.breakAfter), this.length == 0)) return t
    let { i: r, off: i } = this.childPos(e)
    i &&
      (t.append(this.children[r].split(i), 0),
      this.children[r].merge(i, this.children[r].length, null, !1, 0, 0),
      r++)
    for (let s = r; s < this.children.length; s++) t.append(this.children[s], 0)
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy()
    return (this.children.length = r), this.markDirty(), (this.length = e), t
  }
  transferDOM(e) {
    this.dom &&
      (this.markDirty(),
      e.setDOM(this.dom),
      (e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs),
      (this.prevAttrs = void 0),
      (this.dom = null))
  }
  setDeco(e) {
    Df(this.attrs, e) ||
      (this.dom && ((this.prevAttrs = this.attrs), this.markDirty()),
      (this.attrs = e))
  }
  append(e, t) {
    Sy(this, e, t)
  }
  addLineDeco(e) {
    let t = e.spec.attributes,
      r = e.spec.class
    t && (this.attrs = Cu(t, this.attrs || {})),
      r && (this.attrs = Cu({ class: r }, this.attrs || {}))
  }
  domAtPos(e) {
    return vy(this, e)
  }
  reuseDOM(e) {
    e.nodeName == 'DIV' && (this.setDOM(e), (this.flags |= 6))
  }
  sync(e, t) {
    var r
    this.dom
      ? this.flags & 4 &&
        (py(this.dom),
        (this.dom.className = 'cm-line'),
        (this.prevAttrs = this.attrs ? null : void 0))
      : (this.setDOM(document.createElement('div')),
        (this.dom.className = 'cm-line'),
        (this.prevAttrs = this.attrs ? null : void 0)),
      this.prevAttrs !== void 0 &&
        (_u(this.dom, this.prevAttrs, this.attrs),
        this.dom.classList.add('cm-line'),
        (this.prevAttrs = void 0)),
      super.sync(e, t)
    let i = this.dom.lastChild
    for (; i && ve.get(i) instanceof Sn; ) i = i.lastChild
    if (
      !i ||
      !this.length ||
      (i.nodeName != 'BR' &&
        ((r = ve.get(i)) === null || r === void 0 ? void 0 : r.isEditable) ==
          !1 &&
        (!z.ios || !this.children.some((s) => s instanceof vn)))
    ) {
      let s = document.createElement('BR')
      ;(s.cmIgnore = !0), this.dom.appendChild(s)
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null
    let e = 0,
      t
    for (let r of this.children) {
      if (!(r instanceof vn) || /[^ -~]/.test(r.text)) return null
      let i = Gr(r.dom)
      if (i.length != 1) return null
      ;(e += i[0].width), (t = i[0].height)
    }
    return e
      ? {
          lineHeight: this.dom.getBoundingClientRect().height,
          charWidth: e / this.length,
          textHeight: t
        }
      : null
  }
  coordsAt(e, t) {
    let r = xy(this, e, t)
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState,
        s = r.bottom - r.top
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2
        return {
          top: r.top + o,
          bottom: r.bottom - o,
          left: r.left,
          right: r.left
        }
      }
    }
    return r
  }
  become(e) {
    return !1
  }
  covers() {
    return !0
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r],
        o = i + s.length
      if (o >= t) {
        if (s instanceof Ze) return s
        if (o > t) break
      }
      i = o + s.breakAfter
    }
    return null
  }
}
class In extends ve {
  constructor(e, t, r) {
    super(),
      (this.widget = e),
      (this.length = t),
      (this.deco = r),
      (this.breakAfter = 0),
      (this.prevWidget = null)
  }
  merge(e, t, r, i, s, o) {
    return r &&
      (!(r instanceof In) ||
        !this.widget.compare(r.widget) ||
        (e > 0 && s <= 0) ||
        (t < this.length && o <= 0))
      ? !1
      : ((this.length = e + (r ? r.length : 0) + (this.length - t)), !0)
  }
  domAtPos(e) {
    return e == 0 ? Fe.before(this.dom) : Fe.after(this.dom, e == this.length)
  }
  split(e) {
    let t = this.length - e
    this.length = e
    let r = new In(this.widget, t, this.deco)
    return (r.breakAfter = this.breakAfter), r
  }
  get children() {
    return Ef
  }
  sync(e) {
    ;(!this.dom || !this.widget.updateDOM(this.dom, e)) &&
      (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
      (this.prevWidget = null),
      this.setDOM(this.widget.toDOM(e)),
      (this.dom.contentEditable = 'false'))
  }
  get overrideDOMText() {
    return this.parent
      ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd)
      : le.empty
  }
  domBoundsAround() {
    return null
  }
  become(e) {
    return e instanceof In && e.widget.constructor == this.widget.constructor
      ? (e.widget.compare(this.widget) || this.markDirty(!0),
        this.dom && !this.prevWidget && (this.prevWidget = this.widget),
        (this.widget = e.widget),
        (this.length = e.length),
        (this.deco = e.deco),
        (this.breakAfter = e.breakAfter),
        !0)
      : !1
  }
  ignoreMutation() {
    return !0
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e)
  }
  get isEditable() {
    return !1
  }
  get isWidget() {
    return !0
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t)
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom)
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco
    return t == r ? !1 : e < 0 ? t < 0 : r > 0
  }
}
class an {
  eq(e) {
    return !1
  }
  updateDOM(e, t) {
    return !1
  }
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e))
  }
  get estimatedHeight() {
    return -1
  }
  get lineBreaks() {
    return 0
  }
  ignoreEvent(e) {
    return !0
  }
  coordsAt(e, t, r) {
    return null
  }
  get isHidden() {
    return !1
  }
  destroy(e) {}
}
var nt = (function (n) {
  return (
    (n[(n.Text = 0)] = 'Text'),
    (n[(n.WidgetBefore = 1)] = 'WidgetBefore'),
    (n[(n.WidgetAfter = 2)] = 'WidgetAfter'),
    (n[(n.WidgetRange = 3)] = 'WidgetRange'),
    n
  )
})(nt || (nt = {}))
class G extends Or {
  constructor(e, t, r, i) {
    super(),
      (this.startSide = e),
      (this.endSide = t),
      (this.widget = r),
      (this.spec = i)
  }
  get heightRelevant() {
    return !1
  }
  static mark(e) {
    return new xs(e)
  }
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)),
      r = !!e.block
    return (
      (t += r && !e.inlineOrder ? (t > 0 ? 3e8 : -4e8) : t > 0 ? 1e8 : -1e8),
      new Un(e, t, t, r, e.widget || null, !1)
    )
  }
  static replace(e) {
    let t = !!e.block,
      r,
      i
    if (e.isBlockGap) (r = -5e8), (i = 4e8)
    else {
      let { start: s, end: o } = wy(e, t)
      ;(r = (s ? (t ? -3e8 : -1) : 5e8) - 1),
        (i = (o ? (t ? 2e8 : 1) : -6e8) + 1)
    }
    return new Un(e, r, i, t, e.widget || null, !0)
  }
  static line(e) {
    return new ws(e)
  }
  static set(e, t = !1) {
    return ce.of(e, t)
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1
  }
}
G.none = ce.empty
class xs extends G {
  constructor(e) {
    let { start: t, end: r } = wy(e)
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e),
      (this.tagName = e.tagName || 'span'),
      (this.class = e.class || ''),
      (this.attrs = e.attributes || null)
  }
  eq(e) {
    var t, r
    return (
      this == e ||
      (e instanceof xs &&
        this.tagName == e.tagName &&
        (this.class ||
          ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) ==
          (e.class ||
            ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) &&
        Df(this.attrs, e.attrs, 'class'))
    )
  }
  range(e, t = e) {
    if (e >= t) throw new RangeError('Mark decorations may not be empty')
    return super.range(e, t)
  }
}
xs.prototype.point = !1
class ws extends G {
  constructor(e) {
    super(-2e8, -2e8, null, e)
  }
  eq(e) {
    return (
      e instanceof ws &&
      this.spec.class == e.spec.class &&
      Df(this.spec.attributes, e.spec.attributes)
    )
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError('Line decoration ranges must be zero-length')
    return super.range(e, t)
  }
}
ws.prototype.mapMode = Ue.TrackBefore
ws.prototype.point = !0
class Un extends G {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e),
      (this.block = i),
      (this.isReplace = o),
      (this.mapMode = i
        ? t <= 0
          ? Ue.TrackBefore
          : Ue.TrackAfter
        : Ue.TrackDel)
  }
  get type() {
    return this.startSide != this.endSide
      ? nt.WidgetRange
      : this.startSide <= 0
        ? nt.WidgetBefore
        : nt.WidgetAfter
  }
  get heightRelevant() {
    return (
      this.block ||
      (!!this.widget &&
        (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0))
    )
  }
  eq(e) {
    return (
      e instanceof Un &&
      gk(this.widget, e.widget) &&
      this.block == e.block &&
      this.startSide == e.startSide &&
      this.endSide == e.endSide
    )
  }
  range(e, t = e) {
    if (
      this.isReplace &&
      (e > t || (e == t && this.startSide > 0 && this.endSide <= 0))
    )
      throw new RangeError('Invalid range for replacement decoration')
    if (!this.isReplace && t != e)
      throw new RangeError(
        'Widget decorations can only have zero-length ranges'
      )
    return super.range(e, t)
  }
}
Un.prototype.point = !0
function wy(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n
  return (
    t == null && (t = n.inclusive),
    r == null && (r = n.inclusive),
    { start: t ?? e, end: r ?? e }
  )
}
function gk(n, e) {
  return n == e || !!(n && e && n.compare(e))
}
function Ru(n, e, t, r = 0) {
  let i = t.length - 1
  i >= 0 && t[i] + r >= n ? (t[i] = Math.max(t[i], e)) : t.push(n, e)
}
class Bi {
  constructor(e, t, r, i) {
    ;(this.doc = e),
      (this.pos = t),
      (this.end = r),
      (this.disallowBlockEffectsFor = i),
      (this.content = []),
      (this.curLine = null),
      (this.breakAtStart = 0),
      (this.pendingBuffer = 0),
      (this.bufferMarks = []),
      (this.atCursorPos = !0),
      (this.openStart = -1),
      (this.openEnd = -1),
      (this.text = ''),
      (this.textOff = 0),
      (this.cursor = e.iter()),
      (this.skip = t)
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos
    let e = this.content[this.content.length - 1]
    return !(e.breakAfter || (e instanceof In && e.deco.endSide < 0))
  }
  getLine() {
    return (
      this.curLine ||
        (this.content.push((this.curLine = new Ze())), (this.atCursorPos = !0)),
      this.curLine
    )
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer &&
      (this.curLine.append(qs(new Hr(-1), e), e.length),
      (this.pendingBuffer = 0))
  }
  addBlockWidget(e) {
    this.flushBuffer(), (this.curLine = null), this.content.push(e)
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length
      ? this.flushBuffer()
      : (this.pendingBuffer = 0),
      !this.posCovered() &&
        !(
          e &&
          this.content.length &&
          this.content[this.content.length - 1] instanceof In
        ) &&
        this.getLine()
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip)
        if (((this.skip = 0), a))
          throw new Error('Ran out of text content when drawing inline views')
        if (o) {
          this.posCovered() || this.getLine(),
            this.content.length
              ? (this.content[this.content.length - 1].breakAfter = 1)
              : (this.breakAtStart = 1),
            this.flushBuffer(),
            (this.curLine = null),
            (this.atCursorPos = !0),
            e--
          continue
        } else (this.text = s), (this.textOff = 0)
      }
      let i = Math.min(this.text.length - this.textOff, e, 512)
      this.flushBuffer(t.slice(t.length - r)),
        this.getLine().append(
          qs(new vn(this.text.slice(this.textOff, this.textOff + i)), t),
          r
        ),
        (this.atCursorPos = !0),
        (this.textOff += i),
        (e -= i),
        (r = 0)
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i),
      (this.pos = t),
      this.openStart < 0 && (this.openStart = i)
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof Un) {
      if (r.block)
        throw new RangeError(
          'Block decorations may not be specified via plugins'
        )
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError(
          'Decorations that replace line breaks may not be specified via plugins'
        )
    }
    let a = t - e
    if (r instanceof Un)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(),
          this.addBlockWidget(new In(r.widget || new hd('div'), a, r))
      else {
        let l = Xn.create(r.widget || new hd('span'), a, a ? 0 : r.startSide),
          c =
            this.atCursorPos &&
            !l.isEditable &&
            s <= i.length &&
            (e < t || r.startSide > 0),
          u = !l.isEditable && (e < t || s > i.length || r.startSide <= 0),
          f = this.getLine()
        this.pendingBuffer == 2 &&
          !c &&
          !l.isEditable &&
          (this.pendingBuffer = 0),
          this.flushBuffer(i),
          c &&
            (f.append(qs(new Hr(1), i), s),
            (s = i.length + Math.max(0, s - i.length))),
          f.append(qs(l, i), s),
          (this.atCursorPos = u),
          (this.pendingBuffer = u ? (e < t || s > i.length ? 1 : 2) : 0),
          this.pendingBuffer && (this.bufferMarks = i.slice())
      }
    else
      this.doc.lineAt(this.pos).from == this.pos &&
        this.getLine().addLineDeco(r)
    a &&
      (this.textOff + a <= this.text.length
        ? (this.textOff += a)
        : ((this.skip += a - (this.text.length - this.textOff)),
          (this.text = ''),
          (this.textOff = 0)),
      (this.pos = t)),
      this.openStart < 0 && (this.openStart = s)
  }
  static build(e, t, r, i, s) {
    let o = new Bi(e, t, r, s)
    return (
      (o.openEnd = ce.spans(i, t, r, o)),
      o.openStart < 0 && (o.openStart = o.openEnd),
      o.finish(o.openEnd),
      o
    )
  }
}
function qs(n, e) {
  for (let t of e) n = new Sn(t, [n], n.length)
  return n
}
class hd extends an {
  constructor(e) {
    super(), (this.tag = e)
  }
  eq(e) {
    return e.tag == this.tag
  }
  toDOM() {
    return document.createElement(this.tag)
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag
  }
  get isHidden() {
    return !0
  }
}
const Py = U.define(),
  Ty = U.define(),
  $y = U.define(),
  Qy = U.define(),
  Zu = U.define(),
  ky = U.define(),
  Cy = U.define(),
  _y = U.define({ combine: (n) => n.some((e) => e) }),
  Ry = U.define({ combine: (n) => n.some((e) => e) })
class Mr {
  constructor(e, t = 'nearest', r = 'nearest', i = 5, s = 5, o = !1) {
    ;(this.range = e),
      (this.y = t),
      (this.x = r),
      (this.yMargin = i),
      (this.xMargin = s),
      (this.isSnapshot = o)
  }
  map(e) {
    return e.empty
      ? this
      : new Mr(
          this.range.map(e),
          this.y,
          this.x,
          this.yMargin,
          this.xMargin,
          this.isSnapshot
        )
  }
  clip(e) {
    return this.range.to <= e.doc.length
      ? this
      : new Mr(
          C.cursor(e.doc.length),
          this.y,
          this.x,
          this.yMargin,
          this.xMargin,
          this.isSnapshot
        )
  }
}
const zs = ee.define({ map: (n, e) => n.map(e) })
function _t(n, e, t) {
  let r = n.facet(Qy)
  r.length
    ? r[0](e)
    : window.onerror
      ? window.onerror(String(e), t, void 0, void 0, e)
      : t
        ? console.error(t + ':', e)
        : console.error(e)
}
const bl = U.define({ combine: (n) => (n.length ? n[0] : !0) })
let yk = 0
const Xi = U.define()
class _e {
  constructor(e, t, r, i, s) {
    ;(this.id = e),
      (this.create = t),
      (this.domEventHandlers = r),
      (this.domEventObservers = i),
      (this.extension = s(this))
  }
  static define(e, t) {
    const {
      eventHandlers: r,
      eventObservers: i,
      provide: s,
      decorations: o
    } = t || {}
    return new _e(yk++, e, r, i, (a) => {
      let l = [Xi.of(a)]
      return (
        o &&
          l.push(
            Ji.of((c) => {
              let u = c.plugin(a)
              return u ? o(u) : G.none
            })
          ),
        s && l.push(s(a)),
        l
      )
    })
  }
  static fromClass(e, t) {
    return _e.define((r) => new e(r), t)
  }
}
class tc {
  constructor(e) {
    ;(this.spec = e), (this.mustUpdate = null), (this.value = null)
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate
        if (((this.mustUpdate = null), this.value.update))
          try {
            this.value.update(t)
          } catch (r) {
            if (
              (_t(t.state, r, 'CodeMirror plugin crashed'), this.value.destroy)
            )
              try {
                this.value.destroy()
              } catch {}
            this.deactivate()
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e)
      } catch (t) {
        _t(e.state, t, 'CodeMirror plugin crashed'), this.deactivate()
      }
    return this
  }
  destroy(e) {
    var t
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy()
      } catch (r) {
        _t(e.state, r, 'CodeMirror plugin crashed')
      }
  }
  deactivate() {
    this.spec = this.value = null
  }
}
const Zy = U.define(),
  Xf = U.define(),
  Ji = U.define(),
  Yf = U.define(),
  Ay = U.define()
function pd(n, e, t) {
  let r = n.state.facet(Ay)
  if (!r.length) return r
  let i = r.map((o) => (o instanceof Function ? o(n) : o)),
    s = []
  return (
    ce.spans(i, e, t, {
      point() {},
      span(o, a, l, c) {
        let u = s
        for (let f = l.length - 1; f >= 0; f--, c--) {
          let p = l[f].spec.bidiIsolate,
            d
          if (p != null)
            if (
              c > 0 &&
              u.length &&
              (d = u[u.length - 1]).to == o &&
              d.direction == p
            )
              (d.to = a), (u = d.inner)
            else {
              let O = { from: o, to: a, direction: p, inner: [] }
              u.push(O), (u = O.inner)
            }
        }
      }
    }),
    s
  )
}
const Ey = U.define()
function Dy(n) {
  let e = 0,
    t = 0,
    r = 0,
    i = 0
  for (let s of n.state.facet(Ey)) {
    let o = s(n)
    o &&
      (o.left != null && (e = Math.max(e, o.left)),
      o.right != null && (t = Math.max(t, o.right)),
      o.top != null && (r = Math.max(r, o.top)),
      o.bottom != null && (i = Math.max(i, o.bottom)))
  }
  return { left: e, right: t, top: r, bottom: i }
}
const Yi = U.define()
class Rt {
  constructor(e, t, r, i) {
    ;(this.fromA = e), (this.toA = t), (this.fromB = r), (this.toB = i)
  }
  join(e) {
    return new Rt(
      Math.min(this.fromA, e.fromA),
      Math.max(this.toA, e.toA),
      Math.min(this.fromB, e.fromB),
      Math.max(this.toB, e.toB)
    )
  }
  addToSet(e) {
    let t = e.length,
      r = this
    for (; t > 0; t--) {
      let i = e[t - 1]
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA) break
        ;(r = r.join(i)), e.splice(t - 1, 1)
      }
    }
    return e.splice(t, 0, r), e
  }
  static extendWithRanges(e, t) {
    if (t.length == 0) return e
    let r = []
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i],
        c = o - a,
        u = l ? l.fromB : 1e9
      for (; s < t.length && t[s] < u; ) {
        let f = t[s],
          p = t[s + 1],
          d = Math.max(a, f),
          O = Math.min(u, p)
        if ((d <= O && new Rt(d + c, O + c, d, O).addToSet(r), p > u)) break
        s += 2
      }
      if (!l) return r
      new Rt(l.fromA, l.toA, l.fromB, l.toB).addToSet(r),
        (o = l.toA),
        (a = l.toB)
    }
  }
}
class $a {
  constructor(e, t, r) {
    ;(this.view = e),
      (this.state = t),
      (this.transactions = r),
      (this.flags = 0),
      (this.startState = e.state),
      (this.changes = Ae.empty(this.startState.doc.length))
    for (let s of r) this.changes = this.changes.compose(s.changes)
    let i = []
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Rt(s, o, a, l))),
      (this.changedRanges = i)
  }
  static create(e, t, r) {
    return new $a(e, t, r)
  }
  get viewportChanged() {
    return (this.flags & 4) > 0
  }
  get heightChanged() {
    return (this.flags & 2) > 0
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0
  }
  get focusChanged() {
    return (this.flags & 1) > 0
  }
  get docChanged() {
    return !this.changes.empty
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection)
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0
  }
}
var we = (function (n) {
  return (n[(n.LTR = 0)] = 'LTR'), (n[(n.RTL = 1)] = 'RTL'), n
})(we || (we = {}))
const es = we.LTR,
  Xy = we.RTL
function Yy(n) {
  let e = []
  for (let t = 0; t < n.length; t++) e.push(1 << +n[t])
  return e
}
const bk = Yy(
    '88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008'
  ),
  vk = Yy(
    '4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333'
  ),
  Au = Object.create(null),
  Mt = []
for (let n of ['()', '[]', '{}']) {
  let e = n.charCodeAt(0),
    t = n.charCodeAt(1)
  ;(Au[e] = t), (Au[t] = -e)
}
function Sk(n) {
  return n <= 247
    ? bk[n]
    : 1424 <= n && n <= 1524
      ? 2
      : 1536 <= n && n <= 1785
        ? vk[n - 1536]
        : 1774 <= n && n <= 2220
          ? 4
          : 8192 <= n && n <= 8203
            ? 256
            : 64336 <= n && n <= 65023
              ? 4
              : n == 8204
                ? 256
                : 1
}
const xk = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/
class Yn {
  get dir() {
    return this.level % 2 ? Xy : es
  }
  constructor(e, t, r) {
    ;(this.from = e), (this.to = t), (this.level = r)
  }
  side(e, t) {
    return (this.dir == t) == e ? this.to : this.from
  }
  static find(e, t, r, i) {
    let s = -1
    for (let o = 0; o < e.length; o++) {
      let a = e[o]
      if (a.from <= t && a.to >= t) {
        if (a.level == r) return o
        ;(s < 0 ||
          (i != 0 ? (i < 0 ? a.from < t : a.to > t) : e[s].level > a.level)) &&
          (s = o)
      }
    }
    if (s < 0) throw new RangeError('Index out of range')
    return s
  }
}
function Iy(n, e) {
  if (n.length != e.length) return !1
  for (let t = 0; t < n.length; t++) {
    let r = n[t],
      i = e[t]
    if (
      r.from != i.from ||
      r.to != i.to ||
      r.direction != i.direction ||
      !Iy(r.inner, i.inner)
    )
      return !1
  }
  return !0
}
const he = []
function wk(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e,
      a = s < r.length ? r[s].from : t,
      l = s ? 256 : i
    for (let c = o, u = l, f = l; c < a; c++) {
      let p = Sk(n.charCodeAt(c))
      p == 512 ? (p = u) : p == 8 && f == 4 && (p = 16),
        (he[c] = p == 4 ? 2 : p),
        p & 7 && (f = p),
        (u = p)
    }
    for (let c = o, u = l, f = l; c < a; c++) {
      let p = he[c]
      if (p == 128)
        c < a - 1 && u == he[c + 1] && u & 24 ? (p = he[c] = u) : (he[c] = 256)
      else if (p == 64) {
        let d = c + 1
        for (; d < a && he[d] == 64; ) d++
        let O = (c && u == 8) || (d < t && he[d] == 8) ? (f == 1 ? 1 : 8) : 256
        for (let g = c; g < d; g++) he[g] = O
        c = d - 1
      } else p == 8 && f == 1 && (he[c] = 1)
      ;(u = p), p & 7 && (f = p)
    }
  }
}
function Pk(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e,
      u = o < r.length ? r[o].from : t
    for (let f = c, p, d, O; f < u; f++)
      if ((d = Au[(p = n.charCodeAt(f))]))
        if (d < 0) {
          for (let g = a - 3; g >= 0; g -= 3)
            if (Mt[g + 1] == -d) {
              let b = Mt[g + 2],
                x = b & 2 ? i : b & 4 ? (b & 1 ? s : i) : 0
              x && (he[f] = he[Mt[g]] = x), (a = g)
              break
            }
        } else {
          if (Mt.length == 189) break
          ;(Mt[a++] = f), (Mt[a++] = p), (Mt[a++] = l)
        }
      else if ((O = he[f]) == 2 || O == 1) {
        let g = O == i
        l = g ? 0 : 1
        for (let b = a - 3; b >= 0; b -= 3) {
          let x = Mt[b + 2]
          if (x & 2) break
          if (g) Mt[b + 2] |= 2
          else {
            if (x & 4) break
            Mt[b + 2] |= 4
          }
        }
      }
  }
}
function Tk(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n,
      a = i < t.length ? t[i].from : e
    for (let l = o; l < a; ) {
      let c = he[l]
      if (c == 256) {
        let u = l + 1
        for (;;)
          if (u == a) {
            if (i == t.length) break
            ;(u = t[i++].to), (a = i < t.length ? t[i].from : e)
          } else if (he[u] == 256) u++
          else break
        let f = s == 1,
          p = (u < e ? he[u] : r) == 1,
          d = f == p ? (f ? 1 : 2) : r
        for (let O = u, g = i, b = g ? t[g - 1].to : n; O > l; )
          O == b && ((O = t[--g].from), (b = g ? t[g - 1].to : n)),
            (he[--O] = d)
        l = u
      } else (s = c), l++
    }
  }
}
function Eu(n, e, t, r, i, s, o) {
  let a = r % 2 ? 2 : 1
  if (r % 2 == i % 2)
    for (let l = e, c = 0; l < t; ) {
      let u = !0,
        f = !1
      if (c == s.length || l < s[c].from) {
        let g = he[l]
        g != a && ((u = !1), (f = g == 16))
      }
      let p = !u && a == 1 ? [] : null,
        d = u ? r : r + 1,
        O = l
      e: for (;;)
        if (c < s.length && O == s[c].from) {
          if (f) break e
          let g = s[c]
          if (!u)
            for (let b = g.to, x = c + 1; ; ) {
              if (b == t) break e
              if (x < s.length && s[x].from == b) b = s[x++].to
              else {
                if (he[b] == a) break e
                break
              }
            }
          if ((c++, p)) p.push(g)
          else {
            g.from > l && o.push(new Yn(l, g.from, d))
            let b = (g.direction == es) != !(d % 2)
            Du(n, b ? r + 1 : r, i, g.inner, g.from, g.to, o), (l = g.to)
          }
          O = g.to
        } else {
          if (O == t || (u ? he[O] != a : he[O] == a)) break
          O++
        }
      p ? Eu(n, l, O, r + 1, i, p, o) : l < O && o.push(new Yn(l, O, d)),
        (l = O)
    }
  else
    for (let l = t, c = s.length; l > e; ) {
      let u = !0,
        f = !1
      if (!c || l > s[c - 1].to) {
        let g = he[l - 1]
        g != a && ((u = !1), (f = g == 16))
      }
      let p = !u && a == 1 ? [] : null,
        d = u ? r : r + 1,
        O = l
      e: for (;;)
        if (c && O == s[c - 1].to) {
          if (f) break e
          let g = s[--c]
          if (!u)
            for (let b = g.from, x = c; ; ) {
              if (b == e) break e
              if (x && s[x - 1].to == b) b = s[--x].from
              else {
                if (he[b - 1] == a) break e
                break
              }
            }
          if (p) p.push(g)
          else {
            g.to < l && o.push(new Yn(g.to, l, d))
            let b = (g.direction == es) != !(d % 2)
            Du(n, b ? r + 1 : r, i, g.inner, g.from, g.to, o), (l = g.from)
          }
          O = g.from
        } else {
          if (O == e || (u ? he[O - 1] != a : he[O - 1] == a)) break
          O--
        }
      p ? Eu(n, O, l, r + 1, i, p, o) : O < l && o.push(new Yn(O, l, d)),
        (l = O)
    }
}
function Du(n, e, t, r, i, s, o) {
  let a = e % 2 ? 2 : 1
  wk(n, i, s, r, a), Pk(n, i, s, r, a), Tk(i, s, r, a), Eu(n, i, s, e, t, r, o)
}
function $k(n, e, t) {
  if (!n) return [new Yn(0, 0, e == Xy ? 1 : 0)]
  if (e == es && !t.length && !xk.test(n)) return jy(n.length)
  if (t.length) for (; n.length > he.length; ) he[he.length] = 256
  let r = [],
    i = e == es ? 0 : 1
  return Du(n, i, i, t, 0, n.length, r), r
}
function jy(n) {
  return [new Yn(0, n, 0)]
}
let Ny = ''
function Qk(n, e, t, r, i) {
  var s
  let o = r.head - n.from,
    a = -1
  if (o == 0) {
    if (!i || !n.length) return null
    e[0].level != t && ((o = e[0].side(!1, t)), (a = 0))
  } else if (o == n.length) {
    if (i) return null
    let p = e[e.length - 1]
    p.level != t && ((o = p.side(!0, t)), (a = e.length - 1))
  }
  a < 0 &&
    (a = Yn.find(
      e,
      o,
      (s = r.bidiLevel) !== null && s !== void 0 ? s : -1,
      r.assoc
    ))
  let l = e[a]
  o == l.side(i, t) && ((l = e[(a += i ? 1 : -1)]), (o = l.side(!i, t)))
  let c = i == (l.dir == t),
    u = He(n.text, o, c)
  if (((Ny = n.text.slice(Math.min(o, u), Math.max(o, u))), u != l.side(i, t)))
    return C.cursor(u + n.from, c ? -1 : 1, l.level)
  let f = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)]
  return !f && l.level != t
    ? C.cursor(i ? n.to : n.from, i ? -1 : 1, t)
    : f && f.level < l.level
      ? C.cursor(f.side(!i, t) + n.from, i ? 1 : -1, f.level)
      : C.cursor(u + n.from, i ? -1 : 1, l.level)
}
class dd extends ve {
  get length() {
    return this.view.state.doc.length
  }
  constructor(e) {
    super(),
      (this.view = e),
      (this.decorations = []),
      (this.dynamicDecorationMap = []),
      (this.domChanged = null),
      (this.hasComposition = null),
      (this.markedForComposition = new Set()),
      (this.minWidth = 0),
      (this.minWidthFrom = 0),
      (this.minWidthTo = 0),
      (this.impreciseAnchor = null),
      (this.impreciseHead = null),
      (this.forceSelection = !1),
      (this.lastUpdate = Date.now()),
      this.setDOM(e.contentDOM),
      (this.children = [new Ze()]),
      this.children[0].setParent(this),
      this.updateDeco(),
      this.updateInner([new Rt(0, 0, 0, e.state.doc.length)], 0, null)
  }
  update(e) {
    var t
    let r = e.changedRanges
    this.minWidth > 0 &&
      r.length &&
      (r.every(
        ({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo
      )
        ? ((this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1)),
          (this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)))
        : (this.minWidth = this.minWidthFrom = this.minWidthTo = 0))
    let i = -1
    this.view.inputState.composing >= 0 &&
      (!((t = this.domChanged) === null || t === void 0) && t.newSel
        ? (i = this.domChanged.newSel.head)
        : !Ek(e.changes, this.hasComposition) &&
          !e.selectionSet &&
          (i = e.state.selection.main.head))
    let s = i > -1 ? Ck(this.view, e.changes, i) : null
    if (((this.domChanged = null), this.hasComposition)) {
      this.markedForComposition.clear()
      let { from: c, to: u } = this.hasComposition
      r = new Rt(
        c,
        u,
        e.changes.mapPos(c, -1),
        e.changes.mapPos(u, 1)
      ).addToSet(r.slice())
    }
    ;(this.hasComposition = s
      ? { from: s.range.fromB, to: s.range.toB }
      : null),
      (z.ie || z.chrome) &&
        !s &&
        e &&
        e.state.doc.lines != e.startState.doc.lines &&
        (this.forceSelection = !0)
    let o = this.decorations,
      a = this.updateDeco(),
      l = Zk(o, a, e.changes)
    return (
      (r = Rt.extendWithRanges(r, l)),
      !(this.flags & 7) && r.length == 0
        ? !1
        : (this.updateInner(r, e.startState.doc.length, s),
          e.transactions.length && (this.lastUpdate = Date.now()),
          !0)
    )
  }
  updateInner(e, t, r) {
    ;(this.view.viewState.mustMeasureContent = !0), this.updateChildren(e, t, r)
    let { observer: i } = this.view
    i.ignore(() => {
      ;(this.dom.style.height =
        this.view.viewState.contentHeight / this.view.scaleY + 'px'),
        (this.dom.style.flexBasis = this.minWidth ? this.minWidth + 'px' : '')
      let o =
        z.chrome || z.ios
          ? { node: i.selectionRange.focusNode, written: !1 }
          : void 0
      this.sync(this.view, o),
        (this.flags &= -8),
        o &&
          (o.written || i.selectionRange.focusNode != o.node) &&
          (this.forceSelection = !0),
        (this.dom.style.height = '')
    }),
      this.markedForComposition.forEach((o) => (o.flags &= -9))
    let s = []
    if (
      this.view.viewport.from ||
      this.view.viewport.to < this.view.state.doc.length
    )
      for (let o of this.children)
        o instanceof In && o.widget instanceof Od && s.push(o.dom)
    i.updateGaps(s)
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e,
      s = this.childCursor(t)
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null
      if (!a) break
      let { fromA: l, toA: c, fromB: u, toB: f } = a,
        p,
        d,
        O,
        g
      if (r && r.range.fromB < f && r.range.toB > u) {
        let T = Bi.build(
            this.view.state.doc,
            u,
            r.range.fromB,
            this.decorations,
            this.dynamicDecorationMap
          ),
          P = Bi.build(
            this.view.state.doc,
            r.range.toB,
            f,
            this.decorations,
            this.dynamicDecorationMap
          )
        ;(d = T.breakAtStart), (O = T.openStart), (g = P.openEnd)
        let k = this.compositionView(r)
        P.breakAtStart
          ? (k.breakAfter = 1)
          : P.content.length &&
            k.merge(k.length, k.length, P.content[0], !1, P.openStart, 0) &&
            ((k.breakAfter = P.content[0].breakAfter), P.content.shift()),
          T.content.length &&
            k.merge(0, 0, T.content[T.content.length - 1], !0, 0, T.openEnd) &&
            T.content.pop(),
          (p = T.content.concat(k).concat(P.content))
      } else
        ({
          content: p,
          breakAtStart: d,
          openStart: O,
          openEnd: g
        } = Bi.build(
          this.view.state.doc,
          u,
          f,
          this.decorations,
          this.dynamicDecorationMap
        ))
      let { i: b, off: x } = s.findPos(c, 1),
        { i: w, off: Q } = s.findPos(l, -1)
      my(this, w, Q, b, x, p, d, O, g)
    }
    r && this.fixCompositionDOM(r)
  }
  compositionView(e) {
    let t = new vn(e.text.nodeValue)
    t.flags |= 8
    for (let { deco: i } of e.marks) t = new Sn(i, [t], t.length)
    let r = new Ze()
    return r.append(t, 0), r
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
        ;(o.flags |= 8 | (o.children.some((l) => l.flags & 7) ? 1 : 0)),
          this.markedForComposition.add(o)
        let a = ve.get(s)
        a && a != o && (a.dom = null), o.setDOM(s)
      },
      r = this.childPos(e.range.fromB, 1),
      i = this.children[r.i]
    t(e.line, i)
    for (let s = e.marks.length - 1; s >= -1; s--)
      (r = i.childPos(r.off, 1)),
        (i = i.children[r.i]),
        t(s >= 0 ? e.marks[s].node : e.text, i)
  }
  updateSelection(e = !1, t = !1) {
    ;(e || !this.view.observer.selectionRange.focusNode) &&
      this.view.observer.readSelectionRange()
    let r = this.view.root.activeElement,
      i = r == this.dom,
      s =
        !i &&
        Xo(this.dom, this.view.observer.selectionRange) &&
        !(r && this.dom.contains(r))
    if (!(i || t || s)) return
    let o = this.forceSelection
    this.forceSelection = !1
    let a = this.view.state.selection.main,
      l = this.moveToLine(this.domAtPos(a.anchor)),
      c = a.empty ? l : this.moveToLine(this.domAtPos(a.head))
    if (z.gecko && a.empty && !this.hasComposition && kk(l)) {
      let f = document.createTextNode('')
      this.view.observer.ignore(() =>
        l.node.insertBefore(f, l.node.childNodes[l.offset] || null)
      ),
        (l = c = new Fe(f, 0)),
        (o = !0)
    }
    let u = this.view.observer.selectionRange
    ;(o ||
      !u.focusNode ||
      !Ta(l.node, l.offset, u.anchorNode, u.anchorOffset) ||
      !Ta(c.node, c.offset, u.focusNode, u.focusOffset)) &&
      (this.view.observer.ignore(() => {
        z.android &&
          z.chrome &&
          this.dom.contains(u.focusNode) &&
          Ak(u.focusNode, this.dom) &&
          (this.dom.blur(), this.dom.focus({ preventScroll: !0 }))
        let f = Pa(this.view.root)
        if (f)
          if (a.empty) {
            if (z.gecko) {
              let p = _k(l.node, l.offset)
              if (p && p != 3) {
                let d = Vy(l.node, l.offset, p == 1 ? 1 : -1)
                d && (l = new Fe(d.node, d.offset))
              }
            }
            f.collapse(l.node, l.offset),
              a.bidiLevel != null &&
                f.caretBidiLevel !== void 0 &&
                (f.caretBidiLevel = a.bidiLevel)
          } else if (f.extend) {
            f.collapse(l.node, l.offset)
            try {
              f.extend(c.node, c.offset)
            } catch {}
          } else {
            let p = document.createRange()
            a.anchor > a.head && ([l, c] = [c, l]),
              p.setEnd(c.node, c.offset),
              p.setStart(l.node, l.offset),
              f.removeAllRanges(),
              f.addRange(p)
          }
        s &&
          this.view.root.activeElement == this.dom &&
          (this.dom.blur(), r && r.focus())
      }),
      this.view.observer.setSelectionRange(l, c)),
      (this.impreciseAnchor = l.precise
        ? null
        : new Fe(u.anchorNode, u.anchorOffset)),
      (this.impreciseHead = c.precise
        ? null
        : new Fe(u.focusNode, u.focusOffset))
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return
    let { view: e } = this,
      t = e.state.selection.main,
      r = Pa(e.root),
      { anchorNode: i, anchorOffset: s } = e.observer.selectionRange
    if (!r || !t.empty || !t.assoc || !r.modify) return
    let o = Ze.find(this, t.head)
    if (!o) return
    let a = o.posAtStart
    if (t.head == a || t.head == a + o.length) return
    let l = this.coordsAt(t.head, -1),
      c = this.coordsAt(t.head, 1)
    if (!l || !c || l.bottom > c.top) return
    let u = this.domAtPos(t.head + t.assoc)
    r.collapse(u.node, u.offset),
      r.modify('move', t.assoc < 0 ? 'forward' : 'backward', 'lineboundary'),
      e.observer.readSelectionRange()
    let f = e.observer.selectionRange
    e.docView.posFromDOM(f.anchorNode, f.anchorOffset) != t.from &&
      r.collapse(i, s)
  }
  moveToLine(e) {
    let t = this.dom,
      r
    if (e.node != t) return e
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = ve.get(t.childNodes[i])
      s instanceof Ze && (r = s.domAtPos(0))
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = ve.get(t.childNodes[i])
      s instanceof Ze && (r = s.domAtPos(s.length))
    }
    return r ? new Fe(r.node, r.offset, !0) : e
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = ve.get(t)
      if (r && r.rootView == this) return r
      t = t.parentNode
    }
    return null
  }
  posFromDOM(e, t) {
    let r = this.nearest(e)
    if (!r)
      throw new RangeError(
        'Trying to find position for a DOM position outside of the document'
      )
    return r.localPosFromDOM(e, t) + r.posAtStart
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1)
    for (; t < this.children.length - 1; ) {
      let i = this.children[t]
      if (r < i.length || i instanceof Ze) break
      t++, (r = 0)
    }
    return this.children[t].domAtPos(r)
  }
  coordsAt(e, t) {
    let r = null,
      i = 0
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o],
        l = s - a.breakAfter,
        c = l - a.length
      if (l < e) break
      c <= e &&
        (c < e || a.covers(-1)) &&
        (l > e || a.covers(1)) &&
        (!r || (a instanceof Ze && !(r instanceof Ze && t >= 0))) &&
        ((r = a), (i = c)),
        (s = c)
    }
    return r ? r.coordsAt(e - i, t) : null
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1),
      i = this.children[t]
    if (!(i instanceof Ze)) return null
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1)
      for (; ; a++) {
        if (a == i.children.length) return null
        if ((i = i.children[a]).length) break
      }
      r = l
    }
    if (!(i instanceof vn)) return null
    let s = He(i.text, r)
    if (s == r) return null
    let o = mr(i.dom, r, s).getClientRects()
    for (let a = 0; a < o.length; a++) {
      let l = o[a]
      if (a == o.length - 1 || (l.top < l.bottom && l.left < l.right)) return l
    }
    return null
  }
  measureVisibleLineHeights(e) {
    let t = [],
      { from: r, to: i } = e,
      s = this.view.contentDOM.clientWidth,
      o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1,
      a = -1,
      l = this.view.textDirection == we.LTR
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let f = this.children[u],
        p = c + f.length
      if (p > i) break
      if (c >= r) {
        let d = f.dom.getBoundingClientRect()
        if ((t.push(d.height), o)) {
          let O = f.dom.lastChild,
            g = O ? Gr(O) : []
          if (g.length) {
            let b = g[g.length - 1],
              x = l ? b.right - d.left : d.right - b.left
            x > a &&
              ((a = x),
              (this.minWidth = s),
              (this.minWidthFrom = c),
              (this.minWidthTo = p))
          }
        }
      }
      c = p + f.breakAfter
    }
    return t
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1)
    return getComputedStyle(this.children[t].dom).direction == 'rtl'
      ? we.RTL
      : we.LTR
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ze) {
        let o = s.measureTextSize()
        if (o) return o
      }
    let e = document.createElement('div'),
      t,
      r,
      i
    return (
      (e.className = 'cm-line'),
      (e.style.width = '99999px'),
      (e.style.position = 'absolute'),
      (e.textContent = 'abc def ghi jkl mno pqr stu'),
      this.view.observer.ignore(() => {
        this.dom.appendChild(e)
        let s = Gr(e.firstChild)[0]
        ;(t = e.getBoundingClientRect().height),
          (r = s ? s.width / 27 : 7),
          (i = s ? s.height : t),
          e.remove()
      }),
      { lineHeight: t, charWidth: r, textHeight: i }
    )
  }
  childCursor(e = this.length) {
    let t = this.children.length
    return t && (e -= this.children[--t].length), new Oy(this.children, e, t)
  }
  computeBlockGapDeco() {
    let e = [],
      t = this.view.viewState
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i],
        o = s ? s.from - 1 : this.length
      if (o > r) {
        let a =
          (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY
        e.push(
          G.replace({
            widget: new Od(a),
            block: !0,
            inclusive: !0,
            isBlockGap: !0
          }).range(r, o)
        )
      }
      if (!s) break
      r = s.to + 1
    }
    return G.set(e)
  }
  updateDeco() {
    let e = this.view.state
      .facet(Ji)
      .map((t, r) =>
        (this.dynamicDecorationMap[r] = typeof t == 'function')
          ? t(this.view)
          : t
      )
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1
    return (this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ])
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head)
      ;(this.view.scrollDOM.scrollTop = c.top - e.yMargin),
        (this.view.scrollDOM.scrollLeft = e.xMargin)
      return
    }
    let { range: t } = e,
      r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1),
      i
    if (!r) return
    !t.empty &&
      (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) &&
      (r = {
        left: Math.min(r.left, i.left),
        top: Math.min(r.top, i.top),
        right: Math.max(r.right, i.right),
        bottom: Math.max(r.bottom, i.bottom)
      })
    let s = Dy(this.view),
      o = {
        left: r.left - s.left,
        top: r.top - s.top,
        right: r.right + s.right,
        bottom: r.bottom + s.bottom
      },
      { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM
    lk(
      this.view.scrollDOM,
      o,
      t.head < t.anchor ? -1 : 1,
      e.x,
      e.y,
      Math.max(Math.min(e.xMargin, a), -a),
      Math.max(Math.min(e.yMargin, l), -l),
      this.view.textDirection == we.LTR
    )
  }
}
function kk(n) {
  return (
    n.node.nodeType == 1 &&
    n.node.firstChild &&
    (n.offset == 0 ||
      n.node.childNodes[n.offset - 1].contentEditable == 'false') &&
    (n.offset == n.node.childNodes.length ||
      n.node.childNodes[n.offset].contentEditable == 'false')
  )
}
class Od extends an {
  constructor(e) {
    super(), (this.height = e)
  }
  toDOM() {
    let e = document.createElement('div')
    return this.updateDOM(e), e
  }
  eq(e) {
    return e.height == this.height
  }
  updateDOM(e) {
    return (e.style.height = this.height + 'px'), !0
  }
  get estimatedHeight() {
    return this.height
  }
}
function My(n, e) {
  let t = n.observer.selectionRange,
    r = t.focusNode && Vy(t.focusNode, t.focusOffset, 0)
  if (!r) return null
  let i = e - r.offset
  return { from: i, to: i + r.node.nodeValue.length, node: r.node }
}
function Ck(n, e, t) {
  let r = My(n, t)
  if (!r) return null
  let { node: i, from: s, to: o } = r,
    a = i.nodeValue
  if (/[\n\r]/.test(a) || n.state.doc.sliceString(r.from, r.to) != a)
    return null
  let l = e.invertedDesc,
    c = new Rt(l.mapPos(s), l.mapPos(o), s, o),
    u = []
  for (let f = i.parentNode; ; f = f.parentNode) {
    let p = ve.get(f)
    if (p instanceof Sn) u.push({ node: f, deco: p.mark })
    else {
      if (
        p instanceof Ze ||
        (f.nodeName == 'DIV' && f.parentNode == n.contentDOM)
      )
        return { range: c, text: i, marks: u, line: f }
      if (f != n.contentDOM)
        u.push({
          node: f,
          deco: new xs({
            inclusive: !0,
            attributes: mk(f),
            tagName: f.tagName.toLowerCase()
          })
        })
      else return null
    }
  }
}
function Vy(n, e, t) {
  if (t <= 0)
    for (let r = n, i = e; ; ) {
      if (r.nodeType == 3) return { node: r, offset: i }
      if (r.nodeType == 1 && i > 0) (r = r.childNodes[i - 1]), (i = bn(r))
      else break
    }
  if (t >= 0)
    for (let r = n, i = e; ; ) {
      if (r.nodeType == 3) return { node: r, offset: i }
      if (r.nodeType == 1 && i < r.childNodes.length && t >= 0)
        (r = r.childNodes[i]), (i = 0)
      else break
    }
  return null
}
function _k(n, e) {
  return n.nodeType != 1
    ? 0
    : (e && n.childNodes[e - 1].contentEditable == 'false' ? 1 : 0) |
        (e < n.childNodes.length && n.childNodes[e].contentEditable == 'false'
          ? 2
          : 0)
}
let Rk = class {
  constructor() {
    this.changes = []
  }
  compareRange(e, t) {
    Ru(e, t, this.changes)
  }
  comparePoint(e, t) {
    Ru(e, t, this.changes)
  }
}
function Zk(n, e, t) {
  let r = new Rk()
  return ce.compare(n, e, t, r), r.changes
}
function Ak(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == 'false') return !0
  return !1
}
function Ek(n, e) {
  let t = !1
  return (
    e &&
      n.iterChangedRanges((r, i) => {
        r < e.to && i > e.from && (t = !0)
      }),
    t
  )
}
function Dk(n, e, t = 1) {
  let r = n.charCategorizer(e),
    i = n.doc.lineAt(e),
    s = e - i.from
  if (i.length == 0) return C.cursor(e)
  s == 0 ? (t = 1) : s == i.length && (t = -1)
  let o = s,
    a = s
  t < 0 ? (o = He(i.text, s, !1)) : (a = He(i.text, s))
  let l = r(i.text.slice(o, a))
  for (; o > 0; ) {
    let c = He(i.text, o, !1)
    if (r(i.text.slice(c, o)) != l) break
    o = c
  }
  for (; a < i.length; ) {
    let c = He(i.text, a)
    if (r(i.text.slice(a, c)) != l) break
    a = c
  }
  return C.range(o + i.from, a + i.from)
}
function Xk(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right)
}
function Yk(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom)
}
function nc(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1
}
function md(n, e) {
  return e < n.top
    ? { top: e, left: n.left, right: n.right, bottom: n.bottom }
    : n
}
function gd(n, e) {
  return e > n.bottom
    ? { top: n.top, left: n.left, right: n.right, bottom: e }
    : n
}
function Xu(n, e, t) {
  let r,
    i,
    s,
    o,
    a = !1,
    l,
    c,
    u,
    f
  for (let O = n.firstChild; O; O = O.nextSibling) {
    let g = Gr(O)
    for (let b = 0; b < g.length; b++) {
      let x = g[b]
      i && nc(i, x) && (x = md(gd(x, i.bottom), i.top))
      let w = Xk(e, x),
        Q = Yk(t, x)
      if (w == 0 && Q == 0) return O.nodeType == 3 ? yd(O, e, t) : Xu(O, e, t)
      if (!r || o > Q || (o == Q && s > w)) {
        ;(r = O), (i = x), (s = w), (o = Q)
        let T = Q ? (t < x.top ? -1 : 1) : w ? (e < x.left ? -1 : 1) : 0
        a = !T || (T > 0 ? b < g.length - 1 : b > 0)
      }
      w == 0
        ? t > x.bottom && (!u || u.bottom < x.bottom)
          ? ((l = O), (u = x))
          : t < x.top && (!f || f.top > x.top) && ((c = O), (f = x))
        : u && nc(u, x)
          ? (u = gd(u, x.bottom))
          : f && nc(f, x) && (f = md(f, x.top))
    }
  }
  if (
    (u && u.bottom >= t
      ? ((r = l), (i = u))
      : f && f.top <= t && ((r = c), (i = f)),
    !r)
  )
    return { node: n, offset: 0 }
  let p = Math.max(i.left, Math.min(i.right, e))
  if (r.nodeType == 3) return yd(r, p, t)
  if (a && r.contentEditable != 'false') return Xu(r, p, t)
  let d =
    Array.prototype.indexOf.call(n.childNodes, r) +
    (e >= (i.left + i.right) / 2 ? 1 : 0)
  return { node: n, offset: d }
}
function yd(n, e, t) {
  let r = n.nodeValue.length,
    i = -1,
    s = 1e9,
    o = 0
  for (let a = 0; a < r; a++) {
    let l = mr(n, a, a + 1).getClientRects()
    for (let c = 0; c < l.length; c++) {
      let u = l[c]
      if (u.top == u.bottom) continue
      o || (o = e - u.left)
      let f = (u.top > t ? u.top - t : t - u.bottom) - 1
      if (u.left - 1 <= e && u.right + 1 >= e && f < s) {
        let p = e >= (u.left + u.right) / 2,
          d = p
        if (
          ((z.chrome || z.gecko) &&
            mr(n, a).getBoundingClientRect().left == u.right &&
            (d = !p),
          f <= 0)
        )
          return { node: n, offset: a + (d ? 1 : 0) }
        ;(i = a + (d ? 1 : 0)), (s = f)
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 }
}
function Wy(n, e, t, r = -1) {
  var i, s
  let o = n.contentDOM.getBoundingClientRect(),
    a = o.top + n.viewState.paddingTop,
    l,
    { docHeight: c } = n.viewState,
    { x: u, y: f } = e,
    p = f - a
  if (p < 0) return 0
  if (p > c) return n.state.doc.length
  for (
    let T = n.viewState.heightOracle.textHeight / 2, P = !1;
    (l = n.elementAtHeight(p)), l.type != nt.Text;

  )
    for (; (p = r > 0 ? l.bottom + T : l.top - T), !(p >= 0 && p <= c); ) {
      if (P) return t ? null : 0
      ;(P = !0), (r = -r)
    }
  f = a + p
  let d = l.from
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : bd(n, o, l, u, f)
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length
      ? n.state.doc.length
      : t
        ? null
        : bd(n, o, l, u, f)
  let O = n.dom.ownerDocument,
    g = n.root.elementFromPoint ? n.root : O,
    b = g.elementFromPoint(u, f)
  b && !n.contentDOM.contains(b) && (b = null),
    b ||
      ((u = Math.max(o.left + 1, Math.min(o.right - 1, u))),
      (b = g.elementFromPoint(u, f)),
      b && !n.contentDOM.contains(b) && (b = null))
  let x,
    w = -1
  if (
    b &&
    ((i = n.docView.nearest(b)) === null || i === void 0
      ? void 0
      : i.isEditable) != !1
  ) {
    if (O.caretPositionFromPoint) {
      let T = O.caretPositionFromPoint(u, f)
      T && ({ offsetNode: x, offset: w } = T)
    } else if (O.caretRangeFromPoint) {
      let T = O.caretRangeFromPoint(u, f)
      T &&
        (({ startContainer: x, startOffset: w } = T),
        (!n.contentDOM.contains(x) ||
          (z.safari && Ik(x, w, u)) ||
          (z.chrome && jk(x, w, u))) &&
          (x = void 0))
    }
  }
  if (!x || !n.docView.dom.contains(x)) {
    let T = Ze.find(n.docView, d)
    if (!T) return p > l.top + l.height / 2 ? l.to : l.from
    ;({ node: x, offset: w } = Xu(T.dom, u, f))
  }
  let Q = n.docView.nearest(x)
  if (!Q) return null
  if (
    Q.isWidget &&
    ((s = Q.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1
  ) {
    let T = Q.dom.getBoundingClientRect()
    return e.y < T.top || (e.y <= T.bottom && e.x <= (T.left + T.right) / 2)
      ? Q.posAtStart
      : Q.posAtEnd
  } else return Q.localPosFromDOM(x, w) + Q.posAtStart
}
function bd(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth)
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let a = n.viewState.heightOracle.textHeight,
      l = Math.floor((i - t.top - (n.defaultLineHeight - a) * 0.5) / a)
    s += l * n.viewState.heightOracle.lineLength
  }
  let o = n.state.sliceDoc(t.from, t.to)
  return t.from + xu(o, s, n.state.tabSize)
}
function Ik(n, e, t) {
  let r
  if (n.nodeType != 3 || e != (r = n.nodeValue.length)) return !1
  for (let i = n.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != 'BR') return !1
  return mr(n, r - 1, r).getBoundingClientRect().left > t
}
function jk(n, e, t) {
  if (e != 0) return !1
  for (let i = n; ; ) {
    let s = i.parentNode
    if (!s || s.nodeType != 1 || s.firstChild != i) return !1
    if (s.classList.contains('cm-line')) break
    i = s
  }
  let r =
    n.nodeType == 1
      ? n.getBoundingClientRect()
      : mr(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect()
  return t - r.left > 5
}
function Yu(n, e) {
  let t = n.lineBlockAt(e)
  if (Array.isArray(t.type)) {
    for (let r of t.type)
      if (r.to > e || (r.to == e && (r.to == t.to || r.type == nt.Text)))
        return r
  }
  return t
}
function Nk(n, e, t, r) {
  let i = Yu(n, e.head),
    s =
      !r || i.type != nt.Text || !(n.lineWrapping || i.widgetLineBreaks)
        ? null
        : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head)
  if (s) {
    let o = n.dom.getBoundingClientRect(),
      a = n.textDirectionAt(i.from),
      l = n.posAtCoords({
        x: t == (a == we.LTR) ? o.right - 1 : o.left + 1,
        y: (s.top + s.bottom) / 2
      })
    if (l != null) return C.cursor(l, t ? -1 : 1)
  }
  return C.cursor(t ? i.to : i.from, t ? -1 : 1)
}
function vd(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head),
    s = n.bidiSpans(i),
    o = n.textDirectionAt(i.from)
  for (let a = e, l = null; ; ) {
    let c = Qk(i, s, o, a, t),
      u = Ny
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1)) return a
      ;(u = `
`),
        (i = n.state.doc.line(i.number + (t ? 1 : -1))),
        (s = n.bidiSpans(i)),
        (c = C.cursor(t ? i.from : i.to))
    }
    if (l) {
      if (!l(u)) return a
    } else {
      if (!r) return c
      l = r(u)
    }
    a = c
  }
}
function Mk(n, e, t) {
  let r = n.state.charCategorizer(e),
    i = r(t)
  return (s) => {
    let o = r(s)
    return i == Se.Space && (i = o), i == o
  }
}
function Vk(n, e, t, r) {
  let i = e.head,
    s = t ? 1 : -1
  if (i == (t ? n.state.doc.length : 0)) return C.cursor(i, e.assoc)
  let o = e.goalColumn,
    a,
    l = n.contentDOM.getBoundingClientRect(),
    c = n.coordsAtPos(i, e.assoc || -1),
    u = n.documentTop
  if (c) o == null && (o = c.left - l.left), (a = s < 0 ? c.top : c.bottom)
  else {
    let d = n.viewState.lineBlockAt(i)
    o == null &&
      (o = Math.min(l.right - l.left, n.defaultCharacterWidth * (i - d.from))),
      (a = (s < 0 ? d.top : d.bottom) + u)
  }
  let f = l.left + o,
    p = r ?? n.viewState.heightOracle.textHeight >> 1
  for (let d = 0; ; d += 10) {
    let O = a + (p + d) * s,
      g = Wy(n, { x: f, y: O }, !1, s)
    if (O < l.top || O > l.bottom || (s < 0 ? g < i : g > i)) {
      let b = n.docView.coordsForChar(g),
        x = !b || O < b.top ? -1 : 1
      return C.cursor(g, x, void 0, o)
    }
  }
}
function Yo(n, e, t) {
  for (;;) {
    let r = 0
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = r || t || (e - s < o - e ? -1 : 1)
          ;(e = l < 0 ? s : o), (r = l)
        }
      })
    if (!r) return e
  }
}
function rc(n, e, t) {
  let r = Yo(
    n.state.facet(Yf).map((i) => i(n)),
    t.from,
    e.head > t.from ? -1 : 1
  )
  return r == t.from ? t : C.cursor(r, r < t.from ? 1 : -1)
}
class Wk {
  setSelectionOrigin(e) {
    ;(this.lastSelectionOrigin = e), (this.lastSelectionTime = Date.now())
  }
  constructor(e) {
    ;(this.view = e),
      (this.lastKeyCode = 0),
      (this.lastKeyTime = 0),
      (this.lastTouchTime = 0),
      (this.lastFocusTime = 0),
      (this.lastScrollTop = 0),
      (this.lastScrollLeft = 0),
      (this.pendingIOSKey = void 0),
      (this.lastSelectionOrigin = null),
      (this.lastSelectionTime = 0),
      (this.lastEscPress = 0),
      (this.lastContextMenu = 0),
      (this.scrollHandlers = []),
      (this.handlers = Object.create(null)),
      (this.composing = -1),
      (this.compositionFirstChange = null),
      (this.compositionEndedAt = 0),
      (this.compositionPendingKey = !1),
      (this.compositionPendingChange = !1),
      (this.mouseSelection = null),
      (this.draggedContent = null),
      (this.handleEvent = this.handleEvent.bind(this)),
      (this.notifiedFocused = e.hasFocus),
      z.safari && e.contentDOM.addEventListener('input', () => null),
      z.gecko && sC(e.contentDOM.ownerDocument)
  }
  handleEvent(e) {
    !Hk(this.view, e) ||
      this.ignoreDuringComposition(e) ||
      (e.type == 'keydown' && this.keydown(e)) ||
      this.runHandlers(e.type, e)
  }
  runHandlers(e, t) {
    let r = this.handlers[e]
    if (r) {
      for (let i of r.observers) i(this.view, t)
      for (let i of r.handlers) {
        if (t.defaultPrevented) break
        if (i(this.view, t)) {
          t.preventDefault()
          break
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = Lk(e),
      r = this.handlers,
      i = this.view.contentDOM
    for (let s in t)
      if (s != 'scroll') {
        let o = !t[s].handlers.length,
          a = r[s]
        a &&
          o != !a.handlers.length &&
          (i.removeEventListener(s, this.handleEvent), (a = null)),
          a || i.addEventListener(s, this.handleEvent, { passive: o })
      }
    for (let s in r)
      s != 'scroll' && !t[s] && i.removeEventListener(s, this.handleEvent)
    this.handlers = t
  }
  keydown(e) {
    if (
      ((this.lastKeyCode = e.keyCode),
      (this.lastKeyTime = Date.now()),
      e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
    )
      return !0
    if (
      (e.keyCode != 27 &&
        By.indexOf(e.keyCode) < 0 &&
        (this.view.inputState.lastEscPress = 0),
      z.android &&
        z.chrome &&
        !e.synthetic &&
        (e.keyCode == 13 || e.keyCode == 8))
    )
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0
    let t
    return z.ios &&
      !e.synthetic &&
      !e.altKey &&
      !e.metaKey &&
      (((t = Ly.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey) ||
        (Bk.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey))
      ? ((this.pendingIOSKey = t || e),
        setTimeout(() => this.flushIOSKey(), 250),
        !0)
      : (e.keyCode != 229 && this.view.observer.forceFlush(), !1)
  }
  flushIOSKey() {
    let e = this.pendingIOSKey
    return e
      ? ((this.pendingIOSKey = void 0),
        Nr(this.view.contentDOM, e.key, e.keyCode))
      : !1
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type)
      ? this.composing > 0
        ? !0
        : z.safari &&
            !z.ios &&
            this.compositionPendingKey &&
            Date.now() - this.compositionEndedAt < 100
          ? ((this.compositionPendingKey = !1), !0)
          : !1
      : !1
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(),
      (this.mouseSelection = e)
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e),
      this.draggedContent &&
        e.docChanged &&
        (this.draggedContent = this.draggedContent.map(e.changes)),
      e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0)
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy()
  }
}
function Sd(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t)
    } catch (i) {
      _t(t.state, i)
    }
  }
}
function Lk(n) {
  let e = Object.create(null)
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] })
  }
  for (let r of n) {
    let i = r.spec
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s]
        o && t(s).handlers.push(Sd(r.value, o))
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s]
        o && t(s).observers.push(Sd(r.value, o))
      }
  }
  for (let r in Yt) t(r).handlers.push(Yt[r])
  for (let r in It) t(r).observers.push(It[r])
  return e
}
const Ly = [
    { key: 'Backspace', keyCode: 8, inputType: 'deleteContentBackward' },
    { key: 'Enter', keyCode: 13, inputType: 'insertParagraph' },
    { key: 'Enter', keyCode: 13, inputType: 'insertLineBreak' },
    { key: 'Delete', keyCode: 46, inputType: 'deleteContentForward' }
  ],
  Bk = 'dthko',
  By = [16, 17, 18, 20, 91, 92, 224, 225],
  Fs = 6
function Gs(n) {
  return Math.max(0, n) * 0.7 + 8
}
function Uk(n, e) {
  return Math.max(
    Math.abs(n.clientX - e.clientX),
    Math.abs(n.clientY - e.clientY)
  )
}
class qk {
  constructor(e, t, r, i) {
    ;(this.view = e),
      (this.startEvent = t),
      (this.style = r),
      (this.mustSelect = i),
      (this.scrollSpeed = { x: 0, y: 0 }),
      (this.scrolling = -1),
      (this.lastEvent = t),
      (this.scrollParent = ck(e.contentDOM)),
      (this.atoms = e.state.facet(Yf).map((o) => o(e)))
    let s = e.contentDOM.ownerDocument
    s.addEventListener('mousemove', (this.move = this.move.bind(this))),
      s.addEventListener('mouseup', (this.up = this.up.bind(this))),
      (this.extend = t.shiftKey),
      (this.multiple = e.state.facet(ie.allowMultipleSelections) && zk(e, t)),
      (this.dragging = Gk(e, t) && Fy(t) == 1 ? null : !1)
  }
  start(e) {
    this.dragging === !1 && this.select(e)
  }
  move(e) {
    var t
    if (e.buttons == 0) return this.destroy()
    if (this.dragging || (this.dragging == null && Uk(this.startEvent, e) < 10))
      return
    this.select((this.lastEvent = e))
    let r = 0,
      i = 0,
      s = ((t = this.scrollParent) === null || t === void 0
        ? void 0
        : t.getBoundingClientRect()) || {
        left: 0,
        top: 0,
        right: this.view.win.innerWidth,
        bottom: this.view.win.innerHeight
      },
      o = Dy(this.view)
    e.clientX - o.left <= s.left + Fs
      ? (r = -Gs(s.left - e.clientX))
      : e.clientX + o.right >= s.right - Fs && (r = Gs(e.clientX - s.right)),
      e.clientY - o.top <= s.top + Fs
        ? (i = -Gs(s.top - e.clientY))
        : e.clientY + o.bottom >= s.bottom - Fs &&
          (i = Gs(e.clientY - s.bottom)),
      this.setScrollSpeed(r, i)
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent),
      this.dragging || e.preventDefault(),
      this.destroy()
  }
  destroy() {
    this.setScrollSpeed(0, 0)
    let e = this.view.contentDOM.ownerDocument
    e.removeEventListener('mousemove', this.move),
      e.removeEventListener('mouseup', this.up),
      (this.view.inputState.mouseSelection =
        this.view.inputState.draggedContent =
          null)
  }
  setScrollSpeed(e, t) {
    ;(this.scrollSpeed = { x: e, y: t }),
      e || t
        ? this.scrolling < 0 &&
          (this.scrolling = setInterval(() => this.scroll(), 50))
        : this.scrolling > -1 &&
          (clearInterval(this.scrolling), (this.scrolling = -1))
  }
  scroll() {
    this.scrollParent
      ? ((this.scrollParent.scrollLeft += this.scrollSpeed.x),
        (this.scrollParent.scrollTop += this.scrollSpeed.y))
      : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
      this.dragging === !1 && this.select(this.lastEvent)
  }
  skipAtoms(e) {
    let t = null
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r],
        s = null
      if (i.empty) {
        let o = Yo(this.atoms, i.from, 0)
        o != i.from && (s = C.cursor(o, -1))
      } else {
        let o = Yo(this.atoms, i.from, -1),
          a = Yo(this.atoms, i.to, 1)
        ;(o != i.from || a != i.to) &&
          (s = C.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a))
      }
      s && (t || (t = e.ranges.slice()), (t[r] = s))
    }
    return t ? C.create(t, e.mainIndex) : e
  }
  select(e) {
    let { view: t } = this,
      r = this.skipAtoms(this.style.get(e, this.extend, this.multiple))
    ;(this.mustSelect ||
      !r.eq(t.state.selection) ||
      (r.main.assoc != t.state.selection.main.assoc && this.dragging === !1)) &&
      this.view.dispatch({ selection: r, userEvent: 'select.pointer' }),
      (this.mustSelect = !1)
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20)
  }
}
function zk(n, e) {
  let t = n.state.facet(Py)
  return t.length ? t[0](e) : z.mac ? e.metaKey : e.ctrlKey
}
function Fk(n, e) {
  let t = n.state.facet(Ty)
  return t.length ? t[0](e) : z.mac ? !e.altKey : !e.ctrlKey
}
function Gk(n, e) {
  let { main: t } = n.state.selection
  if (t.empty) return !1
  let r = Pa(n.root)
  if (!r || r.rangeCount == 0) return !0
  let i = r.getRangeAt(0).getClientRects()
  for (let s = 0; s < i.length; s++) {
    let o = i[s]
    if (
      o.left <= e.clientX &&
      o.right >= e.clientX &&
      o.top <= e.clientY &&
      o.bottom >= e.clientY
    )
      return !0
  }
  return !1
}
function Hk(n, e) {
  if (!e.bubbles) return !0
  if (e.defaultPrevented) return !1
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || ((r = ve.get(t)) && r.ignoreEvent(e)))
      return !1
  return !0
}
const Yt = Object.create(null),
  It = Object.create(null),
  Uy = (z.ie && z.ie_version < 15) || (z.ios && z.webkit_version < 604)
function Kk(n) {
  let e = n.dom.parentNode
  if (!e) return
  let t = e.appendChild(document.createElement('textarea'))
  ;(t.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    t.focus(),
    setTimeout(() => {
      n.focus(), t.remove(), qy(n, t.value)
    }, 50)
}
function qy(n, e) {
  let { state: t } = n,
    r,
    i = 1,
    s = t.toText(e),
    o = s.lines == t.selection.ranges.length
  if (
    Iu != null &&
    t.selection.ranges.every((l) => l.empty) &&
    Iu == s.toString()
  ) {
    let l = -1
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from)
      if (u.from == l) return { range: c }
      l = u.from
      let f = t.toText((o ? s.line(i++).text : e) + t.lineBreak)
      return {
        changes: { from: u.from, insert: f },
        range: C.cursor(c.from + f.length)
      }
    })
  } else
    o
      ? (r = t.changeByRange((l) => {
          let c = s.line(i++)
          return {
            changes: { from: l.from, to: l.to, insert: c.text },
            range: C.cursor(l.from + c.length)
          }
        }))
      : (r = t.replaceSelection(s))
  n.dispatch(r, { userEvent: 'input.paste', scrollIntoView: !0 })
}
It.scroll = (n) => {
  ;(n.inputState.lastScrollTop = n.scrollDOM.scrollTop),
    (n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft)
}
Yt.keydown = (n, e) => (
  n.inputState.setSelectionOrigin('select'),
  e.keyCode == 27 && (n.inputState.lastEscPress = Date.now()),
  !1
)
It.touchstart = (n, e) => {
  ;(n.inputState.lastTouchTime = Date.now()),
    n.inputState.setSelectionOrigin('select.pointer')
}
It.touchmove = (n) => {
  n.inputState.setSelectionOrigin('select.pointer')
}
Yt.mousedown = (n, e) => {
  if ((n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3))
    return !1
  let t = null
  for (let r of n.state.facet($y)) if (((t = r(n, e)), t)) break
  if ((!t && e.button == 0 && (t = tC(n, e)), t)) {
    let r = !n.hasFocus
    n.inputState.startMouseSelection(new qk(n, e, t, r)),
      r && n.observer.ignore(() => hy(n.contentDOM))
    let i = n.inputState.mouseSelection
    if (i) return i.start(e), i.dragging === !1
  }
  return !1
}
function xd(n, e, t, r) {
  if (r == 1) return C.cursor(e, t)
  if (r == 2) return Dk(n.state, e, t)
  {
    let i = Ze.find(n.docView, e),
      s = n.state.doc.lineAt(i ? i.posAtEnd : e),
      o = i ? i.posAtStart : s.from,
      a = i ? i.posAtEnd : s.to
    return a < n.state.doc.length && a == s.to && a++, C.range(o, a)
  }
}
let zy = (n, e) => n >= e.top && n <= e.bottom,
  wd = (n, e, t) => zy(e, t) && n >= t.left && n <= t.right
function Jk(n, e, t, r) {
  let i = Ze.find(n.docView, e)
  if (!i) return 1
  let s = e - i.posAtStart
  if (s == 0) return 1
  if (s == i.length) return -1
  let o = i.coordsAt(s, -1)
  if (o && wd(t, r, o)) return -1
  let a = i.coordsAt(s, 1)
  return a && wd(t, r, a) ? 1 : o && zy(r, o) ? -1 : 1
}
function Pd(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1)
  return { pos: t, bias: Jk(n, t, e.clientX, e.clientY) }
}
const eC = z.ie && z.ie_version <= 11
let Td = null,
  $d = 0,
  Qd = 0
function Fy(n) {
  if (!eC) return n.detail
  let e = Td,
    t = Qd
  return (
    (Td = n),
    (Qd = Date.now()),
    ($d =
      !e ||
      (t > Date.now() - 400 &&
        Math.abs(e.clientX - n.clientX) < 2 &&
        Math.abs(e.clientY - n.clientY) < 2)
        ? ($d + 1) % 3
        : 1)
  )
}
function tC(n, e) {
  let t = Pd(n, e),
    r = Fy(e),
    i = n.state.selection
  return {
    update(s) {
      s.docChanged &&
        ((t.pos = s.changes.mapPos(t.pos)), (i = i.map(s.changes)))
    },
    get(s, o, a) {
      let l = Pd(n, s),
        c,
        u = xd(n, l.pos, l.bias, r)
      if (t.pos != l.pos && !o) {
        let f = xd(n, t.pos, t.bias, r),
          p = Math.min(f.from, u.from),
          d = Math.max(f.to, u.to)
        u = p < u.from ? C.range(p, d) : C.range(d, p)
      }
      return o
        ? i.replaceRange(i.main.extend(u.from, u.to))
        : a && r == 1 && i.ranges.length > 1 && (c = nC(i, l.pos))
          ? c
          : a
            ? i.addRange(u)
            : C.create([u])
    }
  }
}
function nC(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t]
    if (r <= e && i >= e)
      return C.create(
        n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)),
        n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0)
      )
  }
  return null
}
Yt.dragstart = (n, e) => {
  let {
    selection: { main: t }
  } = n.state
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target)
    if (i && i.isWidget) {
      let s = i.posAtStart,
        o = s + i.length
      ;(s >= t.to || o <= t.from) && (t = C.range(s, o))
    }
  }
  let { inputState: r } = n
  return (
    r.mouseSelection && (r.mouseSelection.dragging = !0),
    (r.draggedContent = t),
    e.dataTransfer &&
      (e.dataTransfer.setData('Text', n.state.sliceDoc(t.from, t.to)),
      (e.dataTransfer.effectAllowed = 'copyMove')),
    !1
  )
}
Yt.dragend = (n) => ((n.inputState.draggedContent = null), !1)
function kd(n, e, t, r) {
  if (!t) return
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    { draggedContent: s } = n.inputState,
    o = r && s && Fk(n, e) ? { from: s.from, to: s.to } : null,
    a = { from: i, insert: t },
    l = n.state.changes(o ? [o, a] : a)
  n.focus(),
    n.dispatch({
      changes: l,
      selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
      userEvent: o ? 'move.drop' : 'input.drop'
    }),
    (n.inputState.draggedContent = null)
}
Yt.drop = (n, e) => {
  if (!e.dataTransfer) return !1
  if (n.state.readOnly) return !0
  let t = e.dataTransfer.files
  if (t && t.length) {
    let r = Array(t.length),
      i = 0,
      s = () => {
        ++i == t.length &&
          kd(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1)
      }
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader()
      ;(a.onerror = s),
        (a.onload = () => {
          ;/[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), s()
        }),
        a.readAsText(t[o])
    }
    return !0
  } else {
    let r = e.dataTransfer.getData('Text')
    if (r) return kd(n, e, r, !0), !0
  }
  return !1
}
Yt.paste = (n, e) => {
  if (n.state.readOnly) return !0
  n.observer.flush()
  let t = Uy ? null : e.clipboardData
  return t
    ? (qy(n, t.getData('text/plain') || t.getData('text/uri-text')), !0)
    : (Kk(n), !1)
}
function rC(n, e) {
  let t = n.dom.parentNode
  if (!t) return
  let r = t.appendChild(document.createElement('textarea'))
  ;(r.style.cssText = 'position: fixed; left: -10000px; top: 10px'),
    (r.value = e),
    r.focus(),
    (r.selectionEnd = e.length),
    (r.selectionStart = 0),
    setTimeout(() => {
      r.remove(), n.focus()
    }, 50)
}
function iC(n) {
  let e = [],
    t = [],
    r = !1
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i))
  if (!e.length) {
    let i = -1
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s)
      o.number > i &&
        (e.push(o.text),
        t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })),
        (i = o.number)
    }
    r = !0
  }
  return { text: e.join(n.lineBreak), ranges: t, linewise: r }
}
let Iu = null
Yt.copy = Yt.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = iC(n.state)
  if (!t && !i) return !1
  ;(Iu = i ? t : null),
    e.type == 'cut' &&
      !n.state.readOnly &&
      n.dispatch({ changes: r, scrollIntoView: !0, userEvent: 'delete.cut' })
  let s = Uy ? null : e.clipboardData
  return s ? (s.clearData(), s.setData('text/plain', t), !0) : (rC(n, t), !1)
}
const Gy = sn.define()
function Hy(n, e) {
  let t = []
  for (let r of n.facet(Cy)) {
    let i = r(n, e)
    i && t.push(i)
  }
  return t ? n.update({ effects: t, annotations: Gy.of(!0) }) : null
}
function Ky(n) {
  setTimeout(() => {
    let e = n.hasFocus
    if (e != n.inputState.notifiedFocused) {
      let t = Hy(n.state, e)
      t ? n.dispatch(t) : n.update([])
    }
  }, 10)
}
It.focus = (n) => {
  ;(n.inputState.lastFocusTime = Date.now()),
    !n.scrollDOM.scrollTop &&
      (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) &&
      ((n.scrollDOM.scrollTop = n.inputState.lastScrollTop),
      (n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft)),
    Ky(n)
}
It.blur = (n) => {
  n.observer.clearSelectionRange(), Ky(n)
}
It.compositionstart = It.compositionupdate = (n) => {
  n.inputState.compositionFirstChange == null &&
    (n.inputState.compositionFirstChange = !0),
    n.inputState.composing < 0 && (n.inputState.composing = 0)
}
It.compositionend = (n) => {
  ;(n.inputState.composing = -1),
    (n.inputState.compositionEndedAt = Date.now()),
    (n.inputState.compositionPendingKey = !0),
    (n.inputState.compositionPendingChange =
      n.observer.pendingRecords().length > 0),
    (n.inputState.compositionFirstChange = null),
    z.chrome && z.android
      ? n.observer.flushSoon()
      : n.inputState.compositionPendingChange
        ? Promise.resolve().then(() => n.observer.flush())
        : setTimeout(() => {
            n.inputState.composing < 0 &&
              n.docView.hasComposition &&
              n.update([])
          }, 50)
}
It.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now()
}
Yt.beforeinput = (n, e) => {
  var t
  let r
  if (
    z.chrome &&
    z.android &&
    (r = Ly.find((i) => i.inputType == e.inputType)) &&
    (n.observer.delayAndroidKey(r.key, r.keyCode),
    r.key == 'Backspace' || r.key == 'Delete')
  ) {
    let i =
      ((t = window.visualViewport) === null || t === void 0
        ? void 0
        : t.height) || 0
    setTimeout(() => {
      var s
      ;(((s = window.visualViewport) === null || s === void 0
        ? void 0
        : s.height) || 0) >
        i + 10 &&
        n.hasFocus &&
        (n.contentDOM.blur(), n.focus())
    }, 100)
  }
  return !1
}
const Cd = new Set()
function sC(n) {
  Cd.has(n) ||
    (Cd.add(n),
    n.addEventListener('copy', () => {}),
    n.addEventListener('cut', () => {}))
}
const _d = ['pre-wrap', 'normal', 'pre-line', 'break-spaces']
class oC {
  constructor(e) {
    ;(this.lineWrapping = e),
      (this.doc = le.empty),
      (this.heightSamples = {}),
      (this.lineHeight = 14),
      (this.charWidth = 7),
      (this.textHeight = 14),
      (this.lineLength = 30),
      (this.heightChanged = !1)
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1
    return (
      this.lineWrapping &&
        (r += Math.max(
          0,
          Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength)
        )),
      this.lineHeight * r
    )
  }
  heightForLine(e) {
    return this.lineWrapping
      ? (1 +
          Math.max(
            0,
            Math.ceil((e - this.lineLength) / (this.lineLength - 5))
          )) *
          this.lineHeight
      : this.lineHeight
  }
  setDoc(e) {
    return (this.doc = e), this
  }
  mustRefreshForWrapping(e) {
    return _d.indexOf(e) > -1 != this.lineWrapping
  }
  mustRefreshForHeights(e) {
    let t = !1
    for (let r = 0; r < e.length; r++) {
      let i = e[r]
      i < 0
        ? r++
        : this.heightSamples[Math.floor(i * 10)] ||
          ((t = !0), (this.heightSamples[Math.floor(i * 10)] = !0))
    }
    return t
  }
  refresh(e, t, r, i, s, o) {
    let a = _d.indexOf(e) > -1,
      l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a
    if (
      ((this.lineWrapping = a),
      (this.lineHeight = t),
      (this.charWidth = r),
      (this.textHeight = i),
      (this.lineLength = s),
      l)
    ) {
      this.heightSamples = {}
      for (let c = 0; c < o.length; c++) {
        let u = o[c]
        u < 0 ? c++ : (this.heightSamples[Math.floor(u * 10)] = !0)
      }
    }
    return l
  }
}
class aC {
  constructor(e, t) {
    ;(this.from = e), (this.heights = t), (this.index = 0)
  }
  get more() {
    return this.index < this.heights.length
  }
}
class Ht {
  constructor(e, t, r, i, s) {
    ;(this.from = e),
      (this.length = t),
      (this.top = r),
      (this.height = i),
      (this._content = s)
  }
  get type() {
    return typeof this._content == 'number'
      ? nt.Text
      : Array.isArray(this._content)
        ? this._content
        : this._content.type
  }
  get to() {
    return this.from + this.length
  }
  get bottom() {
    return this.top + this.height
  }
  get widget() {
    return this._content instanceof Un ? this._content.widget : null
  }
  get widgetLineBreaks() {
    return typeof this._content == 'number' ? this._content : 0
  }
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(
      Array.isArray(e._content) ? e._content : [e]
    )
    return new Ht(
      this.from,
      this.length + e.length,
      this.top,
      this.height + e.height,
      t
    )
  }
}
var be = (function (n) {
  return (
    (n[(n.ByPos = 0)] = 'ByPos'),
    (n[(n.ByHeight = 1)] = 'ByHeight'),
    (n[(n.ByPosNoHeight = 2)] = 'ByPosNoHeight'),
    n
  )
})(be || (be = {}))
const Io = 0.001
class rt {
  constructor(e, t, r = 2) {
    ;(this.length = e), (this.height = t), (this.flags = r)
  }
  get outdated() {
    return (this.flags & 2) > 0
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | (this.flags & -3)
  }
  setHeight(e, t) {
    this.height != t &&
      (Math.abs(this.height - t) > Io && (e.heightChanged = !0),
      (this.height = t))
  }
  replace(e, t, r) {
    return rt.of(r)
  }
  decomposeLeft(e, t) {
    t.push(this)
  }
  decomposeRight(e, t) {
    t.push(this)
  }
  applyChanges(e, t, r, i) {
    let s = this,
      o = r.doc
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: f } = i[a],
        p = s.lineAt(l, be.ByPosNoHeight, r.setDoc(t), 0, 0),
        d = p.to >= c ? p : s.lineAt(c, be.ByPosNoHeight, r, 0, 0)
      for (f += d.to - c, c = d.to; a > 0 && p.from <= i[a - 1].toA; )
        (l = i[a - 1].fromA),
          (u = i[a - 1].fromB),
          a--,
          l < p.from && (p = s.lineAt(l, be.ByPosNoHeight, r, 0, 0))
      ;(u += p.from - l), (l = p.from)
      let O = If.build(r.setDoc(o), e, u, f)
      s = s.replace(l, c, O)
    }
    return s.updateHeight(r, 0)
  }
  static empty() {
    return new Ot(0, 0)
  }
  static of(e) {
    if (e.length == 1) return e[0]
    let t = 0,
      r = e.length,
      i = 0,
      s = 0
    for (;;)
      if (t == r)
        if (i > s * 2) {
          let a = e[t - 1]
          a.break
            ? e.splice(--t, 1, a.left, null, a.right)
            : e.splice(--t, 1, a.left, a.right),
            (r += 1 + a.break),
            (i -= a.size)
        } else if (s > i * 2) {
          let a = e[r]
          a.break
            ? e.splice(r, 1, a.left, null, a.right)
            : e.splice(r, 1, a.left, a.right),
            (r += 2 + a.break),
            (s -= a.size)
        } else break
      else if (i < s) {
        let a = e[t++]
        a && (i += a.size)
      } else {
        let a = e[--r]
        a && (s += a.size)
      }
    let o = 0
    return (
      e[t - 1] == null ? ((o = 1), t--) : e[t] == null && ((o = 1), r++),
      new lC(rt.of(e.slice(0, t)), o, rt.of(e.slice(r)))
    )
  }
}
rt.prototype.size = 1
class Jy extends rt {
  constructor(e, t, r) {
    super(e, t), (this.deco = r)
  }
  blockAt(e, t, r, i) {
    return new Ht(i, this.length, r, this.height, this.deco || 0)
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s)
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s))
  }
  updateHeight(e, t = 0, r = !1, i) {
    return (
      i && i.from <= t && i.more && this.setHeight(e, i.heights[i.index++]),
      (this.outdated = !1),
      this
    )
  }
  toString() {
    return `block(${this.length})`
  }
}
class Ot extends Jy {
  constructor(e, t) {
    super(e, t, null),
      (this.collapsed = 0),
      (this.widgetHeight = 0),
      (this.breaks = 0)
  }
  blockAt(e, t, r, i) {
    return new Ht(i, this.length, r, this.height, this.breaks)
  }
  replace(e, t, r) {
    let i = r[0]
    return r.length == 1 &&
      (i instanceof Ot || (i instanceof We && i.flags & 4)) &&
      Math.abs(this.length - i.length) < 10
      ? (i instanceof We
          ? (i = new Ot(i.length, this.height))
          : (i.height = this.height),
        this.outdated || (i.outdated = !1),
        i)
      : rt.of(r)
  }
  updateHeight(e, t = 0, r = !1, i) {
    return (
      i && i.from <= t && i.more
        ? this.setHeight(e, i.heights[i.index++])
        : (r || this.outdated) &&
          this.setHeight(
            e,
            Math.max(
              this.widgetHeight,
              e.heightForLine(this.length - this.collapsed)
            ) +
              this.breaks * e.lineHeight
          ),
      (this.outdated = !1),
      this
    )
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ''}${
      this.widgetHeight ? ':' + this.widgetHeight : ''
    })`
  }
}
class We extends rt {
  constructor(e) {
    super(e, 0)
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number,
      i = e.doc.lineAt(t + this.length).number,
      s = i - r + 1,
      o,
      a = 0
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s)
      ;(o = l / s),
        this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1))
    } else o = this.height / s
    return { firstLine: r, lastLine: i, perLine: o, perChar: a }
  }
  blockAt(e, t, r, i) {
    let {
      firstLine: s,
      lastLine: o,
      perLine: a,
      perChar: l
    } = this.heightMetrics(t, i)
    if (t.lineWrapping) {
      let c =
          i +
          Math.round(
            Math.max(0, Math.min(1, (e - r) / this.height)) * this.length
          ),
        u = t.doc.lineAt(c),
        f = a + u.length * l,
        p = Math.max(r, e - f / 2)
      return new Ht(u.from, u.length, p, f, 0)
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / a))),
        { from: u, length: f } = t.doc.line(s + c)
      return new Ht(u, f, r + a * c, a, 0)
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == be.ByHeight) return this.blockAt(e, r, i, s)
    if (t == be.ByPosNoHeight) {
      let { from: d, to: O } = r.doc.lineAt(e)
      return new Ht(d, O - d, 0, 0, 0)
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, s),
      c = r.doc.lineAt(e),
      u = a + c.length * l,
      f = c.number - o,
      p = i + a * f + l * (c.from - s - f)
    return new Ht(
      c.from,
      c.length,
      Math.max(i, Math.min(p, i + this.height - u)),
      u,
      0
    )
  }
  forEachLine(e, t, r, i, s, o) {
    ;(e = Math.max(e, s)), (t = Math.min(t, s + this.length))
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, s)
    for (let u = e, f = i; u <= t; ) {
      let p = r.doc.lineAt(u)
      if (u == e) {
        let O = p.number - a
        f += l * O + c * (e - s - O)
      }
      let d = l + c * p.length
      o(new Ht(p.from, p.length, f, d, 0)), (f += d), (u = p.to + 1)
    }
  }
  replace(e, t, r) {
    let i = this.length - t
    if (i > 0) {
      let s = r[r.length - 1]
      s instanceof We
        ? (r[r.length - 1] = new We(s.length + i))
        : r.push(null, new We(i - 1))
    }
    if (e > 0) {
      let s = r[0]
      s instanceof We
        ? (r[0] = new We(e + s.length))
        : r.unshift(new We(e - 1), null)
    }
    return rt.of(r)
  }
  decomposeLeft(e, t) {
    t.push(new We(e - 1), null)
  }
  decomposeRight(e, t) {
    t.push(null, new We(this.length - e - 1))
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length
    if (i && i.from <= t + this.length && i.more) {
      let o = [],
        a = Math.max(t, i.from),
        l = -1
      for (
        i.from > t && o.push(new We(i.from - t - 1).updateHeight(e, t));
        a <= s && i.more;

      ) {
        let u = e.doc.lineAt(a).length
        o.length && o.push(null)
        let f = i.heights[i.index++]
        l == -1 ? (l = f) : Math.abs(f - l) >= Io && (l = -2)
        let p = new Ot(u, f)
        ;(p.outdated = !1), o.push(p), (a += u + 1)
      }
      a <= s && o.push(null, new We(s - a).updateHeight(e, a))
      let c = rt.of(o)
      return (
        (l < 0 ||
          Math.abs(c.height - this.height) >= Io ||
          Math.abs(l - this.heightMetrics(e, t).perLine) >= Io) &&
          (e.heightChanged = !0),
        c
      )
    } else
      (r || this.outdated) &&
        (this.setHeight(e, e.heightForGap(t, t + this.length)),
        (this.outdated = !1))
    return this
  }
  toString() {
    return `gap(${this.length})`
  }
}
class lC extends rt {
  constructor(e, t, r) {
    super(
      e.length + t + r.length,
      e.height + r.height,
      t | (e.outdated || r.outdated ? 2 : 0)
    ),
      (this.left = e),
      (this.right = r),
      (this.size = e.size + r.size)
  }
  get break() {
    return this.flags & 1
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height
    return e < s
      ? this.left.blockAt(e, t, r, i)
      : this.right.blockAt(e, t, s, i + this.left.length + this.break)
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height,
      a = s + this.left.length + this.break,
      l = t == be.ByHeight ? e < o : e < a,
      c = l ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, a)
    if (this.break || (l ? c.to < a : c.from > a)) return c
    let u = t == be.ByPosNoHeight ? be.ByPosNoHeight : be.ByPos
    return l
      ? c.join(this.right.lineAt(a, u, r, o, a))
      : this.left.lineAt(a, u, r, i, s).join(c)
  }
  forEachLine(e, t, r, i, s, o) {
    let a = i + this.left.height,
      l = s + this.left.length + this.break
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, i, s, o),
        t >= l && this.right.forEachLine(e, t, r, a, l, o)
    else {
      let c = this.lineAt(l, be.ByPos, r, i, s)
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o),
        c.to >= e && c.from <= t && o(c),
        t > c.to && this.right.forEachLine(c.to + 1, t, r, a, l, o)
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break
    if (t < i) return this.balanced(this.left.replace(e, t, r), this.right)
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r))
    let s = []
    e > 0 && this.decomposeLeft(e, s)
    let o = s.length
    for (let a of r) s.push(a)
    if ((e > 0 && Rd(s, o - 1), t < this.length)) {
      let a = s.length
      this.decomposeRight(t, s), Rd(s, a)
    }
    return rt.of(s)
  }
  decomposeLeft(e, t) {
    let r = this.left.length
    if (e <= r) return this.left.decomposeLeft(e, t)
    t.push(this.left),
      this.break && (r++, e >= r && t.push(null)),
      e > r && this.right.decomposeLeft(e - r, t)
  }
  decomposeRight(e, t) {
    let r = this.left.length,
      i = r + this.break
    if (e >= i) return this.right.decomposeRight(e - i, t)
    e < r && this.left.decomposeRight(e, t),
      this.break && e < i && t.push(null),
      t.push(this.right)
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size
      ? rt.of(this.break ? [e, null, t] : [e, t])
      : ((this.left = e),
        (this.right = t),
        (this.height = e.height + t.height),
        (this.outdated = e.outdated || t.outdated),
        (this.size = e.size + t.size),
        (this.length = e.length + this.break + t.length),
        this)
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this,
      a = t + s.length + this.break,
      l = null
    return (
      i && i.from <= t + s.length && i.more
        ? (l = s = s.updateHeight(e, t, r, i))
        : s.updateHeight(e, t, r),
      i && i.from <= a + o.length && i.more
        ? (l = o = o.updateHeight(e, a, r, i))
        : o.updateHeight(e, a, r),
      l
        ? this.balanced(s, o)
        : ((this.height = this.left.height + this.right.height),
          (this.outdated = !1),
          this)
    )
  }
  toString() {
    return this.left + (this.break ? ' ' : '-') + this.right
  }
}
function Rd(n, e) {
  let t, r
  n[e] == null &&
    (t = n[e - 1]) instanceof We &&
    (r = n[e + 1]) instanceof We &&
    n.splice(e - 1, 3, new We(t.length + 1 + r.length))
}
const cC = 5
class If {
  constructor(e, t) {
    ;(this.pos = e),
      (this.oracle = t),
      (this.nodes = []),
      (this.lineStart = -1),
      (this.lineEnd = -1),
      (this.covering = null),
      (this.writtenTo = e)
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd),
        i = this.nodes[this.nodes.length - 1]
      i instanceof Ot
        ? (i.length += r - this.pos)
        : (r > this.pos || !this.isCovered) &&
          this.nodes.push(new Ot(r - this.pos, -1)),
        (this.writtenTo = r),
        t > r &&
          (this.nodes.push(null), this.writtenTo++, (this.lineStart = -1))
    }
    this.pos = t
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0,
        s = r.widget ? r.widget.lineBreaks : 0
      i < 0 && (i = this.oracle.lineHeight)
      let o = t - e
      r.block
        ? this.addBlock(new Jy(o, i, r))
        : (o || s || i >= cC) && this.addLineDeco(i, s, o)
    } else t > e && this.span(e, t)
    this.lineEnd > -1 &&
      this.lineEnd < this.pos &&
      (this.lineEnd = this.oracle.doc.lineAt(this.pos).to)
  }
  enterLine() {
    if (this.lineStart > -1) return
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos)
    ;(this.lineStart = e),
      (this.lineEnd = t),
      this.writtenTo < e &&
        ((this.writtenTo < e - 1 ||
          this.nodes[this.nodes.length - 1] == null) &&
          this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
        this.nodes.push(null)),
      this.pos > e && this.nodes.push(new Ot(this.pos - e, -1)),
      (this.writtenTo = this.pos)
  }
  blankContent(e, t) {
    let r = new We(t - e)
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r
  }
  ensureLine() {
    this.enterLine()
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null
    if (e instanceof Ot) return e
    let t = new Ot(0, -1)
    return this.nodes.push(t), t
  }
  addBlock(e) {
    this.enterLine()
    let t = e.deco
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(),
      this.nodes.push(e),
      (this.writtenTo = this.pos = this.pos + e.length),
      t && t.endSide > 0 && (this.covering = e)
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine()
    ;(i.length += r),
      (i.collapsed += r),
      (i.widgetHeight = Math.max(i.widgetHeight, e)),
      (i.breaks += t),
      (this.writtenTo = this.pos = this.pos + r)
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1]
    this.lineStart > -1 && !(t instanceof Ot) && !this.isCovered
      ? this.nodes.push(new Ot(0, -1))
      : (this.writtenTo < this.pos || t == null) &&
        this.nodes.push(this.blankContent(this.writtenTo, this.pos))
    let r = e
    for (let i of this.nodes)
      i instanceof Ot && i.updateHeight(this.oracle, r), (r += i ? i.length : 1)
    return this.nodes
  }
  static build(e, t, r, i) {
    let s = new If(r, e)
    return ce.spans(t, r, i, s, 0), s.finish(r)
  }
}
function uC(n, e, t) {
  let r = new fC()
  return ce.compare(n, e, t, r, 0), r.changes
}
class fC {
  constructor() {
    this.changes = []
  }
  compareRange() {}
  comparePoint(e, t, r, i) {
    ;(e < t || (r && r.heightRelevant) || (i && i.heightRelevant)) &&
      Ru(e, t, this.changes, 5)
  }
}
function hC(n, e) {
  let t = n.getBoundingClientRect(),
    r = n.ownerDocument,
    i = r.defaultView || window,
    s = Math.max(0, t.left),
    o = Math.min(i.innerWidth, t.right),
    a = Math.max(0, t.top),
    l = Math.min(i.innerHeight, t.bottom)
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c,
        f = window.getComputedStyle(u)
      if (
        (u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) &&
        f.overflow != 'visible'
      ) {
        let p = u.getBoundingClientRect()
        ;(s = Math.max(s, p.left)),
          (o = Math.min(o, p.right)),
          (a = Math.max(a, p.top)),
          (l = c == n.parentNode ? p.bottom : Math.min(l, p.bottom))
      }
      c =
        f.position == 'absolute' || f.position == 'fixed'
          ? u.offsetParent
          : u.parentNode
    } else if (c.nodeType == 11) c = c.host
    else break
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  }
}
function pC(n, e) {
  let t = n.getBoundingClientRect()
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  }
}
class ic {
  constructor(e, t, r) {
    ;(this.from = e), (this.to = t), (this.size = r)
  }
  static same(e, t) {
    if (e.length != t.length) return !1
    for (let r = 0; r < e.length; r++) {
      let i = e[r],
        s = t[r]
      if (i.from != s.from || i.to != s.to || i.size != s.size) return !1
    }
    return !0
  }
  draw(e, t) {
    return G.replace({
      widget: new dC(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to)
  }
}
class dC extends an {
  constructor(e, t) {
    super(), (this.size = e), (this.vertical = t)
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical
  }
  toDOM() {
    let e = document.createElement('div')
    return (
      this.vertical
        ? (e.style.height = this.size + 'px')
        : ((e.style.width = this.size + 'px'),
          (e.style.height = '2px'),
          (e.style.display = 'inline-block')),
      e
    )
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1
  }
}
class Zd {
  constructor(e) {
    ;(this.state = e),
      (this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
      }),
      (this.inView = !0),
      (this.paddingTop = 0),
      (this.paddingBottom = 0),
      (this.contentDOMWidth = 0),
      (this.contentDOMHeight = 0),
      (this.editorHeight = 0),
      (this.editorWidth = 0),
      (this.scrollTop = 0),
      (this.scrolledToBottom = !0),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.scrollAnchorPos = 0),
      (this.scrollAnchorHeight = -1),
      (this.scaler = Ad),
      (this.scrollTarget = null),
      (this.printing = !1),
      (this.mustMeasureContent = !0),
      (this.defaultTextDirection = we.LTR),
      (this.visibleRanges = []),
      (this.mustEnforceCursorAssoc = !1)
    let t = e
      .facet(Xf)
      .some((r) => typeof r != 'function' && r.class == 'cm-lineWrapping')
    ;(this.heightOracle = new oC(t)),
      (this.stateDeco = e.facet(Ji).filter((r) => typeof r != 'function')),
      (this.heightMap = rt
        .empty()
        .applyChanges(
          this.stateDeco,
          le.empty,
          this.heightOracle.setDoc(e.doc),
          [new Rt(0, 0, 0, e.doc.length)]
        )),
      (this.viewport = this.getViewport(0, null)),
      this.updateViewportLines(),
      this.updateForViewport(),
      (this.lineGaps = this.ensureLineGaps([])),
      (this.lineGapDeco = G.set(this.lineGaps.map((r) => r.draw(this, !1)))),
      this.computeVisibleRanges()
  }
  updateForViewport() {
    let e = [this.viewport],
      { main: t } = this.state.selection
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i)
        e.push(new Hs(s, o))
      }
    }
    ;(this.viewports = e.sort((r, i) => r.from - i.from)),
      (this.scaler =
        this.heightMap.height <= 7e6
          ? Ad
          : new gC(this.heightOracle, this.heightMap, this.viewports))
  }
  updateViewportLines() {
    ;(this.viewportLines = []),
      this.heightMap.forEachLine(
        this.viewport.from,
        this.viewport.to,
        this.heightOracle.setDoc(this.state.doc),
        0,
        0,
        (e) => {
          this.viewportLines.push(
            this.scaler.scale == 1 ? e : Ii(e, this.scaler)
          )
        }
      )
  }
  update(e, t = null) {
    this.state = e.state
    let r = this.stateDeco
    this.stateDeco = this.state.facet(Ji).filter((u) => typeof u != 'function')
    let i = e.changedRanges,
      s = Rt.extendWithRanges(
        i,
        uC(r, this.stateDeco, e ? e.changes : Ae.empty(this.state.doc.length))
      ),
      o = this.heightMap.height,
      a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop)
    ;(this.heightMap = this.heightMap.applyChanges(
      this.stateDeco,
      e.startState.doc,
      this.heightOracle.setDoc(this.state.doc),
      s
    )),
      this.heightMap.height != o && (e.flags |= 2),
      a
        ? ((this.scrollAnchorPos = e.changes.mapPos(a.from, -1)),
          (this.scrollAnchorHeight = a.top))
        : ((this.scrollAnchorPos = -1),
          (this.scrollAnchorHeight = this.heightMap.height))
    let l = s.length
      ? this.mapViewport(this.viewport, e.changes)
      : this.viewport
    ;((t && (t.range.head < l.from || t.range.head > l.to)) ||
      !this.viewportIsAppropriate(l)) &&
      (l = this.getViewport(0, t))
    let c =
      !e.changes.empty ||
      e.flags & 2 ||
      l.from != this.viewport.from ||
      l.to != this.viewport.to
    ;(this.viewport = l),
      this.updateForViewport(),
      c && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(
          this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))
        ),
      (e.flags |= this.computeVisibleRanges()),
      t && (this.scrollTarget = t),
      !this.mustEnforceCursorAssoc &&
        e.selectionSet &&
        e.view.lineWrapping &&
        e.state.selection.main.empty &&
        e.state.selection.main.assoc &&
        !e.state.facet(Ry) &&
        (this.mustEnforceCursorAssoc = !0)
  }
  measure(e) {
    let t = e.contentDOM,
      r = window.getComputedStyle(t),
      i = this.heightOracle,
      s = r.whiteSpace
    this.defaultTextDirection = r.direction == 'rtl' ? we.RTL : we.LTR
    let o = this.heightOracle.mustRefreshForWrapping(s),
      a = t.getBoundingClientRect(),
      l = o || this.mustMeasureContent || this.contentDOMHeight != a.height
    ;(this.contentDOMHeight = a.height), (this.mustMeasureContent = !1)
    let c = 0,
      u = 0
    if (a.width && a.height) {
      let T = a.width / t.offsetWidth,
        P = a.height / t.offsetHeight
      ;((T > 0.995 && T < 1.005) ||
        !isFinite(T) ||
        Math.abs(a.width - t.offsetWidth) < 1) &&
        (T = 1),
        ((P > 0.995 && P < 1.005) ||
          !isFinite(P) ||
          Math.abs(a.height - t.offsetHeight) < 1) &&
          (P = 1),
        (this.scaleX != T || this.scaleY != P) &&
          ((this.scaleX = T), (this.scaleY = P), (c |= 8), (o = l = !0))
    }
    let f = (parseInt(r.paddingTop) || 0) * this.scaleY,
      p = (parseInt(r.paddingBottom) || 0) * this.scaleY
    ;(this.paddingTop != f || this.paddingBottom != p) &&
      ((this.paddingTop = f), (this.paddingBottom = p), (c |= 10)),
      this.editorWidth != e.scrollDOM.clientWidth &&
        (i.lineWrapping && (l = !0),
        (this.editorWidth = e.scrollDOM.clientWidth),
        (c |= 8))
    let d = e.scrollDOM.scrollTop * this.scaleY
    this.scrollTop != d &&
      ((this.scrollAnchorHeight = -1), (this.scrollTop = d)),
      (this.scrolledToBottom = dy(e.scrollDOM))
    let O = (this.printing ? pC : hC)(t, this.paddingTop),
      g = O.top - this.pixelViewport.top,
      b = O.bottom - this.pixelViewport.bottom
    this.pixelViewport = O
    let x =
      this.pixelViewport.bottom > this.pixelViewport.top &&
      this.pixelViewport.right > this.pixelViewport.left
    if (
      (x != this.inView && ((this.inView = x), x && (l = !0)),
      !this.inView && !this.scrollTarget)
    )
      return 0
    let w = a.width
    if (
      ((this.contentDOMWidth != w ||
        this.editorHeight != e.scrollDOM.clientHeight) &&
        ((this.contentDOMWidth = a.width),
        (this.editorHeight = e.scrollDOM.clientHeight),
        (c |= 8)),
      l)
    ) {
      let T = e.docView.measureVisibleLineHeights(this.viewport)
      if (
        (i.mustRefreshForHeights(T) && (o = !0),
        o ||
          (i.lineWrapping && Math.abs(w - this.contentDOMWidth) > i.charWidth))
      ) {
        let {
          lineHeight: P,
          charWidth: k,
          textHeight: R
        } = e.docView.measureTextSize()
        ;(o = P > 0 && i.refresh(s, P, k, R, w / k, T)),
          o && ((e.docView.minWidth = 0), (c |= 8))
      }
      g > 0 && b > 0
        ? (u = Math.max(g, b))
        : g < 0 && b < 0 && (u = Math.min(g, b)),
        (i.heightChanged = !1)
      for (let P of this.viewports) {
        let k =
          P.from == this.viewport.from
            ? T
            : e.docView.measureVisibleLineHeights(P)
        this.heightMap = (
          o
            ? rt
                .empty()
                .applyChanges(this.stateDeco, le.empty, this.heightOracle, [
                  new Rt(0, 0, 0, e.state.doc.length)
                ])
            : this.heightMap
        ).updateHeight(i, 0, o, new aC(P.from, k))
      }
      i.heightChanged && (c |= 2)
    }
    let Q =
      !this.viewportIsAppropriate(this.viewport, u) ||
      (this.scrollTarget &&
        (this.scrollTarget.range.head < this.viewport.from ||
          this.scrollTarget.range.head > this.viewport.to))
    return (
      Q && (this.viewport = this.getViewport(u, this.scrollTarget)),
      this.updateForViewport(),
      (c & 2 || Q) && this.updateViewportLines(),
      (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) &&
        this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)),
      (c |= this.computeVisibleRanges()),
      this.mustEnforceCursorAssoc &&
        ((this.mustEnforceCursorAssoc = !1), e.docView.enforceCursorAssoc()),
      c
    )
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top)
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom)
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)),
      i = this.heightMap,
      s = this.heightOracle,
      { visibleTop: o, visibleBottom: a } = this,
      l = new Hs(
        i.lineAt(o - r * 1e3, be.ByHeight, s, 0, 0).from,
        i.lineAt(a + (1 - r) * 1e3, be.ByHeight, s, 0, 0).to
      )
    if (t) {
      let { head: c } = t.range
      if (c < l.from || c > l.to) {
        let u = Math.min(
            this.editorHeight,
            this.pixelViewport.bottom - this.pixelViewport.top
          ),
          f = i.lineAt(c, be.ByPos, s, 0, 0),
          p
        t.y == 'center'
          ? (p = (f.top + f.bottom) / 2 - u / 2)
          : t.y == 'start' || (t.y == 'nearest' && c < l.from)
            ? (p = f.top)
            : (p = f.bottom - u),
          (l = new Hs(
            i.lineAt(p - 1e3 / 2, be.ByHeight, s, 0, 0).from,
            i.lineAt(p + u + 1e3 / 2, be.ByHeight, s, 0, 0).to
          ))
      }
    }
    return l
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1),
      i = t.mapPos(e.to, 1)
    return new Hs(
      this.heightMap.lineAt(r, be.ByPos, this.heightOracle, 0, 0).from,
      this.heightMap.lineAt(i, be.ByPos, this.heightOracle, 0, 0).to
    )
  }
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView) return !0
    let { top: i } = this.heightMap.lineAt(
        e,
        be.ByPos,
        this.heightOracle,
        0,
        0
      ),
      { bottom: s } = this.heightMap.lineAt(
        t,
        be.ByPos,
        this.heightOracle,
        0,
        0
      ),
      { visibleTop: o, visibleBottom: a } = this
    return (
      (e == 0 || i <= o - Math.max(10, Math.min(-r, 250))) &&
      (t == this.state.doc.length || s >= a + Math.max(10, Math.min(r, 250))) &&
      i > o - 2 * 1e3 &&
      s < a + 2 * 1e3
    )
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty) return e
    let r = []
    for (let i of e)
      t.touchesRange(i.from, i.to) ||
        r.push(new ic(t.mapPos(i.from), t.mapPos(i.to), i.size))
    return r
  }
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping,
      i = r ? 1e4 : 2e3,
      s = i >> 1,
      o = i << 1
    if (this.defaultTextDirection != we.LTR && !r) return []
    let a = [],
      l = (c, u, f, p) => {
        if (u - c < s) return
        let d = this.state.selection.main,
          O = [d.from]
        d.empty || O.push(d.to)
        for (let b of O)
          if (b > c && b < u) {
            l(c, b - 10, f, p), l(b + 10, u, f, p)
            return
          }
        let g = mC(
          e,
          (b) =>
            b.from >= f.from &&
            b.to <= f.to &&
            Math.abs(b.from - c) < s &&
            Math.abs(b.to - u) < s &&
            !O.some((x) => b.from < x && b.to > x)
        )
        if (!g) {
          if (
            u < f.to &&
            t &&
            r &&
            t.visibleRanges.some((b) => b.from <= u && b.to >= u)
          ) {
            let b = t.moveToLineBoundary(C.cursor(u), !1, !0).head
            b > c && (u = b)
          }
          g = new ic(c, u, this.gapSize(f, c, u, p))
        }
        a.push(g)
      }
    for (let c of this.viewportLines) {
      if (c.length < o) continue
      let u = OC(c.from, c.to, this.stateDeco)
      if (u.total < o) continue
      let f = this.scrollTarget ? this.scrollTarget.range.head : null,
        p,
        d
      if (r) {
        let O =
            (i / this.heightOracle.lineLength) * this.heightOracle.lineHeight,
          g,
          b
        if (f != null) {
          let x = Js(u, f),
            w = ((this.visibleBottom - this.visibleTop) / 2 + O) / c.height
          ;(g = x - w), (b = x + w)
        } else
          (g = (this.visibleTop - c.top - O) / c.height),
            (b = (this.visibleBottom - c.top + O) / c.height)
        ;(p = Ks(u, g)), (d = Ks(u, b))
      } else {
        let O = u.total * this.heightOracle.charWidth,
          g = i * this.heightOracle.charWidth,
          b,
          x
        if (f != null) {
          let w = Js(u, f),
            Q =
              ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / O
          ;(b = w - Q), (x = w + Q)
        } else
          (b = (this.pixelViewport.left - g) / O),
            (x = (this.pixelViewport.right + g) / O)
        ;(p = Ks(u, b)), (d = Ks(u, x))
      }
      p > c.from && l(c.from, p, c, u), d < c.to && l(d, c.to, c, u)
    }
    return a
  }
  gapSize(e, t, r, i) {
    let s = Js(i, r) - Js(i, t)
    return this.heightOracle.lineWrapping
      ? e.height * s
      : i.total * this.heightOracle.charWidth * s
  }
  updateLineGaps(e) {
    ic.same(e, this.lineGaps) ||
      ((this.lineGaps = e),
      (this.lineGapDeco = G.set(
        e.map((t) => t.draw(this, this.heightOracle.lineWrapping))
      )))
  }
  computeVisibleRanges() {
    let e = this.stateDeco
    this.lineGaps.length && (e = e.concat(this.lineGapDeco))
    let t = []
    ce.spans(
      e,
      this.viewport.from,
      this.viewport.to,
      {
        span(i, s) {
          t.push({ from: i, to: s })
        },
        point() {}
      },
      20
    )
    let r =
      t.length != this.visibleRanges.length ||
      this.visibleRanges.some((i, s) => i.from != t[s].from || i.to != t[s].to)
    return (this.visibleRanges = t), r ? 4 : 0
  }
  lineBlockAt(e) {
    return (
      (e >= this.viewport.from &&
        e <= this.viewport.to &&
        this.viewportLines.find((t) => t.from <= e && t.to >= e)) ||
      Ii(
        this.heightMap.lineAt(e, be.ByPos, this.heightOracle, 0, 0),
        this.scaler
      )
    )
  }
  lineBlockAtHeight(e) {
    return Ii(
      this.heightMap.lineAt(
        this.scaler.fromDOM(e),
        be.ByHeight,
        this.heightOracle,
        0,
        0
      ),
      this.scaler
    )
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8)
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200
      ? t
      : this.viewportLines[0]
  }
  elementAtHeight(e) {
    return Ii(
      this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0),
      this.scaler
    )
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height)
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom
  }
}
class Hs {
  constructor(e, t) {
    ;(this.from = e), (this.to = t)
  }
}
function OC(n, e, t) {
  let r = [],
    i = n,
    s = 0
  return (
    ce.spans(
      t,
      n,
      e,
      {
        span() {},
        point(o, a) {
          o > i && (r.push({ from: i, to: o }), (s += o - i)), (i = a)
        }
      },
      20
    ),
    i < e && (r.push({ from: i, to: e }), (s += e - i)),
    { total: s, ranges: r }
  )
}
function Ks({ total: n, ranges: e }, t) {
  if (t <= 0) return e[0].from
  if (t >= 1) return e[e.length - 1].to
  let r = Math.floor(n * t)
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i],
      a = o - s
    if (r <= a) return s + r
    r -= a
  }
}
function Js(n, e) {
  let t = 0
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r
      break
    }
    t += i - r
  }
  return t / n.total
}
function mC(n, e) {
  for (let t of n) if (e(t)) return t
}
const Ad = {
  toDOM(n) {
    return n
  },
  fromDOM(n) {
    return n
  },
  scale: 1
}
class gC {
  constructor(e, t, r) {
    let i = 0,
      s = 0,
      o = 0
    ;(this.viewports = r.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, be.ByPos, e, 0, 0).top,
        u = t.lineAt(l, be.ByPos, e, 0, 0).bottom
      return (
        (i += u - c),
        { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 }
      )
    })),
      (this.scale = (7e6 - i) / (t.height - i))
    for (let a of this.viewports)
      (a.domTop = o + (a.top - s) * this.scale),
        (o = a.domBottom = a.domTop + (a.bottom - a.top)),
        (s = a.bottom)
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null
      if (!s || e < s.top) return i + (e - r) * this.scale
      if (e <= s.bottom) return s.domTop + (e - s.top)
      ;(r = s.bottom), (i = s.domBottom)
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null
      if (!s || e < s.domTop) return r + (e - i) / this.scale
      if (e <= s.domBottom) return s.top + (e - s.domTop)
      ;(r = s.bottom), (i = s.domBottom)
    }
  }
}
function Ii(n, e) {
  if (e.scale == 1) return n
  let t = e.toDOM(n.top),
    r = e.toDOM(n.bottom)
  return new Ht(
    n.from,
    n.length,
    t,
    r - t,
    Array.isArray(n._content) ? n._content.map((i) => Ii(i, e)) : n._content
  )
}
const eo = U.define({ combine: (n) => n.join(' ') }),
  ju = U.define({ combine: (n) => n.indexOf(!0) > -1 }),
  Nu = Ln.newName(),
  eb = Ln.newName(),
  tb = Ln.newName(),
  nb = { '&light': '.' + eb, '&dark': '.' + tb }
function Mu(n, e, t) {
  return new Ln(e, {
    finish(r) {
      return /&/.test(r)
        ? r.replace(/&\w*/, (i) => {
            if (i == '&') return n
            if (!t || !t[i]) throw new RangeError(`Unsupported selector: ${i}`)
            return t[i]
          })
        : n + ' ' + r
    }
  })
}
const yC = Mu(
    '.' + Nu,
    {
      '&': {
        position: 'relative !important',
        boxSizing: 'border-box',
        '&.cm-focused': { outline: '1px dotted #212121' },
        display: 'flex !important',
        flexDirection: 'column'
      },
      '.cm-scroller': {
        display: 'flex !important',
        alignItems: 'flex-start !important',
        fontFamily: 'monospace',
        lineHeight: 1.4,
        height: '100%',
        overflowX: 'auto',
        position: 'relative',
        zIndex: 0
      },
      '.cm-content': {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: 'block',
        whiteSpace: 'pre',
        wordWrap: 'normal',
        boxSizing: 'border-box',
        minHeight: '100%',
        padding: '4px 0',
        outline: 'none',
        '&[contenteditable=true]': {
          WebkitUserModify: 'read-write-plaintext-only'
        }
      },
      '.cm-lineWrapping': {
        whiteSpace_fallback: 'pre-wrap',
        whiteSpace: 'break-spaces',
        wordBreak: 'break-word',
        overflowWrap: 'anywhere',
        flexShrink: 1
      },
      '&light .cm-content': { caretColor: 'black' },
      '&dark .cm-content': { caretColor: 'white' },
      '.cm-line': { display: 'block', padding: '0 2px 0 6px' },
      '.cm-layer': {
        position: 'absolute',
        left: 0,
        top: 0,
        contain: 'size style',
        '& > *': { position: 'absolute' }
      },
      '&light .cm-selectionBackground': { background: '#d9d9d9' },
      '&dark .cm-selectionBackground': { background: '#222' },
      '&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground':
        { background: '#d7d4f0' },
      '&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground':
        { background: '#233' },
      '.cm-cursorLayer': { pointerEvents: 'none' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer': {
        animation: 'steps(1) cm-blink 1.2s infinite'
      },
      '@keyframes cm-blink': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '@keyframes cm-blink2': { '0%': {}, '50%': { opacity: 0 }, '100%': {} },
      '.cm-cursor, .cm-dropCursor': {
        borderLeft: '1.2px solid black',
        marginLeft: '-0.6px',
        pointerEvents: 'none'
      },
      '.cm-cursor': { display: 'none' },
      '&dark .cm-cursor': { borderLeftColor: '#444' },
      '.cm-dropCursor': { position: 'absolute' },
      '&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor': {
        display: 'block'
      },
      '&light .cm-activeLine': { backgroundColor: '#cceeff44' },
      '&dark .cm-activeLine': { backgroundColor: '#99eeff33' },
      '&light .cm-specialChar': { color: 'red' },
      '&dark .cm-specialChar': { color: '#f78' },
      '.cm-gutters': {
        flexShrink: 0,
        display: 'flex',
        height: '100%',
        boxSizing: 'border-box',
        insetInlineStart: 0,
        zIndex: 200
      },
      '&light .cm-gutters': {
        backgroundColor: '#f5f5f5',
        color: '#6c6c6c',
        borderRight: '1px solid #ddd'
      },
      '&dark .cm-gutters': { backgroundColor: '#333338', color: '#ccc' },
      '.cm-gutter': {
        display: 'flex !important',
        flexDirection: 'column',
        flexShrink: 0,
        boxSizing: 'border-box',
        minHeight: '100%',
        overflow: 'hidden'
      },
      '.cm-gutterElement': { boxSizing: 'border-box' },
      '.cm-lineNumbers .cm-gutterElement': {
        padding: '0 3px 0 5px',
        minWidth: '20px',
        textAlign: 'right',
        whiteSpace: 'nowrap'
      },
      '&light .cm-activeLineGutter': { backgroundColor: '#e2f2ff' },
      '&dark .cm-activeLineGutter': { backgroundColor: '#222227' },
      '.cm-panels': {
        boxSizing: 'border-box',
        position: 'sticky',
        left: 0,
        right: 0
      },
      '&light .cm-panels': { backgroundColor: '#f5f5f5', color: 'black' },
      '&light .cm-panels-top': { borderBottom: '1px solid #ddd' },
      '&light .cm-panels-bottom': { borderTop: '1px solid #ddd' },
      '&dark .cm-panels': { backgroundColor: '#333338', color: 'white' },
      '.cm-tab': {
        display: 'inline-block',
        overflow: 'hidden',
        verticalAlign: 'bottom'
      },
      '.cm-widgetBuffer': {
        verticalAlign: 'text-top',
        height: '1em',
        width: 0,
        display: 'inline'
      },
      '.cm-placeholder': {
        color: '#888',
        display: 'inline-block',
        verticalAlign: 'top'
      },
      '.cm-highlightSpace:before': {
        content: 'attr(data-display)',
        position: 'absolute',
        pointerEvents: 'none',
        color: '#888'
      },
      '.cm-highlightTab': {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: 'auto 100%',
        backgroundPosition: 'right 90%',
        backgroundRepeat: 'no-repeat'
      },
      '.cm-trailingSpace': { backgroundColor: '#ff332255' },
      '.cm-button': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        padding: '.2em 1em',
        borderRadius: '1px'
      },
      '&light .cm-button': {
        backgroundImage: 'linear-gradient(#eff1f5, #d9d9df)',
        border: '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#b4b4b4, #d0d3d6)' }
      },
      '&dark .cm-button': {
        backgroundImage: 'linear-gradient(#393939, #111)',
        border: '1px solid #888',
        '&:active': { backgroundImage: 'linear-gradient(#111, #333)' }
      },
      '.cm-textfield': {
        verticalAlign: 'middle',
        color: 'inherit',
        fontSize: '70%',
        border: '1px solid silver',
        padding: '.2em .5em'
      },
      '&light .cm-textfield': { backgroundColor: 'white' },
      '&dark .cm-textfield': {
        border: '1px solid #555',
        backgroundColor: 'inherit'
      }
    },
    nb
  ),
  ji = ''
class bC {
  constructor(e, t) {
    ;(this.points = e),
      (this.text = ''),
      (this.lineSeparator = t.facet(ie.lineSeparator))
  }
  append(e) {
    this.text += e
  }
  lineBreak() {
    this.text += ji
  }
  readRange(e, t) {
    if (!e) return this
    let r = e.parentNode
    for (let i = e; ; ) {
      this.findPointBefore(r, i)
      let s = this.text.length
      this.readNode(i)
      let o = i.nextSibling
      if (o == t) break
      let a = ve.get(i),
        l = ve.get(o)
      ;(a && l
        ? a.breakAfter
        : (a ? a.breakAfter : Ed(i)) ||
          (Ed(o) &&
            (i.nodeName != 'BR' || i.cmIgnore) &&
            this.text.length > s)) && this.lineBreak(),
        (i = o)
    }
    return this.findPointBefore(r, t), this
  }
  readTextNode(e) {
    let t = e.nodeValue
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length))
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1,
        o = 1,
        a
      if (
        (this.lineSeparator
          ? ((s = t.indexOf(this.lineSeparator, r)),
            (o = this.lineSeparator.length))
          : (a = i.exec(t)) && ((s = a.index), (o = a[0].length)),
        this.append(t.slice(r, s < 0 ? t.length : s)),
        s < 0)
      )
        break
      if ((this.lineBreak(), o > 1))
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1)
      r = s + o
    }
  }
  readNode(e) {
    if (e.cmIgnore) return
    let t = ve.get(e),
      r = t && t.overrideDOMText
    if (r != null) {
      this.findPointInside(e, r.length)
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value)
    } else
      e.nodeType == 3
        ? this.readTextNode(e)
        : e.nodeName == 'BR'
          ? e.nextSibling && this.lineBreak()
          : e.nodeType == 1 && this.readRange(e.firstChild, null)
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length)
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) &&
        (r.pos = this.text.length + (vC(e, r.node, r.offset) ? t : 0))
  }
}
function vC(n, e, t) {
  for (;;) {
    if (!e || t < bn(e)) return !1
    if (e == n) return !0
    ;(t = Ki(e) + 1), (e = e.parentNode)
  }
}
function Ed(n) {
  return (
    n.nodeType == 1 &&
    /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName)
  )
}
class Dd {
  constructor(e, t) {
    ;(this.node = e), (this.offset = t), (this.pos = -1)
  }
}
class SC {
  constructor(e, t, r, i) {
    ;(this.typeOver = i), (this.bounds = null), (this.text = '')
    let { impreciseHead: s, impreciseAnchor: o } = e.docView
    if (e.state.readOnly && t > -1) this.newSel = null
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let a = s || o ? [] : PC(e),
        l = new bC(a, e.state)
      l.readRange(this.bounds.startDOM, this.bounds.endDOM),
        (this.text = l.text),
        (this.newSel = TC(a, this.bounds.from))
    } else {
      let a = e.observer.selectionRange,
        l =
          (s && s.node == a.focusNode && s.offset == a.focusOffset) ||
          !Tu(e.contentDOM, a.focusNode)
            ? e.state.selection.main.head
            : e.docView.posFromDOM(a.focusNode, a.focusOffset),
        c =
          (o && o.node == a.anchorNode && o.offset == a.anchorOffset) ||
          !Tu(e.contentDOM, a.anchorNode)
            ? e.state.selection.main.anchor
            : e.docView.posFromDOM(a.anchorNode, a.anchorOffset)
      this.newSel = C.single(c, l)
    }
  }
}
function rb(n, e) {
  let t,
    { newSel: r } = e,
    i = n.state.selection.main,
    s =
      n.inputState.lastKeyTime > Date.now() - 100
        ? n.inputState.lastKeyCode
        : -1
  if (e.bounds) {
    let { from: o, to: a } = e.bounds,
      l = i.from,
      c = null
    ;(s === 8 || (z.android && e.text.length < a - o)) &&
      ((l = i.to), (c = 'end'))
    let u = wC(n.state.doc.sliceString(o, a, ji), e.text, l - o, c)
    u &&
      (z.chrome &&
        s == 13 &&
        u.toB == u.from + 2 &&
        e.text.slice(u.from, u.toB) == ji + ji &&
        u.toB--,
      (t = {
        from: o + u.from,
        to: o + u.toA,
        insert: le.of(e.text.slice(u.from, u.toB).split(ji))
      }))
  } else r && ((!n.hasFocus && n.state.facet(bl)) || r.main.eq(i)) && (r = null)
  if (!t && !r) return !1
  if (
    (!t && e.typeOver && !i.empty && r && r.main.empty
      ? (t = {
          from: i.from,
          to: i.to,
          insert: n.state.doc.slice(i.from, i.to)
        })
      : t &&
          t.from >= i.from &&
          t.to <= i.to &&
          (t.from != i.from || t.to != i.to) &&
          i.to - i.from - (t.to - t.from) <= 4
        ? (t = {
            from: i.from,
            to: i.to,
            insert: n.state.doc
              .slice(i.from, t.from)
              .append(t.insert)
              .append(n.state.doc.slice(t.to, i.to))
          })
        : (z.mac || z.android) &&
            t &&
            t.from == t.to &&
            t.from == i.head - 1 &&
            /^\. ?$/.test(t.insert.toString()) &&
            n.contentDOM.getAttribute('autocorrect') == 'off'
          ? (r &&
              t.insert.length == 2 &&
              (r = C.single(r.main.anchor - 1, r.main.head - 1)),
            (t = { from: i.from, to: i.to, insert: le.of([' ']) }))
          : z.chrome &&
            t &&
            t.from == t.to &&
            t.from == i.head &&
            t.insert.toString() ==
              `
 ` &&
            n.lineWrapping &&
            (r && (r = C.single(r.main.anchor - 1, r.main.head - 1)),
            (t = { from: i.from, to: i.to, insert: le.of([' ']) })),
    t)
  ) {
    if (
      (z.ios && n.inputState.flushIOSKey()) ||
      (z.android &&
        ((t.from == i.from &&
          t.to == i.to &&
          t.insert.length == 1 &&
          t.insert.lines == 2 &&
          Nr(n.contentDOM, 'Enter', 13)) ||
          (((t.from == i.from - 1 && t.to == i.to && t.insert.length == 0) ||
            (s == 8 && t.insert.length < t.to - t.from && t.to > i.head)) &&
            Nr(n.contentDOM, 'Backspace', 8)) ||
          (t.from == i.from &&
            t.to == i.to + 1 &&
            t.insert.length == 0 &&
            Nr(n.contentDOM, 'Delete', 46))))
    )
      return !0
    let o = t.insert.toString()
    n.inputState.composing >= 0 && n.inputState.composing++
    let a,
      l = () => a || (a = xC(n, t, r))
    return (
      n.state.facet(ky).some((c) => c(n, t.from, t.to, o, l)) ||
        n.dispatch(l()),
      !0
    )
  } else if (r && !r.main.eq(i)) {
    let o = !1,
      a = 'select'
    return (
      n.inputState.lastSelectionTime > Date.now() - 50 &&
        (n.inputState.lastSelectionOrigin == 'select' && (o = !0),
        (a = n.inputState.lastSelectionOrigin)),
      n.dispatch({ selection: r, scrollIntoView: o, userEvent: a }),
      !0
    )
  } else return !1
}
function xC(n, e, t) {
  let r,
    i = n.state,
    s = i.selection.main
  if (
    e.from >= s.from &&
    e.to <= s.to &&
    e.to - e.from >= (s.to - s.from) / 3 &&
    (!t || (t.main.empty && t.main.from == e.from + e.insert.length)) &&
    n.inputState.composing < 0
  ) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : '',
      l = s.to > e.to ? i.sliceDoc(e.to, s.to) : ''
    r = i.replaceSelection(
      n.state.toText(a + e.insert.sliceString(0, void 0, n.state.lineBreak) + l)
    )
  } else {
    let a = i.changes(e),
      l = t && t.main.to <= a.newLength ? t.main : void 0
    if (
      i.selection.ranges.length > 1 &&
      n.inputState.composing >= 0 &&
      e.to <= s.to &&
      e.to >= s.to - 10
    ) {
      let c = n.state.sliceDoc(e.from, e.to),
        u,
        f = t && My(n, t.main.head)
      if (f) {
        let O = e.insert.length - (e.to - e.from)
        u = { from: f.from, to: f.to - O }
      } else u = n.state.doc.lineAt(s.head)
      let p = s.to - e.to,
        d = s.to - s.from
      r = i.changeByRange((O) => {
        if (O.from == s.from && O.to == s.to)
          return { changes: a, range: l || O.map(a) }
        let g = O.to - p,
          b = g - c.length
        if (
          O.to - O.from != d ||
          n.state.sliceDoc(b, g) != c ||
          (O.to >= u.from && O.from <= u.to)
        )
          return { range: O }
        let x = i.changes({ from: b, to: g, insert: e.insert }),
          w = O.to - s.to
        return {
          changes: x,
          range: l
            ? C.range(Math.max(0, l.anchor + w), Math.max(0, l.head + w))
            : O.map(x)
        }
      })
    } else r = { changes: a, selection: l && i.selection.replaceRange(l) }
  }
  let o = 'input.type'
  return (
    (n.composing ||
      (n.inputState.compositionPendingChange &&
        n.inputState.compositionEndedAt > Date.now() - 50)) &&
      ((n.inputState.compositionPendingChange = !1),
      (o += '.compose'),
      n.inputState.compositionFirstChange &&
        ((o += '.start'), (n.inputState.compositionFirstChange = !1))),
    i.update(r, { userEvent: o, scrollIntoView: !0 })
  )
}
function wC(n, e, t, r) {
  let i = Math.min(n.length, e.length),
    s = 0
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); ) s++
  if (s == i && n.length == e.length) return null
  let o = n.length,
    a = e.length
  for (; o > 0 && a > 0 && n.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--
  if (r == 'end') {
    let l = Math.max(0, s - Math.min(o, a))
    t -= o + l - s
  }
  if (o < s && n.length < e.length) {
    let l = t <= s && t >= o ? s - t : 0
    ;(s -= l), (a = s + (a - o)), (o = s)
  } else if (a < s) {
    let l = t <= s && t >= a ? s - t : 0
    ;(s -= l), (o = s + (o - a)), (a = s)
  }
  return { from: s, toA: o, toB: a }
}
function PC(n) {
  let e = []
  if (n.root.activeElement != n.contentDOM) return e
  let {
    anchorNode: t,
    anchorOffset: r,
    focusNode: i,
    focusOffset: s
  } = n.observer.selectionRange
  return (
    t && (e.push(new Dd(t, r)), (i != t || s != r) && e.push(new Dd(i, s))), e
  )
}
function TC(n, e) {
  if (n.length == 0) return null
  let t = n[0].pos,
    r = n.length == 2 ? n[1].pos : t
  return t > -1 && r > -1 ? C.single(t + e, r + e) : null
}
const $C = {
    childList: !0,
    characterData: !0,
    subtree: !0,
    attributes: !0,
    characterDataOldValue: !0
  },
  sc = z.ie && z.ie_version <= 11
class QC {
  constructor(e) {
    ;(this.view = e),
      (this.active = !1),
      (this.selectionRange = new uk()),
      (this.selectionChanged = !1),
      (this.delayedFlush = -1),
      (this.resizeTimeout = -1),
      (this.queue = []),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1),
      (this.lastChange = 0),
      (this.scrollTargets = []),
      (this.intersection = null),
      (this.resizeScroll = null),
      (this.intersecting = !1),
      (this.gapIntersection = null),
      (this.gaps = []),
      (this.parentCheck = -1),
      (this.dom = e.contentDOM),
      (this.observer = new MutationObserver((t) => {
        for (let r of t) this.queue.push(r)
        ;((z.ie && z.ie_version <= 11) || (z.ios && e.composing)) &&
        t.some(
          (r) =>
            (r.type == 'childList' && r.removedNodes.length) ||
            (r.type == 'characterData' &&
              r.oldValue.length > r.target.nodeValue.length)
        )
          ? this.flushSoon()
          : this.flush()
      })),
      sc &&
        (this.onCharData = (t) => {
          this.queue.push({
            target: t.target,
            type: 'characterData',
            oldValue: t.prevValue
          }),
            this.flushSoon()
        }),
      (this.onSelectionChange = this.onSelectionChange.bind(this)),
      (this.onResize = this.onResize.bind(this)),
      (this.onPrint = this.onPrint.bind(this)),
      (this.onScroll = this.onScroll.bind(this)),
      typeof ResizeObserver == 'function' &&
        ((this.resizeScroll = new ResizeObserver(() => {
          var t
          ;((t = this.view.docView) === null || t === void 0
            ? void 0
            : t.lastUpdate) <
            Date.now() - 75 && this.onResize()
        })),
        this.resizeScroll.observe(e.scrollDOM)),
      this.addWindowListeners((this.win = e.win)),
      this.start(),
      typeof IntersectionObserver == 'function' &&
        ((this.intersection = new IntersectionObserver(
          (t) => {
            this.parentCheck < 0 &&
              (this.parentCheck = setTimeout(
                this.listenForScroll.bind(this),
                1e3
              )),
              t.length > 0 &&
                t[t.length - 1].intersectionRatio > 0 != this.intersecting &&
                ((this.intersecting = !this.intersecting),
                this.intersecting != this.view.inView &&
                  this.onScrollChanged(document.createEvent('Event')))
          },
          { threshold: [0, 0.001] }
        )),
        this.intersection.observe(this.dom),
        (this.gapIntersection = new IntersectionObserver((t) => {
          t.length > 0 &&
            t[t.length - 1].intersectionRatio > 0 &&
            this.onScrollChanged(document.createEvent('Event'))
        }, {}))),
      this.listenForScroll(),
      this.readSelectionRange()
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers('scroll', e),
      this.intersecting && this.view.measure()
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e)
  }
  onResize() {
    this.resizeTimeout < 0 &&
      (this.resizeTimeout = setTimeout(() => {
        ;(this.resizeTimeout = -1), this.view.requestMeasure()
      }, 50))
  }
  onPrint() {
    ;(this.view.viewState.printing = !0),
      this.view.measure(),
      setTimeout(() => {
        ;(this.view.viewState.printing = !1), this.view.requestMeasure()
      }, 500)
  }
  updateGaps(e) {
    if (
      this.gapIntersection &&
      (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))
    ) {
      this.gapIntersection.disconnect()
      for (let t of e) this.gapIntersection.observe(t)
      this.gaps = e
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged
    if (!this.readSelectionRange() || this.delayedAndroidKey) return
    let { view: r } = this,
      i = this.selectionRange
    if (r.state.facet(bl) ? r.root.activeElement != this.dom : !Xo(r.dom, i))
      return
    let s = i.anchorNode && r.docView.nearest(i.anchorNode)
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1)
      return
    }
    ;((z.ie && z.ie_version <= 11) || (z.android && z.chrome)) &&
    !r.state.selection.main.empty &&
    i.focusNode &&
    Ta(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset)
      ? this.flushSoon()
      : this.flush(!1)
  }
  readSelectionRange() {
    let { view: e } = this,
      t =
        (z.safari &&
          e.root.nodeType == 11 &&
          ok(this.dom.ownerDocument) == this.dom &&
          kC(this.view)) ||
        Pa(e.root)
    if (!t || this.selectionRange.eq(t)) return !1
    let r = Xo(this.dom, t)
    return r &&
      !this.selectionChanged &&
      e.inputState.lastFocusTime > Date.now() - 200 &&
      e.inputState.lastTouchTime < Date.now() - 300 &&
      hk(this.dom, t)
      ? ((this.view.inputState.lastFocusTime = 0),
        e.docView.updateSelection(),
        !1)
      : (this.selectionRange.setRange(t), r && (this.selectionChanged = !0), !0)
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset),
      (this.selectionChanged = !1)
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0)
  }
  listenForScroll() {
    this.parentCheck = -1
    let e = 0,
      t = null
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r
          ? e++
          : t || (t = this.scrollTargets.slice(0, e)),
          t && t.push(r),
          (r = r.assignedSlot || r.parentNode)
      else if (r.nodeType == 11) r = r.host
      else break
    if (
      (e < this.scrollTargets.length &&
        !t &&
        (t = this.scrollTargets.slice(0, e)),
      t)
    ) {
      for (let r of this.scrollTargets)
        r.removeEventListener('scroll', this.onScroll)
      for (let r of (this.scrollTargets = t))
        r.addEventListener('scroll', this.onScroll)
    }
  }
  ignore(e) {
    if (!this.active) return e()
    try {
      return this.stop(), e()
    } finally {
      this.start(), this.clear()
    }
  }
  start() {
    this.active ||
      (this.observer.observe(this.dom, $C),
      sc &&
        this.dom.addEventListener('DOMCharacterDataModified', this.onCharData),
      (this.active = !0))
  }
  stop() {
    this.active &&
      ((this.active = !1),
      this.observer.disconnect(),
      sc &&
        this.dom.removeEventListener(
          'DOMCharacterDataModified',
          this.onCharData
        ))
  }
  clear() {
    this.processRecords(), (this.queue.length = 0), (this.selectionChanged = !1)
  }
  delayAndroidKey(e, t) {
    var r
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey
        s &&
          (this.clearDelayedAndroidKey(),
          (this.view.inputState.lastKeyCode = s.keyCode),
          (this.view.inputState.lastKeyTime = Date.now()),
          !this.flush() && s.force && Nr(this.dom, s.key, s.keyCode))
      }
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i)
    }
    ;(!this.delayedAndroidKey || e == 'Enter') &&
      (this.delayedAndroidKey = {
        key: e,
        keyCode: t,
        force:
          this.lastChange < Date.now() - 50 ||
          !!(
            !((r = this.delayedAndroidKey) === null || r === void 0) && r.force
          )
      })
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey),
      (this.delayedAndroidKey = null),
      (this.flushingAndroidKey = -1)
  }
  flushSoon() {
    this.delayedFlush < 0 &&
      (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        ;(this.delayedFlush = -1), this.flush()
      }))
  }
  forceFlush() {
    this.delayedFlush >= 0 &&
      (this.view.win.cancelAnimationFrame(this.delayedFlush),
      (this.delayedFlush = -1)),
      this.flush()
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords()) this.queue.push(e)
    return this.queue
  }
  processRecords() {
    let e = this.pendingRecords()
    e.length && (this.queue = [])
    let t = -1,
      r = -1,
      i = !1
    for (let s of e) {
      let o = this.readMutation(s)
      o &&
        (o.typeOver && (i = !0),
        t == -1
          ? ({ from: t, to: r } = o)
          : ((t = Math.min(o.from, t)), (r = Math.max(o.to, r))))
    }
    return { from: t, to: r, typeOver: i }
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(),
      i = this.selectionChanged && Xo(this.dom, this.selectionRange)
    if (e < 0 && !i) return null
    e > -1 && (this.lastChange = Date.now()),
      (this.view.inputState.lastFocusTime = 0),
      (this.selectionChanged = !1)
    let s = new SC(this.view, e, t, r)
    return (
      (this.view.docView.domChanged = {
        newSel: s.newSel ? s.newSel.main : null
      }),
      s
    )
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return !1
    e && this.readSelectionRange()
    let t = this.readChange()
    if (!t) return this.view.requestMeasure(), !1
    let r = this.view.state,
      i = rb(this.view, t)
    return this.view.state == r && this.view.update([]), i
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target)
    if (!t || t.ignoreMutation(e)) return null
    if (
      (t.markDirty(e.type == 'attributes'),
      e.type == 'attributes' && (t.flags |= 4),
      e.type == 'childList')
    ) {
      let r = Xd(t, e.previousSibling || e.target.previousSibling, -1),
        i = Xd(t, e.nextSibling || e.target.nextSibling, 1)
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      }
    } else
      return e.type == 'characterData'
        ? {
            from: t.posAtStart,
            to: t.posAtEnd,
            typeOver: e.target.nodeValue == e.oldValue
          }
        : null
  }
  setWindow(e) {
    e != this.win &&
      (this.removeWindowListeners(this.win),
      (this.win = e),
      this.addWindowListeners(this.win))
  }
  addWindowListeners(e) {
    e.addEventListener('resize', this.onResize),
      e.addEventListener('beforeprint', this.onPrint),
      e.addEventListener('scroll', this.onScroll),
      e.document.addEventListener('selectionchange', this.onSelectionChange)
  }
  removeWindowListeners(e) {
    e.removeEventListener('scroll', this.onScroll),
      e.removeEventListener('resize', this.onResize),
      e.removeEventListener('beforeprint', this.onPrint),
      e.document.removeEventListener('selectionchange', this.onSelectionChange)
  }
  destroy() {
    var e, t, r
    this.stop(),
      (e = this.intersection) === null || e === void 0 || e.disconnect(),
      (t = this.gapIntersection) === null || t === void 0 || t.disconnect(),
      (r = this.resizeScroll) === null || r === void 0 || r.disconnect()
    for (let i of this.scrollTargets)
      i.removeEventListener('scroll', this.onScroll)
    this.removeWindowListeners(this.win),
      clearTimeout(this.parentCheck),
      clearTimeout(this.resizeTimeout),
      this.win.cancelAnimationFrame(this.delayedFlush),
      this.win.cancelAnimationFrame(this.flushingAndroidKey)
  }
}
function Xd(n, e, t) {
  for (; e; ) {
    let r = ve.get(e)
    if (r && r.parent == n) return r
    let i = e.parentNode
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling
  }
  return null
}
function kC(n) {
  let e = null
  function t(l) {
    l.preventDefault(),
      l.stopImmediatePropagation(),
      (e = l.getTargetRanges()[0])
  }
  if (
    (n.contentDOM.addEventListener('beforeinput', t, !0),
    n.dom.ownerDocument.execCommand('indent'),
    n.contentDOM.removeEventListener('beforeinput', t, !0),
    !e)
  )
    return null
  let r = e.startContainer,
    i = e.startOffset,
    s = e.endContainer,
    o = e.endOffset,
    a = n.docView.domAtPos(n.state.selection.main.anchor)
  return (
    Ta(a.node, a.offset, s, o) && ([r, i, s, o] = [s, o, r, i]),
    { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o }
  )
}
class j {
  get state() {
    return this.viewState.state
  }
  get viewport() {
    return this.viewState.viewport
  }
  get visibleRanges() {
    return this.viewState.visibleRanges
  }
  get inView() {
    return this.viewState.inView
  }
  get composing() {
    return this.inputState.composing > 0
  }
  get compositionStarted() {
    return this.inputState.composing >= 0
  }
  get root() {
    return this._root
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window
  }
  constructor(e = {}) {
    ;(this.plugins = []),
      (this.pluginMap = new Map()),
      (this.editorAttrs = {}),
      (this.contentAttrs = {}),
      (this.bidiCache = []),
      (this.destroyed = !1),
      (this.updateState = 2),
      (this.measureScheduled = -1),
      (this.measureRequests = []),
      (this.contentDOM = document.createElement('div')),
      (this.scrollDOM = document.createElement('div')),
      (this.scrollDOM.tabIndex = -1),
      (this.scrollDOM.className = 'cm-scroller'),
      this.scrollDOM.appendChild(this.contentDOM),
      (this.announceDOM = document.createElement('div')),
      (this.announceDOM.style.cssText = 'position: fixed; top: -10000px'),
      this.announceDOM.setAttribute('aria-live', 'polite'),
      (this.dom = document.createElement('div')),
      this.dom.appendChild(this.announceDOM),
      this.dom.appendChild(this.scrollDOM)
    let { dispatch: t } = e
    ;(this.dispatchTransactions =
      e.dispatchTransactions ||
      (t && ((r) => r.forEach((i) => t(i, this)))) ||
      ((r) => this.update(r))),
      (this.dispatch = this.dispatch.bind(this)),
      (this._root = e.root || fk(e.parent) || document),
      (this.viewState = new Zd(e.state || ie.create(e))),
      e.scrollTo &&
        e.scrollTo.is(zs) &&
        (this.viewState.scrollTarget = e.scrollTo.value.clip(
          this.viewState.state
        )),
      (this.plugins = this.state.facet(Xi).map((r) => new tc(r)))
    for (let r of this.plugins) r.update(this)
    ;(this.observer = new QC(this)),
      (this.inputState = new Wk(this)),
      this.inputState.ensureHandlers(this.plugins),
      (this.docView = new dd(this)),
      this.mountStyles(),
      this.updateAttrs(),
      (this.updateState = 0),
      this.requestMeasure(),
      e.parent && e.parent.appendChild(this.dom)
  }
  dispatch(...e) {
    let t =
      e.length == 1 && e[0] instanceof Ee
        ? e
        : e.length == 1 && Array.isArray(e[0])
          ? e[0]
          : [this.state.update(...e)]
    this.dispatchTransactions(t, this)
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error(
        'Calls to EditorView.update are not allowed while an update is in progress'
      )
    let t = !1,
      r = !1,
      i,
      s = this.state
    for (let p of e) {
      if (p.startState != s)
        throw new RangeError(
          "Trying to update state with a transaction that doesn't start from the previous state."
        )
      s = p.state
    }
    if (this.destroyed) {
      this.viewState.state = s
      return
    }
    let o = this.hasFocus,
      a = 0,
      l = null
    e.some((p) => p.annotation(Gy))
      ? ((this.inputState.notifiedFocused = o), (a = 1))
      : o != this.inputState.notifiedFocused &&
        ((this.inputState.notifiedFocused = o), (l = Hy(s, o)), l || (a = 1))
    let c = this.observer.delayedAndroidKey,
      u = null
    if (
      (c
        ? (this.observer.clearDelayedAndroidKey(),
          (u = this.observer.readChange()),
          ((u && !this.state.doc.eq(s.doc)) ||
            !this.state.selection.eq(s.selection)) &&
            (u = null))
        : this.observer.clear(),
      s.facet(ie.phrases) != this.state.facet(ie.phrases))
    )
      return this.setState(s)
    ;(i = $a.create(this, s, e)), (i.flags |= a)
    let f = this.viewState.scrollTarget
    try {
      this.updateState = 2
      for (let p of e) {
        if ((f && (f = f.map(p.changes)), p.scrollIntoView)) {
          let { main: d } = p.state.selection
          f = new Mr(d.empty ? d : C.cursor(d.head, d.head > d.anchor ? -1 : 1))
        }
        for (let d of p.effects) d.is(zs) && (f = d.value.clip(this.state))
      }
      this.viewState.update(i, f),
        (this.bidiCache = Qa.update(this.bidiCache, i.changes)),
        i.empty || (this.updatePlugins(i), this.inputState.update(i)),
        (t = this.docView.update(i)),
        this.state.facet(Yi) != this.styleModules && this.mountStyles(),
        (r = this.updateAttrs()),
        this.showAnnouncements(e),
        this.docView.updateSelection(
          t,
          e.some((p) => p.isUserEvent('select.pointer'))
        )
    } finally {
      this.updateState = 0
    }
    if (
      (i.startState.facet(eo) != i.state.facet(eo) &&
        (this.viewState.mustMeasureContent = !0),
      (t ||
        r ||
        f ||
        this.viewState.mustEnforceCursorAssoc ||
        this.viewState.mustMeasureContent) &&
        this.requestMeasure(),
      !i.empty)
    )
      for (let p of this.state.facet(Zu))
        try {
          p(i)
        } catch (d) {
          _t(this.state, d, 'update listener')
        }
    ;(l || u) &&
      Promise.resolve().then(() => {
        l && this.state == l.startState && this.dispatch(l),
          u && !rb(this, u) && c.force && Nr(this.contentDOM, c.key, c.keyCode)
      })
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error(
        'Calls to EditorView.setState are not allowed while an update is in progress'
      )
    if (this.destroyed) {
      this.viewState.state = e
      return
    }
    this.updateState = 2
    let t = this.hasFocus
    try {
      for (let r of this.plugins) r.destroy(this)
      ;(this.viewState = new Zd(e)),
        (this.plugins = e.facet(Xi).map((r) => new tc(r))),
        this.pluginMap.clear()
      for (let r of this.plugins) r.update(this)
      ;(this.docView = new dd(this)),
        this.inputState.ensureHandlers(this.plugins),
        this.mountStyles(),
        this.updateAttrs(),
        (this.bidiCache = [])
    } finally {
      this.updateState = 0
    }
    t && this.focus(), this.requestMeasure()
  }
  updatePlugins(e) {
    let t = e.startState.facet(Xi),
      r = e.state.facet(Xi)
    if (t != r) {
      let i = []
      for (let s of r) {
        let o = t.indexOf(s)
        if (o < 0) i.push(new tc(s))
        else {
          let a = this.plugins[o]
          ;(a.mustUpdate = e), i.push(a)
        }
      }
      for (let s of this.plugins) s.mustUpdate != e && s.destroy(this)
      ;(this.plugins = i), this.pluginMap.clear()
    } else for (let i of this.plugins) i.mustUpdate = e
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this)
    t != r && this.inputState.ensureHandlers(this.plugins)
  }
  measure(e = !0) {
    if (this.destroyed) return
    if (
      (this.measureScheduled > -1 &&
        this.win.cancelAnimationFrame(this.measureScheduled),
      this.observer.delayedAndroidKey)
    ) {
      ;(this.measureScheduled = -1), this.requestMeasure()
      return
    }
    ;(this.measureScheduled = 0), e && this.observer.forceFlush()
    let t = null,
      r = this.scrollDOM,
      i = r.scrollTop * this.scaleY,
      { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1),
      (this.viewState.scrollAnchorHeight = -1)
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (dy(r)) (s = -1), (o = this.viewState.heightMap.height)
          else {
            let d = this.viewState.scrollAnchorAt(i)
            ;(s = d.from), (o = d.top)
          }
        this.updateState = 1
        let l = this.viewState.measure(this)
        if (
          !l &&
          !this.measureRequests.length &&
          this.viewState.scrollTarget == null
        )
          break
        if (a > 5) {
          console.warn(
            this.measureRequests.length
              ? 'Measure loop restarted more than 5 times'
              : 'Viewport failed to stabilize'
          )
          break
        }
        let c = []
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests])
        let u = c.map((d) => {
            try {
              return d.read(this)
            } catch (O) {
              return _t(this.state, O), Yd
            }
          }),
          f = $a.create(this, this.state, []),
          p = !1
        ;(f.flags |= l),
          t ? (t.flags |= l) : (t = f),
          (this.updateState = 2),
          f.empty ||
            (this.updatePlugins(f),
            this.inputState.update(f),
            this.updateAttrs(),
            (p = this.docView.update(f)))
        for (let d = 0; d < c.length; d++)
          if (u[d] != Yd)
            try {
              let O = c[d]
              O.write && O.write(u[d], this)
            } catch (O) {
              _t(this.state, O)
            }
        if (
          (p && this.docView.updateSelection(!0),
          !f.viewportChanged && this.measureRequests.length == 0)
        ) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget),
                (this.viewState.scrollTarget = null)
              continue
            } else {
              let O =
                (s < 0
                  ? this.viewState.heightMap.height
                  : this.viewState.lineBlockAt(s).top) - o
              if (O > 1 || O < -1) {
                ;(i = i + O), (r.scrollTop = i / this.scaleY), (o = -1)
                continue
              }
            }
          break
        }
      }
    } finally {
      ;(this.updateState = 0), (this.measureScheduled = -1)
    }
    if (t && !t.empty) for (let a of this.state.facet(Zu)) a(t)
  }
  get themeClasses() {
    return (
      Nu + ' ' + (this.state.facet(ju) ? tb : eb) + ' ' + this.state.facet(eo)
    )
  }
  updateAttrs() {
    let e = Id(this, Zy, {
        class:
          'cm-editor' +
          (this.hasFocus ? ' cm-focused ' : ' ') +
          this.themeClasses
      }),
      t = {
        spellcheck: 'false',
        autocorrect: 'off',
        autocapitalize: 'off',
        translate: 'no',
        contenteditable: this.state.facet(bl) ? 'true' : 'false',
        class: 'cm-content',
        style: `${z.tabSize}: ${this.state.tabSize}`,
        role: 'textbox',
        'aria-multiline': 'true'
      }
    this.state.readOnly && (t['aria-readonly'] = 'true'), Id(this, Xf, t)
    let r = this.observer.ignore(() => {
      let i = _u(this.contentDOM, this.contentAttrs, t),
        s = _u(this.dom, this.editorAttrs, e)
      return i || s
    })
    return (this.editorAttrs = e), (this.contentAttrs = t), r
  }
  showAnnouncements(e) {
    let t = !0
    for (let r of e)
      for (let i of r.effects)
        if (i.is(j.announce)) {
          t && (this.announceDOM.textContent = ''), (t = !1)
          let s = this.announceDOM.appendChild(document.createElement('div'))
          s.textContent = i.value
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Yi)
    let e = this.state.facet(j.cspNonce)
    Ln.mount(
      this.root,
      this.styleModules.concat(yC).reverse(),
      e ? { nonce: e } : void 0
    )
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error(
        "Reading the editor layout isn't allowed during an update"
      )
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1)
  }
  requestMeasure(e) {
    if (
      (this.measureScheduled < 0 &&
        (this.measureScheduled = this.win.requestAnimationFrame(() =>
          this.measure()
        )),
      e)
    ) {
      if (this.measureRequests.indexOf(e) > -1) return
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e
            return
          }
      }
      this.measureRequests.push(e)
    }
  }
  plugin(e) {
    let t = this.pluginMap.get(e)
    return (
      (t === void 0 || (t && t.spec != e)) &&
        this.pluginMap.set(
          e,
          (t = this.plugins.find((r) => r.spec == e) || null)
        ),
      t && t.update(this).value
    )
  }
  get documentTop() {
    return (
      this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
    )
  }
  get documentPadding() {
    return {
      top: this.viewState.paddingTop,
      bottom: this.viewState.paddingBottom
    }
  }
  get scaleX() {
    return this.viewState.scaleX
  }
  get scaleY() {
    return this.viewState.scaleY
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e)
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e)
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e)
  }
  get contentHeight() {
    return this.viewState.contentHeight
  }
  moveByChar(e, t, r) {
    return rc(this, e, vd(this, e, t, r))
  }
  moveByGroup(e, t) {
    return rc(
      this,
      e,
      vd(this, e, t, (r) => Mk(this, e.head, r))
    )
  }
  moveToLineBoundary(e, t, r = !0) {
    return Nk(this, e, t, r)
  }
  moveVertically(e, t, r) {
    return rc(this, e, Vk(this, e, t, r))
  }
  domAtPos(e) {
    return this.docView.domAtPos(e)
  }
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t)
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), Wy(this, e, t)
  }
  coordsAtPos(e, t = 1) {
    this.readMeasured()
    let r = this.docView.coordsAt(e, t)
    if (!r || r.left == r.right) return r
    let i = this.state.doc.lineAt(e),
      s = this.bidiSpans(i),
      o = s[Yn.find(s, e - i.from, -1, t)]
    return gl(r, (o.dir == we.LTR) == t > 0)
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e)
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight
  }
  get textDirection() {
    return this.viewState.defaultTextDirection
  }
  textDirectionAt(e) {
    return !this.state.facet(_y) ||
      e < this.viewport.from ||
      e > this.viewport.to
      ? this.textDirection
      : (this.readMeasured(), this.docView.textDirectionAt(e))
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping
  }
  bidiSpans(e) {
    if (e.length > CC) return jy(e.length)
    let t = this.textDirectionAt(e.from),
      r
    for (let s of this.bidiCache)
      if (
        s.from == e.from &&
        s.dir == t &&
        (s.fresh || Iy(s.isolates, (r = pd(this, e.from, e.to))))
      )
        return s.order
    r || (r = pd(this, e.from, e.to))
    let i = $k(e.text, t, r)
    return this.bidiCache.push(new Qa(e.from, e.to, t, r, !0, i)), i
  }
  get hasFocus() {
    var e
    return (
      (this.dom.ownerDocument.hasFocus() ||
        (z.safari &&
          ((e = this.inputState) === null || e === void 0
            ? void 0
            : e.lastContextMenu) >
            Date.now() - 3e4)) &&
      this.root.activeElement == this.contentDOM
    )
  }
  focus() {
    this.observer.ignore(() => {
      hy(this.contentDOM), this.docView.updateSelection()
    })
  }
  setRoot(e) {
    this._root != e &&
      ((this._root = e),
      this.observer.setWindow(
        (e.nodeType == 9 ? e : e.ownerDocument).defaultView || window
      ),
      this.mountStyles())
  }
  destroy() {
    for (let e of this.plugins) e.destroy(this)
    ;(this.plugins = []),
      this.inputState.destroy(),
      this.dom.remove(),
      this.observer.destroy(),
      this.measureScheduled > -1 &&
        this.win.cancelAnimationFrame(this.measureScheduled),
      (this.destroyed = !0)
  }
  static scrollIntoView(e, t = {}) {
    return zs.of(
      new Mr(
        typeof e == 'number' ? C.cursor(e) : e,
        t.y,
        t.x,
        t.yMargin,
        t.xMargin
      )
    )
  }
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM,
      r = this.viewState.scrollAnchorAt(e)
    return zs.of(new Mr(C.cursor(r.from), 'start', 'start', r.top - e, t, !0))
  }
  static domEventHandlers(e) {
    return _e.define(() => ({}), { eventHandlers: e })
  }
  static domEventObservers(e) {
    return _e.define(() => ({}), { eventObservers: e })
  }
  static theme(e, t) {
    let r = Ln.newName(),
      i = [eo.of(r), Yi.of(Mu(`.${r}`, e))]
    return t && t.dark && i.push(ju.of(!0)), i
  }
  static baseTheme(e) {
    return vr.lowest(Yi.of(Mu('.' + Nu, e, nb)))
  }
  static findFromDOM(e) {
    var t
    let r = e.querySelector('.cm-content'),
      i = (r && ve.get(r)) || ve.get(e)
    return (
      ((t = i == null ? void 0 : i.rootView) === null || t === void 0
        ? void 0
        : t.view) || null
    )
  }
}
j.styleModule = Yi
j.inputHandler = ky
j.focusChangeEffect = Cy
j.perLineTextDirection = _y
j.exceptionSink = Qy
j.updateListener = Zu
j.editable = bl
j.mouseSelectionStyle = $y
j.dragMovesSelection = Ty
j.clickAddsSelectionRange = Py
j.decorations = Ji
j.atomicRanges = Yf
j.bidiIsolatedRanges = Ay
j.scrollMargins = Ey
j.darkTheme = ju
j.cspNonce = U.define({ combine: (n) => (n.length ? n[0] : '') })
j.contentAttributes = Xf
j.editorAttributes = Zy
j.lineWrapping = j.contentAttributes.of({ class: 'cm-lineWrapping' })
j.announce = ee.define()
const CC = 4096,
  Yd = {}
class Qa {
  constructor(e, t, r, i, s, o) {
    ;(this.from = e),
      (this.to = t),
      (this.dir = r),
      (this.isolates = i),
      (this.fresh = s),
      (this.order = o)
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh)) return e
    let r = [],
      i = e.length ? e[e.length - 1].dir : we.LTR
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s]
      o.dir == i &&
        !t.touchesRange(o.from, o.to) &&
        r.push(
          new Qa(
            t.mapPos(o.from, 1),
            t.mapPos(o.to, -1),
            o.dir,
            o.isolates,
            !1,
            o.order
          )
        )
    }
    return r
  }
}
function Id(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i],
      o = typeof s == 'function' ? s(n) : s
    o && Cu(o, t)
  }
  return t
}
const _C = z.mac ? 'mac' : z.windows ? 'win' : z.linux ? 'linux' : 'key'
function RC(n, e) {
  const t = n.split(/-(?!$)/)
  let r = t[t.length - 1]
  r == 'Space' && (r = ' ')
  let i, s, o, a
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l]
    if (/^(cmd|meta|m)$/i.test(c)) a = !0
    else if (/^a(lt)?$/i.test(c)) i = !0
    else if (/^(c|ctrl|control)$/i.test(c)) s = !0
    else if (/^s(hift)?$/i.test(c)) o = !0
    else if (/^mod$/i.test(c)) e == 'mac' ? (a = !0) : (s = !0)
    else throw new Error('Unrecognized modifier name: ' + c)
  }
  return (
    i && (r = 'Alt-' + r),
    s && (r = 'Ctrl-' + r),
    a && (r = 'Meta-' + r),
    o && (r = 'Shift-' + r),
    r
  )
}
function to(n, e, t) {
  return (
    e.altKey && (n = 'Alt-' + n),
    e.ctrlKey && (n = 'Ctrl-' + n),
    e.metaKey && (n = 'Meta-' + n),
    t !== !1 && e.shiftKey && (n = 'Shift-' + n),
    n
  )
}
const ZC = vr.default(
    j.domEventHandlers({
      keydown(n, e) {
        return sb(ib(e.state), n, e, 'editor')
      }
    })
  ),
  Ps = U.define({ enables: ZC }),
  jd = new WeakMap()
function ib(n) {
  let e = n.facet(Ps),
    t = jd.get(e)
  return t || jd.set(e, (t = DC(e.reduce((r, i) => r.concat(i), [])))), t
}
function AC(n, e, t) {
  return sb(ib(n.state), e, n, t)
}
let Zn = null
const EC = 4e3
function DC(n, e = _C) {
  let t = Object.create(null),
    r = Object.create(null),
    i = (o, a) => {
      let l = r[o]
      if (l == null) r[o] = a
      else if (l != a)
        throw new Error(
          'Key binding ' +
            o +
            ' is used both as a regular binding and as a multi-stroke prefix'
        )
    },
    s = (o, a, l, c, u) => {
      var f, p
      let d = t[o] || (t[o] = Object.create(null)),
        O = a.split(/ (?!$)/).map((x) => RC(x, e))
      for (let x = 1; x < O.length; x++) {
        let w = O.slice(0, x).join(' ')
        i(w, !0),
          d[w] ||
            (d[w] = {
              preventDefault: !0,
              stopPropagation: !1,
              run: [
                (Q) => {
                  let T = (Zn = { view: Q, prefix: w, scope: o })
                  return (
                    setTimeout(() => {
                      Zn == T && (Zn = null)
                    }, EC),
                    !0
                  )
                }
              ]
            })
      }
      let g = O.join(' ')
      i(g, !1)
      let b =
        d[g] ||
        (d[g] = {
          preventDefault: !1,
          stopPropagation: !1,
          run:
            ((p = (f = d._any) === null || f === void 0 ? void 0 : f.run) ===
              null || p === void 0
              ? void 0
              : p.slice()) || []
        })
      l && b.run.push(l),
        c && (b.preventDefault = !0),
        u && (b.stopPropagation = !0)
    }
  for (let o of n) {
    let a = o.scope ? o.scope.split(' ') : ['editor']
    if (o.any)
      for (let c of a) {
        let u = t[c] || (t[c] = Object.create(null))
        u._any ||
          (u._any = { preventDefault: !1, stopPropagation: !1, run: [] })
        for (let f in u) u[f].run.push(o.any)
      }
    let l = o[e] || o.key
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation),
          o.shift &&
            s(c, 'Shift-' + l, o.shift, o.preventDefault, o.stopPropagation)
  }
  return t
}
function sb(n, e, t, r) {
  let i = sk(e),
    s = Le(i, 0),
    o = $t(s) == i.length && i != ' ',
    a = '',
    l = !1,
    c = !1,
    u = !1
  Zn &&
    Zn.view == t &&
    Zn.scope == r &&
    ((a = Zn.prefix + ' '),
    By.indexOf(e.keyCode) < 0 && ((c = !0), (Zn = null)))
  let f = new Set(),
    p = (b) => {
      if (b) {
        for (let x of b.run)
          if (!f.has(x) && (f.add(x), x(t, e)))
            return b.stopPropagation && (u = !0), !0
        b.preventDefault && (b.stopPropagation && (u = !0), (c = !0))
      }
      return !1
    },
    d = n[r],
    O,
    g
  return (
    d &&
      (p(d[a + to(i, e, !o)])
        ? (l = !0)
        : o &&
            (e.altKey || e.metaKey || e.ctrlKey) &&
            !(z.windows && e.ctrlKey && e.altKey) &&
            (O = Bn[e.keyCode]) &&
            O != i
          ? (p(d[a + to(O, e, !0)]) ||
              (e.shiftKey &&
                (g = Hi[e.keyCode]) != i &&
                g != O &&
                p(d[a + to(g, e, !1)]))) &&
            (l = !0)
          : o && e.shiftKey && p(d[a + to(i, e, !0)]) && (l = !0),
      !l && p(d._any) && (l = !0)),
    c && (l = !0),
    l && u && e.stopPropagation(),
    l
  )
}
class Ts {
  constructor(e, t, r, i, s) {
    ;(this.className = e),
      (this.left = t),
      (this.top = r),
      (this.width = i),
      (this.height = s)
  }
  draw() {
    let e = document.createElement('div')
    return (e.className = this.className), this.adjust(e), e
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0)
  }
  adjust(e) {
    ;(e.style.left = this.left + 'px'),
      (e.style.top = this.top + 'px'),
      this.width != null && (e.style.width = this.width + 'px'),
      (e.style.height = this.height + 'px')
  }
  eq(e) {
    return (
      this.left == e.left &&
      this.top == e.top &&
      this.width == e.width &&
      this.height == e.height &&
      this.className == e.className
    )
  }
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1)
      if (!i) return []
      let s = ob(e)
      return [new Ts(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)]
    } else return XC(e, t, r)
  }
}
function ob(n) {
  let e = n.scrollDOM.getBoundingClientRect()
  return {
    left:
      (n.textDirection == we.LTR
        ? e.left
        : e.right - n.scrollDOM.clientWidth * n.scaleX) -
      n.scrollDOM.scrollLeft * n.scaleX,
    top: e.top - n.scrollDOM.scrollTop * n.scaleY
  }
}
function Nd(n, e, t) {
  let r = C.cursor(e)
  return {
    from: Math.max(t.from, n.moveToLineBoundary(r, !1, !0).from),
    to: Math.min(t.to, n.moveToLineBoundary(r, !0, !0).from),
    type: nt.Text
  }
}
function XC(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to) return []
  let r = Math.max(t.from, n.viewport.from),
    i = Math.min(t.to, n.viewport.to),
    s = n.textDirection == we.LTR,
    o = n.contentDOM,
    a = o.getBoundingClientRect(),
    l = ob(n),
    c = o.querySelector('.cm-line'),
    u = c && window.getComputedStyle(c),
    f =
      a.left +
      (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0),
    p = a.right - (u ? parseInt(u.paddingRight) : 0),
    d = Yu(n, r),
    O = Yu(n, i),
    g = d.type == nt.Text ? d : null,
    b = O.type == nt.Text ? O : null
  if (
    (g && (n.lineWrapping || d.widgetLineBreaks) && (g = Nd(n, r, g)),
    b && (n.lineWrapping || O.widgetLineBreaks) && (b = Nd(n, i, b)),
    g && b && g.from == b.from)
  )
    return w(Q(t.from, t.to, g))
  {
    let P = g ? Q(t.from, null, g) : T(d, !1),
      k = b ? Q(null, t.to, b) : T(O, !0),
      R = []
    return (
      (g || d).to < (b || O).from - (g && b ? 1 : 0) ||
      (d.widgetLineBreaks > 1 && P.bottom + n.defaultLineHeight / 2 < k.top)
        ? R.push(x(f, P.bottom, p, k.top))
        : P.bottom < k.top &&
          n.elementAtHeight((P.bottom + k.top) / 2).type == nt.Text &&
          (P.bottom = k.top = (P.bottom + k.top) / 2),
      w(P).concat(R).concat(w(k))
    )
  }
  function x(P, k, R, V) {
    return new Ts(e, P - l.left, k - l.top - 0.01, R - P, V - k + 0.01)
  }
  function w({ top: P, bottom: k, horizontal: R }) {
    let V = []
    for (let D = 0; D < R.length; D += 2) V.push(x(R[D], P, R[D + 1], k))
    return V
  }
  function Q(P, k, R) {
    let V = 1e9,
      D = -1e9,
      L = []
    function B(W, K, te, J, ae) {
      let me = n.coordsAtPos(W, W == R.to ? -2 : 2),
        ue = n.coordsAtPos(te, te == R.from ? 2 : -2)
      !me ||
        !ue ||
        ((V = Math.min(me.top, ue.top, V)),
        (D = Math.max(me.bottom, ue.bottom, D)),
        ae == we.LTR
          ? L.push(s && K ? f : me.left, s && J ? p : ue.right)
          : L.push(!s && J ? f : ue.left, !s && K ? p : me.right))
    }
    let A = P ?? R.from,
      Y = k ?? R.to
    for (let W of n.visibleRanges)
      if (W.to > A && W.from < Y)
        for (let K = Math.max(W.from, A), te = Math.min(W.to, Y); ; ) {
          let J = n.state.doc.lineAt(K)
          for (let ae of n.bidiSpans(J)) {
            let me = ae.from + J.from,
              ue = ae.to + J.from
            if (me >= te) break
            ue > K &&
              B(
                Math.max(me, K),
                P == null && me <= A,
                Math.min(ue, te),
                k == null && ue >= Y,
                ae.dir
              )
          }
          if (((K = J.to + 1), K >= te)) break
        }
    return (
      L.length == 0 && B(A, P == null, Y, k == null, n.textDirection),
      { top: V, bottom: D, horizontal: L }
    )
  }
  function T(P, k) {
    let R = a.top + (k ? P.top : P.bottom)
    return { top: R, bottom: R, horizontal: [] }
  }
}
function YC(n, e) {
  return n.constructor == e.constructor && n.eq(e)
}
class IC {
  constructor(e, t) {
    ;(this.view = e),
      (this.layer = t),
      (this.drawn = []),
      (this.scaleX = 1),
      (this.scaleY = 1),
      (this.measureReq = {
        read: this.measure.bind(this),
        write: this.draw.bind(this)
      }),
      (this.dom = e.scrollDOM.appendChild(document.createElement('div'))),
      this.dom.classList.add('cm-layer'),
      t.above && this.dom.classList.add('cm-layer-above'),
      t.class && this.dom.classList.add(t.class),
      this.scale(),
      this.dom.setAttribute('aria-hidden', 'true'),
      this.setOrder(e.state),
      e.requestMeasure(this.measureReq),
      t.mount && t.mount(this.dom, e)
  }
  update(e) {
    e.startState.facet(jo) != e.state.facet(jo) && this.setOrder(e.state),
      (this.layer.update(e, this.dom) || e.geometryChanged) &&
        (this.scale(), e.view.requestMeasure(this.measureReq))
  }
  setOrder(e) {
    let t = 0,
      r = e.facet(jo)
    for (; t < r.length && r[t] != this.layer; ) t++
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t)
  }
  measure() {
    return this.layer.markers(this.view)
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view
    ;(e != this.scaleX || t != this.scaleY) &&
      ((this.scaleX = e),
      (this.scaleY = t),
      (this.dom.style.transform = `scale(${1 / e}, ${1 / t})`))
  }
  draw(e) {
    if (
      e.length != this.drawn.length ||
      e.some((t, r) => !YC(t, this.drawn[r]))
    ) {
      let t = this.dom.firstChild,
        r = 0
      for (let i of e)
        i.update &&
        t &&
        i.constructor &&
        this.drawn[r].constructor &&
        i.update(t, this.drawn[r])
          ? ((t = t.nextSibling), r++)
          : this.dom.insertBefore(i.draw(), t)
      for (; t; ) {
        let i = t.nextSibling
        t.remove(), (t = i)
      }
      this.drawn = e
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view),
      this.dom.remove()
  }
}
const jo = U.define()
function ab(n) {
  return [_e.define((e) => new IC(e, n)), jo.of(n)]
}
const lb = !z.ios,
  ts = U.define({
    combine(n) {
      return on(
        n,
        { cursorBlinkRate: 1200, drawRangeCursor: !0 },
        {
          cursorBlinkRate: (e, t) => Math.min(e, t),
          drawRangeCursor: (e, t) => e || t
        }
      )
    }
  })
function jC(n = {}) {
  return [ts.of(n), NC, MC, VC, Ry.of(!0)]
}
function cb(n) {
  return n.startState.facet(ts) != n.state.facet(ts)
}
const NC = ab({
  above: !0,
  markers(n) {
    let { state: e } = n,
      t = e.facet(ts),
      r = []
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main
      if (i.empty ? !s || lb : t.drawRangeCursor) {
        let o = s
            ? 'cm-cursor cm-cursor-primary'
            : 'cm-cursor cm-cursor-secondary',
          a = i.empty ? i : C.cursor(i.head, i.head > i.anchor ? -1 : 1)
        for (let l of Ts.forRange(n, o, a)) r.push(l)
      }
    }
    return r
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) &&
      (e.style.animationName =
        e.style.animationName == 'cm-blink' ? 'cm-blink2' : 'cm-blink')
    let t = cb(n)
    return t && Md(n.state, e), n.docChanged || n.selectionSet || t
  },
  mount(n, e) {
    Md(e.state, n)
  },
  class: 'cm-cursorLayer'
})
function Md(n, e) {
  e.style.animationDuration = n.facet(ts).cursorBlinkRate + 'ms'
}
const MC = ab({
    above: !1,
    markers(n) {
      return n.state.selection.ranges
        .map((e) =>
          e.empty ? [] : Ts.forRange(n, 'cm-selectionBackground', e)
        )
        .reduce((e, t) => e.concat(t))
    },
    update(n, e) {
      return n.docChanged || n.selectionSet || n.viewportChanged || cb(n)
    },
    class: 'cm-selectionLayer'
  }),
  ub = {
    '.cm-line': {
      '& ::selection': { backgroundColor: 'transparent !important' },
      '&::selection': { backgroundColor: 'transparent !important' }
    }
  }
lb && (ub['.cm-line'].caretColor = 'transparent !important')
const VC = vr.highest(j.theme(ub)),
  fb = ee.define({
    map(n, e) {
      return n == null ? null : e.mapPos(n)
    }
  }),
  Ni = je.define({
    create() {
      return null
    },
    update(n, e) {
      return (
        n != null && (n = e.changes.mapPos(n)),
        e.effects.reduce((t, r) => (r.is(fb) ? r.value : t), n)
      )
    }
  }),
  WC = _e.fromClass(
    class {
      constructor(n) {
        ;(this.view = n),
          (this.cursor = null),
          (this.measureReq = {
            read: this.readPos.bind(this),
            write: this.drawCursor.bind(this)
          })
      }
      update(n) {
        var e
        let t = n.state.field(Ni)
        t == null
          ? this.cursor != null &&
            ((e = this.cursor) === null || e === void 0 || e.remove(),
            (this.cursor = null))
          : (this.cursor ||
              ((this.cursor = this.view.scrollDOM.appendChild(
                document.createElement('div')
              )),
              (this.cursor.className = 'cm-dropCursor')),
            (n.startState.field(Ni) != t ||
              n.docChanged ||
              n.geometryChanged) &&
              this.view.requestMeasure(this.measureReq))
      }
      readPos() {
        let { view: n } = this,
          e = n.state.field(Ni),
          t = e != null && n.coordsAtPos(e)
        if (!t) return null
        let r = n.scrollDOM.getBoundingClientRect()
        return {
          left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
          top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
          height: t.bottom - t.top
        }
      }
      drawCursor(n) {
        if (this.cursor) {
          let { scaleX: e, scaleY: t } = this.view
          n
            ? ((this.cursor.style.left = n.left / e + 'px'),
              (this.cursor.style.top = n.top / t + 'px'),
              (this.cursor.style.height = n.height / t + 'px'))
            : (this.cursor.style.left = '-100000px')
        }
      }
      destroy() {
        this.cursor && this.cursor.remove()
      }
      setDropPos(n) {
        this.view.state.field(Ni) != n &&
          this.view.dispatch({ effects: fb.of(n) })
      }
    },
    {
      eventObservers: {
        dragover(n) {
          this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }))
        },
        dragleave(n) {
          ;(n.target == this.view.contentDOM ||
            !this.view.contentDOM.contains(n.relatedTarget)) &&
            this.setDropPos(null)
        },
        dragend() {
          this.setDropPos(null)
        },
        drop() {
          this.setDropPos(null)
        }
      }
    }
  )
function LC() {
  return [Ni, WC]
}
function Vd(n, e, t, r, i) {
  e.lastIndex = 0
  for (let s = n.iterRange(t, r), o = t, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak) for (; (a = e.exec(s.value)); ) i(o + a.index, a)
}
function BC(n, e) {
  let t = n.visibleRanges
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t
  let r = []
  for (let { from: i, to: s } of t)
    (i = Math.max(n.state.doc.lineAt(i).from, i - e)),
      (s = Math.min(n.state.doc.lineAt(s).to, s + e)),
      r.length && r[r.length - 1].to >= i
        ? (r[r.length - 1].to = s)
        : r.push({ from: i, to: s })
  return r
}
class UC {
  constructor(e) {
    const {
      regexp: t,
      decoration: r,
      decorate: i,
      boundary: s,
      maxLength: o = 1e3
    } = e
    if (!t.global)
      throw new RangeError(
        "The regular expression given to MatchDecorator should have its 'g' flag set"
      )
    if (((this.regexp = t), i))
      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l)
    else if (typeof r == 'function')
      this.addMatch = (a, l, c, u) => {
        let f = r(a, l, c)
        f && u(c, c + a[0].length, f)
      }
    else if (r) this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r)
    else
      throw new RangeError(
        "Either 'decorate' or 'decoration' should be provided to MatchDecorator"
      )
    ;(this.boundary = s), (this.maxLength = o)
  }
  createDeco(e) {
    let t = new Wn(),
      r = t.add.bind(t)
    for (let { from: i, to: s } of BC(e, this.maxLength))
      Vd(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, r))
    return t.finish()
  }
  updateDeco(e, t) {
    let r = 1e9,
      i = -1
    return (
      e.docChanged &&
        e.changes.iterChanges((s, o, a, l) => {
          l > e.view.viewport.from &&
            a < e.view.viewport.to &&
            ((r = Math.min(a, r)), (i = Math.max(l, i)))
        }),
      e.viewportChanged || i - r > 1e3
        ? this.createDeco(e.view)
        : i > -1
          ? this.updateRange(e.view, t.map(e.changes), r, i)
          : t
    )
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r),
        a = Math.min(s.to, i)
      if (a > o) {
        let l = e.state.doc.lineAt(o),
          c = l.to < a ? e.state.doc.lineAt(a) : l,
          u = Math.max(s.from, l.from),
          f = Math.min(s.to, c.to)
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o
              break
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              f = a
              break
            }
        }
        let p = [],
          d,
          O = (g, b, x) => p.push(x.range(g, b))
        if (l == c)
          for (
            this.regexp.lastIndex = u - l.from;
            (d = this.regexp.exec(l.text)) && d.index < f - l.from;

          )
            this.addMatch(d, e, d.index + l.from, O)
        else
          Vd(e.state.doc, this.regexp, u, f, (g, b) =>
            this.addMatch(b, e, g, O)
          )
        t = t.update({
          filterFrom: u,
          filterTo: f,
          filter: (g, b) => g < u || b > f,
          add: p
        })
      }
    }
    return t
  }
}
const Vu = /x/.unicode != null ? 'gu' : 'g',
  qC = new RegExp(
    `[\0-\b
--\u2028\u2029\uFEFF-]`,
    Vu
  ),
  zC = {
    0: 'null',
    7: 'bell',
    8: 'backspace',
    10: 'newline',
    11: 'vertical tab',
    13: 'carriage return',
    27: 'escape',
    8203: 'zero width space',
    8204: 'zero width non-joiner',
    8205: 'zero width joiner',
    8206: 'left-to-right mark',
    8207: 'right-to-left mark',
    8232: 'line separator',
    8237: 'left-to-right override',
    8238: 'right-to-left override',
    8294: 'left-to-right isolate',
    8295: 'right-to-left isolate',
    8297: 'pop directional isolate',
    8233: 'paragraph separator',
    65279: 'zero width no-break space',
    65532: 'object replacement'
  }
let oc = null
function FC() {
  var n
  if (oc == null && typeof document < 'u' && document.body) {
    let e = document.body.style
    oc = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null
  }
  return oc || !1
}
const No = U.define({
  combine(n) {
    let e = on(n, { render: null, specialChars: qC, addSpecialChars: null })
    return (
      (e.replaceTabs = !FC()) &&
        (e.specialChars = new RegExp('	|' + e.specialChars.source, Vu)),
      e.addSpecialChars &&
        (e.specialChars = new RegExp(
          e.specialChars.source + '|' + e.addSpecialChars.source,
          Vu
        )),
      e
    )
  }
})
function GC(n = {}) {
  return [No.of(n), HC()]
}
let Wd = null
function HC() {
  return (
    Wd ||
    (Wd = _e.fromClass(
      class {
        constructor(n) {
          ;(this.view = n),
            (this.decorations = G.none),
            (this.decorationCache = Object.create(null)),
            (this.decorator = this.makeDecorator(n.state.facet(No))),
            (this.decorations = this.decorator.createDeco(n))
        }
        makeDecorator(n) {
          return new UC({
            regexp: n.specialChars,
            decoration: (e, t, r) => {
              let { doc: i } = t.state,
                s = Le(e[0], 0)
              if (s == 9) {
                let o = i.lineAt(r),
                  a = t.state.tabSize,
                  l = oi(o.text, a, r - o.from)
                return G.replace({
                  widget: new t_(
                    ((a - (l % a)) * this.view.defaultCharacterWidth) /
                      this.view.scaleX
                  )
                })
              }
              return (
                this.decorationCache[s] ||
                (this.decorationCache[s] = G.replace({ widget: new e_(n, s) }))
              )
            },
            boundary: n.replaceTabs ? void 0 : /[^]/
          })
        }
        update(n) {
          let e = n.state.facet(No)
          n.startState.facet(No) != e
            ? ((this.decorator = this.makeDecorator(e)),
              (this.decorations = this.decorator.createDeco(n.view)))
            : (this.decorations = this.decorator.updateDeco(
                n,
                this.decorations
              ))
        }
      },
      { decorations: (n) => n.decorations }
    ))
  )
}
const KC = ''
function JC(n) {
  return n >= 32 ? KC : n == 10 ? '' : String.fromCharCode(9216 + n)
}
class e_ extends an {
  constructor(e, t) {
    super(), (this.options = e), (this.code = t)
  }
  eq(e) {
    return e.code == this.code
  }
  toDOM(e) {
    let t = JC(this.code),
      r =
        e.state.phrase('Control character') +
        ' ' +
        (zC[this.code] || '0x' + this.code.toString(16)),
      i = this.options.render && this.options.render(this.code, r, t)
    if (i) return i
    let s = document.createElement('span')
    return (
      (s.textContent = t),
      (s.title = r),
      s.setAttribute('aria-label', r),
      (s.className = 'cm-specialChar'),
      s
    )
  }
  ignoreEvent() {
    return !1
  }
}
class t_ extends an {
  constructor(e) {
    super(), (this.width = e)
  }
  eq(e) {
    return e.width == this.width
  }
  toDOM() {
    let e = document.createElement('span')
    return (
      (e.textContent = '	'),
      (e.className = 'cm-tab'),
      (e.style.width = this.width + 'px'),
      e
    )
  }
  ignoreEvent() {
    return !1
  }
}
function n_() {
  return i_
}
const r_ = G.line({ class: 'cm-activeLine' }),
  i_ = _e.fromClass(
    class {
      constructor(n) {
        this.decorations = this.getDeco(n)
      }
      update(n) {
        ;(n.docChanged || n.selectionSet) &&
          (this.decorations = this.getDeco(n.view))
      }
      getDeco(n) {
        let e = -1,
          t = []
        for (let r of n.state.selection.ranges) {
          let i = n.lineBlockAt(r.head)
          i.from > e && (t.push(r_.range(i.from)), (e = i.from))
        }
        return G.set(t)
      }
    },
    { decorations: (n) => n.decorations }
  )
class s_ extends an {
  constructor(e) {
    super(), (this.content = e)
  }
  toDOM() {
    let e = document.createElement('span')
    return (
      (e.className = 'cm-placeholder'),
      (e.style.pointerEvents = 'none'),
      e.appendChild(
        typeof this.content == 'string'
          ? document.createTextNode(this.content)
          : this.content
      ),
      typeof this.content == 'string'
        ? e.setAttribute('aria-label', 'placeholder ' + this.content)
        : e.setAttribute('aria-hidden', 'true'),
      e
    )
  }
  coordsAt(e) {
    let t = e.firstChild ? Gr(e.firstChild) : []
    if (!t.length) return null
    let r = window.getComputedStyle(e.parentNode),
      i = gl(t[0], r.direction != 'rtl'),
      s = parseInt(r.lineHeight)
    return i.bottom - i.top > s * 1.5
      ? { left: i.left, right: i.right, top: i.top, bottom: i.top + s }
      : i
  }
  ignoreEvent() {
    return !1
  }
}
function o_(n) {
  return _e.fromClass(
    class {
      constructor(e) {
        ;(this.view = e),
          (this.placeholder = n
            ? G.set([G.widget({ widget: new s_(n), side: 1 }).range(0)])
            : G.none)
      }
      get decorations() {
        return this.view.state.doc.length ? G.none : this.placeholder
      }
    },
    { decorations: (e) => e.decorations }
  )
}
const Wu = 2e3
function a_(n, e, t) {
  let r = Math.min(e.line, t.line),
    i = Math.max(e.line, t.line),
    s = []
  if (e.off > Wu || t.off > Wu || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off),
      a = Math.max(e.off, t.off)
    for (let l = r; l <= i; l++) {
      let c = n.doc.line(l)
      c.length <= a && s.push(C.range(c.from + o, c.to + a))
    }
  } else {
    let o = Math.min(e.col, t.col),
      a = Math.max(e.col, t.col)
    for (let l = r; l <= i; l++) {
      let c = n.doc.line(l),
        u = xu(c.text, o, n.tabSize, !0)
      if (u < 0) s.push(C.cursor(c.to))
      else {
        let f = xu(c.text, a, n.tabSize)
        s.push(C.range(c.from + u, c.from + f))
      }
    }
  }
  return s
}
function l_(n, e) {
  let t = n.coordsAtPos(n.viewport.from)
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1
}
function Ld(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1),
    r = n.state.doc.lineAt(t),
    i = t - r.from,
    s =
      i > Wu
        ? -1
        : i == r.length
          ? l_(n, e.clientX)
          : oi(r.text, n.state.tabSize, t - r.from)
  return { line: r.number, col: s, off: i }
}
function c_(n, e) {
  let t = Ld(n, e),
    r = n.state.selection
  return t
    ? {
        update(i) {
          if (i.docChanged) {
            let s = i.changes.mapPos(i.startState.doc.line(t.line).from),
              o = i.state.doc.lineAt(s)
            ;(t = {
              line: o.number,
              col: t.col,
              off: Math.min(t.off, o.length)
            }),
              (r = r.map(i.changes))
          }
        },
        get(i, s, o) {
          let a = Ld(n, i)
          if (!a) return r
          let l = a_(n.state, t, a)
          return l.length ? (o ? C.create(l.concat(r.ranges)) : C.create(l)) : r
        }
      }
    : null
}
function u_(n) {
  let e =
    (n == null ? void 0 : n.eventFilter) || ((t) => t.altKey && t.button == 0)
  return j.mouseSelectionStyle.of((t, r) => (e(r) ? c_(t, r) : null))
}
const f_ = {
    Alt: [18, (n) => !!n.altKey],
    Control: [17, (n) => !!n.ctrlKey],
    Shift: [16, (n) => !!n.shiftKey],
    Meta: [91, (n) => !!n.metaKey]
  },
  h_ = { style: 'cursor: crosshair' }
function p_(n = {}) {
  let [e, t] = f_[n.key || 'Alt'],
    r = _e.fromClass(
      class {
        constructor(i) {
          ;(this.view = i), (this.isDown = !1)
        }
        set(i) {
          this.isDown != i && ((this.isDown = i), this.view.update([]))
        }
      },
      {
        eventObservers: {
          keydown(i) {
            this.set(i.keyCode == e || t(i))
          },
          keyup(i) {
            ;(i.keyCode == e || !t(i)) && this.set(!1)
          },
          mousemove(i) {
            this.set(t(i))
          }
        }
      }
    )
  return [
    r,
    j.contentAttributes.of((i) => {
      var s
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown
        ? h_
        : null
    })
  ]
}
const Ti = '-10000px'
class hb {
  constructor(e, t, r) {
    ;(this.facet = t),
      (this.createTooltipView = r),
      (this.input = e.state.facet(t)),
      (this.tooltips = this.input.filter((i) => i)),
      (this.tooltipViews = this.tooltips.map(r))
  }
  update(e, t) {
    var r
    let i = e.state.facet(this.facet),
      s = i.filter((l) => l)
    if (i === this.input) {
      for (let l of this.tooltipViews) l.update && l.update(e)
      return !1
    }
    let o = [],
      a = t ? [] : null
    for (let l = 0; l < s.length; l++) {
      let c = s[l],
        u = -1
      if (c) {
        for (let f = 0; f < this.tooltips.length; f++) {
          let p = this.tooltips[f]
          p && p.create == c.create && (u = f)
        }
        if (u < 0) (o[l] = this.createTooltipView(c)), a && (a[l] = !!c.above)
        else {
          let f = (o[l] = this.tooltipViews[u])
          a && (a[l] = t[u]), f.update && f.update(e)
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 &&
        (l.dom.remove(), (r = l.destroy) === null || r === void 0 || r.call(l))
    return (
      t && (a.forEach((l, c) => (t[c] = l)), (t.length = a.length)),
      (this.input = i),
      (this.tooltips = s),
      (this.tooltipViews = o),
      !0
    )
  }
}
function d_(n) {
  let { win: e } = n
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth }
}
const ac = U.define({
    combine: (n) => {
      var e, t, r
      return {
        position: z.ios
          ? 'absolute'
          : ((e = n.find((i) => i.position)) === null || e === void 0
              ? void 0
              : e.position) || 'fixed',
        parent:
          ((t = n.find((i) => i.parent)) === null || t === void 0
            ? void 0
            : t.parent) || null,
        tooltipSpace:
          ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0
            ? void 0
            : r.tooltipSpace) || d_
      }
    }
  }),
  Bd = new WeakMap(),
  pb = _e.fromClass(
    class {
      constructor(n) {
        ;(this.view = n),
          (this.above = []),
          (this.inView = !0),
          (this.madeAbsolute = !1),
          (this.lastTransaction = 0),
          (this.measureTimeout = -1)
        let e = n.state.facet(ac)
        ;(this.position = e.position),
          (this.parent = e.parent),
          (this.classes = n.themeClasses),
          this.createContainer(),
          (this.measureReq = {
            read: this.readMeasure.bind(this),
            write: this.writeMeasure.bind(this),
            key: this
          }),
          (this.manager = new hb(n, jf, (t) => this.createTooltip(t))),
          (this.intersectionObserver =
            typeof IntersectionObserver == 'function'
              ? new IntersectionObserver(
                  (t) => {
                    Date.now() > this.lastTransaction - 50 &&
                      t.length > 0 &&
                      t[t.length - 1].intersectionRatio < 1 &&
                      this.measureSoon()
                  },
                  { threshold: [1] }
                )
              : null),
          this.observeIntersection(),
          n.win.addEventListener(
            'resize',
            (this.measureSoon = this.measureSoon.bind(this))
          ),
          this.maybeMeasure()
      }
      createContainer() {
        this.parent
          ? ((this.container = document.createElement('div')),
            (this.container.style.position = 'relative'),
            (this.container.className = this.view.themeClasses),
            this.parent.appendChild(this.container))
          : (this.container = this.view.dom)
      }
      observeIntersection() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect()
          for (let n of this.manager.tooltipViews)
            this.intersectionObserver.observe(n.dom)
        }
      }
      measureSoon() {
        this.measureTimeout < 0 &&
          (this.measureTimeout = setTimeout(() => {
            ;(this.measureTimeout = -1), this.maybeMeasure()
          }, 50))
      }
      update(n) {
        n.transactions.length && (this.lastTransaction = Date.now())
        let e = this.manager.update(n, this.above)
        e && this.observeIntersection()
        let t = e || n.geometryChanged,
          r = n.state.facet(ac)
        if (r.position != this.position && !this.madeAbsolute) {
          this.position = r.position
          for (let i of this.manager.tooltipViews)
            i.dom.style.position = this.position
          t = !0
        }
        if (r.parent != this.parent) {
          this.parent && this.container.remove(),
            (this.parent = r.parent),
            this.createContainer()
          for (let i of this.manager.tooltipViews)
            this.container.appendChild(i.dom)
          t = !0
        } else
          this.parent &&
            this.view.themeClasses != this.classes &&
            (this.classes = this.container.className = this.view.themeClasses)
        t && this.maybeMeasure()
      }
      createTooltip(n) {
        let e = n.create(this.view)
        if (
          (e.dom.classList.add('cm-tooltip'),
          n.arrow && !e.dom.querySelector('.cm-tooltip > .cm-tooltip-arrow'))
        ) {
          let t = document.createElement('div')
          ;(t.className = 'cm-tooltip-arrow'), e.dom.appendChild(t)
        }
        return (
          (e.dom.style.position = this.position),
          (e.dom.style.top = Ti),
          (e.dom.style.left = '0px'),
          this.container.appendChild(e.dom),
          e.mount && e.mount(this.view),
          e
        )
      }
      destroy() {
        var n, e
        this.view.win.removeEventListener('resize', this.measureSoon)
        for (let t of this.manager.tooltipViews)
          t.dom.remove(), (n = t.destroy) === null || n === void 0 || n.call(t)
        this.parent && this.container.remove(),
          (e = this.intersectionObserver) === null ||
            e === void 0 ||
            e.disconnect(),
          clearTimeout(this.measureTimeout)
      }
      readMeasure() {
        let n = this.view.dom.getBoundingClientRect(),
          e = 1,
          t = 1,
          r = !1
        if (this.position == 'fixed' && this.manager.tooltipViews.length) {
          let { dom: i } = this.manager.tooltipViews[0]
          if (z.gecko) r = i.offsetParent != this.container.ownerDocument.body
          else if (this.view.scaleX != 1 || this.view.scaleY != 1) r = !0
          else if (i.style.top == Ti && i.style.left == '0px') {
            let s = i.getBoundingClientRect()
            r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1
          }
        }
        if (r || this.position == 'absolute')
          if (this.parent) {
            let i = this.parent.getBoundingClientRect()
            i.width &&
              i.height &&
              ((e = i.width / this.parent.offsetWidth),
              (t = i.height / this.parent.offsetHeight))
          } else ({ scaleX: e, scaleY: t } = this.view.viewState)
        return {
          editor: n,
          parent: this.parent ? this.container.getBoundingClientRect() : n,
          pos: this.manager.tooltips.map((i, s) => {
            let o = this.manager.tooltipViews[s]
            return o.getCoords
              ? o.getCoords(i.pos)
              : this.view.coordsAtPos(i.pos)
          }),
          size: this.manager.tooltipViews.map(({ dom: i }) =>
            i.getBoundingClientRect()
          ),
          space: this.view.state.facet(ac).tooltipSpace(this.view),
          scaleX: e,
          scaleY: t,
          makeAbsolute: r
        }
      }
      writeMeasure(n) {
        var e
        if (n.makeAbsolute) {
          ;(this.madeAbsolute = !0), (this.position = 'absolute')
          for (let a of this.manager.tooltipViews)
            a.dom.style.position = 'absolute'
        }
        let { editor: t, space: r, scaleX: i, scaleY: s } = n,
          o = []
        for (let a = 0; a < this.manager.tooltips.length; a++) {
          let l = this.manager.tooltips[a],
            c = this.manager.tooltipViews[a],
            { dom: u } = c,
            f = n.pos[a],
            p = n.size[a]
          if (
            !f ||
            f.bottom <= Math.max(t.top, r.top) ||
            f.top >= Math.min(t.bottom, r.bottom) ||
            f.right < Math.max(t.left, r.left) - 0.1 ||
            f.left > Math.min(t.right, r.right) + 0.1
          ) {
            u.style.top = Ti
            continue
          }
          let d = l.arrow ? c.dom.querySelector('.cm-tooltip-arrow') : null,
            O = d ? 7 : 0,
            g = p.right - p.left,
            b = (e = Bd.get(c)) !== null && e !== void 0 ? e : p.bottom - p.top,
            x = c.offset || m_,
            w = this.view.textDirection == we.LTR,
            Q =
              p.width > r.right - r.left
                ? w
                  ? r.left
                  : r.right - p.width
                : w
                  ? Math.min(f.left - (d ? 14 : 0) + x.x, r.right - g)
                  : Math.max(r.left, f.left - g + (d ? 14 : 0) - x.x),
            T = this.above[a]
          !l.strictSide &&
            (T
              ? f.top - (p.bottom - p.top) - x.y < r.top
              : f.bottom + (p.bottom - p.top) + x.y > r.bottom) &&
            T == r.bottom - f.bottom > f.top - r.top &&
            (T = this.above[a] = !T)
          let P = (T ? f.top - r.top : r.bottom - f.bottom) - O
          if (P < b && c.resize !== !1) {
            if (P < this.view.defaultLineHeight) {
              u.style.top = Ti
              continue
            }
            Bd.set(c, b), (u.style.height = (b = P) / s + 'px')
          } else u.style.height && (u.style.height = '')
          let k = T ? f.top - b - O - x.y : f.bottom + O + x.y,
            R = Q + g
          if (c.overlap !== !0)
            for (let V of o)
              V.left < R &&
                V.right > Q &&
                V.top < k + b &&
                V.bottom > k &&
                (k = T ? V.top - b - 2 - O : V.bottom + O + 2)
          if (
            (this.position == 'absolute'
              ? ((u.style.top = (k - n.parent.top) / s + 'px'),
                (u.style.left = (Q - n.parent.left) / i + 'px'))
              : ((u.style.top = k / s + 'px'), (u.style.left = Q / i + 'px')),
            d)
          ) {
            let V = f.left + (w ? x.x : -x.x) - (Q + 14 - 7)
            d.style.left = V / i + 'px'
          }
          c.overlap !== !0 &&
            o.push({ left: Q, top: k, right: R, bottom: k + b }),
            u.classList.toggle('cm-tooltip-above', T),
            u.classList.toggle('cm-tooltip-below', !T),
            c.positioned && c.positioned(n.space)
        }
      }
      maybeMeasure() {
        if (
          this.manager.tooltips.length &&
          (this.view.inView && this.view.requestMeasure(this.measureReq),
          this.inView != this.view.inView &&
            ((this.inView = this.view.inView), !this.inView))
        )
          for (let n of this.manager.tooltipViews) n.dom.style.top = Ti
      }
    },
    {
      eventObservers: {
        scroll() {
          this.maybeMeasure()
        }
      }
    }
  ),
  O_ = j.baseTheme({
    '.cm-tooltip': { zIndex: 100, boxSizing: 'border-box' },
    '&light .cm-tooltip': {
      border: '1px solid #bbb',
      backgroundColor: '#f5f5f5'
    },
    '&light .cm-tooltip-section:not(:first-child)': {
      borderTop: '1px solid #bbb'
    },
    '&dark .cm-tooltip': { backgroundColor: '#333338', color: 'white' },
    '.cm-tooltip-arrow': {
      height: '7px',
      width: `${7 * 2}px`,
      position: 'absolute',
      zIndex: -1,
      overflow: 'hidden',
      '&:before, &:after': {
        content: "''",
        position: 'absolute',
        width: 0,
        height: 0,
        borderLeft: '7px solid transparent',
        borderRight: '7px solid transparent'
      },
      '.cm-tooltip-above &': {
        bottom: '-7px',
        '&:before': { borderTop: '7px solid #bbb' },
        '&:after': { borderTop: '7px solid #f5f5f5', bottom: '1px' }
      },
      '.cm-tooltip-below &': {
        top: '-7px',
        '&:before': { borderBottom: '7px solid #bbb' },
        '&:after': { borderBottom: '7px solid #f5f5f5', top: '1px' }
      }
    },
    '&dark .cm-tooltip .cm-tooltip-arrow': {
      '&:before': { borderTopColor: '#333338', borderBottomColor: '#333338' },
      '&:after': {
        borderTopColor: 'transparent',
        borderBottomColor: 'transparent'
      }
    }
  }),
  m_ = { x: 0, y: 0 },
  jf = U.define({ enables: [pb, O_] }),
  ka = U.define()
class Nf {
  static create(e) {
    return new Nf(e)
  }
  constructor(e) {
    ;(this.view = e),
      (this.mounted = !1),
      (this.dom = document.createElement('div')),
      this.dom.classList.add('cm-tooltip-hover'),
      (this.manager = new hb(e, ka, (t) => this.createHostedView(t)))
  }
  createHostedView(e) {
    let t = e.create(this.view)
    return (
      t.dom.classList.add('cm-tooltip-section'),
      this.dom.appendChild(t.dom),
      this.mounted && t.mount && t.mount(this.view),
      t
    )
  }
  mount(e) {
    for (let t of this.manager.tooltipViews) t.mount && t.mount(e)
    this.mounted = !0
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews) t.positioned && t.positioned(e)
  }
  update(e) {
    this.manager.update(e)
  }
  destroy() {
    var e
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t)
  }
  passProp(e) {
    let t
    for (let r of this.manager.tooltipViews) {
      let i = r[e]
      if (i !== void 0) {
        if (t === void 0) t = i
        else if (t !== i) return
      }
    }
    return t
  }
  get offset() {
    return this.passProp('offset')
  }
  get getCoords() {
    return this.passProp('getCoords')
  }
  get overlap() {
    return this.passProp('overlap')
  }
  get resize() {
    return this.passProp('resize')
  }
}
const g_ = jf.compute([ka], (n) => {
  let e = n.facet(ka).filter((t) => t)
  return e.length === 0
    ? null
    : {
        pos: Math.min(...e.map((t) => t.pos)),
        end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
        create: Nf.create,
        above: e[0].above,
        arrow: e.some((t) => t.arrow)
      }
})
class y_ {
  constructor(e, t, r, i, s) {
    ;(this.view = e),
      (this.source = t),
      (this.field = r),
      (this.setHover = i),
      (this.hoverTime = s),
      (this.hoverTimeout = -1),
      (this.restartTimeout = -1),
      (this.pending = null),
      (this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }),
      (this.checkHover = this.checkHover.bind(this)),
      e.dom.addEventListener(
        'mouseleave',
        (this.mouseleave = this.mouseleave.bind(this))
      ),
      e.dom.addEventListener(
        'mousemove',
        (this.mousemove = this.mousemove.bind(this))
      )
  }
  update() {
    this.pending &&
      ((this.pending = null),
      clearTimeout(this.restartTimeout),
      (this.restartTimeout = setTimeout(() => this.startHover(), 20)))
  }
  get active() {
    return this.view.state.field(this.field)
  }
  checkHover() {
    if (((this.hoverTimeout = -1), this.active)) return
    let e = Date.now() - this.lastMove.time
    e < this.hoverTime
      ? (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e))
      : this.startHover()
  }
  startHover() {
    clearTimeout(this.restartTimeout)
    let { view: e, lastMove: t } = this,
      r = e.docView.nearest(t.target)
    if (!r) return
    let i,
      s = 1
    if (r instanceof Xn) i = r.posAtStart
    else {
      if (((i = e.posAtCoords(t)), i == null)) return
      let a = e.coordsAtPos(i)
      if (
        !a ||
        t.y < a.top ||
        t.y > a.bottom ||
        t.x < a.left - e.defaultCharacterWidth ||
        t.x > a.right + e.defaultCharacterWidth
      )
        return
      let l = e
          .bidiSpans(e.state.doc.lineAt(i))
          .find((u) => u.from <= i && u.to >= i),
        c = l && l.dir == we.RTL ? -1 : 1
      s = t.x < a.left ? -c : c
    }
    let o = this.source(e, i, s)
    if (o != null && o.then) {
      let a = (this.pending = { pos: i })
      o.then(
        (l) => {
          this.pending == a &&
            ((this.pending = null),
            l && e.dispatch({ effects: this.setHover.of(l) }))
        },
        (l) => _t(e.state, l, 'hover tooltip')
      )
    } else o && e.dispatch({ effects: this.setHover.of(o) })
  }
  mousemove(e) {
    var t
    ;(this.lastMove = {
      x: e.clientX,
      y: e.clientY,
      target: e.target,
      time: Date.now()
    }),
      this.hoverTimeout < 0 &&
        (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime))
    let r = this.active
    if ((r && !Ud(this.lastMove.target)) || this.pending) {
      let { pos: i } = r || this.pending,
        s = (t = r == null ? void 0 : r.end) !== null && t !== void 0 ? t : i
      ;(i == s
        ? this.view.posAtCoords(this.lastMove) != i
        : !b_(this.view, i, s, e.clientX, e.clientY)) &&
        (this.view.dispatch({ effects: this.setHover.of(null) }),
        (this.pending = null))
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout),
      (this.hoverTimeout = -1),
      this.active &&
        !Ud(e.relatedTarget) &&
        this.view.dispatch({ effects: this.setHover.of(null) })
  }
  destroy() {
    clearTimeout(this.hoverTimeout),
      this.view.dom.removeEventListener('mouseleave', this.mouseleave),
      this.view.dom.removeEventListener('mousemove', this.mousemove)
  }
}
function Ud(n) {
  for (let e = n; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains('cm-tooltip')) return !0
  return !1
}
function b_(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(),
    a = n.documentTop + n.documentPadding.top + n.contentHeight
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, a) < i)
    return !1
  let l = n.posAtCoords({ x: r, y: i }, !1)
  return l >= e && l <= t
}
function v_(n, e = {}) {
  let t = ee.define(),
    r = je.define({
      create() {
        return null
      },
      update(i, s) {
        if (
          i &&
          ((e.hideOnChange && (s.docChanged || s.selection)) ||
            (e.hideOn && e.hideOn(s, i)))
        )
          return null
        if (i && s.docChanged) {
          let o = s.changes.mapPos(i.pos, -1, Ue.TrackDel)
          if (o == null) return null
          let a = Object.assign(Object.create(null), i)
          ;(a.pos = o),
            i.end != null && (a.end = s.changes.mapPos(i.end)),
            (i = a)
        }
        for (let o of s.effects)
          o.is(t) && (i = o.value), o.is(S_) && (i = null)
        return i
      },
      provide: (i) => ka.from(i)
    })
  return [r, _e.define((i) => new y_(i, n, r, t, e.hoverTime || 300)), g_]
}
function db(n, e) {
  let t = n.plugin(pb)
  if (!t) return null
  let r = t.manager.tooltips.indexOf(e)
  return r < 0 ? null : t.manager.tooltipViews[r]
}
const S_ = ee.define(),
  qd = U.define({
    combine(n) {
      let e, t
      for (let r of n) (e = e || r.topContainer), (t = t || r.bottomContainer)
      return { topContainer: e, bottomContainer: t }
    }
  })
function ns(n, e) {
  let t = n.plugin(Ob),
    r = t ? t.specs.indexOf(e) : -1
  return r > -1 ? t.panels[r] : null
}
const Ob = _e.fromClass(
  class {
    constructor(n) {
      ;(this.input = n.state.facet(rs)),
        (this.specs = this.input.filter((t) => t)),
        (this.panels = this.specs.map((t) => t(n)))
      let e = n.state.facet(qd)
      ;(this.top = new no(n, !0, e.topContainer)),
        (this.bottom = new no(n, !1, e.bottomContainer)),
        this.top.sync(this.panels.filter((t) => t.top)),
        this.bottom.sync(this.panels.filter((t) => !t.top))
      for (let t of this.panels)
        t.dom.classList.add('cm-panel'), t.mount && t.mount()
    }
    update(n) {
      let e = n.state.facet(qd)
      this.top.container != e.topContainer &&
        (this.top.sync([]), (this.top = new no(n.view, !0, e.topContainer))),
        this.bottom.container != e.bottomContainer &&
          (this.bottom.sync([]),
          (this.bottom = new no(n.view, !1, e.bottomContainer))),
        this.top.syncClasses(),
        this.bottom.syncClasses()
      let t = n.state.facet(rs)
      if (t != this.input) {
        let r = t.filter((l) => l),
          i = [],
          s = [],
          o = [],
          a = []
        for (let l of r) {
          let c = this.specs.indexOf(l),
            u
          c < 0
            ? ((u = l(n.view)), a.push(u))
            : ((u = this.panels[c]), u.update && u.update(n)),
            i.push(u),
            (u.top ? s : o).push(u)
        }
        ;(this.specs = r),
          (this.panels = i),
          this.top.sync(s),
          this.bottom.sync(o)
        for (let l of a) l.dom.classList.add('cm-panel'), l.mount && l.mount()
      } else for (let r of this.panels) r.update && r.update(n)
    }
    destroy() {
      this.top.sync([]), this.bottom.sync([])
    }
  },
  {
    provide: (n) =>
      j.scrollMargins.of((e) => {
        let t = e.plugin(n)
        return (
          t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() }
        )
      })
  }
)
class no {
  constructor(e, t, r) {
    ;(this.view = e),
      (this.top = t),
      (this.container = r),
      (this.dom = void 0),
      (this.classes = ''),
      (this.panels = []),
      this.syncClasses()
  }
  sync(e) {
    for (let t of this.panels) t.destroy && e.indexOf(t) < 0 && t.destroy()
    ;(this.panels = e), this.syncDOM()
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), (this.dom = void 0))
      return
    }
    if (!this.dom) {
      ;(this.dom = document.createElement('div')),
        (this.dom.className = this.top
          ? 'cm-panels cm-panels-top'
          : 'cm-panels cm-panels-bottom'),
        (this.dom.style[this.top ? 'top' : 'bottom'] = '0')
      let t = this.container || this.view.dom
      t.insertBefore(this.dom, this.top ? t.firstChild : null)
    }
    let e = this.dom.firstChild
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; ) e = zd(e)
        e = e.nextSibling
      } else this.dom.insertBefore(t.dom, e)
    for (; e; ) e = zd(e)
  }
  scrollMargin() {
    return !this.dom || this.container
      ? 0
      : Math.max(
          0,
          this.top
            ? this.dom.getBoundingClientRect().bottom -
                Math.max(0, this.view.scrollDOM.getBoundingClientRect().top)
            : Math.min(
                innerHeight,
                this.view.scrollDOM.getBoundingClientRect().bottom
              ) - this.dom.getBoundingClientRect().top
        )
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(' '))
        e && this.container.classList.remove(e)
      for (let e of (this.classes = this.view.themeClasses).split(' '))
        e && this.container.classList.add(e)
    }
  }
}
function zd(n) {
  let e = n.nextSibling
  return n.remove(), e
}
const rs = U.define({ enables: Ob })
class xn extends Or {
  compare(e) {
    return this == e || (this.constructor == e.constructor && this.eq(e))
  }
  eq(e) {
    return !1
  }
  destroy(e) {}
}
xn.prototype.elementClass = ''
xn.prototype.toDOM = void 0
xn.prototype.mapMode = Ue.TrackBefore
xn.prototype.startSide = xn.prototype.endSide = -1
xn.prototype.point = !0
const Mo = U.define(),
  x_ = {
    class: '',
    renderEmptyElements: !1,
    elementStyle: '',
    markers: () => ce.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  },
  Ui = U.define()
function w_(n) {
  return [mb(), Ui.of(Object.assign(Object.assign({}, x_), n))]
}
const Lu = U.define({ combine: (n) => n.some((e) => e) })
function mb(n) {
  let e = [P_]
  return n && n.fixed === !1 && e.push(Lu.of(!0)), e
}
const P_ = _e.fromClass(
  class {
    constructor(n) {
      ;(this.view = n),
        (this.prevViewport = n.viewport),
        (this.dom = document.createElement('div')),
        (this.dom.className = 'cm-gutters'),
        this.dom.setAttribute('aria-hidden', 'true'),
        (this.dom.style.minHeight =
          this.view.contentHeight / this.view.scaleY + 'px'),
        (this.gutters = n.state.facet(Ui).map((e) => new Gd(n, e)))
      for (let e of this.gutters) this.dom.appendChild(e.dom)
      ;(this.fixed = !n.state.facet(Lu)),
        this.fixed && (this.dom.style.position = 'sticky'),
        this.syncGutters(!1),
        n.scrollDOM.insertBefore(this.dom, n.contentDOM)
    }
    update(n) {
      if (this.updateGutters(n)) {
        let e = this.prevViewport,
          t = n.view.viewport,
          r = Math.min(e.to, t.to) - Math.max(e.from, t.from)
        this.syncGutters(r < (t.to - t.from) * 0.8)
      }
      n.geometryChanged &&
        (this.dom.style.minHeight = this.view.contentHeight + 'px'),
        this.view.state.facet(Lu) != !this.fixed &&
          ((this.fixed = !this.fixed),
          (this.dom.style.position = this.fixed ? 'sticky' : '')),
        (this.prevViewport = n.view.viewport)
    }
    syncGutters(n) {
      let e = this.dom.nextSibling
      n && this.dom.remove()
      let t = ce.iter(this.view.state.facet(Mo), this.view.viewport.from),
        r = [],
        i = this.gutters.map(
          (s) => new T_(s, this.view.viewport, -this.view.documentPadding.top)
        )
      for (let s of this.view.viewportLineBlocks)
        if ((r.length && (r = []), Array.isArray(s.type))) {
          let o = !0
          for (let a of s.type)
            if (a.type == nt.Text && o) {
              Bu(t, r, a.from)
              for (let l of i) l.line(this.view, a, r)
              o = !1
            } else if (a.widget) for (let l of i) l.widget(this.view, a)
        } else if (s.type == nt.Text) {
          Bu(t, r, s.from)
          for (let o of i) o.line(this.view, s, r)
        } else if (s.widget) for (let o of i) o.widget(this.view, s)
      for (let s of i) s.finish()
      n && this.view.scrollDOM.insertBefore(this.dom, e)
    }
    updateGutters(n) {
      let e = n.startState.facet(Ui),
        t = n.state.facet(Ui),
        r =
          n.docChanged ||
          n.heightChanged ||
          n.viewportChanged ||
          !ce.eq(
            n.startState.facet(Mo),
            n.state.facet(Mo),
            n.view.viewport.from,
            n.view.viewport.to
          )
      if (e == t) for (let i of this.gutters) i.update(n) && (r = !0)
      else {
        r = !0
        let i = []
        for (let s of t) {
          let o = e.indexOf(s)
          o < 0
            ? i.push(new Gd(this.view, s))
            : (this.gutters[o].update(n), i.push(this.gutters[o]))
        }
        for (let s of this.gutters)
          s.dom.remove(), i.indexOf(s) < 0 && s.destroy()
        for (let s of i) this.dom.appendChild(s.dom)
        this.gutters = i
      }
      return r
    }
    destroy() {
      for (let n of this.gutters) n.destroy()
      this.dom.remove()
    }
  },
  {
    provide: (n) =>
      j.scrollMargins.of((e) => {
        let t = e.plugin(n)
        return !t || t.gutters.length == 0 || !t.fixed
          ? null
          : e.textDirection == we.LTR
            ? { left: t.dom.offsetWidth * e.scaleX }
            : { right: t.dom.offsetWidth * e.scaleX }
      })
  }
)
function Fd(n) {
  return Array.isArray(n) ? n : [n]
}
function Bu(n, e, t) {
  for (; n.value && n.from <= t; ) n.from == t && e.push(n.value), n.next()
}
class T_ {
  constructor(e, t, r) {
    ;(this.gutter = e),
      (this.height = r),
      (this.i = 0),
      (this.cursor = ce.iter(e.markers, t.from))
  }
  addElement(e, t, r) {
    let { gutter: i } = this,
      s = (t.top - this.height) / e.scaleY,
      o = t.height / e.scaleY
    if (this.i == i.elements.length) {
      let a = new gb(e, o, s, r)
      i.elements.push(a), i.dom.appendChild(a.dom)
    } else i.elements[this.i].update(e, o, s, r)
    ;(this.height = t.bottom), this.i++
  }
  line(e, t, r) {
    let i = []
    Bu(this.cursor, i, t.from), r.length && (i = i.concat(r))
    let s = this.gutter.config.lineMarker(e, t, i)
    s && i.unshift(s)
    let o = this.gutter
    ;(i.length == 0 && !o.config.renderEmptyElements) ||
      this.addElement(e, t, i)
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t)
    r && this.addElement(e, t, [r])
  }
  finish() {
    let e = this.gutter
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop()
      e.dom.removeChild(t.dom), t.destroy()
    }
  }
}
class Gd {
  constructor(e, t) {
    ;(this.view = e),
      (this.config = t),
      (this.elements = []),
      (this.spacer = null),
      (this.dom = document.createElement('div')),
      (this.dom.className =
        'cm-gutter' + (this.config.class ? ' ' + this.config.class : ''))
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target,
          o
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; ) s = s.parentNode
          let l = s.getBoundingClientRect()
          o = (l.top + l.bottom) / 2
        } else o = i.clientY
        let a = e.lineBlockAtHeight(o - e.documentTop)
        t.domEventHandlers[r](e, a, i) && i.preventDefault()
      })
    ;(this.markers = Fd(t.markers(e))),
      t.initialSpacer &&
        ((this.spacer = new gb(e, 0, 0, [t.initialSpacer(e)])),
        this.dom.appendChild(this.spacer.dom),
        (this.spacer.dom.style.cssText +=
          'visibility: hidden; pointer-events: none'))
  }
  update(e) {
    let t = this.markers
    if (
      ((this.markers = Fd(this.config.markers(e.view))),
      this.spacer && this.config.updateSpacer)
    ) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e)
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i])
    }
    let r = e.view.viewport
    return (
      !ce.eq(this.markers, t, r.from, r.to) ||
      (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1)
    )
  }
  destroy() {
    for (let e of this.elements) e.destroy()
  }
}
class gb {
  constructor(e, t, r, i) {
    ;(this.height = -1),
      (this.above = 0),
      (this.markers = []),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-gutterElement'),
      this.update(e, t, r, i)
  }
  update(e, t, r, i) {
    this.height != t && ((this.height = t), (this.dom.style.height = t + 'px')),
      this.above != r &&
        (this.dom.style.marginTop = (this.above = r) ? r + 'px' : ''),
      $_(this.markers, i) || this.setMarkers(e, i)
  }
  setMarkers(e, t) {
    let r = 'cm-gutterElement',
      i = this.dom.firstChild
    for (let s = 0, o = 0; ; ) {
      let a = o,
        l = s < t.length ? t[s++] : null,
        c = !1
      if (l) {
        let u = l.elementClass
        u && (r += ' ' + u)
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(l)) {
            ;(a = f), (c = !0)
            break
          }
      } else a = this.markers.length
      for (; o < a; ) {
        let u = this.markers[o++]
        if (u.toDOM) {
          u.destroy(i)
          let f = i.nextSibling
          i.remove(), (i = f)
        }
      }
      if (!l) break
      l.toDOM &&
        (c ? (i = i.nextSibling) : this.dom.insertBefore(l.toDOM(e), i)),
        c && o++
    }
    ;(this.dom.className = r), (this.markers = t)
  }
  destroy() {
    this.setMarkers(null, [])
  }
}
function $_(n, e) {
  if (n.length != e.length) return !1
  for (let t = 0; t < n.length; t++) if (!n[t].compare(e[t])) return !1
  return !0
}
const Q_ = U.define(),
  Dr = U.define({
    combine(n) {
      return on(
        n,
        { formatNumber: String, domEventHandlers: {} },
        {
          domEventHandlers(e, t) {
            let r = Object.assign({}, e)
            for (let i in t) {
              let s = r[i],
                o = t[i]
              r[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o
            }
            return r
          }
        }
      )
    }
  })
class lc extends xn {
  constructor(e) {
    super(), (this.number = e)
  }
  eq(e) {
    return this.number == e.number
  }
  toDOM() {
    return document.createTextNode(this.number)
  }
}
function cc(n, e) {
  return n.state.facet(Dr).formatNumber(e, n.state)
}
const k_ = Ui.compute([Dr], (n) => ({
  class: 'cm-lineNumbers',
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Q_)
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM)
      ? null
      : new lc(cc(e, e.state.doc.lineAt(t.from).number))
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Dr) != e.state.facet(Dr),
  initialSpacer(e) {
    return new lc(cc(e, Hd(e.state.doc.lines)))
  },
  updateSpacer(e, t) {
    let r = cc(t.view, Hd(t.view.state.doc.lines))
    return r == e.number ? e : new lc(r)
  },
  domEventHandlers: n.facet(Dr).domEventHandlers
}))
function C_(n = {}) {
  return [Dr.of(n), mb(), k_]
}
function Hd(n) {
  let e = 9
  for (; e < n; ) e = e * 10 + 9
  return e
}
const __ = new (class extends xn {
    constructor() {
      super(...arguments), (this.elementClass = 'cm-activeLineGutter')
    }
  })(),
  R_ = Mo.compute(['selection'], (n) => {
    let e = [],
      t = -1
    for (let r of n.selection.ranges) {
      let i = n.doc.lineAt(r.head).from
      i > t && ((t = i), e.push(__.range(i)))
    }
    return ce.of(e)
  })
function Z_() {
  return R_
}
const yb = 1024
let A_ = 0
class kt {
  constructor(e, t) {
    ;(this.from = e), (this.to = t)
  }
}
class re {
  constructor(e = {}) {
    ;(this.id = A_++),
      (this.perNode = !!e.perNode),
      (this.deserialize =
        e.deserialize ||
        (() => {
          throw new Error(
            "This node type doesn't define a deserialize function"
          )
        }))
  }
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types")
    return (
      typeof e != 'function' && (e = it.match(e)),
      (t) => {
        let r = e(t)
        return r === void 0 ? null : [this, r]
      }
    )
  }
}
re.closedBy = new re({ deserialize: (n) => n.split(' ') })
re.openedBy = new re({ deserialize: (n) => n.split(' ') })
re.group = new re({ deserialize: (n) => n.split(' ') })
re.contextHash = new re({ perNode: !0 })
re.lookAhead = new re({ perNode: !0 })
re.mounted = new re({ perNode: !0 })
class is {
  constructor(e, t, r) {
    ;(this.tree = e), (this.overlay = t), (this.parser = r)
  }
  static get(e) {
    return e && e.props && e.props[re.mounted.id]
  }
}
const E_ = Object.create(null)
class it {
  constructor(e, t, r, i = 0) {
    ;(this.name = e), (this.props = t), (this.id = r), (this.flags = i)
  }
  static define(e) {
    let t = e.props && e.props.length ? Object.create(null) : E_,
      r =
        (e.top ? 1 : 0) |
        (e.skipped ? 2 : 0) |
        (e.error ? 4 : 0) |
        (e.name == null ? 8 : 0),
      i = new it(e.name || '', t, e.id, r)
    if (e.props) {
      for (let s of e.props)
        if ((Array.isArray(s) || (s = s(i)), s)) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type")
          t[s[0].id] = s[1]
        }
    }
    return i
  }
  prop(e) {
    return this.props[e.id]
  }
  get isTop() {
    return (this.flags & 1) > 0
  }
  get isSkipped() {
    return (this.flags & 2) > 0
  }
  get isError() {
    return (this.flags & 4) > 0
  }
  get isAnonymous() {
    return (this.flags & 8) > 0
  }
  is(e) {
    if (typeof e == 'string') {
      if (this.name == e) return !0
      let t = this.prop(re.group)
      return t ? t.indexOf(e) > -1 : !1
    }
    return this.id == e
  }
  static match(e) {
    let t = Object.create(null)
    for (let r in e) for (let i of r.split(' ')) t[i] = e[r]
    return (r) => {
      for (let i = r.prop(re.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]]
        if (o) return o
      }
    }
  }
}
it.none = new it('', Object.create(null), 0, 8)
class Mf {
  constructor(e) {
    this.types = e
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError(
          'Node type ids should correspond to array positions when creating a node set'
        )
  }
  extend(...e) {
    let t = []
    for (let r of this.types) {
      let i = null
      for (let s of e) {
        let o = s(r)
        o && (i || (i = Object.assign({}, r.props)), (i[o[0].id] = o[1]))
      }
      t.push(i ? new it(r.name, i, r.id, r.flags) : r)
    }
    return new Mf(t)
  }
}
const ro = new WeakMap(),
  Kd = new WeakMap()
var Oe
;(function (n) {
  ;(n[(n.ExcludeBuffers = 1)] = 'ExcludeBuffers'),
    (n[(n.IncludeAnonymous = 2)] = 'IncludeAnonymous'),
    (n[(n.IgnoreMounts = 4)] = 'IgnoreMounts'),
    (n[(n.IgnoreOverlays = 8)] = 'IgnoreOverlays')
})(Oe || (Oe = {}))
class Pe {
  constructor(e, t, r, i, s) {
    if (
      ((this.type = e),
      (this.children = t),
      (this.positions = r),
      (this.length = i),
      (this.props = null),
      s && s.length)
    ) {
      this.props = Object.create(null)
      for (let [o, a] of s) this.props[typeof o == 'number' ? o : o.id] = a
    }
  }
  toString() {
    let e = is.get(this)
    if (e && !e.overlay) return e.tree.toString()
    let t = ''
    for (let r of this.children) {
      let i = r.toString()
      i && (t && (t += ','), (t += i))
    }
    return this.type.name
      ? (/\W/.test(this.type.name) && !this.type.isError
          ? JSON.stringify(this.type.name)
          : this.type.name) + (t.length ? '(' + t + ')' : '')
      : t
  }
  cursor(e = 0) {
    return new Ca(this.topNode, e)
  }
  cursorAt(e, t = 0, r = 0) {
    let i = ro.get(this) || this.topNode,
      s = new Ca(i)
    return s.moveTo(e, t), ro.set(this, s._tree), s
  }
  get topNode() {
    return new Ke(this, 0, 0, null)
  }
  resolve(e, t = 0) {
    let r = ss(ro.get(this) || this.topNode, e, t, !1)
    return ro.set(this, r), r
  }
  resolveInner(e, t = 0) {
    let r = ss(Kd.get(this) || this.topNode, e, t, !0)
    return Kd.set(this, r), r
  }
  resolveStack(e, t = 0) {
    return Y_(this, e, t)
  }
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e,
      o = e.mode || 0,
      a = (o & Oe.IncludeAnonymous) > 0
    for (let l = this.cursor(o | Oe.IncludeAnonymous); ; ) {
      let c = !1
      if (
        l.from <= s &&
        l.to >= i &&
        ((!a && l.type.isAnonymous) || t(l) !== !1)
      ) {
        if (l.firstChild()) continue
        c = !0
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent()) return
        c = !0
      }
    }
  }
  prop(e) {
    return e.perNode
      ? this.props
        ? this.props[e.id]
        : void 0
      : this.type.prop(e)
  }
  get propValues() {
    let e = []
    if (this.props) for (let t in this.props) e.push([+t, this.props[t]])
    return e
  }
  balance(e = {}) {
    return this.children.length <= 8
      ? this
      : Lf(
          it.none,
          this.children,
          this.positions,
          0,
          this.children.length,
          0,
          this.length,
          (t, r, i) => new Pe(this.type, t, r, i, this.propValues),
          e.makeTree || ((t, r, i) => new Pe(it.none, t, r, i))
        )
  }
  static build(e) {
    return I_(e)
  }
}
Pe.empty = new Pe(it.none, [], [], 0)
class Vf {
  constructor(e, t) {
    ;(this.buffer = e), (this.index = t)
  }
  get id() {
    return this.buffer[this.index - 4]
  }
  get start() {
    return this.buffer[this.index - 3]
  }
  get end() {
    return this.buffer[this.index - 2]
  }
  get size() {
    return this.buffer[this.index - 1]
  }
  get pos() {
    return this.index
  }
  next() {
    this.index -= 4
  }
  fork() {
    return new Vf(this.buffer, this.index)
  }
}
class qn {
  constructor(e, t, r) {
    ;(this.buffer = e), (this.length = t), (this.set = r)
  }
  get type() {
    return it.none
  }
  toString() {
    let e = []
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), (t = this.buffer[t + 3])
    return e.join(',')
  }
  childString(e) {
    let t = this.buffer[e],
      r = this.buffer[e + 3],
      i = this.set.types[t],
      s = i.name
    if (
      (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), (e += 4), r == e)
    )
      return s
    let o = []
    for (; e < r; ) o.push(this.childString(e)), (e = this.buffer[e + 3])
    return s + '(' + o.join(',') + ')'
  }
  findChild(e, t, r, i, s) {
    let { buffer: o } = this,
      a = -1
    for (
      let l = e;
      l != t && !(bb(s, i, o[l + 1], o[l + 2]) && ((a = l), r > 0));
      l = o[l + 3]
    );
    return a
  }
  slice(e, t, r) {
    let i = this.buffer,
      s = new Uint16Array(t - e),
      o = 0
    for (let a = e, l = 0; a < t; ) {
      ;(s[l++] = i[a++]), (s[l++] = i[a++] - r)
      let c = (s[l++] = i[a++] - r)
      ;(s[l++] = i[a++] - e), (o = Math.max(o, c))
    }
    return new qn(s, o, this.set)
  }
}
function bb(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e
    case -1:
      return r >= e && t < e
    case 0:
      return t < e && r > e
    case 1:
      return t <= e && r > e
    case 2:
      return r > e
    case 4:
      return !0
  }
}
function ss(n, e, t, r) {
  for (
    var i;
    n.from == n.to ||
    (t < 1 ? n.from >= e : n.from > e) ||
    (t > -1 ? n.to <= e : n.to < e);

  ) {
    let o = !r && n instanceof Ke && n.index < 0 ? null : n.parent
    if (!o) return n
    n = o
  }
  let s = r ? 0 : Oe.IgnoreOverlays
  if (r)
    for (let o = n, a = o.parent; a; o = a, a = o.parent)
      o instanceof Ke &&
        o.index < 0 &&
        ((i = a.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) !=
          o.from &&
        (n = a)
  for (;;) {
    let o = n.enter(e, t, s)
    if (!o) return n
    n = o
  }
}
class vb {
  cursor(e = 0) {
    return new Ca(this, e)
  }
  getChild(e, t = null, r = null) {
    let i = Jd(this, e, t, r)
    return i.length ? i[0] : null
  }
  getChildren(e, t = null, r = null) {
    return Jd(this, e, t, r)
  }
  resolve(e, t = 0) {
    return ss(this, e, t, !1)
  }
  resolveInner(e, t = 0) {
    return ss(this, e, t, !0)
  }
  matchContext(e) {
    return Uu(this, e)
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e),
      r = this
    for (; t; ) {
      let i = t.lastChild
      if (!i || i.to != t.to) break
      i.type.isError && i.from == i.to
        ? ((r = t), (t = i.prevSibling))
        : (t = i)
    }
    return r
  }
  get node() {
    return this
  }
  get next() {
    return this.parent
  }
}
class Ke extends vb {
  constructor(e, t, r, i) {
    super(),
      (this._tree = e),
      (this.from = t),
      (this.index = r),
      (this._parent = i)
  }
  get type() {
    return this._tree.type
  }
  get name() {
    return this._tree.type.name
  }
  get to() {
    return this.from + this._tree.length
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (
        let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1;
        e != c;
        e += t
      ) {
        let u = a[e],
          f = l[e] + o.from
        if (bb(i, r, f, f + u.length)) {
          if (u instanceof qn) {
            if (s & Oe.ExcludeBuffers) continue
            let p = u.findChild(0, u.buffer.length, t, r - f, i)
            if (p > -1) return new Jt(new D_(o, u, e, f), null, p)
          } else if (s & Oe.IncludeAnonymous || !u.type.isAnonymous || Wf(u)) {
            let p
            if (!(s & Oe.IgnoreMounts) && (p = is.get(u)) && !p.overlay)
              return new Ke(p.tree, f, e, o)
            let d = new Ke(u, f, e, o)
            return s & Oe.IncludeAnonymous || !d.type.isAnonymous
              ? d
              : d.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i)
          }
        }
      }
      if (
        s & Oe.IncludeAnonymous ||
        !o.type.isAnonymous ||
        (o.index >= 0
          ? (e = o.index + t)
          : (e = t < 0 ? -1 : o._parent._tree.children.length),
        (o = o._parent),
        !o)
      )
        return null
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4)
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4)
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2)
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2)
  }
  enter(e, t, r = 0) {
    let i
    if (!(r & Oe.IgnoreOverlays) && (i = is.get(this._tree)) && i.overlay) {
      let s = e - this.from
      for (let { from: o, to: a } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? a >= s : a > s))
          return new Ke(i.tree, i.overlay[0].from + this.from, -1, this)
    }
    return this.nextChild(0, 1, e, t, r)
  }
  nextSignificantParent() {
    let e = this
    for (; e.type.isAnonymous && e._parent; ) e = e._parent
    return e
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null
  }
  get nextSibling() {
    return this._parent && this.index >= 0
      ? this._parent.nextChild(this.index + 1, 1, 0, 4)
      : null
  }
  get prevSibling() {
    return this._parent && this.index >= 0
      ? this._parent.nextChild(this.index - 1, -1, 0, 4)
      : null
  }
  get tree() {
    return this._tree
  }
  toTree() {
    return this._tree
  }
  toString() {
    return this._tree.toString()
  }
}
function Jd(n, e, t, r) {
  let i = n.cursor(),
    s = []
  if (!i.firstChild()) return s
  if (t != null) {
    for (; !i.type.is(t); ) if (!i.nextSibling()) return s
  }
  for (;;) {
    if (r != null && i.type.is(r)) return s
    if ((i.type.is(e) && s.push(i.node), !i.nextSibling()))
      return r == null ? s : []
  }
}
function Uu(n, e, t = e.length - 1) {
  for (let r = n.parent; t >= 0; r = r.parent) {
    if (!r) return !1
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name) return !1
      t--
    }
  }
  return !0
}
class D_ {
  constructor(e, t, r, i) {
    ;(this.parent = e), (this.buffer = t), (this.index = r), (this.start = i)
  }
}
class Jt extends vb {
  get name() {
    return this.type.name
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1]
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2]
  }
  constructor(e, t, r) {
    super(),
      (this.context = e),
      (this._parent = t),
      (this.index = r),
      (this.type = e.buffer.set.types[e.buffer.buffer[r]])
  }
  child(e, t, r) {
    let { buffer: i } = this.context,
      s = i.findChild(
        this.index + 4,
        i.buffer[this.index + 3],
        e,
        t - this.context.start,
        r
      )
    return s < 0 ? null : new Jt(this.context, this, s)
  }
  get firstChild() {
    return this.child(1, 0, 4)
  }
  get lastChild() {
    return this.child(-1, 0, 4)
  }
  childAfter(e) {
    return this.child(1, e, 2)
  }
  childBefore(e) {
    return this.child(-1, e, -2)
  }
  enter(e, t, r = 0) {
    if (r & Oe.ExcludeBuffers) return null
    let { buffer: i } = this.context,
      s = i.findChild(
        this.index + 4,
        i.buffer[this.index + 3],
        t > 0 ? 1 : -1,
        e - this.context.start,
        t
      )
    return s < 0 ? null : new Jt(this.context, this, s)
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent()
  }
  externalSibling(e) {
    return this._parent
      ? null
      : this.context.parent.nextChild(this.context.index + e, e, 0, 4)
  }
  get nextSibling() {
    let { buffer: e } = this.context,
      t = e.buffer[this.index + 3]
    return t <
      (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length)
      ? new Jt(this.context, this._parent, t)
      : this.externalSibling(1)
  }
  get prevSibling() {
    let { buffer: e } = this.context,
      t = this._parent ? this._parent.index + 4 : 0
    return this.index == t
      ? this.externalSibling(-1)
      : new Jt(this.context, this._parent, e.findChild(t, this.index, -1, 0, 4))
  }
  get tree() {
    return null
  }
  toTree() {
    let e = [],
      t = [],
      { buffer: r } = this.context,
      i = this.index + 4,
      s = r.buffer[this.index + 3]
    if (s > i) {
      let o = r.buffer[this.index + 1]
      e.push(r.slice(i, s, o)), t.push(0)
    }
    return new Pe(this.type, e, t, this.to - this.from)
  }
  toString() {
    return this.context.buffer.childString(this.index)
  }
}
function Sb(n) {
  if (!n.length) return null
  let e = 0,
    t = n[0]
  for (let s = 1; s < n.length; s++) {
    let o = n[s]
    ;(o.from > t.from || o.to < t.to) && ((t = o), (e = s))
  }
  let r = t instanceof Ke && t.index < 0 ? null : t.parent,
    i = n.slice()
  return r ? (i[e] = r) : i.splice(e, 1), new X_(i, t)
}
class X_ {
  constructor(e, t) {
    ;(this.heads = e), (this.node = t)
  }
  get next() {
    return Sb(this.heads)
  }
}
function Y_(n, e, t) {
  let r = n.resolveInner(e, t),
    i = null
  for (let s = r instanceof Ke ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent
      ;(i || (i = [r])).push(o.resolve(e, t)), (s = o)
    } else {
      let o = is.get(s.tree)
      if (
        o &&
        o.overlay &&
        o.overlay[0].from <= e &&
        o.overlay[o.overlay.length - 1].to >= e
      ) {
        let a = new Ke(o.tree, o.overlay[0].from + s.from, -1, s)
        ;(i || (i = [r])).push(ss(a, e, t, !1))
      }
    }
  return i ? Sb(i) : r
}
class Ca {
  get name() {
    return this.type.name
  }
  constructor(e, t = 0) {
    if (
      ((this.mode = t),
      (this.buffer = null),
      (this.stack = []),
      (this.index = 0),
      (this.bufferNode = null),
      e instanceof Ke)
    )
      this.yieldNode(e)
    else {
      ;(this._tree = e.context.parent), (this.buffer = e.context)
      for (let r = e._parent; r; r = r._parent) this.stack.unshift(r.index)
      ;(this.bufferNode = e), this.yieldBuf(e.index)
    }
  }
  yieldNode(e) {
    return e
      ? ((this._tree = e),
        (this.type = e.type),
        (this.from = e.from),
        (this.to = e.to),
        !0)
      : !1
  }
  yieldBuf(e, t) {
    this.index = e
    let { start: r, buffer: i } = this.buffer
    return (
      (this.type = t || i.set.types[i.buffer[e]]),
      (this.from = r + i.buffer[e + 1]),
      (this.to = r + i.buffer[e + 2]),
      !0
    )
  }
  yield(e) {
    return e
      ? e instanceof Ke
        ? ((this.buffer = null), this.yieldNode(e))
        : ((this.buffer = e.context), this.yieldBuf(e.index, e.type))
      : !1
  }
  toString() {
    return this.buffer
      ? this.buffer.buffer.childString(this.index)
      : this._tree.toString()
  }
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(
        this._tree.nextChild(
          e < 0 ? this._tree._tree.children.length - 1 : 0,
          e,
          t,
          r,
          this.mode
        )
      )
    let { buffer: i } = this.buffer,
      s = i.findChild(
        this.index + 4,
        i.buffer[this.index + 3],
        e,
        t - this.buffer.start,
        r
      )
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s))
  }
  firstChild() {
    return this.enterChild(1, 0, 4)
  }
  lastChild() {
    return this.enterChild(-1, 0, 4)
  }
  childAfter(e) {
    return this.enterChild(1, e, 2)
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2)
  }
  enter(e, t, r = this.mode) {
    return this.buffer
      ? r & Oe.ExcludeBuffers
        ? !1
        : this.enterChild(1, e, t)
      : this.yield(this._tree.enter(e, t, r))
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(
        this.mode & Oe.IncludeAnonymous ? this._tree._parent : this._tree.parent
      )
    if (this.stack.length) return this.yieldBuf(this.stack.pop())
    let e =
      this.mode & Oe.IncludeAnonymous
        ? this.buffer.parent
        : this.buffer.parent.nextSignificantParent()
    return (this.buffer = null), this.yieldNode(e)
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent
        ? this.yield(
            this._tree.index < 0
              ? null
              : this._tree._parent.nextChild(
                  this._tree.index + e,
                  e,
                  0,
                  4,
                  this.mode
                )
          )
        : !1
    let { buffer: t } = this.buffer,
      r = this.stack.length - 1
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4
      if (this.index != i)
        return this.yieldBuf(t.findChild(i, this.index, -1, 0, 4))
    } else {
      let i = t.buffer[this.index + 3]
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i)
    }
    return r < 0
      ? this.yield(
          this.buffer.parent.nextChild(
            this.buffer.index + e,
            e,
            0,
            4,
            this.mode
          )
        )
      : !1
  }
  nextSibling() {
    return this.sibling(1)
  }
  prevSibling() {
    return this.sibling(-1)
  }
  atLastNode(e) {
    let t,
      r,
      { buffer: i } = this
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length) return !1
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index) return !1
      ;({ index: t, parent: r } = i)
    } else ({ index: t, _parent: r } = this._tree)
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (
          let s = t + e, o = e < 0 ? -1 : r._tree.children.length;
          s != o;
          s += e
        ) {
          let a = r._tree.children[s]
          if (
            this.mode & Oe.IncludeAnonymous ||
            a instanceof qn ||
            !a.type.isAnonymous ||
            Wf(a)
          )
            return !1
        }
    return !0
  }
  move(e, t) {
    if (t && this.enterChild(e, 0, 4)) return !0
    for (;;) {
      if (this.sibling(e)) return !0
      if (this.atLastNode(e) || !this.parent()) return !1
    }
  }
  next(e = !0) {
    return this.move(1, e)
  }
  prev(e = !0) {
    return this.move(-1, e)
  }
  moveTo(e, t = 0) {
    for (
      ;
      (this.from == this.to ||
        (t < 1 ? this.from >= e : this.from > e) ||
        (t > -1 ? this.to <= e : this.to < e)) &&
      this.parent();

    );
    for (; this.enterChild(1, e, t); );
    return this
  }
  get node() {
    if (!this.buffer) return this._tree
    let e = this.bufferNode,
      t = null,
      r = 0
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index) return o
            ;(t = o), (r = s + 1)
            break e
          }
        i = this.stack[--s]
      }
    for (let i = r; i < this.stack.length; i++)
      t = new Jt(this.buffer, t, this.stack[i])
    return (this.bufferNode = new Jt(this.buffer, t, this.index))
  }
  get tree() {
    return this.buffer ? null : this._tree._tree
  }
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++
          continue
        }
        this.type.isAnonymous || (i = !0)
      }
      for (
        ;
        i && t && t(this), (i = this.type.isAnonymous), !this.nextSibling();

      ) {
        if (!r) return
        this.parent(), r--, (i = !0)
      }
    }
  }
  matchContext(e) {
    if (!this.buffer) return Uu(this.node, e)
    let { buffer: t } = this.buffer,
      { types: r } = t.set
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0) return Uu(this.node, e, i)
      let o = r[t.buffer[this.stack[s]]]
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name) return !1
        i--
      }
    }
    return !0
  }
}
function Wf(n) {
  return n.children.some((e) => e instanceof qn || !e.type.isAnonymous || Wf(e))
}
function I_(n) {
  var e
  let {
      buffer: t,
      nodeSet: r,
      maxBufferLength: i = yb,
      reused: s = [],
      minRepeatType: o = r.types.length
    } = n,
    a = Array.isArray(t) ? new Vf(t, t.length) : t,
    l = r.types,
    c = 0,
    u = 0
  function f(P, k, R, V, D, L) {
    let { id: B, start: A, end: Y, size: W } = a,
      K = u
    for (; W < 0; )
      if ((a.next(), W == -1)) {
        let ue = s[B]
        R.push(ue), V.push(A - P)
        return
      } else if (W == -3) {
        c = B
        return
      } else if (W == -4) {
        u = B
        return
      } else throw new RangeError(`Unrecognized record size: ${W}`)
    let te = l[B],
      J,
      ae,
      me = A - P
    if (Y - A <= i && (ae = b(a.pos - k, D))) {
      let ue = new Uint16Array(ae.size - ae.skip),
        Xe = a.pos - ae.size,
        et = ue.length
      for (; a.pos > Xe; ) et = x(ae.start, ue, et)
      ;(J = new qn(ue, Y - ae.start, r)), (me = ae.start - P)
    } else {
      let ue = a.pos - W
      a.next()
      let Xe = [],
        et = [],
        bt = B >= o ? B : -1,
        Nt = 0,
        oe = Y
      for (; a.pos > ue; )
        bt >= 0 && a.id == bt && a.size >= 0
          ? (a.end <= oe - i &&
              (O(Xe, et, A, Nt, a.end, oe, bt, K),
              (Nt = Xe.length),
              (oe = a.end)),
            a.next())
          : L > 2500
            ? p(A, ue, Xe, et)
            : f(A, ue, Xe, et, bt, L + 1)
      if (
        (bt >= 0 && Nt > 0 && Nt < Xe.length && O(Xe, et, A, Nt, A, oe, bt, K),
        Xe.reverse(),
        et.reverse(),
        bt > -1 && Nt > 0)
      ) {
        let Hn = d(te)
        J = Lf(te, Xe, et, 0, Xe.length, 0, Y - A, Hn, Hn)
      } else J = g(te, Xe, et, Y - A, K - Y)
    }
    R.push(J), V.push(me)
  }
  function p(P, k, R, V) {
    let D = [],
      L = 0,
      B = -1
    for (; a.pos > k; ) {
      let { id: A, start: Y, end: W, size: K } = a
      if (K > 4) a.next()
      else {
        if (B > -1 && Y < B) break
        B < 0 && (B = W - i), D.push(A, Y, W), L++, a.next()
      }
    }
    if (L) {
      let A = new Uint16Array(L * 4),
        Y = D[D.length - 2]
      for (let W = D.length - 3, K = 0; W >= 0; W -= 3)
        (A[K++] = D[W]),
          (A[K++] = D[W + 1] - Y),
          (A[K++] = D[W + 2] - Y),
          (A[K++] = K)
      R.push(new qn(A, D[2] - Y, r)), V.push(Y - P)
    }
  }
  function d(P) {
    return (k, R, V) => {
      let D = 0,
        L = k.length - 1,
        B,
        A
      if (L >= 0 && (B = k[L]) instanceof Pe) {
        if (!L && B.type == P && B.length == V) return B
        ;(A = B.prop(re.lookAhead)) && (D = R[L] + B.length + A)
      }
      return g(P, k, R, V, D)
    }
  }
  function O(P, k, R, V, D, L, B, A) {
    let Y = [],
      W = []
    for (; P.length > V; ) Y.push(P.pop()), W.push(k.pop() + R - D)
    P.push(g(r.types[B], Y, W, L - D, A - L)), k.push(D - R)
  }
  function g(P, k, R, V, D = 0, L) {
    if (c) {
      let B = [re.contextHash, c]
      L = L ? [B].concat(L) : [B]
    }
    if (D > 25) {
      let B = [re.lookAhead, D]
      L = L ? [B].concat(L) : [B]
    }
    return new Pe(P, k, R, V, L)
  }
  function b(P, k) {
    let R = a.fork(),
      V = 0,
      D = 0,
      L = 0,
      B = R.end - i,
      A = { size: 0, start: 0, skip: 0 }
    e: for (let Y = R.pos - P; R.pos > Y; ) {
      let W = R.size
      if (R.id == k && W >= 0) {
        ;(A.size = V), (A.start = D), (A.skip = L), (L += 4), (V += 4), R.next()
        continue
      }
      let K = R.pos - W
      if (W < 0 || K < Y || R.start < B) break
      let te = R.id >= o ? 4 : 0,
        J = R.start
      for (R.next(); R.pos > K; ) {
        if (R.size < 0)
          if (R.size == -3) te += 4
          else break e
        else R.id >= o && (te += 4)
        R.next()
      }
      ;(D = J), (V += W), (L += te)
    }
    return (
      (k < 0 || V == P) && ((A.size = V), (A.start = D), (A.skip = L)),
      A.size > 4 ? A : void 0
    )
  }
  function x(P, k, R) {
    let { id: V, start: D, end: L, size: B } = a
    if ((a.next(), B >= 0 && V < o)) {
      let A = R
      if (B > 4) {
        let Y = a.pos - (B - 4)
        for (; a.pos > Y; ) R = x(P, k, R)
      }
      ;(k[--R] = A), (k[--R] = L - P), (k[--R] = D - P), (k[--R] = V)
    } else B == -3 ? (c = V) : B == -4 && (u = V)
    return R
  }
  let w = [],
    Q = []
  for (; a.pos > 0; ) f(n.start || 0, n.bufferStart || 0, w, Q, -1, 0)
  let T =
    (e = n.length) !== null && e !== void 0
      ? e
      : w.length
        ? Q[0] + w[0].length
        : 0
  return new Pe(l[n.topID], w.reverse(), Q.reverse(), T)
}
const eO = new WeakMap()
function Vo(n, e) {
  if (!n.isAnonymous || e instanceof qn || e.type != n) return 1
  let t = eO.get(e)
  if (t == null) {
    t = 1
    for (let r of e.children) {
      if (r.type != n || !(r instanceof Pe)) {
        t = 1
        break
      }
      t += Vo(n, r)
    }
    eO.set(e, t)
  }
  return t
}
function Lf(n, e, t, r, i, s, o, a, l) {
  let c = 0
  for (let O = r; O < i; O++) c += Vo(n, e[O])
  let u = Math.ceil((c * 1.5) / 8),
    f = [],
    p = []
  function d(O, g, b, x, w) {
    for (let Q = b; Q < x; ) {
      let T = Q,
        P = g[Q],
        k = Vo(n, O[Q])
      for (Q++; Q < x; Q++) {
        let R = Vo(n, O[Q])
        if (k + R >= u) break
        k += R
      }
      if (Q == T + 1) {
        if (k > u) {
          let R = O[T]
          d(R.children, R.positions, 0, R.children.length, g[T] + w)
          continue
        }
        f.push(O[T])
      } else {
        let R = g[Q - 1] + O[Q - 1].length - P
        f.push(Lf(n, O, g, T, Q, P, R, null, l))
      }
      p.push(P + w - s)
    }
  }
  return d(e, t, r, i, 0), (a || l)(f, p, o)
}
class xb {
  constructor() {
    this.map = new WeakMap()
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e)
    i || this.map.set(e, (i = new Map())), i.set(t, r)
  }
  getBuffer(e, t) {
    let r = this.map.get(e)
    return r && r.get(t)
  }
  set(e, t) {
    e instanceof Jt
      ? this.setBuffer(e.context.buffer, e.index, t)
      : e instanceof Ke && this.map.set(e.tree, t)
  }
  get(e) {
    return e instanceof Jt
      ? this.getBuffer(e.context.buffer, e.index)
      : e instanceof Ke
        ? this.map.get(e.tree)
        : void 0
  }
  cursorSet(e, t) {
    e.buffer
      ? this.setBuffer(e.buffer.buffer, e.index, t)
      : this.map.set(e.tree, t)
  }
  cursorGet(e) {
    return e.buffer
      ? this.getBuffer(e.buffer.buffer, e.index)
      : this.map.get(e.tree)
  }
}
class yn {
  constructor(e, t, r, i, s = !1, o = !1) {
    ;(this.from = e),
      (this.to = t),
      (this.tree = r),
      (this.offset = i),
      (this.open = (s ? 1 : 0) | (o ? 2 : 0))
  }
  get openStart() {
    return (this.open & 1) > 0
  }
  get openEnd() {
    return (this.open & 2) > 0
  }
  static addTree(e, t = [], r = !1) {
    let i = [new yn(0, e.length, e, 0, !1, r)]
    for (let s of t) s.to > e.length && i.push(s)
    return i
  }
  static applyChanges(e, t, r = 128) {
    if (!t.length) return e
    let i = [],
      s = 1,
      o = e.length ? e[0] : null
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < t.length ? t[a] : null,
        f = u ? u.fromA : 1e9
      if (f - l >= r)
        for (; o && o.from < f; ) {
          let p = o
          if (l >= p.from || f <= p.to || c) {
            let d = Math.max(p.from, l) - c,
              O = Math.min(p.to, f) - c
            p = d >= O ? null : new yn(d, O, p.tree, p.offset + c, a > 0, !!u)
          }
          if ((p && i.push(p), o.to > f)) break
          o = s < e.length ? e[s++] : null
        }
      if (!u) break
      ;(l = u.toA), (c = u.toA - u.toB)
    }
    return i
  }
}
class wb {
  startParse(e, t, r) {
    return (
      typeof e == 'string' && (e = new j_(e)),
      (r = r
        ? r.length
          ? r.map((i) => new kt(i.from, i.to))
          : [new kt(0, 0)]
        : [new kt(0, e.length)]),
      this.createParse(e, t || [], r)
    )
  }
  parse(e, t, r) {
    let i = this.startParse(e, t, r)
    for (;;) {
      let s = i.advance()
      if (s) return s
    }
  }
}
class j_ {
  constructor(e) {
    this.string = e
  }
  get length() {
    return this.string.length
  }
  chunk(e) {
    return this.string.slice(e)
  }
  get lineChunks() {
    return !1
  }
  read(e, t) {
    return this.string.slice(e, t)
  }
}
function N_(n) {
  return (e, t, r, i) => new V_(e, n, t, r, i)
}
class tO {
  constructor(e, t, r, i, s) {
    ;(this.parser = e),
      (this.parse = t),
      (this.overlay = r),
      (this.target = i),
      (this.from = s)
  }
}
function nO(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError(
      'Invalid inner parse ranges given: ' + JSON.stringify(n)
    )
}
class M_ {
  constructor(e, t, r, i, s, o, a) {
    ;(this.parser = e),
      (this.predicate = t),
      (this.mounts = r),
      (this.index = i),
      (this.start = s),
      (this.target = o),
      (this.prev = a),
      (this.depth = 0),
      (this.ranges = [])
  }
}
const qu = new re({ perNode: !0 })
class V_ {
  constructor(e, t, r, i, s) {
    ;(this.nest = t),
      (this.input = r),
      (this.fragments = i),
      (this.ranges = s),
      (this.inner = []),
      (this.innerDone = 0),
      (this.baseTree = null),
      (this.stoppedAt = null),
      (this.baseParse = e)
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance()
      if (!r) return null
      if (
        ((this.baseParse = null),
        (this.baseTree = r),
        this.startInner(),
        this.stoppedAt != null)
      )
        for (let i of this.inner) i.parse.stopAt(this.stoppedAt)
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree
      return (
        this.stoppedAt != null &&
          (r = new Pe(
            r.type,
            r.children,
            r.positions,
            r.length,
            r.propValues.concat([[qu, this.stoppedAt]])
          )),
        r
      )
    }
    let e = this.inner[this.innerDone],
      t = e.parse.advance()
    if (t) {
      this.innerDone++
      let r = Object.assign(Object.create(null), e.target.props)
      ;(r[re.mounted.id] = new is(t, e.overlay, e.parser)), (e.target.props = r)
    }
    return null
  }
  get parsedPos() {
    if (this.baseParse) return 0
    let e = this.input.length
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos))
    return e
  }
  stopAt(e) {
    if (((this.stoppedAt = e), this.baseParse)) this.baseParse.stopAt(e)
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e)
  }
  startInner() {
    let e = new B_(this.fragments),
      t = null,
      r = null,
      i = new Ca(
        new Ke(this.baseTree, this.ranges[0].from, 0, null),
        Oe.IncludeAnonymous | Oe.IgnoreMounts
      )
    e: for (let s, o; ; ) {
      let a = !0,
        l
      if (this.stoppedAt != null && i.from >= this.stoppedAt) a = !1
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find(
            (u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay
          )
          if (c)
            for (let u of c.mount.overlay) {
              let f = u.from + c.pos,
                p = u.to + c.pos
              f >= i.from &&
                p <= i.to &&
                !t.ranges.some((d) => d.from < p && d.to > f) &&
                t.ranges.push({ from: f, to: p })
            }
        }
        a = !1
      } else if (r && (o = W_(r.ranges, i.from, i.to))) a = o != 2
      else if (
        !i.type.isAnonymous &&
        (s = this.nest(i, this.input)) &&
        (i.from < i.to || !s.overlay)
      ) {
        i.tree || L_(i)
        let c = e.findMounts(i.from, s.parser)
        if (typeof s.overlay == 'function')
          t = new M_(
            s.parser,
            s.overlay,
            c,
            this.inner.length,
            i.from,
            i.tree,
            t
          )
        else {
          let u = sO(
            this.ranges,
            s.overlay || (i.from < i.to ? [new kt(i.from, i.to)] : [])
          )
          u.length && nO(u),
            (u.length || !s.overlay) &&
              this.inner.push(
                new tO(
                  s.parser,
                  u.length
                    ? s.parser.startParse(this.input, oO(c, u), u)
                    : s.parser.startParse(''),
                  s.overlay
                    ? s.overlay.map(
                        (f) => new kt(f.from - i.from, f.to - i.from)
                      )
                    : null,
                  i.tree,
                  u.length ? u[0].from : i.from
                )
              ),
            s.overlay
              ? u.length && (r = { ranges: u, depth: 0, prev: r })
              : (a = !1)
        }
      } else
        t &&
          (l = t.predicate(i)) &&
          (l === !0 && (l = new kt(i.from, i.to)),
          l.from < l.to && t.ranges.push(l))
      if (a && i.firstChild()) t && t.depth++, r && r.depth++
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent()) break e
          if (t && !--t.depth) {
            let c = sO(this.ranges, t.ranges)
            c.length &&
              (nO(c),
              this.inner.splice(
                t.index,
                0,
                new tO(
                  t.parser,
                  t.parser.startParse(this.input, oO(t.mounts, c), c),
                  t.ranges.map((u) => new kt(u.from - t.start, u.to - t.start)),
                  t.target,
                  c[0].from
                )
              )),
              (t = t.prev)
          }
          r && !--r.depth && (r = r.prev)
        }
    }
  }
}
function W_(n, e, t) {
  for (let r of n) {
    if (r.from >= t) break
    if (r.to > e) return r.from <= e && r.to >= t ? 2 : 1
  }
  return 0
}
function rO(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1]
    r.push(n.slice(e, t, o)), i.push(o - s)
  }
}
function L_(n) {
  let { node: e } = n,
    t = []
  do t.push(n.index), n.parent()
  while (!n.tree)
  let r = 0,
    i = n.tree,
    s = 0
  for (
    ;
    (s = i.positions[r] + n.from),
      !(s <= e.from && s + i.children[r].length >= e.to);
    r++
  );
  let o = i.children[r],
    a = o.buffer,
    l = [r]
  function c(u, f, p, d, O, g) {
    let b = t[g],
      x = [],
      w = []
    rO(o, u, b, x, w, d)
    let Q = a[b + 1],
      T = a[b + 2]
    l.push(x.length)
    let P = g
      ? c(b + 4, a[b + 3], o.set.types[a[b]], Q, T - Q, g - 1)
      : e.toTree()
    return (
      x.push(P), w.push(Q - d), rO(o, a[b + 3], f, x, w, d), new Pe(p, x, w, O)
    )
  }
  i.children[r] = c(0, a.length, it.none, 0, o.length, t.length - 1)
  for (let u of l) {
    let f = n.tree.children[u],
      p = n.tree.positions[u]
    n.yield(new Ke(f, p + n.from, u, n._tree))
  }
}
class iO {
  constructor(e, t) {
    ;(this.offset = t),
      (this.done = !1),
      (this.cursor = e.cursor(Oe.IncludeAnonymous | Oe.IgnoreMounts))
  }
  moveTo(e) {
    let { cursor: t } = this,
      r = e - this.offset
    for (; !this.done && t.from < r; )
      (t.to >= e && t.enter(r, 1, Oe.IgnoreOverlays | Oe.ExcludeBuffers)) ||
        t.next(!1) ||
        (this.done = !0)
  }
  hasNode(e) {
    if (
      (this.moveTo(e.from),
      !this.done &&
        this.cursor.from + this.offset == e.from &&
        this.cursor.tree)
    )
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree) return !0
        if (
          t.children.length &&
          t.positions[0] == 0 &&
          t.children[0] instanceof Pe
        )
          t = t.children[0]
        else break
      }
    return !1
  }
}
let B_ = class {
  constructor(e) {
    var t
    if (((this.fragments = e), (this.curTo = 0), (this.fragI = 0), e.length)) {
      let r = (this.curFrag = e[0])
      ;(this.curTo = (t = r.tree.prop(qu)) !== null && t !== void 0 ? t : r.to),
        (this.inner = new iO(r.tree, -r.offset))
    } else this.curFrag = this.inner = null
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; ) this.nextFrag()
    return (
      this.curFrag &&
      this.curFrag.from <= e.from &&
      this.curTo >= e.to &&
      this.inner.hasNode(e)
    )
  }
  nextFrag() {
    var e
    if ((this.fragI++, this.fragI == this.fragments.length))
      this.curFrag = this.inner = null
    else {
      let t = (this.curFrag = this.fragments[this.fragI])
      ;(this.curTo = (e = t.tree.prop(qu)) !== null && e !== void 0 ? e : t.to),
        (this.inner = new iO(t.tree, -t.offset))
    }
  }
  findMounts(e, t) {
    var r
    let i = []
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1)
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o =
          (r = s.tree) === null || r === void 0 ? void 0 : r.prop(re.mounted)
        if (o && o.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a]
            if (l.from >= s.to) break
            l.tree == this.curFrag.tree &&
              i.push({ frag: l, pos: s.from - l.offset, mount: o })
          }
      }
    }
    return i
  }
}
function sO(n, e) {
  let t = null,
    r = e
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to,
      a = n[i].from
    for (; s < r.length; s++) {
      let l = r[s]
      if (l.from >= a) break
      l.to <= o ||
        (t || (r = t = e.slice()),
        l.from < o
          ? ((t[s] = new kt(l.from, o)),
            l.to > a && t.splice(s + 1, 0, new kt(a, l.to)))
          : l.to > a
            ? (t[s--] = new kt(a, l.to))
            : t.splice(s--, 1))
    }
  }
  return r
}
function U_(n, e, t, r) {
  let i = 0,
    s = 0,
    o = !1,
    a = !1,
    l = -1e9,
    c = []
  for (;;) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from,
      f = s == e.length ? 1e9 : a ? e[s].to : e[s].from
    if (o != a) {
      let p = Math.max(l, t),
        d = Math.min(u, f, r)
      p < d && c.push(new kt(p, d))
    }
    if (((l = Math.min(u, f)), l == 1e9)) break
    u == l && (o ? ((o = !1), i++) : (o = !0)),
      f == l && (a ? ((a = !1), s++) : (a = !0))
  }
  return c
}
function oO(n, e) {
  let t = []
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0),
      a = o + i.tree.length,
      l = Math.max(s.from, o),
      c = Math.min(s.to, a)
    if (i.overlay) {
      let u = i.overlay.map((p) => new kt(p.from + r, p.to + r)),
        f = U_(e, u, l, c)
      for (let p = 0, d = l; ; p++) {
        let O = p == f.length,
          g = O ? c : f[p].from
        if (
          (g > d &&
            t.push(
              new yn(
                d,
                g,
                i.tree,
                -o,
                s.from >= d || s.openStart,
                s.to <= g || s.openEnd
              )
            ),
          O)
        )
          break
        d = f[p].to
      }
    } else
      t.push(
        new yn(
          l,
          c,
          i.tree,
          -o,
          s.from >= o || s.openStart,
          s.to <= a || s.openEnd
        )
      )
  }
  return t
}
let q_ = 0
class zt {
  constructor(e, t, r) {
    ;(this.set = e), (this.base = t), (this.modified = r), (this.id = q_++)
  }
  static define(e) {
    if (e != null && e.base)
      throw new Error('Can not derive from a modified tag')
    let t = new zt([], null, [])
    if ((t.set.push(t), e)) for (let r of e.set) t.set.push(r)
    return t
  }
  static defineModifier() {
    let e = new _a()
    return (t) =>
      t.modified.indexOf(e) > -1
        ? t
        : _a.get(
            t.base || t,
            t.modified.concat(e).sort((r, i) => r.id - i.id)
          )
  }
}
let z_ = 0
class _a {
  constructor() {
    ;(this.instances = []), (this.id = z_++)
  }
  static get(e, t) {
    if (!t.length) return e
    let r = t[0].instances.find((a) => a.base == e && F_(t, a.modified))
    if (r) return r
    let i = [],
      s = new zt(i, e, t)
    for (let a of t) a.instances.push(s)
    let o = G_(t)
    for (let a of e.set)
      if (!a.modified.length) for (let l of o) i.push(_a.get(a, l))
    return s
  }
}
function F_(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r])
}
function G_(n) {
  let e = [[]]
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++) e.push(e[r].concat(n[t]))
  return e.sort((t, r) => r.length - t.length)
}
function vl(n) {
  let e = Object.create(null)
  for (let t in n) {
    let r = n[t]
    Array.isArray(r) || (r = [r])
    for (let i of t.split(' '))
      if (i) {
        let s = [],
          o = 2,
          a = i
        for (let f = 0; ; ) {
          if (a == '...' && f > 0 && f + 3 == i.length) {
            o = 1
            break
          }
          let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a)
          if (!p) throw new RangeError('Invalid path: ' + i)
          if (
            (s.push(
              p[0] == '*' ? '' : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]
            ),
            (f += p[0].length),
            f == i.length)
          )
            break
          let d = i[f++]
          if (f == i.length && d == '!') {
            o = 0
            break
          }
          if (d != '/') throw new RangeError('Invalid path: ' + i)
          a = i.slice(f)
        }
        let l = s.length - 1,
          c = s[l]
        if (!c) throw new RangeError('Invalid path: ' + i)
        let u = new Ra(r, o, l > 0 ? s.slice(0, l) : null)
        e[c] = u.sort(e[c])
      }
  }
  return Pb.add(e)
}
const Pb = new re()
class Ra {
  constructor(e, t, r, i) {
    ;(this.tags = e), (this.mode = t), (this.context = r), (this.next = i)
  }
  get opaque() {
    return this.mode == 0
  }
  get inherit() {
    return this.mode == 1
  }
  sort(e) {
    return !e || e.depth < this.depth
      ? ((this.next = e), this)
      : ((e.next = this.sort(e.next)), e)
  }
  get depth() {
    return this.context ? this.context.length : 0
  }
}
Ra.empty = new Ra([], 2, null)
function Tb(n, e) {
  let t = Object.create(null)
  for (let s of n)
    if (!Array.isArray(s.tag)) t[s.tag.id] = s.class
    else for (let o of s.tag) t[o.id] = s.class
  let { scope: r, all: i = null } = e || {}
  return {
    style: (s) => {
      let o = i
      for (let a of s)
        for (let l of a.set) {
          let c = t[l.id]
          if (c) {
            o = o ? o + ' ' + c : c
            break
          }
        }
      return o
    },
    scope: r
  }
}
function H_(n, e) {
  let t = null
  for (let r of n) {
    let i = r.style(e)
    i && (t = t ? t + ' ' + i : i)
  }
  return t
}
function K_(n, e, t, r = 0, i = n.length) {
  let s = new J_(r, Array.isArray(e) ? e : [e], t)
  s.highlightRange(n.cursor(), r, i, '', s.highlighters), s.flush(i)
}
class J_ {
  constructor(e, t, r) {
    ;(this.at = e), (this.highlighters = t), (this.span = r), (this.class = '')
  }
  startSpan(e, t) {
    t != this.class &&
      (this.flush(e), e > this.at && (this.at = e), (this.class = t))
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class)
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: a, to: l } = e
    if (a >= r || l <= t) return
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)))
    let c = i,
      u = eR(e) || Ra.empty,
      f = H_(s, u.tags)
    if (
      (f &&
        (c && (c += ' '), (c += f), u.mode == 1 && (i += (i ? ' ' : '') + f)),
      this.startSpan(Math.max(t, a), c),
      u.opaque)
    )
      return
    let p = e.tree && e.tree.prop(re.mounted)
    if (p && p.overlay) {
      let d = e.node.enter(p.overlay[0].from + a, 1),
        O = this.highlighters.filter((b) => !b.scope || b.scope(p.tree.type)),
        g = e.firstChild()
      for (let b = 0, x = a; ; b++) {
        let w = b < p.overlay.length ? p.overlay[b] : null,
          Q = w ? w.from + a : l,
          T = Math.max(t, x),
          P = Math.min(r, Q)
        if (T < P && g)
          for (
            ;
            e.from < P &&
            (this.highlightRange(e, T, P, i, s),
            this.startSpan(Math.min(P, e.to), c),
            !(e.to >= Q || !e.nextSibling()));

          );
        if (!w || Q > r) break
        ;(x = w.to + a),
          x > t &&
            (this.highlightRange(
              d.cursor(),
              Math.max(t, w.from + a),
              Math.min(r, x),
              '',
              O
            ),
            this.startSpan(Math.min(r, x), c))
      }
      g && e.parent()
    } else if (e.firstChild()) {
      p && (i = '')
      do
        if (!(e.to <= t)) {
          if (e.from >= r) break
          this.highlightRange(e, t, r, i, s),
            this.startSpan(Math.min(r, e.to), c)
        }
      while (e.nextSibling())
      e.parent()
    }
  }
}
function eR(n) {
  let e = n.type.prop(Pb)
  for (; e && e.context && !n.matchContext(e.context); ) e = e.next
  return e || null
}
const X = zt.define,
  io = X(),
  _n = X(),
  aO = X(_n),
  lO = X(_n),
  Rn = X(),
  so = X(Rn),
  uc = X(Rn),
  Bt = X(),
  rr = X(Bt),
  Vt = X(),
  Wt = X(),
  zu = X(),
  $i = X(zu),
  oo = X(),
  m = {
    comment: io,
    lineComment: X(io),
    blockComment: X(io),
    docComment: X(io),
    name: _n,
    variableName: X(_n),
    typeName: aO,
    tagName: X(aO),
    propertyName: lO,
    attributeName: X(lO),
    className: X(_n),
    labelName: X(_n),
    namespace: X(_n),
    macroName: X(_n),
    literal: Rn,
    string: so,
    docString: X(so),
    character: X(so),
    attributeValue: X(so),
    number: uc,
    integer: X(uc),
    float: X(uc),
    bool: X(Rn),
    regexp: X(Rn),
    escape: X(Rn),
    color: X(Rn),
    url: X(Rn),
    keyword: Vt,
    self: X(Vt),
    null: X(Vt),
    atom: X(Vt),
    unit: X(Vt),
    modifier: X(Vt),
    operatorKeyword: X(Vt),
    controlKeyword: X(Vt),
    definitionKeyword: X(Vt),
    moduleKeyword: X(Vt),
    operator: Wt,
    derefOperator: X(Wt),
    arithmeticOperator: X(Wt),
    logicOperator: X(Wt),
    bitwiseOperator: X(Wt),
    compareOperator: X(Wt),
    updateOperator: X(Wt),
    definitionOperator: X(Wt),
    typeOperator: X(Wt),
    controlOperator: X(Wt),
    punctuation: zu,
    separator: X(zu),
    bracket: $i,
    angleBracket: X($i),
    squareBracket: X($i),
    paren: X($i),
    brace: X($i),
    content: Bt,
    heading: rr,
    heading1: X(rr),
    heading2: X(rr),
    heading3: X(rr),
    heading4: X(rr),
    heading5: X(rr),
    heading6: X(rr),
    contentSeparator: X(Bt),
    list: X(Bt),
    quote: X(Bt),
    emphasis: X(Bt),
    strong: X(Bt),
    link: X(Bt),
    monospace: X(Bt),
    strikethrough: X(Bt),
    inserted: X(),
    deleted: X(),
    changed: X(),
    invalid: X(),
    meta: oo,
    documentMeta: X(oo),
    annotation: X(oo),
    processingInstruction: X(oo),
    definition: zt.defineModifier(),
    constant: zt.defineModifier(),
    function: zt.defineModifier(),
    standard: zt.defineModifier(),
    local: zt.defineModifier(),
    special: zt.defineModifier()
  }
Tb([
  { tag: m.link, class: 'tok-link' },
  { tag: m.heading, class: 'tok-heading' },
  { tag: m.emphasis, class: 'tok-emphasis' },
  { tag: m.strong, class: 'tok-strong' },
  { tag: m.keyword, class: 'tok-keyword' },
  { tag: m.atom, class: 'tok-atom' },
  { tag: m.bool, class: 'tok-bool' },
  { tag: m.url, class: 'tok-url' },
  { tag: m.labelName, class: 'tok-labelName' },
  { tag: m.inserted, class: 'tok-inserted' },
  { tag: m.deleted, class: 'tok-deleted' },
  { tag: m.literal, class: 'tok-literal' },
  { tag: m.string, class: 'tok-string' },
  { tag: m.number, class: 'tok-number' },
  { tag: [m.regexp, m.escape, m.special(m.string)], class: 'tok-string2' },
  { tag: m.variableName, class: 'tok-variableName' },
  { tag: m.local(m.variableName), class: 'tok-variableName tok-local' },
  {
    tag: m.definition(m.variableName),
    class: 'tok-variableName tok-definition'
  },
  { tag: m.special(m.variableName), class: 'tok-variableName2' },
  {
    tag: m.definition(m.propertyName),
    class: 'tok-propertyName tok-definition'
  },
  { tag: m.typeName, class: 'tok-typeName' },
  { tag: m.namespace, class: 'tok-namespace' },
  { tag: m.className, class: 'tok-className' },
  { tag: m.macroName, class: 'tok-macroName' },
  { tag: m.propertyName, class: 'tok-propertyName' },
  { tag: m.operator, class: 'tok-operator' },
  { tag: m.comment, class: 'tok-comment' },
  { tag: m.meta, class: 'tok-meta' },
  { tag: m.invalid, class: 'tok-invalid' },
  { tag: m.punctuation, class: 'tok-punctuation' }
])
var fc
const Xr = new re()
function $b(n) {
  return U.define({ combine: n ? (e) => e.concat(n) : void 0 })
}
const Bf = new re()
class Xt {
  constructor(e, t, r = [], i = '') {
    ;(this.data = e),
      (this.name = i),
      ie.prototype.hasOwnProperty('tree') ||
        Object.defineProperty(ie.prototype, 'tree', {
          get() {
            return ke(this)
          }
        }),
      (this.parser = t),
      (this.extension = [
        zn.of(this),
        ie.languageData.of((s, o, a) => {
          let l = cO(s, o, a),
            c = l.type.prop(Xr)
          if (!c) return []
          let u = s.facet(c),
            f = l.type.prop(Bf)
          if (f) {
            let p = l.resolve(o - l.from, a)
            for (let d of f)
              if (d.test(p, s)) {
                let O = s.facet(d.facet)
                return d.type == 'replace' ? O : O.concat(u)
              }
          }
          return u
        })
      ].concat(r))
  }
  isActiveAt(e, t, r = -1) {
    return cO(e, t, r).type.prop(Xr) == this.data
  }
  findRegions(e) {
    let t = e.facet(zn)
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }]
    if (!t || !t.allowsNesting) return []
    let r = [],
      i = (s, o) => {
        if (s.prop(Xr) == this.data) {
          r.push({ from: o, to: o + s.length })
          return
        }
        let a = s.prop(re.mounted)
        if (a) {
          if (a.tree.prop(Xr) == this.data) {
            if (a.overlay)
              for (let l of a.overlay)
                r.push({ from: l.from + o, to: l.to + o })
            else r.push({ from: o, to: o + s.length })
            return
          } else if (a.overlay) {
            let l = r.length
            if ((i(a.tree, a.overlay[0].from + o), r.length > l)) return
          }
        }
        for (let l = 0; l < s.children.length; l++) {
          let c = s.children[l]
          c instanceof Pe && i(c, s.positions[l] + o)
        }
      }
    return i(ke(e), 0), r
  }
  get allowsNesting() {
    return !0
  }
}
Xt.setState = ee.define()
function cO(n, e, t) {
  let r = n.facet(zn),
    i = ke(n).topNode
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, Oe.ExcludeBuffers))
      s.type.isTop && (i = s)
  return i
}
class Kr extends Xt {
  constructor(e, t, r) {
    super(e, t, [], r), (this.parser = t)
  }
  static define(e) {
    let t = $b(e.languageData)
    return new Kr(
      t,
      e.parser.configure({ props: [Xr.add((r) => (r.isTop ? t : void 0))] }),
      e.name
    )
  }
  configure(e, t) {
    return new Kr(this.data, this.parser.configure(e), t || this.name)
  }
  get allowsNesting() {
    return this.parser.hasWrappers()
  }
}
function ke(n) {
  let e = n.field(Xt.state, !1)
  return e ? e.tree : Pe.empty
}
class tR {
  constructor(e) {
    ;(this.doc = e),
      (this.cursorPos = 0),
      (this.string = ''),
      (this.cursor = e.iter())
  }
  get length() {
    return this.doc.length
  }
  syncTo(e) {
    return (
      (this.string = this.cursor.next(e - this.cursorPos).value),
      (this.cursorPos = e + this.string.length),
      this.cursorPos - this.string.length
    )
  }
  chunk(e) {
    return this.syncTo(e), this.string
  }
  get lineChunks() {
    return !0
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length
    return e < r || t >= this.cursorPos
      ? this.doc.sliceString(e, t)
      : this.string.slice(e - r, t - r)
  }
}
let Qi = null
class Za {
  constructor(e, t, r = [], i, s, o, a, l) {
    ;(this.parser = e),
      (this.state = t),
      (this.fragments = r),
      (this.tree = i),
      (this.treeLen = s),
      (this.viewport = o),
      (this.skipped = a),
      (this.scheduleOn = l),
      (this.parse = null),
      (this.tempSkipped = [])
  }
  static create(e, t, r) {
    return new Za(e, t, [], Pe.empty, 0, r, [], null)
  }
  startParse() {
    return this.parser.startParse(new tR(this.state.doc), this.fragments)
  }
  work(e, t) {
    return (
      t != null && t >= this.state.doc.length && (t = void 0),
      this.tree != Pe.empty && this.isDone(t ?? this.state.doc.length)
        ? (this.takeTree(), !0)
        : this.withContext(() => {
            var r
            if (typeof e == 'number') {
              let i = Date.now() + e
              e = () => Date.now() > i
            }
            for (
              this.parse || (this.parse = this.startParse()),
                t != null &&
                  (this.parse.stoppedAt == null || this.parse.stoppedAt > t) &&
                  t < this.state.doc.length &&
                  this.parse.stopAt(t);
              ;

            ) {
              let i = this.parse.advance()
              if (i)
                if (
                  ((this.fragments = this.withoutTempSkipped(
                    yn.addTree(i, this.fragments, this.parse.stoppedAt != null)
                  )),
                  (this.treeLen =
                    (r = this.parse.stoppedAt) !== null && r !== void 0
                      ? r
                      : this.state.doc.length),
                  (this.tree = i),
                  (this.parse = null),
                  this.treeLen < (t ?? this.state.doc.length))
                )
                  this.parse = this.startParse()
                else return !0
              if (e()) return !1
            }
          })
    )
  }
  takeTree() {
    let e, t
    this.parse &&
      (e = this.parse.parsedPos) >= this.treeLen &&
      ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) &&
        this.parse.stopAt(e),
      this.withContext(() => {
        for (; !(t = this.parse.advance()); );
      }),
      (this.treeLen = e),
      (this.tree = t),
      (this.fragments = this.withoutTempSkipped(
        yn.addTree(this.tree, this.fragments, !0)
      )),
      (this.parse = null))
  }
  withContext(e) {
    let t = Qi
    Qi = this
    try {
      return e()
    } finally {
      Qi = t
    }
  }
  withoutTempSkipped(e) {
    for (let t; (t = this.tempSkipped.pop()); ) e = uO(e, t.from, t.to)
    return e
  }
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: a } = this
    if ((this.takeTree(), !e.empty)) {
      let l = []
      if (
        (e.iterChangedRanges((c, u, f, p) =>
          l.push({ fromA: c, toA: u, fromB: f, toB: p })
        ),
        (r = yn.applyChanges(r, l)),
        (i = Pe.empty),
        (s = 0),
        (o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }),
        this.skipped.length)
      ) {
        a = []
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1),
            f = e.mapPos(c.to, -1)
          u < f && a.push({ from: u, to: f })
        }
      }
    }
    return new Za(this.parser, t, r, i, s, o, a, this.scheduleOn)
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to) return !1
    this.viewport = e
    let t = this.skipped.length
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r]
      i < e.to &&
        s > e.from &&
        ((this.fragments = uO(this.fragments, i, s)),
        this.skipped.splice(r--, 1))
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0)
  }
  reset() {
    this.parse && (this.takeTree(), (this.parse = null))
  }
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t })
  }
  static getSkippingParser(e) {
    return new (class extends wb {
      createParse(t, r, i) {
        let s = i[0].from,
          o = i[i.length - 1].to
        return {
          parsedPos: s,
          advance() {
            let l = Qi
            if (l) {
              for (let c of i) l.tempSkipped.push(c)
              e &&
                (l.scheduleOn = l.scheduleOn
                  ? Promise.all([l.scheduleOn, e])
                  : e)
            }
            return (this.parsedPos = o), new Pe(it.none, [], [], o - s)
          },
          stoppedAt: null,
          stopAt() {}
        }
      }
    })()
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length)
    let t = this.fragments
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e
  }
  static get() {
    return Qi
  }
}
function uO(n, e, t) {
  return yn.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }])
}
class Jr {
  constructor(e) {
    ;(this.context = e), (this.tree = e.tree)
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree) return this
    let t = this.context.changes(e.changes, e.state),
      r =
        this.context.treeLen == e.startState.doc.length
          ? void 0
          : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to)
    return t.work(20, r) || t.takeTree(), new Jr(t)
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length),
      r = Za.create(e.facet(zn).parser, e, { from: 0, to: t })
    return r.work(20, t) || r.takeTree(), new Jr(r)
  }
}
Xt.state = je.define({
  create: Jr.init,
  update(n, e) {
    for (let t of e.effects) if (t.is(Xt.setState)) return t.value
    return e.startState.facet(zn) != e.state.facet(zn)
      ? Jr.init(e.state)
      : n.apply(e)
  }
})
let Qb = (n) => {
  let e = setTimeout(() => n(), 500)
  return () => clearTimeout(e)
}
typeof requestIdleCallback < 'u' &&
  (Qb = (n) => {
    let e = -1,
      t = setTimeout(() => {
        e = requestIdleCallback(n, { timeout: 500 - 100 })
      }, 100)
    return () => (e < 0 ? clearTimeout(t) : cancelIdleCallback(e))
  })
const hc =
    typeof navigator < 'u' &&
    !((fc = navigator.scheduling) === null || fc === void 0) &&
    fc.isInputPending
      ? () => navigator.scheduling.isInputPending()
      : null,
  nR = _e.fromClass(
    class {
      constructor(e) {
        ;(this.view = e),
          (this.working = null),
          (this.workScheduled = 0),
          (this.chunkEnd = -1),
          (this.chunkBudget = -1),
          (this.work = this.work.bind(this)),
          this.scheduleWork()
      }
      update(e) {
        let t = this.view.state.field(Xt.state).context
        ;(t.updateViewport(e.view.viewport) ||
          this.view.viewport.to > t.treeLen) &&
          this.scheduleWork(),
          (e.docChanged || e.selectionSet) &&
            (this.view.hasFocus && (this.chunkBudget += 50),
            this.scheduleWork()),
          this.checkAsyncSchedule(t)
      }
      scheduleWork() {
        if (this.working) return
        let { state: e } = this.view,
          t = e.field(Xt.state)
        ;(t.tree != t.context.tree || !t.context.isDone(e.doc.length)) &&
          (this.working = Qb(this.work))
      }
      work(e) {
        this.working = null
        let t = Date.now()
        if (
          (this.chunkEnd < t &&
            (this.chunkEnd < 0 || this.view.hasFocus) &&
            ((this.chunkEnd = t + 3e4), (this.chunkBudget = 3e3)),
          this.chunkBudget <= 0)
        )
          return
        let {
            state: r,
            viewport: { to: i }
          } = this.view,
          s = r.field(Xt.state)
        if (s.tree == s.context.tree && s.context.isDone(i + 1e5)) return
        let o =
            Date.now() +
            Math.min(
              this.chunkBudget,
              100,
              e && !hc ? Math.max(25, e.timeRemaining() - 5) : 1e9
            ),
          a = s.context.treeLen < i && r.doc.length > i + 1e3,
          l = s.context.work(
            () => (hc && hc()) || Date.now() > o,
            i + (a ? 0 : 1e5)
          )
        ;(this.chunkBudget -= Date.now() - t),
          (l || this.chunkBudget <= 0) &&
            (s.context.takeTree(),
            this.view.dispatch({ effects: Xt.setState.of(new Jr(s.context)) })),
          this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(),
          this.checkAsyncSchedule(s.context)
      }
      checkAsyncSchedule(e) {
        e.scheduleOn &&
          (this.workScheduled++,
          e.scheduleOn
            .then(() => this.scheduleWork())
            .catch((t) => _t(this.view.state, t))
            .then(() => this.workScheduled--),
          (e.scheduleOn = null))
      }
      destroy() {
        this.working && this.working()
      }
      isWorking() {
        return !!(this.working || this.workScheduled > 0)
      }
    },
    {
      eventHandlers: {
        focus() {
          this.scheduleWork()
        }
      }
    }
  ),
  zn = U.define({
    combine(n) {
      return n.length ? n[0] : null
    },
    enables: (n) => [
      Xt.state,
      nR,
      j.contentAttributes.compute([n], (e) => {
        let t = e.facet(n)
        return t && t.name ? { 'data-language': t.name } : {}
      })
    ]
  })
class Uf {
  constructor(e, t = []) {
    ;(this.language = e), (this.support = t), (this.extension = [e, t])
  }
}
const rR = U.define(),
  $s = U.define({
    combine: (n) => {
      if (!n.length) return '  '
      let e = n[0]
      if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
        throw new Error('Invalid indent unit: ' + JSON.stringify(n[0]))
      return e
    }
  })
function Aa(n) {
  let e = n.facet($s)
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length
}
function os(n, e) {
  let t = '',
    r = n.tabSize,
    i = n.facet($s)[0]
  if (i == '	') {
    for (; e >= r; ) (t += '	'), (e -= r)
    i = ' '
  }
  for (let s = 0; s < e; s++) t += i
  return t
}
function qf(n, e) {
  n instanceof ie && (n = new Sl(n))
  for (let r of n.state.facet(rR)) {
    let i = r(n, e)
    if (i !== void 0) return i
  }
  let t = ke(n.state)
  return t.length >= e ? iR(n, t, e) : null
}
class Sl {
  constructor(e, t = {}) {
    ;(this.state = e), (this.options = t), (this.unit = Aa(e))
  }
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e),
      { simulateBreak: i, simulateDoubleBreak: s } = this.options
    return i != null && i >= r.from && i <= r.to
      ? s && i == e
        ? { text: '', from: e }
        : (t < 0 ? i < e : i <= e)
          ? { text: r.text.slice(i - r.from), from: i }
          : { text: r.text.slice(0, i - r.from), from: r.from }
      : r
  }
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return ''
    let { text: r, from: i } = this.lineAt(e, t)
    return r.slice(e - i, Math.min(r.length, e + 100 - i))
  }
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t),
      s = this.countColumn(r, e - i),
      o = this.options.overrideIndentation
        ? this.options.overrideIndentation(i)
        : -1
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s
  }
  countColumn(e, t = e.length) {
    return oi(e, this.state.tabSize, t)
  }
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t),
      s = this.options.overrideIndentation
    if (s) {
      let o = s(i)
      if (o > -1) return o
    }
    return this.countColumn(r, r.search(/\S|$/))
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null
  }
}
const xl = new re()
function iR(n, e, t) {
  let r = e.resolveStack(t),
    i = r.node.enterUnfinishedNodesBefore(t)
  if (i != r.node) {
    let s = []
    for (let o = i; o != r.node; o = o.parent) s.push(o)
    for (let o = s.length - 1; o >= 0; o--) r = { node: s[o], next: r }
  }
  return kb(r, n, t)
}
function kb(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = oR(r.node)
    if (i) return i(zf.create(e, t, r))
  }
  return 0
}
function sR(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak
}
function oR(n) {
  let e = n.type.prop(xl)
  if (e) return e
  let t = n.firstChild,
    r
  if (t && (r = t.type.prop(re.closedBy))) {
    let i = n.lastChild,
      s = i && r.indexOf(i.name) > -1
    return (o) => Cb(o, !0, 1, void 0, s && !sR(o) ? i.from : void 0)
  }
  return n.parent == null ? aR : null
}
function aR() {
  return 0
}
class zf extends Sl {
  constructor(e, t, r) {
    super(e.state, e.options),
      (this.base = e),
      (this.pos = t),
      (this.context = r)
  }
  get node() {
    return this.context.node
  }
  static create(e, t, r) {
    return new zf(e, t, r)
  }
  get textAfter() {
    return this.textAfterPos(this.pos)
  }
  get baseIndent() {
    return this.baseIndentFor(this.node)
  }
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from)
    for (;;) {
      let r = e.resolve(t.from)
      for (; r.parent && r.parent.from == r.from; ) r = r.parent
      if (lR(r, e)) break
      t = this.state.doc.lineAt(r.from)
    }
    return this.lineIndent(t.from)
  }
  continue() {
    return kb(this.context.next, this.base, this.pos)
  }
}
function lR(n, e) {
  for (let t = e; t; t = t.parent) if (n == t) return !0
  return !1
}
function cR(n) {
  let e = n.node,
    t = e.childAfter(e.from),
    r = e.lastChild
  if (!t) return null
  let i = n.options.simulateBreak,
    s = n.state.doc.lineAt(t.from),
    o = i == null || i <= s.from ? s.to : Math.min(s.to, i)
  for (let a = t.to; ; ) {
    let l = e.childAfter(a)
    if (!l || l == r) return null
    if (!l.type.isSkipped) return l.from < o ? t : null
    a = l.to
  }
}
function uR({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => Cb(r, e, t, n)
}
function Cb(n, e, t, r, i) {
  let s = n.textAfter,
    o = s.match(/^\s*/)[0].length,
    a = (r && s.slice(o, o + r.length) == r) || i == n.pos + o,
    l = e ? cR(n) : null
  return l
    ? a
      ? n.column(l.from)
      : n.column(l.to)
    : n.baseIndent + (a ? 0 : n.unit * t)
}
const fR = (n) => n.baseIndent
function Wo({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter)
    return t.baseIndent + (r ? 0 : e * t.unit)
  }
}
const hR = 200
function pR() {
  return ie.transactionFilter.of((n) => {
    if (
      !n.docChanged ||
      (!n.isUserEvent('input.type') && !n.isUserEvent('input.complete'))
    )
      return n
    let e = n.startState.languageDataAt(
      'indentOnInput',
      n.startState.selection.main.head
    )
    if (!e.length) return n
    let t = n.newDoc,
      { head: r } = n.newSelection.main,
      i = t.lineAt(r)
    if (r > i.from + hR) return n
    let s = t.sliceString(i.from, r)
    if (!e.some((c) => c.test(s))) return n
    let { state: o } = n,
      a = -1,
      l = []
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c)
      if (u.from == a) continue
      a = u.from
      let f = qf(o, u.from)
      if (f == null) continue
      let p = /^\s*/.exec(u.text)[0],
        d = os(o, f)
      p != d && l.push({ from: u.from, to: u.from + p.length, insert: d })
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n
  })
}
const dR = U.define(),
  wl = new re()
function _b(n) {
  let e = n.firstChild,
    t = n.lastChild
  return e && e.to < t.from
    ? { from: e.to, to: t.type.isError ? n.to : t.from }
    : null
}
function OR(n, e, t) {
  let r = ke(n)
  if (r.length < t) return null
  let i = r.resolveStack(t, 1),
    s = null
  for (let o = i; o; o = o.next) {
    let a = o.node
    if (a.to <= t || a.from > t) continue
    if (s && a.from < e) break
    let l = a.type.prop(wl)
    if (l && (a.to < r.length - 50 || r.length == n.doc.length || !mR(a))) {
      let c = l(a, n)
      c && c.from <= t && c.from >= e && c.to > t && (s = c)
    }
  }
  return s
}
function mR(n) {
  let e = n.lastChild
  return e && e.to == n.to && e.type.isError
}
function Ea(n, e, t) {
  for (let r of n.facet(dR)) {
    let i = r(n, e, t)
    if (i) return i
  }
  return OR(n, e, t)
}
function Rb(n, e) {
  let t = e.mapPos(n.from, 1),
    r = e.mapPos(n.to, -1)
  return t >= r ? void 0 : { from: t, to: r }
}
const Pl = ee.define({ map: Rb }),
  Qs = ee.define({ map: Rb })
function Zb(n) {
  let e = []
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t))
  return e
}
const gr = je.define({
  create() {
    return G.none
  },
  update(n, e) {
    n = n.map(e.changes)
    for (let t of e.effects)
      if (t.is(Pl) && !gR(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(Ff),
          i = r ? G.replace({ widget: new PR(r(e.state, t.value)) }) : fO
        n = n.update({ add: [i.range(t.value.from, t.value.to)] })
      } else
        t.is(Qs) &&
          (n = n.update({
            filter: (r, i) => t.value.from != r || t.value.to != i,
            filterFrom: t.value.from,
            filterTo: t.value.to
          }))
    if (e.selection) {
      let t = !1,
        { head: r } = e.selection.main
      n.between(r, r, (i, s) => {
        i < r && s > r && (t = !0)
      }),
        t &&
          (n = n.update({
            filterFrom: r,
            filterTo: r,
            filter: (i, s) => s <= r || i >= r
          }))
    }
    return n
  },
  provide: (n) => j.decorations.from(n),
  toJSON(n, e) {
    let t = []
    return (
      n.between(0, e.doc.length, (r, i) => {
        t.push(r, i)
      }),
      t
    )
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError('Invalid JSON for fold state')
    let e = []
    for (let t = 0; t < n.length; ) {
      let r = n[t++],
        i = n[t++]
      if (typeof r != 'number' || typeof i != 'number')
        throw new RangeError('Invalid JSON for fold state')
      e.push(fO.range(r, i))
    }
    return G.set(e, !0)
  }
})
function Da(n, e, t) {
  var r
  let i = null
  return (
    (r = n.field(gr, !1)) === null ||
      r === void 0 ||
      r.between(e, t, (s, o) => {
        ;(!i || i.from > s) && (i = { from: s, to: o })
      }),
    i
  )
}
function gR(n, e, t) {
  let r = !1
  return (
    n.between(e, e, (i, s) => {
      i == e && s == t && (r = !0)
    }),
    r
  )
}
function Ab(n, e) {
  return n.field(gr, !1) ? e : e.concat(ee.appendConfig.of(Db()))
}
const yR = (n) => {
    for (let e of Zb(n)) {
      let t = Ea(n.state, e.from, e.to)
      if (t)
        return n.dispatch({ effects: Ab(n.state, [Pl.of(t), Eb(n, t)]) }), !0
    }
    return !1
  },
  bR = (n) => {
    if (!n.state.field(gr, !1)) return !1
    let e = []
    for (let t of Zb(n)) {
      let r = Da(n.state, t.from, t.to)
      r && e.push(Qs.of(r), Eb(n, r, !1))
    }
    return e.length && n.dispatch({ effects: e }), e.length > 0
  }
function Eb(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number,
    i = n.state.doc.lineAt(e.to).number
  return j.announce.of(
    `${n.state.phrase(
      t ? 'Folded lines' : 'Unfolded lines'
    )} ${r} ${n.state.phrase('to')} ${i}.`
  )
}
const vR = (n) => {
    let { state: e } = n,
      t = []
    for (let r = 0; r < e.doc.length; ) {
      let i = n.lineBlockAt(r),
        s = Ea(e, i.from, i.to)
      s && t.push(Pl.of(s)), (r = (s ? n.lineBlockAt(s.to) : i).to + 1)
    }
    return t.length && n.dispatch({ effects: Ab(n.state, t) }), !!t.length
  },
  SR = (n) => {
    let e = n.state.field(gr, !1)
    if (!e || !e.size) return !1
    let t = []
    return (
      e.between(0, n.state.doc.length, (r, i) => {
        t.push(Qs.of({ from: r, to: i }))
      }),
      n.dispatch({ effects: t }),
      !0
    )
  },
  xR = [
    { key: 'Ctrl-Shift-[', mac: 'Cmd-Alt-[', run: yR },
    { key: 'Ctrl-Shift-]', mac: 'Cmd-Alt-]', run: bR },
    { key: 'Ctrl-Alt-[', run: vR },
    { key: 'Ctrl-Alt-]', run: SR }
  ],
  wR = { placeholderDOM: null, preparePlaceholder: null, placeholderText: '' },
  Ff = U.define({
    combine(n) {
      return on(n, wR)
    }
  })
function Db(n) {
  let e = [gr, QR]
  return n && e.push(Ff.of(n)), e
}
function Xb(n, e) {
  let { state: t } = n,
    r = t.facet(Ff),
    i = (o) => {
      let a = n.lineBlockAt(n.posAtDOM(o.target)),
        l = Da(n.state, a.from, a.to)
      l && n.dispatch({ effects: Qs.of(l) }), o.preventDefault()
    }
  if (r.placeholderDOM) return r.placeholderDOM(n, i, e)
  let s = document.createElement('span')
  return (
    (s.textContent = r.placeholderText),
    s.setAttribute('aria-label', t.phrase('folded code')),
    (s.title = t.phrase('unfold')),
    (s.className = 'cm-foldPlaceholder'),
    (s.onclick = i),
    s
  )
}
const fO = G.replace({
  widget: new (class extends an {
    toDOM(n) {
      return Xb(n, null)
    }
  })()
})
class PR extends an {
  constructor(e) {
    super(), (this.value = e)
  }
  eq(e) {
    return this.value == e.value
  }
  toDOM(e) {
    return Xb(e, this.value)
  }
}
const TR = {
  openText: '',
  closedText: '',
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
}
class pc extends xn {
  constructor(e, t) {
    super(), (this.config = e), (this.open = t)
  }
  eq(e) {
    return this.config == e.config && this.open == e.open
  }
  toDOM(e) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open)
    let t = document.createElement('span')
    return (
      (t.textContent = this.open
        ? this.config.openText
        : this.config.closedText),
      (t.title = e.state.phrase(this.open ? 'Fold line' : 'Unfold line')),
      t
    )
  }
}
function $R(n = {}) {
  let e = Object.assign(Object.assign({}, TR), n),
    t = new pc(e, !0),
    r = new pc(e, !1),
    i = _e.fromClass(
      class {
        constructor(o) {
          ;(this.from = o.viewport.from), (this.markers = this.buildMarkers(o))
        }
        update(o) {
          ;(o.docChanged ||
            o.viewportChanged ||
            o.startState.facet(zn) != o.state.facet(zn) ||
            o.startState.field(gr, !1) != o.state.field(gr, !1) ||
            ke(o.startState) != ke(o.state) ||
            e.foldingChanged(o)) &&
            (this.markers = this.buildMarkers(o.view))
        }
        buildMarkers(o) {
          let a = new Wn()
          for (let l of o.viewportLineBlocks) {
            let c = Da(o.state, l.from, l.to)
              ? r
              : Ea(o.state, l.from, l.to)
                ? t
                : null
            c && a.add(l.from, l.from, c)
          }
          return a.finish()
        }
      }
    ),
    { domEventHandlers: s } = e
  return [
    i,
    w_({
      class: 'cm-foldGutter',
      markers(o) {
        var a
        return (
          ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) ||
          ce.empty
        )
      },
      initialSpacer() {
        return new pc(e, !1)
      },
      domEventHandlers: Object.assign(Object.assign({}, s), {
        click: (o, a, l) => {
          if (s.click && s.click(o, a, l)) return !0
          let c = Da(o.state, a.from, a.to)
          if (c) return o.dispatch({ effects: Qs.of(c) }), !0
          let u = Ea(o.state, a.from, a.to)
          return u ? (o.dispatch({ effects: Pl.of(u) }), !0) : !1
        }
      })
    }),
    Db()
  ]
}
const QR = j.baseTheme({
  '.cm-foldPlaceholder': {
    backgroundColor: '#eee',
    border: '1px solid #ddd',
    color: '#888',
    borderRadius: '.2em',
    margin: '0 1px',
    padding: '0 1px',
    cursor: 'pointer'
  },
  '.cm-foldGutter span': { padding: '0 1px', cursor: 'pointer' }
})
class ai {
  constructor(e, t) {
    this.specs = e
    let r
    function i(a) {
      let l = Ln.newName()
      return ((r || (r = Object.create(null)))['.' + l] = a), l
    }
    const s = typeof t.all == 'string' ? t.all : t.all ? i(t.all) : void 0,
      o = t.scope
    ;(this.scope =
      o instanceof Xt
        ? (a) => a.prop(Xr) == o.data
        : o
          ? (a) => a == o
          : void 0),
      (this.style = Tb(
        e.map((a) => ({
          tag: a.tag,
          class: a.class || i(Object.assign({}, a, { tag: null }))
        })),
        { all: s }
      ).style),
      (this.module = r ? new Ln(r) : null),
      (this.themeType = t.themeType)
  }
  static define(e, t) {
    return new ai(e, t || {})
  }
}
const Fu = U.define(),
  Yb = U.define({
    combine(n) {
      return n.length ? [n[0]] : null
    }
  })
function dc(n) {
  let e = n.facet(Fu)
  return e.length ? e : n.facet(Yb)
}
function Gf(n, e) {
  let t = [CR],
    r
  return (
    n instanceof ai &&
      (n.module && t.push(j.styleModule.of(n.module)), (r = n.themeType)),
    e != null && e.fallback
      ? t.push(Yb.of(n))
      : r
        ? t.push(
            Fu.computeN([j.darkTheme], (i) =>
              i.facet(j.darkTheme) == (r == 'dark') ? [n] : []
            )
          )
        : t.push(Fu.of(n)),
    t
  )
}
class kR {
  constructor(e) {
    ;(this.markCache = Object.create(null)),
      (this.tree = ke(e.state)),
      (this.decorations = this.buildDeco(e, dc(e.state)))
  }
  update(e) {
    let t = ke(e.state),
      r = dc(e.state),
      i = r != dc(e.startState)
    t.length < e.view.viewport.to && !i && t.type == this.tree.type
      ? (this.decorations = this.decorations.map(e.changes))
      : (t != this.tree || e.viewportChanged || i) &&
        ((this.tree = t), (this.decorations = this.buildDeco(e.view, r)))
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length) return G.none
    let r = new Wn()
    for (let { from: i, to: s } of e.visibleRanges)
      K_(
        this.tree,
        t,
        (o, a, l) => {
          r.add(
            o,
            a,
            this.markCache[l] || (this.markCache[l] = G.mark({ class: l }))
          )
        },
        i,
        s
      )
    return r.finish()
  }
}
const CR = vr.high(_e.fromClass(kR, { decorations: (n) => n.decorations })),
  _R = ai.define([
    { tag: m.meta, color: '#404740' },
    { tag: m.link, textDecoration: 'underline' },
    { tag: m.heading, textDecoration: 'underline', fontWeight: 'bold' },
    { tag: m.emphasis, fontStyle: 'italic' },
    { tag: m.strong, fontWeight: 'bold' },
    { tag: m.strikethrough, textDecoration: 'line-through' },
    { tag: m.keyword, color: '#708' },
    {
      tag: [m.atom, m.bool, m.url, m.contentSeparator, m.labelName],
      color: '#219'
    },
    { tag: [m.literal, m.inserted], color: '#164' },
    { tag: [m.string, m.deleted], color: '#a11' },
    { tag: [m.regexp, m.escape, m.special(m.string)], color: '#e40' },
    { tag: m.definition(m.variableName), color: '#00f' },
    { tag: m.local(m.variableName), color: '#30a' },
    { tag: [m.typeName, m.namespace], color: '#085' },
    { tag: m.className, color: '#167' },
    { tag: [m.special(m.variableName), m.macroName], color: '#256' },
    { tag: m.definition(m.propertyName), color: '#00c' },
    { tag: m.comment, color: '#940' },
    { tag: m.invalid, color: '#f00' }
  ]),
  RR = j.baseTheme({
    '&.cm-focused .cm-matchingBracket': { backgroundColor: '#328c8252' },
    '&.cm-focused .cm-nonmatchingBracket': { backgroundColor: '#bb555544' }
  }),
  Ib = 1e4,
  jb = '()[]{}',
  Nb = U.define({
    combine(n) {
      return on(n, {
        afterCursor: !0,
        brackets: jb,
        maxScanDistance: Ib,
        renderMatch: ER
      })
    }
  }),
  ZR = G.mark({ class: 'cm-matchingBracket' }),
  AR = G.mark({ class: 'cm-nonmatchingBracket' })
function ER(n) {
  let e = [],
    t = n.matched ? ZR : AR
  return (
    e.push(t.range(n.start.from, n.start.to)),
    n.end && e.push(t.range(n.end.from, n.end.to)),
    e
  )
}
const DR = je.define({
    create() {
      return G.none
    },
    update(n, e) {
      if (!e.docChanged && !e.selection) return n
      let t = [],
        r = e.state.facet(Nb)
      for (let i of e.state.selection.ranges) {
        if (!i.empty) continue
        let s =
          en(e.state, i.head, -1, r) ||
          (i.head > 0 && en(e.state, i.head - 1, 1, r)) ||
          (r.afterCursor &&
            (en(e.state, i.head, 1, r) ||
              (i.head < e.state.doc.length && en(e.state, i.head + 1, -1, r))))
        s && (t = t.concat(r.renderMatch(s, e.state)))
      }
      return G.set(t, !0)
    },
    provide: (n) => j.decorations.from(n)
  }),
  XR = [DR, RR]
function YR(n = {}) {
  return [Nb.of(n), XR]
}
const Mb = new re()
function Gu(n, e, t) {
  let r = n.prop(e < 0 ? re.openedBy : re.closedBy)
  if (r) return r
  if (n.name.length == 1) {
    let i = t.indexOf(n.name)
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0)) return [t[i + e]]
  }
  return null
}
function Hu(n) {
  let e = n.type.prop(Mb)
  return e ? e(n.node) : n
}
function en(n, e, t, r = {}) {
  let i = r.maxScanDistance || Ib,
    s = r.brackets || jb,
    o = ke(n),
    a = o.resolveInner(e, t)
  for (let l = a; l; l = l.parent) {
    let c = Gu(l.type, t, s)
    if (c && l.from < l.to) {
      let u = Hu(l)
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return IR(n, e, t, l, u, c, s)
    }
  }
  return jR(n, e, t, o, a.type, i, s)
}
function IR(n, e, t, r, i, s, o) {
  let a = r.parent,
    l = { from: i.from, to: i.to },
    c = 0,
    u = a == null ? void 0 : a.cursor()
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let f = Hu(u)
          return {
            start: l,
            end: f ? { from: f.from, to: f.to } : void 0,
            matched: !0
          }
        } else if (Gu(u.type, t, o)) c++
        else if (Gu(u.type, -t, o)) {
          if (c == 0) {
            let f = Hu(u)
            return {
              start: l,
              end: f && f.from < f.to ? { from: f.from, to: f.to } : void 0,
              matched: !1
            }
          }
          c--
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling())
  return { start: l, matched: !1 }
}
function jR(n, e, t, r, i, s, o) {
  let a = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1),
    l = o.indexOf(a)
  if (l < 0 || (l % 2 == 0) != t > 0) return null
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e },
    u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0),
    f = 0
  for (let p = 0; !u.next().done && p <= s; ) {
    let d = u.value
    t < 0 && (p += d.length)
    let O = e + p * t
    for (
      let g = t > 0 ? 0 : d.length - 1, b = t > 0 ? d.length : -1;
      g != b;
      g += t
    ) {
      let x = o.indexOf(d[g])
      if (!(x < 0 || r.resolveInner(O + g, 1).type != i))
        if ((x % 2 == 0) == t > 0) f++
        else {
          if (f == 1)
            return {
              start: c,
              end: { from: O + g, to: O + g + 1 },
              matched: x >> 1 == l >> 1
            }
          f--
        }
    }
    t > 0 && (p += d.length)
  }
  return u.done ? { start: c, matched: !1 } : null
}
const NR = Object.create(null),
  hO = [it.none],
  pO = [],
  MR = Object.create(null)
for (let [n, e] of [
  ['variable', 'variableName'],
  ['variable-2', 'variableName.special'],
  ['string-2', 'string.special'],
  ['def', 'variableName.definition'],
  ['tag', 'tagName'],
  ['attribute', 'attributeName'],
  ['type', 'typeName'],
  ['builtin', 'variableName.standard'],
  ['qualifier', 'modifier'],
  ['error', 'invalid'],
  ['header', 'heading'],
  ['property', 'propertyName']
])
  MR[n] = VR(NR, e)
function Oc(n, e) {
  pO.indexOf(n) > -1 || (pO.push(n), console.warn(e))
}
function VR(n, e) {
  let t = []
  for (let s of e.split(' ')) {
    let o = []
    for (let a of s.split('.')) {
      let l = n[a] || m[a]
      l
        ? typeof l == 'function'
          ? o.length
            ? (o = o.map(l))
            : Oc(a, `Modifier ${a} used at start of tag`)
          : o.length
            ? Oc(a, `Tag ${a} used as modifier`)
            : (o = Array.isArray(l) ? l : [l])
        : Oc(a, `Unknown highlighting tag ${a}`)
    }
    for (let a of o) t.push(a)
  }
  if (!t.length) return 0
  let r = e.replace(/ /g, '_'),
    i = it.define({ id: hO.length, name: r, props: [vl({ [r]: t })] })
  return hO.push(i), i.id
}
const WR = (n) => {
  let { state: e } = n,
    t = e.doc.lineAt(e.selection.main.from),
    r = Kf(n.state, t.from)
  return r.line ? LR(n) : r.block ? UR(n) : !1
}
function Hf(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly) return !1
    let i = n(e, t)
    return i ? (r(t.update(i)), !0) : !1
  }
}
const LR = Hf(FR, 0),
  BR = Hf(Vb, 0),
  UR = Hf((n, e) => Vb(n, e, zR(e)), 0)
function Kf(n, e) {
  let t = n.languageDataAt('commentTokens', e)
  return t.length ? t[0] : {}
}
const ki = 50
function qR(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - ki, r),
    o = n.sliceDoc(i, i + ki),
    a = /\s*$/.exec(s)[0].length,
    l = /^\s*/.exec(o)[0].length,
    c = s.length - a
  if (s.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    }
  let u, f
  i - r <= 2 * ki
    ? (u = f = n.sliceDoc(r, i))
    : ((u = n.sliceDoc(r, r + ki)), (f = n.sliceDoc(i - ki, i)))
  let p = /^\s*/.exec(u)[0].length,
    d = /\s*$/.exec(f)[0].length,
    O = f.length - d - t.length
  return u.slice(p, p + e.length) == e && f.slice(O, O + t.length) == t
    ? {
        open: {
          pos: r + p + e.length,
          margin: /\s/.test(u.charAt(p + e.length)) ? 1 : 0
        },
        close: {
          pos: i - d - t.length,
          margin: /\s/.test(f.charAt(O - 1)) ? 1 : 0
        }
      }
    : null
}
function zR(n) {
  let e = []
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from),
      i = t.to <= r.to ? r : n.doc.lineAt(t.to),
      s = e.length - 1
    s >= 0 && e[s].to > r.from
      ? (e[s].to = i.to)
      : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to })
  }
  return e
}
function Vb(n, e, t = e.selection.ranges) {
  let r = t.map((s) => Kf(e, s.from).block)
  if (!r.every((s) => s)) return null
  let i = t.map((s, o) => qR(e, r[o], s.from, s.to))
  if (n != 2 && !i.every((s) => s))
    return {
      changes: e.changes(
        t.map((s, o) =>
          i[o]
            ? []
            : [
                { from: s.from, insert: r[o].open + ' ' },
                { from: s.to, insert: ' ' + r[o].close }
              ]
        )
      )
    }
  if (n != 1 && i.some((s) => s)) {
    let s = []
    for (let o = 0, a; o < i.length; o++)
      if ((a = i[o])) {
        let l = r[o],
          { open: c, close: u } = a
        s.push(
          { from: c.pos - l.open.length, to: c.pos + c.margin },
          { from: u.pos - u.margin, to: u.pos + l.close.length }
        )
      }
    return { changes: s }
  }
  return null
}
function FR(n, e, t = e.selection.ranges) {
  let r = [],
    i = -1
  for (let { from: s, to: o } of t) {
    let a = r.length,
      l = 1e9,
      c = Kf(e, s).line
    if (c) {
      for (let u = s; u <= o; ) {
        let f = e.doc.lineAt(u)
        if (f.from > i && (s == o || o > f.from)) {
          i = f.from
          let p = /^\s*/.exec(f.text)[0].length,
            d = p == f.length,
            O = f.text.slice(p, p + c.length) == c ? p : -1
          p < f.text.length && p < l && (l = p),
            r.push({
              line: f,
              comment: O,
              token: c,
              indent: p,
              empty: d,
              single: !1
            })
        }
        u = f.to + 1
      }
      if (l < 1e9)
        for (let u = a; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = l)
      r.length == a + 1 && (r[a].single = !0)
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = []
    for (let { line: a, token: l, indent: c, empty: u, single: f } of r)
      (f || !u) && s.push({ from: a.from + c, insert: l + ' ' })
    let o = e.changes(s)
    return { changes: o, selection: e.selection.map(o, 1) }
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = []
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a,
          u = c + l.length
        o.text[u - o.from] == ' ' && u++, s.push({ from: c, to: u })
      }
    return { changes: s }
  }
  return null
}
const Ku = sn.define(),
  GR = sn.define(),
  HR = U.define(),
  Wb = U.define({
    combine(n) {
      return on(
        n,
        { minDepth: 100, newGroupDelay: 500, joinToEvent: (e, t) => t },
        {
          minDepth: Math.max,
          newGroupDelay: Math.min,
          joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
        }
      )
    }
  })
function KR(n) {
  let e = 0
  return n.iterChangedRanges((t, r) => (e = r)), e
}
const Lb = je.define({
  create() {
    return tn.empty
  },
  update(n, e) {
    let t = e.state.facet(Wb),
      r = e.annotation(Ku)
    if (r) {
      let l = e.docChanged ? C.single(KR(e.changes)) : void 0,
        c = ct.fromTransaction(e, l),
        u = r.side,
        f = u == 0 ? n.undone : n.done
      return (
        c
          ? (f = Xa(f, f.length, t.minDepth, c))
          : (f = qb(f, e.startState.selection)),
        new tn(u == 0 ? r.rest : f, u == 0 ? f : r.rest)
      )
    }
    let i = e.annotation(GR)
    if (
      ((i == 'full' || i == 'before') && (n = n.isolate()),
      e.annotation(Ee.addToHistory) === !1)
    )
      return e.changes.empty ? n : n.addMapping(e.changes.desc)
    let s = ct.fromTransaction(e),
      o = e.annotation(Ee.time),
      a = e.annotation(Ee.userEvent)
    return (
      s
        ? (n = n.addChanges(s, o, a, t, e))
        : e.selection &&
          (n = n.addSelection(e.startState.selection, o, a, t.newGroupDelay)),
      (i == 'full' || i == 'after') && (n = n.isolate()),
      n
    )
  },
  toJSON(n) {
    return {
      done: n.done.map((e) => e.toJSON()),
      undone: n.undone.map((e) => e.toJSON())
    }
  },
  fromJSON(n) {
    return new tn(n.done.map(ct.fromJSON), n.undone.map(ct.fromJSON))
  }
})
function JR(n = {}) {
  return [
    Lb,
    Wb.of(n),
    j.domEventHandlers({
      beforeinput(e, t) {
        let r =
          e.inputType == 'historyUndo'
            ? Bb
            : e.inputType == 'historyRedo'
              ? Ju
              : null
        return r ? (e.preventDefault(), r(t)) : !1
      }
    })
  ]
}
function Tl(n, e) {
  return function ({ state: t, dispatch: r }) {
    if (!e && t.readOnly) return !1
    let i = t.field(Lb, !1)
    if (!i) return !1
    let s = i.pop(n, t, e)
    return s ? (r(s), !0) : !1
  }
}
const Bb = Tl(0, !1),
  Ju = Tl(1, !1),
  eZ = Tl(0, !0),
  tZ = Tl(1, !0)
class ct {
  constructor(e, t, r, i, s) {
    ;(this.changes = e),
      (this.effects = t),
      (this.mapped = r),
      (this.startSelection = i),
      (this.selectionsAfter = s)
  }
  setSelAfter(e) {
    return new ct(
      this.changes,
      this.effects,
      this.mapped,
      this.startSelection,
      e
    )
  }
  toJSON() {
    var e, t, r
    return {
      changes:
        (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection:
        (r = this.startSelection) === null || r === void 0
          ? void 0
          : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    }
  }
  static fromJSON(e) {
    return new ct(
      e.changes && Ae.fromJSON(e.changes),
      [],
      e.mapped && nn.fromJSON(e.mapped),
      e.startSelection && C.fromJSON(e.startSelection),
      e.selectionsAfter.map(C.fromJSON)
    )
  }
  static fromTransaction(e, t) {
    let r = Ct
    for (let i of e.startState.facet(HR)) {
      let s = i(e)
      s.length && (r = r.concat(s))
    }
    return !r.length && e.changes.empty
      ? null
      : new ct(
          e.changes.invert(e.startState.doc),
          r,
          void 0,
          t || e.startState.selection,
          Ct
        )
  }
  static selection(e) {
    return new ct(void 0, Ct, void 0, void 0, e)
  }
}
function Xa(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0,
    s = n.slice(i, e)
  return s.push(r), s
}
function nZ(n, e) {
  let t = [],
    r = !1
  return (
    n.iterChangedRanges((i, s) => t.push(i, s)),
    e.iterChangedRanges((i, s, o, a) => {
      for (let l = 0; l < t.length; ) {
        let c = t[l++],
          u = t[l++]
        a >= c && o <= u && (r = !0)
      }
    }),
    r
  )
}
function rZ(n, e) {
  return (
    n.ranges.length == e.ranges.length &&
    n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0
  )
}
function Ub(n, e) {
  return n.length ? (e.length ? n.concat(e) : n) : e
}
const Ct = [],
  iZ = 200
function qb(n, e) {
  if (n.length) {
    let t = n[n.length - 1],
      r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - iZ))
    return r.length && r[r.length - 1].eq(e)
      ? n
      : (r.push(e), Xa(n, n.length - 1, 1e9, t.setSelAfter(r)))
  } else return [ct.selection([e])]
}
function sZ(n) {
  let e = n[n.length - 1],
    t = n.slice()
  return (
    (t[n.length - 1] = e.setSelAfter(
      e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)
    )),
    t
  )
}
function mc(n, e) {
  if (!n.length) return n
  let t = n.length,
    r = Ct
  for (; t; ) {
    let i = oZ(n[t - 1], e, r)
    if ((i.changes && !i.changes.empty) || i.effects.length) {
      let s = n.slice(0, t)
      return (s[t - 1] = i), s
    } else (e = i.mapped), t--, (r = i.selectionsAfter)
  }
  return r.length ? [ct.selection(r)] : Ct
}
function oZ(n, e, t) {
  let r = Ub(
    n.selectionsAfter.length ? n.selectionsAfter.map((a) => a.map(e)) : Ct,
    t
  )
  if (!n.changes) return ct.selection(r)
  let i = n.changes.map(e),
    s = e.mapDesc(n.changes, !0),
    o = n.mapped ? n.mapped.composeDesc(s) : s
  return new ct(i, ee.mapEffects(n.effects, e), o, n.startSelection.map(s), r)
}
const aZ = /^(input\.type|delete)($|\.)/
class tn {
  constructor(e, t, r = 0, i = void 0) {
    ;(this.done = e),
      (this.undone = t),
      (this.prevTime = r),
      (this.prevUserEvent = i)
  }
  isolate() {
    return this.prevTime ? new tn(this.done, this.undone) : this
  }
  addChanges(e, t, r, i, s) {
    let o = this.done,
      a = o[o.length - 1]
    return (
      a &&
      a.changes &&
      !a.changes.empty &&
      e.changes &&
      (!r || aZ.test(r)) &&
      ((!a.selectionsAfter.length &&
        t - this.prevTime < i.newGroupDelay &&
        i.joinToEvent(s, nZ(a.changes, e.changes))) ||
        r == 'input.type.compose')
        ? (o = Xa(
            o,
            o.length - 1,
            i.minDepth,
            new ct(
              e.changes.compose(a.changes),
              Ub(e.effects, a.effects),
              a.mapped,
              a.startSelection,
              Ct
            )
          ))
        : (o = Xa(o, o.length, i.minDepth, e)),
      new tn(o, Ct, t, r)
    )
  }
  addSelection(e, t, r, i) {
    let s = this.done.length
      ? this.done[this.done.length - 1].selectionsAfter
      : Ct
    return s.length > 0 &&
      t - this.prevTime < i &&
      r == this.prevUserEvent &&
      r &&
      /^select($|\.)/.test(r) &&
      rZ(s[s.length - 1], e)
      ? this
      : new tn(qb(this.done, e), this.undone, t, r)
  }
  addMapping(e) {
    return new tn(
      mc(this.done, e),
      mc(this.undone, e),
      this.prevTime,
      this.prevUserEvent
    )
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone
    if (i.length == 0) return null
    let s = i[i.length - 1]
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Ku.of({ side: e, rest: sZ(i) }),
        userEvent: e == 0 ? 'select.undo' : 'select.redo',
        scrollIntoView: !0
      })
    if (s.changes) {
      let o = i.length == 1 ? Ct : i.slice(0, i.length - 1)
      return (
        s.mapped && (o = mc(o, s.mapped)),
        t.update({
          changes: s.changes,
          selection: s.startSelection,
          effects: s.effects,
          annotations: Ku.of({ side: e, rest: o }),
          filter: !1,
          userEvent: e == 0 ? 'undo' : 'redo',
          scrollIntoView: !0
        })
      )
    } else return null
  }
}
tn.empty = new tn(Ct, Ct)
const lZ = [
  { key: 'Mod-z', run: Bb, preventDefault: !0 },
  { key: 'Mod-y', mac: 'Mod-Shift-z', run: Ju, preventDefault: !0 },
  { linux: 'Ctrl-Shift-z', run: Ju, preventDefault: !0 },
  { key: 'Mod-u', run: eZ, preventDefault: !0 },
  { key: 'Alt-u', mac: 'Mod-Shift-u', run: tZ, preventDefault: !0 }
]
function li(n, e) {
  return C.create(n.ranges.map(e), n.mainIndex)
}
function ln(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: 'select' })
}
function jt({ state: n, dispatch: e }, t) {
  let r = li(n.selection, t)
  return r.eq(n.selection) ? !1 : (e(ln(n, r)), !0)
}
function $l(n, e) {
  return C.cursor(e ? n.to : n.from)
}
function zb(n, e) {
  return jt(n, (t) => (t.empty ? n.moveByChar(t, e) : $l(t, e)))
}
function Je(n) {
  return n.textDirectionAt(n.state.selection.main.head) == we.LTR
}
const Fb = (n) => zb(n, !Je(n)),
  Gb = (n) => zb(n, Je(n))
function Hb(n, e) {
  return jt(n, (t) => (t.empty ? n.moveByGroup(t, e) : $l(t, e)))
}
const cZ = (n) => Hb(n, !Je(n)),
  uZ = (n) => Hb(n, Je(n))
function fZ(n, e, t) {
  if (e.type.prop(t)) return !0
  let r = e.to - e.from
  return (
    (r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to)))) || e.firstChild
  )
}
function Ql(n, e, t) {
  let r = ke(n).resolveInner(e.head),
    i = t ? re.closedBy : re.openedBy
  for (let l = e.head; ; ) {
    let c = t ? r.childAfter(l) : r.childBefore(l)
    if (!c) break
    fZ(n, c, i) ? (r = c) : (l = t ? c.to : c.from)
  }
  let s = r.type.prop(i),
    o,
    a
  return (
    s && (o = t ? en(n, r.from, 1) : en(n, r.to, -1)) && o.matched
      ? (a = t ? o.end.to : o.end.from)
      : (a = t ? r.to : r.from),
    C.cursor(a, t ? -1 : 1)
  )
}
const hZ = (n) => jt(n, (e) => Ql(n.state, e, !Je(n))),
  pZ = (n) => jt(n, (e) => Ql(n.state, e, Je(n)))
function Kb(n, e) {
  return jt(n, (t) => {
    if (!t.empty) return $l(t, e)
    let r = n.moveVertically(t, e)
    return r.head != t.head ? r : n.moveToLineBoundary(t, e)
  })
}
const Jb = (n) => Kb(n, !1),
  ev = (n) => Kb(n, !0)
function tv(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2,
    t = 0,
    r = 0,
    i
  if (e) {
    for (let s of n.state.facet(j.scrollMargins)) {
      let o = s(n)
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)),
        o != null &&
          o.bottom &&
          (r = Math.max(o == null ? void 0 : o.bottom, r))
    }
    i = n.scrollDOM.clientHeight - t - r
  } else i = (n.dom.ownerDocument.defaultView || window).innerHeight
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  }
}
function nv(n, e) {
  let t = tv(n),
    { state: r } = n,
    i = li(r.selection, (o) =>
      o.empty ? n.moveVertically(o, e, t.height) : $l(o, e)
    )
  if (i.eq(r.selection)) return !1
  let s
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head),
      a = n.scrollDOM.getBoundingClientRect(),
      l = a.top + t.marginTop,
      c = a.bottom - t.marginBottom
    o &&
      o.top > l &&
      o.bottom < c &&
      (s = j.scrollIntoView(i.main.head, { y: 'start', yMargin: o.top - l }))
  }
  return n.dispatch(ln(r, i), { effects: s }), !0
}
const dO = (n) => nv(n, !1),
  ef = (n) => nv(n, !0)
function Gn(n, e, t) {
  let r = n.lineBlockAt(e.head),
    i = n.moveToLineBoundary(e, t)
  if (
    (i.head == e.head &&
      i.head != (t ? r.to : r.from) &&
      (i = n.moveToLineBoundary(e, t, !1)),
    !t && i.head == r.from && r.length)
  ) {
    let s = /^\s*/.exec(
      n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to))
    )[0].length
    s && e.head != r.from + s && (i = C.cursor(r.from + s))
  }
  return i
}
const dZ = (n) => jt(n, (e) => Gn(n, e, !0)),
  OZ = (n) => jt(n, (e) => Gn(n, e, !1)),
  mZ = (n) => jt(n, (e) => Gn(n, e, !Je(n))),
  gZ = (n) => jt(n, (e) => Gn(n, e, Je(n))),
  yZ = (n) => jt(n, (e) => C.cursor(n.lineBlockAt(e.head).from, 1)),
  bZ = (n) => jt(n, (e) => C.cursor(n.lineBlockAt(e.head).to, -1))
function vZ(n, e, t) {
  let r = !1,
    i = li(n.selection, (s) => {
      let o =
        en(n, s.head, -1) ||
        en(n, s.head, 1) ||
        (s.head > 0 && en(n, s.head - 1, 1)) ||
        (s.head < n.doc.length && en(n, s.head + 1, -1))
      if (!o || !o.end) return s
      r = !0
      let a = o.start.from == s.head ? o.end.to : o.end.from
      return t ? C.range(s.anchor, a) : C.cursor(a)
    })
  return r ? (e(ln(n, i)), !0) : !1
}
const SZ = ({ state: n, dispatch: e }) => vZ(n, e, !1)
function Zt(n, e) {
  let t = li(n.state.selection, (r) => {
    let i = e(r)
    return C.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0)
  })
  return t.eq(n.state.selection) ? !1 : (n.dispatch(ln(n.state, t)), !0)
}
function rv(n, e) {
  return Zt(n, (t) => n.moveByChar(t, e))
}
const iv = (n) => rv(n, !Je(n)),
  sv = (n) => rv(n, Je(n))
function ov(n, e) {
  return Zt(n, (t) => n.moveByGroup(t, e))
}
const xZ = (n) => ov(n, !Je(n)),
  wZ = (n) => ov(n, Je(n)),
  PZ = (n) => Zt(n, (e) => Ql(n.state, e, !Je(n))),
  TZ = (n) => Zt(n, (e) => Ql(n.state, e, Je(n)))
function av(n, e) {
  return Zt(n, (t) => n.moveVertically(t, e))
}
const lv = (n) => av(n, !1),
  cv = (n) => av(n, !0)
function uv(n, e) {
  return Zt(n, (t) => n.moveVertically(t, e, tv(n).height))
}
const OO = (n) => uv(n, !1),
  mO = (n) => uv(n, !0),
  $Z = (n) => Zt(n, (e) => Gn(n, e, !0)),
  QZ = (n) => Zt(n, (e) => Gn(n, e, !1)),
  kZ = (n) => Zt(n, (e) => Gn(n, e, !Je(n))),
  CZ = (n) => Zt(n, (e) => Gn(n, e, Je(n))),
  _Z = (n) => Zt(n, (e) => C.cursor(n.lineBlockAt(e.head).from)),
  RZ = (n) => Zt(n, (e) => C.cursor(n.lineBlockAt(e.head).to)),
  gO = ({ state: n, dispatch: e }) => (e(ln(n, { anchor: 0 })), !0),
  yO = ({ state: n, dispatch: e }) => (e(ln(n, { anchor: n.doc.length })), !0),
  bO = ({ state: n, dispatch: e }) => (
    e(ln(n, { anchor: n.selection.main.anchor, head: 0 })), !0
  ),
  vO = ({ state: n, dispatch: e }) => (
    e(ln(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0
  ),
  ZZ = ({ state: n, dispatch: e }) => (
    e(
      n.update({
        selection: { anchor: 0, head: n.doc.length },
        userEvent: 'select'
      })
    ),
    !0
  ),
  AZ = ({ state: n, dispatch: e }) => {
    let t = kl(n).map(({ from: r, to: i }) =>
      C.range(r, Math.min(i + 1, n.doc.length))
    )
    return e(n.update({ selection: C.create(t), userEvent: 'select' })), !0
  },
  EZ = ({ state: n, dispatch: e }) => {
    let t = li(n.selection, (r) => {
      var i
      let s = ke(n).resolveStack(r.from, 1)
      for (let o = s; o; o = o.next) {
        let { node: a } = o
        if (
          ((a.from < r.from && a.to >= r.to) ||
            (a.to > r.to && a.from <= r.from)) &&
          !((i = a.parent) === null || i === void 0) &&
          i.parent
        )
          return C.range(a.to, a.from)
      }
      return r
    })
    return e(ln(n, t)), !0
  },
  DZ = ({ state: n, dispatch: e }) => {
    let t = n.selection,
      r = null
    return (
      t.ranges.length > 1
        ? (r = C.create([t.main]))
        : t.main.empty || (r = C.create([C.cursor(t.main.head)])),
      r ? (e(ln(n, r)), !0) : !1
    )
  }
function ks(n, e) {
  if (n.state.readOnly) return !1
  let t = 'delete.selection',
    { state: r } = n,
    i = r.changeByRange((s) => {
      let { from: o, to: a } = s
      if (o == a) {
        let l = e(s)
        l < o
          ? ((t = 'delete.backward'), (l = ao(n, l, !1)))
          : l > o && ((t = 'delete.forward'), (l = ao(n, l, !0))),
          (o = Math.min(o, l)),
          (a = Math.max(a, l))
      } else (o = ao(n, o, !1)), (a = ao(n, a, !0))
      return o == a
        ? { range: s }
        : {
            changes: { from: o, to: a },
            range: C.cursor(o, o < s.head ? -1 : 1)
          }
    })
  return i.changes.empty
    ? !1
    : (n.dispatch(
        r.update(i, {
          scrollIntoView: !0,
          userEvent: t,
          effects:
            t == 'delete.selection'
              ? j.announce.of(r.phrase('Selection deleted'))
              : void 0
        })
      ),
      !0)
}
function ao(n, e, t) {
  if (n instanceof j)
    for (let r of n.state.facet(j.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i)
      })
  return e
}
const fv = (n, e) =>
    ks(n, (t) => {
      let r = t.from,
        { state: i } = n,
        s = i.doc.lineAt(r),
        o,
        a
      if (
        !e &&
        r > s.from &&
        r < s.from + 200 &&
        !/[^ \t]/.test((o = s.text.slice(0, r - s.from)))
      ) {
        if (o[o.length - 1] == '	') return r - 1
        let l = oi(o, i.tabSize),
          c = l % Aa(i) || Aa(i)
        for (let u = 0; u < c && o[o.length - 1 - u] == ' '; u++) r--
        a = r
      } else
        (a = He(s.text, r - s.from, e, e) + s.from),
          a == r && s.number != (e ? i.doc.lines : 1) && (a += e ? 1 : -1)
      return a
    }),
  tf = (n) => fv(n, !1),
  hv = (n) => fv(n, !0),
  pv = (n, e) =>
    ks(n, (t) => {
      let r = t.head,
        { state: i } = n,
        s = i.doc.lineAt(r),
        o = i.charCategorizer(r)
      for (let a = null; ; ) {
        if (r == (e ? s.to : s.from)) {
          r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1)
          break
        }
        let l = He(s.text, r - s.from, e) + s.from,
          c = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from),
          u = o(c)
        if (a != null && u != a) break
        ;(c != ' ' || r != t.head) && (a = u), (r = l)
      }
      return r
    }),
  dv = (n) => pv(n, !1),
  XZ = (n) => pv(n, !0),
  YZ = (n) =>
    ks(n, (e) => {
      let t = n.lineBlockAt(e.head).to
      return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1)
    }),
  IZ = (n) =>
    ks(n, (e) => {
      let t = n.moveToLineBoundary(e, !1).head
      return e.head > t ? t : Math.max(0, e.head - 1)
    }),
  jZ = (n) =>
    ks(n, (e) => {
      let t = n.moveToLineBoundary(e, !0).head
      return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1)
    }),
  NZ = ({ state: n, dispatch: e }) => {
    if (n.readOnly) return !1
    let t = n.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: le.of(['', '']) },
      range: C.cursor(r.from)
    }))
    return e(n.update(t, { scrollIntoView: !0, userEvent: 'input' })), !0
  },
  MZ = ({ state: n, dispatch: e }) => {
    if (n.readOnly) return !1
    let t = n.changeByRange((r) => {
      if (!r.empty || r.from == 0 || r.from == n.doc.length) return { range: r }
      let i = r.from,
        s = n.doc.lineAt(i),
        o = i == s.from ? i - 1 : He(s.text, i - s.from, !1) + s.from,
        a = i == s.to ? i + 1 : He(s.text, i - s.from, !0) + s.from
      return {
        changes: {
          from: o,
          to: a,
          insert: n.doc.slice(i, a).append(n.doc.slice(o, i))
        },
        range: C.cursor(a)
      }
    })
    return t.changes.empty
      ? !1
      : (e(n.update(t, { scrollIntoView: !0, userEvent: 'move.character' })),
        !0)
  }
function kl(n) {
  let e = [],
    t = -1
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from),
      s = n.doc.lineAt(r.to)
    if (
      (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)),
      t >= i.number)
    ) {
      let o = e[e.length - 1]
      ;(o.to = s.to), o.ranges.push(r)
    } else e.push({ from: i.from, to: s.to, ranges: [r] })
    t = s.number + 1
  }
  return e
}
function Ov(n, e, t) {
  if (n.readOnly) return !1
  let r = [],
    i = []
  for (let s of kl(n)) {
    if (t ? s.to == n.doc.length : s.from == 0) continue
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1),
      a = o.length + 1
    if (t) {
      r.push(
        { from: s.to, to: o.to },
        { from: s.from, insert: o.text + n.lineBreak }
      )
      for (let l of s.ranges)
        i.push(
          C.range(
            Math.min(n.doc.length, l.anchor + a),
            Math.min(n.doc.length, l.head + a)
          )
        )
    } else {
      r.push(
        { from: o.from, to: s.from },
        { from: s.to, insert: n.lineBreak + o.text }
      )
      for (let l of s.ranges) i.push(C.range(l.anchor - a, l.head - a))
    }
  }
  return r.length
    ? (e(
        n.update({
          changes: r,
          scrollIntoView: !0,
          selection: C.create(i, n.selection.mainIndex),
          userEvent: 'move.line'
        })
      ),
      !0)
    : !1
}
const VZ = ({ state: n, dispatch: e }) => Ov(n, e, !1),
  WZ = ({ state: n, dispatch: e }) => Ov(n, e, !0)
function mv(n, e, t) {
  if (n.readOnly) return !1
  let r = []
  for (let i of kl(n))
    t
      ? r.push({
          from: i.from,
          insert: n.doc.slice(i.from, i.to) + n.lineBreak
        })
      : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) })
  return (
    e(
      n.update({ changes: r, scrollIntoView: !0, userEvent: 'input.copyline' })
    ),
    !0
  )
}
const LZ = ({ state: n, dispatch: e }) => mv(n, e, !1),
  BZ = ({ state: n, dispatch: e }) => mv(n, e, !0),
  UZ = (n) => {
    if (n.state.readOnly) return !1
    let { state: e } = n,
      t = e.changes(
        kl(e).map(
          ({ from: i, to: s }) => (
            i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }
          )
        )
      ),
      r = li(e.selection, (i) => n.moveVertically(i, !0)).map(t)
    return (
      n.dispatch({
        changes: t,
        selection: r,
        scrollIntoView: !0,
        userEvent: 'delete.line'
      }),
      !0
    )
  }
function qZ(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1))) return { from: e, to: e }
  let t = ke(n).resolveInner(e),
    r = t.childBefore(e),
    i = t.childAfter(e),
    s
  return r &&
    i &&
    r.to <= e &&
    i.from >= e &&
    (s = r.type.prop(re.closedBy)) &&
    s.indexOf(i.name) > -1 &&
    n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from &&
    !/\S/.test(n.sliceDoc(r.to, i.from))
    ? { from: r.to, to: i.from }
    : null
}
const zZ = gv(!1),
  FZ = gv(!0)
function gv(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly) return !1
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i,
        a = e.doc.lineAt(s),
        l = !n && s == o && qZ(e, s)
      n && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to)
      let c = new Sl(e, { simulateBreak: s, simulateDoubleBreak: !!l }),
        u = qf(c, s)
      for (
        u == null && (u = oi(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize));
        o < a.to && /\s/.test(a.text[o - a.from]);

      )
        o++
      l
        ? ({ from: s, to: o } = l)
        : s > a.from &&
          s < a.from + 100 &&
          !/\S/.test(a.text.slice(0, s)) &&
          (s = a.from)
      let f = ['', os(e, u)]
      return (
        l && f.push(os(e, c.lineIndent(a.from, -1))),
        {
          changes: { from: s, to: o, insert: le.of(f) },
          range: C.cursor(s + 1 + f[1].length)
        }
      )
    })
    return t(e.update(r, { scrollIntoView: !0, userEvent: 'input' })), !0
  }
}
function Jf(n, e) {
  let t = -1
  return n.changeByRange((r) => {
    let i = []
    for (let o = r.from; o <= r.to; ) {
      let a = n.doc.lineAt(o)
      a.number > t &&
        (r.empty || r.to > a.from) &&
        (e(a, i, r), (t = a.number)),
        (o = a.to + 1)
    }
    let s = n.changes(i)
    return {
      changes: i,
      range: C.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    }
  })
}
const GZ = ({ state: n, dispatch: e }) => {
    if (n.readOnly) return !1
    let t = Object.create(null),
      r = new Sl(n, {
        overrideIndentation: (s) => {
          let o = t[s]
          return o ?? -1
        }
      }),
      i = Jf(n, (s, o, a) => {
        let l = qf(r, s.from)
        if (l == null) return
        ;/\S/.test(s.text) || (l = 0)
        let c = /^\s*/.exec(s.text)[0],
          u = os(n, l)
        ;(c != u || a.from < s.from + c.length) &&
          ((t[s.from] = l),
          o.push({ from: s.from, to: s.from + c.length, insert: u }))
      })
    return i.changes.empty || e(n.update(i, { userEvent: 'indent' })), !0
  },
  yv = ({ state: n, dispatch: e }) =>
    n.readOnly
      ? !1
      : (e(
          n.update(
            Jf(n, (t, r) => {
              r.push({ from: t.from, insert: n.facet($s) })
            }),
            { userEvent: 'input.indent' }
          )
        ),
        !0),
  bv = ({ state: n, dispatch: e }) =>
    n.readOnly
      ? !1
      : (e(
          n.update(
            Jf(n, (t, r) => {
              let i = /^\s*/.exec(t.text)[0]
              if (!i) return
              let s = oi(i, n.tabSize),
                o = 0,
                a = os(n, Math.max(0, s - Aa(n)))
              for (
                ;
                o < i.length &&
                o < a.length &&
                i.charCodeAt(o) == a.charCodeAt(o);

              )
                o++
              r.push({
                from: t.from + o,
                to: t.from + i.length,
                insert: a.slice(o)
              })
            }),
            { userEvent: 'delete.dedent' }
          )
        ),
        !0),
  HZ = [
    { key: 'Ctrl-b', run: Fb, shift: iv, preventDefault: !0 },
    { key: 'Ctrl-f', run: Gb, shift: sv },
    { key: 'Ctrl-p', run: Jb, shift: lv },
    { key: 'Ctrl-n', run: ev, shift: cv },
    { key: 'Ctrl-a', run: yZ, shift: _Z },
    { key: 'Ctrl-e', run: bZ, shift: RZ },
    { key: 'Ctrl-d', run: hv },
    { key: 'Ctrl-h', run: tf },
    { key: 'Ctrl-k', run: YZ },
    { key: 'Ctrl-Alt-h', run: dv },
    { key: 'Ctrl-o', run: NZ },
    { key: 'Ctrl-t', run: MZ },
    { key: 'Ctrl-v', run: ef }
  ],
  KZ = [
    { key: 'ArrowLeft', run: Fb, shift: iv, preventDefault: !0 },
    {
      key: 'Mod-ArrowLeft',
      mac: 'Alt-ArrowLeft',
      run: cZ,
      shift: xZ,
      preventDefault: !0
    },
    { mac: 'Cmd-ArrowLeft', run: mZ, shift: kZ, preventDefault: !0 },
    { key: 'ArrowRight', run: Gb, shift: sv, preventDefault: !0 },
    {
      key: 'Mod-ArrowRight',
      mac: 'Alt-ArrowRight',
      run: uZ,
      shift: wZ,
      preventDefault: !0
    },
    { mac: 'Cmd-ArrowRight', run: gZ, shift: CZ, preventDefault: !0 },
    { key: 'ArrowUp', run: Jb, shift: lv, preventDefault: !0 },
    { mac: 'Cmd-ArrowUp', run: gO, shift: bO },
    { mac: 'Ctrl-ArrowUp', run: dO, shift: OO },
    { key: 'ArrowDown', run: ev, shift: cv, preventDefault: !0 },
    { mac: 'Cmd-ArrowDown', run: yO, shift: vO },
    { mac: 'Ctrl-ArrowDown', run: ef, shift: mO },
    { key: 'PageUp', run: dO, shift: OO },
    { key: 'PageDown', run: ef, shift: mO },
    { key: 'Home', run: OZ, shift: QZ, preventDefault: !0 },
    { key: 'Mod-Home', run: gO, shift: bO },
    { key: 'End', run: dZ, shift: $Z, preventDefault: !0 },
    { key: 'Mod-End', run: yO, shift: vO },
    { key: 'Enter', run: zZ },
    { key: 'Mod-a', run: ZZ },
    { key: 'Backspace', run: tf, shift: tf },
    { key: 'Delete', run: hv },
    { key: 'Mod-Backspace', mac: 'Alt-Backspace', run: dv },
    { key: 'Mod-Delete', mac: 'Alt-Delete', run: XZ },
    { mac: 'Mod-Backspace', run: IZ },
    { mac: 'Mod-Delete', run: jZ }
  ].concat(HZ.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))),
  JZ = [
    { key: 'Alt-ArrowLeft', mac: 'Ctrl-ArrowLeft', run: hZ, shift: PZ },
    { key: 'Alt-ArrowRight', mac: 'Ctrl-ArrowRight', run: pZ, shift: TZ },
    { key: 'Alt-ArrowUp', run: VZ },
    { key: 'Shift-Alt-ArrowUp', run: LZ },
    { key: 'Alt-ArrowDown', run: WZ },
    { key: 'Shift-Alt-ArrowDown', run: BZ },
    { key: 'Escape', run: DZ },
    { key: 'Mod-Enter', run: FZ },
    { key: 'Alt-l', mac: 'Ctrl-l', run: AZ },
    { key: 'Mod-i', run: EZ, preventDefault: !0 },
    { key: 'Mod-[', run: bv },
    { key: 'Mod-]', run: yv },
    { key: 'Mod-Alt-\\', run: GZ },
    { key: 'Shift-Mod-k', run: UZ },
    { key: 'Shift-Mod-\\', run: SZ },
    { key: 'Mod-/', run: WR },
    { key: 'Alt-A', run: BR }
  ].concat(KZ),
  eA = { key: 'Tab', run: yv, shift: bv }
function de() {
  var n = arguments[0]
  typeof n == 'string' && (n = document.createElement(n))
  var e = 1,
    t = arguments[1]
  if (t && typeof t == 'object' && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        var i = t[r]
        typeof i == 'string' ? n.setAttribute(r, i) : i != null && (n[r] = i)
      }
    e++
  }
  for (; e < arguments.length; e++) vv(n, arguments[e])
  return n
}
function vv(n, e) {
  if (typeof e == 'string') n.appendChild(document.createTextNode(e))
  else if (e != null)
    if (e.nodeType != null) n.appendChild(e)
    else if (Array.isArray(e)) for (var t = 0; t < e.length; t++) vv(n, e[t])
    else throw new RangeError('Unsupported child node: ' + e)
}
const SO =
  typeof String.prototype.normalize == 'function'
    ? (n) => n.normalize('NFKD')
    : (n) => n
class ei {
  constructor(e, t, r = 0, i = e.length, s, o) {
    ;(this.test = o),
      (this.value = { from: 0, to: 0 }),
      (this.done = !1),
      (this.matches = []),
      (this.buffer = ''),
      (this.bufferPos = 0),
      (this.iter = e.iterRange(r, i)),
      (this.bufferStart = r),
      (this.normalize = s ? (a) => s(SO(a)) : SO),
      (this.query = this.normalize(t))
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (
        ((this.bufferStart += this.buffer.length),
        this.iter.next(),
        this.iter.done)
      )
        return -1
      ;(this.bufferPos = 0), (this.buffer = this.iter.value)
    }
    return Le(this.buffer, this.bufferPos)
  }
  next() {
    for (; this.matches.length; ) this.matches.pop()
    return this.nextOverlapping()
  }
  nextOverlapping() {
    for (;;) {
      let e = this.peek()
      if (e < 0) return (this.done = !0), this
      let t = _f(e),
        r = this.bufferStart + this.bufferPos
      this.bufferPos += $t(e)
      let i = this.normalize(t)
      for (let s = 0, o = r; ; s++) {
        let a = i.charCodeAt(s),
          l = this.match(a, o)
        if (s == i.length - 1) {
          if (l) return (this.value = l), this
          break
        }
        o == r && s < t.length && t.charCodeAt(s) == a && o++
      }
    }
  }
  match(e, t) {
    let r = null
    for (let i = 0; i < this.matches.length; i += 2) {
      let s = this.matches[i],
        o = !1
      this.query.charCodeAt(s) == e &&
        (s == this.query.length - 1
          ? (r = { from: this.matches[i + 1], to: t + 1 })
          : (this.matches[i]++, (o = !0))),
        o || (this.matches.splice(i, 2), (i -= 2))
    }
    return (
      this.query.charCodeAt(0) == e &&
        (this.query.length == 1
          ? (r = { from: t, to: t + 1 })
          : this.matches.push(1, t)),
      r &&
        this.test &&
        !this.test(r.from, r.to, this.buffer, this.bufferStart) &&
        (r = null),
      r
    )
  }
}
typeof Symbol < 'u' &&
  (ei.prototype[Symbol.iterator] = function () {
    return this
  })
const Sv = { from: -1, to: -1, match: /.*/.exec('') },
  eh = 'gm' + (/x/.unicode == null ? '' : 'u')
class xv {
  constructor(e, t, r, i = 0, s = e.length) {
    if (
      ((this.text = e),
      (this.to = s),
      (this.curLine = ''),
      (this.done = !1),
      (this.value = Sv),
      /\\[sWDnr]|\n|\r|\[\^/.test(t))
    )
      return new wv(e, t, r, i, s)
    ;(this.re = new RegExp(t, eh + (r != null && r.ignoreCase ? 'i' : ''))),
      (this.test = r == null ? void 0 : r.test),
      (this.iter = e.iter())
    let o = e.lineAt(i)
    ;(this.curLineStart = o.from),
      (this.matchPos = Ya(e, i)),
      this.getLine(this.curLineStart)
  }
  getLine(e) {
    this.iter.next(e),
      this.iter.lineBreak
        ? (this.curLine = '')
        : ((this.curLine = this.iter.value),
          this.curLineStart + this.curLine.length > this.to &&
            (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)),
          this.iter.next())
  }
  nextLine() {
    ;(this.curLineStart = this.curLineStart + this.curLine.length + 1),
      this.curLineStart > this.to ? (this.curLine = '') : this.getLine(0)
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e
      let t = this.matchPos <= this.to && this.re.exec(this.curLine)
      if (t) {
        let r = this.curLineStart + t.index,
          i = r + t[0].length
        if (
          ((this.matchPos = Ya(this.text, i + (r == i ? 1 : 0))),
          r == this.curLineStart + this.curLine.length && this.nextLine(),
          (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
        )
          return (this.value = { from: r, to: i, match: t }), this
        e = this.matchPos - this.curLineStart
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), (e = 0)
      else return (this.done = !0), this
    }
  }
}
const gc = new WeakMap()
class Vr {
  constructor(e, t) {
    ;(this.from = e), (this.text = t)
  }
  get to() {
    return this.from + this.text.length
  }
  static get(e, t, r) {
    let i = gc.get(e)
    if (!i || i.from >= r || i.to <= t) {
      let a = new Vr(t, e.sliceString(t, r))
      return gc.set(e, a), a
    }
    if (i.from == t && i.to == r) return i
    let { text: s, from: o } = i
    return (
      o > t && ((s = e.sliceString(t, o) + s), (o = t)),
      i.to < r && (s += e.sliceString(i.to, r)),
      gc.set(e, new Vr(o, s)),
      new Vr(t, s.slice(t - o, r - o))
    )
  }
}
class wv {
  constructor(e, t, r, i, s) {
    ;(this.text = e),
      (this.to = s),
      (this.done = !1),
      (this.value = Sv),
      (this.matchPos = Ya(e, i)),
      (this.re = new RegExp(t, eh + (r != null && r.ignoreCase ? 'i' : ''))),
      (this.test = r == null ? void 0 : r.test),
      (this.flat = Vr.get(e, i, this.chunkEnd(i + 5e3)))
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to
  }
  next() {
    for (;;) {
      let e = (this.re.lastIndex = this.matchPos - this.flat.from),
        t = this.re.exec(this.flat.text)
      if (
        (t &&
          !t[0] &&
          t.index == e &&
          ((this.re.lastIndex = e + 1), (t = this.re.exec(this.flat.text))),
        t)
      ) {
        let r = this.flat.from + t.index,
          i = r + t[0].length
        if (
          (this.flat.to >= this.to ||
            t.index + t[0].length <= this.flat.text.length - 10) &&
          (!this.test || this.test(r, i, t))
        )
          return (
            (this.value = { from: r, to: i, match: t }),
            (this.matchPos = Ya(this.text, i + (r == i ? 1 : 0))),
            this
          )
      }
      if (this.flat.to == this.to) return (this.done = !0), this
      this.flat = Vr.get(
        this.text,
        this.flat.from,
        this.chunkEnd(this.flat.from + this.flat.text.length * 2)
      )
    }
  }
}
typeof Symbol < 'u' &&
  (xv.prototype[Symbol.iterator] = wv.prototype[Symbol.iterator] =
    function () {
      return this
    })
function tA(n) {
  try {
    return new RegExp(n, eh), !0
  } catch {
    return !1
  }
}
function Ya(n, e) {
  if (e >= n.length) return e
  let t = n.lineAt(e),
    r
  for (
    ;
    e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344;

  )
    e++
  return e
}
function nf(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number),
    t = de('input', { class: 'cm-textfield', name: 'line', value: e }),
    r = de(
      'form',
      {
        class: 'cm-gotoLine',
        onkeydown: (s) => {
          s.keyCode == 27
            ? (s.preventDefault(),
              n.dispatch({ effects: Ia.of(!1) }),
              n.focus())
            : s.keyCode == 13 && (s.preventDefault(), i())
        },
        onsubmit: (s) => {
          s.preventDefault(), i()
        }
      },
      de('label', n.state.phrase('Go to line'), ': ', t),
      ' ',
      de('button', { class: 'cm-button', type: 'submit' }, n.state.phrase('go'))
    )
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value)
    if (!s) return
    let { state: o } = n,
      a = o.doc.lineAt(o.selection.main.head),
      [, l, c, u, f] = s,
      p = u ? +u.slice(1) : 0,
      d = c ? +c : a.number
    if (c && f) {
      let b = d / 100
      l && (b = b * (l == '-' ? -1 : 1) + a.number / o.doc.lines),
        (d = Math.round(o.doc.lines * b))
    } else c && l && (d = d * (l == '-' ? -1 : 1) + a.number)
    let O = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))),
      g = C.cursor(O.from + Math.max(0, Math.min(p, O.length)))
    n.dispatch({
      effects: [Ia.of(!1), j.scrollIntoView(g.from, { y: 'center' })],
      selection: g
    }),
      n.focus()
  }
  return { dom: r }
}
const Ia = ee.define(),
  xO = je.define({
    create() {
      return !0
    },
    update(n, e) {
      for (let t of e.effects) t.is(Ia) && (n = t.value)
      return n
    },
    provide: (n) => rs.from(n, (e) => (e ? nf : null))
  }),
  nA = (n) => {
    let e = ns(n, nf)
    if (!e) {
      let t = [Ia.of(!0)]
      n.state.field(xO, !1) == null && t.push(ee.appendConfig.of([xO, rA])),
        n.dispatch({ effects: t }),
        (e = ns(n, nf))
    }
    return e && e.dom.querySelector('input').select(), !0
  },
  rA = j.baseTheme({
    '.cm-panel.cm-gotoLine': {
      padding: '2px 6px 4px',
      '& label': { fontSize: '80%' }
    }
  }),
  iA = {
    highlightWordAroundCursor: !1,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: !1
  },
  Pv = U.define({
    combine(n) {
      return on(n, iA, {
        highlightWordAroundCursor: (e, t) => e || t,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      })
    }
  })
function sA(n) {
  let e = [uA, cA]
  return n && e.push(Pv.of(n)), e
}
const oA = G.mark({ class: 'cm-selectionMatch' }),
  aA = G.mark({ class: 'cm-selectionMatch cm-selectionMatch-main' })
function wO(n, e, t, r) {
  return (
    (t == 0 || n(e.sliceDoc(t - 1, t)) != Se.Word) &&
    (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != Se.Word)
  )
}
function lA(n, e, t, r) {
  return (
    n(e.sliceDoc(t, t + 1)) == Se.Word && n(e.sliceDoc(r - 1, r)) == Se.Word
  )
}
const cA = _e.fromClass(
    class {
      constructor(n) {
        this.decorations = this.getDeco(n)
      }
      update(n) {
        ;(n.selectionSet || n.docChanged || n.viewportChanged) &&
          (this.decorations = this.getDeco(n.view))
      }
      getDeco(n) {
        let e = n.state.facet(Pv),
          { state: t } = n,
          r = t.selection
        if (r.ranges.length > 1) return G.none
        let i = r.main,
          s,
          o = null
        if (i.empty) {
          if (!e.highlightWordAroundCursor) return G.none
          let l = t.wordAt(i.head)
          if (!l) return G.none
          ;(o = t.charCategorizer(i.head)), (s = t.sliceDoc(l.from, l.to))
        } else {
          let l = i.to - i.from
          if (l < e.minSelectionLength || l > 200) return G.none
          if (e.wholeWords) {
            if (
              ((s = t.sliceDoc(i.from, i.to)),
              (o = t.charCategorizer(i.head)),
              !(wO(o, t, i.from, i.to) && lA(o, t, i.from, i.to)))
            )
              return G.none
          } else if (((s = t.sliceDoc(i.from, i.to).trim()), !s)) return G.none
        }
        let a = []
        for (let l of n.visibleRanges) {
          let c = new ei(t.doc, s, l.from, l.to)
          for (; !c.next().done; ) {
            let { from: u, to: f } = c.value
            if (
              (!o || wO(o, t, u, f)) &&
              (i.empty && u <= i.from && f >= i.to
                ? a.push(aA.range(u, f))
                : (u >= i.to || f <= i.from) && a.push(oA.range(u, f)),
              a.length > e.maxMatches)
            )
              return G.none
          }
        }
        return G.set(a)
      }
    },
    { decorations: (n) => n.decorations }
  ),
  uA = j.baseTheme({
    '.cm-selectionMatch': { backgroundColor: '#99ff7780' },
    '.cm-searchMatch .cm-selectionMatch': { backgroundColor: 'transparent' }
  }),
  fA = ({ state: n, dispatch: e }) => {
    let { selection: t } = n,
      r = C.create(
        t.ranges.map((i) => n.wordAt(i.head) || C.cursor(i.head)),
        t.mainIndex
      )
    return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0)
  }
function hA(n, e) {
  let { main: t, ranges: r } = n.selection,
    i = n.wordAt(t.head),
    s = i && i.from == t.from && i.to == t.to
  for (let o = !1, a = new ei(n.doc, e, r[r.length - 1].to); ; )
    if ((a.next(), a.done)) {
      if (o) return null
      ;(a = new ei(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1))),
        (o = !0)
    } else {
      if (o && r.some((l) => l.from == a.value.from)) continue
      if (s) {
        let l = n.wordAt(a.value.from)
        if (!l || l.from != a.value.from || l.to != a.value.to) continue
      }
      return a.value
    }
}
const pA = ({ state: n, dispatch: e }) => {
    let { ranges: t } = n.selection
    if (t.some((s) => s.from === s.to)) return fA({ state: n, dispatch: e })
    let r = n.sliceDoc(t[0].from, t[0].to)
    if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r)) return !1
    let i = hA(n, r)
    return i
      ? (e(
          n.update({
            selection: n.selection.addRange(C.range(i.from, i.to), !1),
            effects: j.scrollIntoView(i.to)
          })
        ),
        !0)
      : !1
  },
  ci = U.define({
    combine(n) {
      return on(n, {
        top: !1,
        caseSensitive: !1,
        literal: !1,
        regexp: !1,
        wholeWord: !1,
        createPanel: (e) => new TA(e),
        scrollToMatch: (e) => j.scrollIntoView(e)
      })
    }
  })
class Tv {
  constructor(e) {
    ;(this.search = e.search),
      (this.caseSensitive = !!e.caseSensitive),
      (this.literal = !!e.literal),
      (this.regexp = !!e.regexp),
      (this.replace = e.replace || ''),
      (this.valid = !!this.search && (!this.regexp || tA(this.search))),
      (this.unquoted = this.unquote(this.search)),
      (this.wholeWord = !!e.wholeWord)
  }
  unquote(e) {
    return this.literal
      ? e
      : e.replace(/\\([nrt\\])/g, (t, r) =>
          r == 'n'
            ? `
`
            : r == 'r'
              ? '\r'
              : r == 't'
                ? '	'
                : '\\'
        )
  }
  eq(e) {
    return (
      this.search == e.search &&
      this.replace == e.replace &&
      this.caseSensitive == e.caseSensitive &&
      this.regexp == e.regexp &&
      this.wholeWord == e.wholeWord
    )
  }
  create() {
    return this.regexp ? new gA(this) : new OA(this)
  }
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : ie.create({ doc: e })
    return (
      r == null && (r = i.doc.length),
      this.regexp ? Rr(this, i, t, r) : _r(this, i, t, r)
    )
  }
}
class $v {
  constructor(e) {
    this.spec = e
  }
}
function _r(n, e, t, r) {
  return new ei(
    e.doc,
    n.unquoted,
    t,
    r,
    n.caseSensitive ? void 0 : (i) => i.toLowerCase(),
    n.wholeWord ? dA(e.doc, e.charCategorizer(e.selection.main.head)) : void 0
  )
}
function dA(n, e) {
  return (t, r, i, s) => (
    (s > t || s + i.length < r) &&
      ((s = Math.max(0, t - 2)),
      (i = n.sliceString(s, Math.min(n.length, r + 2)))),
    (e(ja(i, t - s)) != Se.Word || e(Na(i, t - s)) != Se.Word) &&
      (e(Na(i, r - s)) != Se.Word || e(ja(i, r - s)) != Se.Word)
  )
}
class OA extends $v {
  constructor(e) {
    super(e)
  }
  nextMatch(e, t, r) {
    let i = _r(this.spec, e, r, e.doc.length).nextOverlapping()
    return (
      i.done && (i = _r(this.spec, e, 0, t).nextOverlapping()),
      i.done ? null : i.value
    )
  }
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length),
        o = _r(this.spec, e, s, i),
        a = null
      for (; !o.nextOverlapping().done; ) a = o.value
      if (a) return a
      if (s == t) return null
      i -= 1e4
    }
  }
  prevMatch(e, t, r) {
    return (
      this.prevMatchInRange(e, 0, t) ||
      this.prevMatchInRange(e, r, e.doc.length)
    )
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace)
  }
  matchAll(e, t) {
    let r = _r(this.spec, e, 0, e.doc.length),
      i = []
    for (; !r.next().done; ) {
      if (i.length >= t) return null
      i.push(r.value)
    }
    return i
  }
  highlight(e, t, r, i) {
    let s = _r(
      this.spec,
      e,
      Math.max(0, t - this.spec.unquoted.length),
      Math.min(r + this.spec.unquoted.length, e.doc.length)
    )
    for (; !s.next().done; ) i(s.value.from, s.value.to)
  }
}
function Rr(n, e, t, r) {
  return new xv(
    e.doc,
    n.search,
    {
      ignoreCase: !n.caseSensitive,
      test: n.wholeWord ? mA(e.charCategorizer(e.selection.main.head)) : void 0
    },
    t,
    r
  )
}
function ja(n, e) {
  return n.slice(He(n, e, !1), e)
}
function Na(n, e) {
  return n.slice(e, He(n, e))
}
function mA(n) {
  return (e, t, r) =>
    !r[0].length ||
    ((n(ja(r.input, r.index)) != Se.Word ||
      n(Na(r.input, r.index)) != Se.Word) &&
      (n(Na(r.input, r.index + r[0].length)) != Se.Word ||
        n(ja(r.input, r.index + r[0].length)) != Se.Word))
}
class gA extends $v {
  nextMatch(e, t, r) {
    let i = Rr(this.spec, e, r, e.doc.length).next()
    return (
      i.done && (i = Rr(this.spec, e, 0, t).next()), i.done ? null : i.value
    )
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(t, r - i * 1e4),
        o = Rr(this.spec, e, s, r),
        a = null
      for (; !o.next().done; ) a = o.value
      if (a && (s == t || a.from > s + 10)) return a
      if (s == t) return null
    }
  }
  prevMatch(e, t, r) {
    return (
      this.prevMatchInRange(e, 0, t) ||
      this.prevMatchInRange(e, r, e.doc.length)
    )
  }
  getReplacement(e) {
    return this.spec.unquote(
      this.spec.replace.replace(/\$([$&\d+])/g, (t, r) =>
        r == '$'
          ? '$'
          : r == '&'
            ? e.match[0]
            : r != '0' && +r < e.match.length
              ? e.match[r]
              : t
      )
    )
  }
  matchAll(e, t) {
    let r = Rr(this.spec, e, 0, e.doc.length),
      i = []
    for (; !r.next().done; ) {
      if (i.length >= t) return null
      i.push(r.value)
    }
    return i
  }
  highlight(e, t, r, i) {
    let s = Rr(
      this.spec,
      e,
      Math.max(0, t - 250),
      Math.min(r + 250, e.doc.length)
    )
    for (; !s.next().done; ) i(s.value.from, s.value.to)
  }
}
const as = ee.define(),
  th = ee.define(),
  jn = je.define({
    create(n) {
      return new yc(rf(n).create(), null)
    },
    update(n, e) {
      for (let t of e.effects)
        t.is(as)
          ? (n = new yc(t.value.create(), n.panel))
          : t.is(th) && (n = new yc(n.query, t.value ? nh : null))
      return n
    },
    provide: (n) => rs.from(n, (e) => e.panel)
  })
class yc {
  constructor(e, t) {
    ;(this.query = e), (this.panel = t)
  }
}
const yA = G.mark({ class: 'cm-searchMatch' }),
  bA = G.mark({ class: 'cm-searchMatch cm-searchMatch-selected' }),
  vA = _e.fromClass(
    class {
      constructor(n) {
        ;(this.view = n), (this.decorations = this.highlight(n.state.field(jn)))
      }
      update(n) {
        let e = n.state.field(jn)
        ;(e != n.startState.field(jn) ||
          n.docChanged ||
          n.selectionSet ||
          n.viewportChanged) &&
          (this.decorations = this.highlight(e))
      }
      highlight({ query: n, panel: e }) {
        if (!e || !n.spec.valid) return G.none
        let { view: t } = this,
          r = new Wn()
        for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
          let { from: a, to: l } = s[i]
          for (; i < o - 1 && l > s[i + 1].from - 2 * 250; ) l = s[++i].to
          n.highlight(t.state, a, l, (c, u) => {
            let f = t.state.selection.ranges.some(
              (p) => p.from == c && p.to == u
            )
            r.add(c, u, f ? bA : yA)
          })
        }
        return r.finish()
      }
    },
    { decorations: (n) => n.decorations }
  )
function Cs(n) {
  return (e) => {
    let t = e.state.field(jn, !1)
    return t && t.query.spec.valid ? n(e, t) : Cv(e)
  }
}
const Ma = Cs((n, { query: e }) => {
    let { to: t } = n.state.selection.main,
      r = e.nextMatch(n.state, t, t)
    if (!r) return !1
    let i = C.single(r.from, r.to),
      s = n.state.facet(ci)
    return (
      n.dispatch({
        selection: i,
        effects: [rh(n, r), s.scrollToMatch(i.main, n)],
        userEvent: 'select.search'
      }),
      kv(n),
      !0
    )
  }),
  Va = Cs((n, { query: e }) => {
    let { state: t } = n,
      { from: r } = t.selection.main,
      i = e.prevMatch(t, r, r)
    if (!i) return !1
    let s = C.single(i.from, i.to),
      o = n.state.facet(ci)
    return (
      n.dispatch({
        selection: s,
        effects: [rh(n, i), o.scrollToMatch(s.main, n)],
        userEvent: 'select.search'
      }),
      kv(n),
      !0
    )
  }),
  SA = Cs((n, { query: e }) => {
    let t = e.matchAll(n.state, 1e3)
    return !t || !t.length
      ? !1
      : (n.dispatch({
          selection: C.create(t.map((r) => C.range(r.from, r.to))),
          userEvent: 'select.search.matches'
        }),
        !0)
  }),
  xA = ({ state: n, dispatch: e }) => {
    let t = n.selection
    if (t.ranges.length > 1 || t.main.empty) return !1
    let { from: r, to: i } = t.main,
      s = [],
      o = 0
    for (let a = new ei(n.doc, n.sliceDoc(r, i)); !a.next().done; ) {
      if (s.length > 1e3) return !1
      a.value.from == r && (o = s.length),
        s.push(C.range(a.value.from, a.value.to))
    }
    return (
      e(
        n.update({
          selection: C.create(s, o),
          userEvent: 'select.search.matches'
        })
      ),
      !0
    )
  },
  PO = Cs((n, { query: e }) => {
    let { state: t } = n,
      { from: r, to: i } = t.selection.main
    if (t.readOnly) return !1
    let s = e.nextMatch(t, r, r)
    if (!s) return !1
    let o = [],
      a,
      l,
      c = []
    if (
      (s.from == r &&
        s.to == i &&
        ((l = t.toText(e.getReplacement(s))),
        o.push({ from: s.from, to: s.to, insert: l }),
        (s = e.nextMatch(t, s.from, s.to)),
        c.push(
          j.announce.of(
            t.phrase('replaced match on line $', t.doc.lineAt(r).number) + '.'
          )
        )),
      s)
    ) {
      let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length
      ;(a = C.single(s.from - u, s.to - u)),
        c.push(rh(n, s)),
        c.push(t.facet(ci).scrollToMatch(a.main, n))
    }
    return (
      n.dispatch({
        changes: o,
        selection: a,
        effects: c,
        userEvent: 'input.replace'
      }),
      !0
    )
  }),
  wA = Cs((n, { query: e }) => {
    if (n.state.readOnly) return !1
    let t = e.matchAll(n.state, 1e9).map((i) => {
      let { from: s, to: o } = i
      return { from: s, to: o, insert: e.getReplacement(i) }
    })
    if (!t.length) return !1
    let r = n.state.phrase('replaced $ matches', t.length) + '.'
    return (
      n.dispatch({
        changes: t,
        effects: j.announce.of(r),
        userEvent: 'input.replace.all'
      }),
      !0
    )
  })
function nh(n) {
  return n.state.facet(ci).createPanel(n)
}
function rf(n, e) {
  var t, r, i, s, o
  let a = n.selection.main,
    l = a.empty || a.to > a.from + 100 ? '' : n.sliceDoc(a.from, a.to)
  if (e && !l) return e
  let c = n.facet(ci)
  return new Tv({
    search: (
      (t = e == null ? void 0 : e.literal) !== null && t !== void 0
        ? t
        : c.literal
    )
      ? l
      : l.replace(/\n/g, '\\n'),
    caseSensitive:
      (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0
        ? r
        : c.caseSensitive,
    literal:
      (i = e == null ? void 0 : e.literal) !== null && i !== void 0
        ? i
        : c.literal,
    regexp:
      (s = e == null ? void 0 : e.regexp) !== null && s !== void 0
        ? s
        : c.regexp,
    wholeWord:
      (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0
        ? o
        : c.wholeWord
  })
}
function Qv(n) {
  let e = ns(n, nh)
  return e && e.dom.querySelector('[main-field]')
}
function kv(n) {
  let e = Qv(n)
  e && e == n.root.activeElement && e.select()
}
const Cv = (n) => {
    let e = n.state.field(jn, !1)
    if (e && e.panel) {
      let t = Qv(n)
      if (t && t != n.root.activeElement) {
        let r = rf(n.state, e.query.spec)
        r.valid && n.dispatch({ effects: as.of(r) }), t.focus(), t.select()
      }
    } else
      n.dispatch({
        effects: [
          th.of(!0),
          e ? as.of(rf(n.state, e.query.spec)) : ee.appendConfig.of(QA)
        ]
      })
    return !0
  },
  _v = (n) => {
    let e = n.state.field(jn, !1)
    if (!e || !e.panel) return !1
    let t = ns(n, nh)
    return (
      t && t.dom.contains(n.root.activeElement) && n.focus(),
      n.dispatch({ effects: th.of(!1) }),
      !0
    )
  },
  PA = [
    { key: 'Mod-f', run: Cv, scope: 'editor search-panel' },
    {
      key: 'F3',
      run: Ma,
      shift: Va,
      scope: 'editor search-panel',
      preventDefault: !0
    },
    {
      key: 'Mod-g',
      run: Ma,
      shift: Va,
      scope: 'editor search-panel',
      preventDefault: !0
    },
    { key: 'Escape', run: _v, scope: 'editor search-panel' },
    { key: 'Mod-Shift-l', run: xA },
    { key: 'Alt-g', run: nA },
    { key: 'Mod-d', run: pA, preventDefault: !0 }
  ]
class TA {
  constructor(e) {
    this.view = e
    let t = (this.query = e.state.field(jn).query.spec)
    ;(this.commit = this.commit.bind(this)),
      (this.searchField = de('input', {
        value: t.search,
        placeholder: ft(e, 'Find'),
        'aria-label': ft(e, 'Find'),
        class: 'cm-textfield',
        name: 'search',
        form: '',
        'main-field': 'true',
        onchange: this.commit,
        onkeyup: this.commit
      })),
      (this.replaceField = de('input', {
        value: t.replace,
        placeholder: ft(e, 'Replace'),
        'aria-label': ft(e, 'Replace'),
        class: 'cm-textfield',
        name: 'replace',
        form: '',
        onchange: this.commit,
        onkeyup: this.commit
      })),
      (this.caseField = de('input', {
        type: 'checkbox',
        name: 'case',
        form: '',
        checked: t.caseSensitive,
        onchange: this.commit
      })),
      (this.reField = de('input', {
        type: 'checkbox',
        name: 're',
        form: '',
        checked: t.regexp,
        onchange: this.commit
      })),
      (this.wordField = de('input', {
        type: 'checkbox',
        name: 'word',
        form: '',
        checked: t.wholeWord,
        onchange: this.commit
      }))
    function r(i, s, o) {
      return de(
        'button',
        { class: 'cm-button', name: i, onclick: s, type: 'button' },
        o
      )
    }
    this.dom = de(
      'div',
      { onkeydown: (i) => this.keydown(i), class: 'cm-search' },
      [
        this.searchField,
        r('next', () => Ma(e), [ft(e, 'next')]),
        r('prev', () => Va(e), [ft(e, 'previous')]),
        r('select', () => SA(e), [ft(e, 'all')]),
        de('label', null, [this.caseField, ft(e, 'match case')]),
        de('label', null, [this.reField, ft(e, 'regexp')]),
        de('label', null, [this.wordField, ft(e, 'by word')]),
        ...(e.state.readOnly
          ? []
          : [
              de('br'),
              this.replaceField,
              r('replace', () => PO(e), [ft(e, 'replace')]),
              r('replaceAll', () => wA(e), [ft(e, 'replace all')])
            ]),
        de(
          'button',
          {
            name: 'close',
            onclick: () => _v(e),
            'aria-label': ft(e, 'close'),
            type: 'button'
          },
          ['']
        )
      ]
    )
  }
  commit() {
    let e = new Tv({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    })
    e.eq(this.query) ||
      ((this.query = e), this.view.dispatch({ effects: as.of(e) }))
  }
  keydown(e) {
    AC(this.view, e, 'search-panel')
      ? e.preventDefault()
      : e.keyCode == 13 && e.target == this.searchField
        ? (e.preventDefault(), (e.shiftKey ? Va : Ma)(this.view))
        : e.keyCode == 13 &&
          e.target == this.replaceField &&
          (e.preventDefault(), PO(this.view))
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(as) && !r.value.eq(this.query) && this.setQuery(r.value)
  }
  setQuery(e) {
    ;(this.query = e),
      (this.searchField.value = e.search),
      (this.replaceField.value = e.replace),
      (this.caseField.checked = e.caseSensitive),
      (this.reField.checked = e.regexp),
      (this.wordField.checked = e.wholeWord)
  }
  mount() {
    this.searchField.select()
  }
  get pos() {
    return 80
  }
  get top() {
    return this.view.state.facet(ci).top
  }
}
function ft(n, e) {
  return n.state.phrase(e)
}
const lo = 30,
  co = /[\s\.,:;?!]/
function rh(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e),
    i = n.state.doc.lineAt(t).to,
    s = Math.max(r.from, e - lo),
    o = Math.min(i, t + lo),
    a = n.state.sliceDoc(s, o)
  if (s != r.from) {
    for (let l = 0; l < lo; l++)
      if (!co.test(a[l + 1]) && co.test(a[l])) {
        a = a.slice(l)
        break
      }
  }
  if (o != i) {
    for (let l = a.length - 1; l > a.length - lo; l--)
      if (!co.test(a[l - 1]) && co.test(a[l])) {
        a = a.slice(0, l)
        break
      }
  }
  return j.announce.of(
    `${n.state.phrase('current match')}. ${a} ${n.state.phrase('on line')} ${
      r.number
    }.`
  )
}
const $A = j.baseTheme({
    '.cm-panel.cm-search': {
      padding: '2px 6px 4px',
      position: 'relative',
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '4px',
        backgroundColor: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0
      },
      '& input, & button, & label': { margin: '.2em .6em .2em 0' },
      '& input[type=checkbox]': { marginRight: '.2em' },
      '& label': { fontSize: '80%', whiteSpace: 'pre' }
    },
    '&light .cm-searchMatch': { backgroundColor: '#ffff0054' },
    '&dark .cm-searchMatch': { backgroundColor: '#00ffff8a' },
    '&light .cm-searchMatch-selected': { backgroundColor: '#ff6a0054' },
    '&dark .cm-searchMatch-selected': { backgroundColor: '#ff00ff8a' }
  }),
  QA = [jn, vr.low(vA), $A]
class Rv {
  constructor(e, t, r) {
    ;(this.state = e),
      (this.pos = t),
      (this.explicit = r),
      (this.abortListeners = [])
  }
  tokenBefore(e) {
    let t = ke(this.state).resolveInner(this.pos, -1)
    for (; t && e.indexOf(t.name) < 0; ) t = t.parent
    return t
      ? {
          from: t.from,
          to: this.pos,
          text: this.state.sliceDoc(t.from, this.pos),
          type: t.type
        }
      : null
  }
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos),
      r = Math.max(t.from, this.pos - 250),
      i = t.text.slice(r - t.from, this.pos - t.from),
      s = i.search(Av(e, !1))
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) }
  }
  get aborted() {
    return this.abortListeners == null
  }
  addEventListener(e, t) {
    e == 'abort' && this.abortListeners && this.abortListeners.push(t)
  }
}
function TO(n) {
  let e = Object.keys(n).join(''),
    t = /\w/.test(e)
  return (
    t && (e = e.replace(/\w/g, '')),
    `[${t ? '\\w' : ''}${e.replace(/[^\w\s]/g, '\\$&')}]`
  )
}
function kA(n) {
  let e = Object.create(null),
    t = Object.create(null)
  for (let { label: i } of n) {
    e[i[0]] = !0
    for (let s = 1; s < i.length; s++) t[i[s]] = !0
  }
  let r = TO(e) + TO(t) + '*$'
  return [new RegExp('^' + r), new RegExp(r)]
}
function Zv(n) {
  let e = n.map((i) => (typeof i == 'string' ? { label: i } : i)),
    [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : kA(e)
  return (i) => {
    let s = i.matchBefore(r)
    return s || i.explicit
      ? { from: s ? s.from : i.pos, options: e, validFor: t }
      : null
  }
}
function CA(n, e) {
  return (t) => {
    for (let r = ke(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1) return null
      if (r.type.isTop) break
    }
    return e(t)
  }
}
class $O {
  constructor(e, t, r, i) {
    ;(this.completion = e),
      (this.source = t),
      (this.match = r),
      (this.score = i)
  }
}
function Nn(n) {
  return n.selection.main.from
}
function Av(n, e) {
  var t
  let { source: r } = n,
    i = e && r[0] != '^',
    s = r[r.length - 1] != '$'
  return !i && !s
    ? n
    : new RegExp(
        `${i ? '^' : ''}(?:${r})${s ? '$' : ''}`,
        (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? 'i' : ''
      )
}
const Ev = sn.define()
function _A(n, e, t, r) {
  let { main: i } = n.selection,
    s = t - i.from,
    o = r - i.from
  return Object.assign(
    Object.assign(
      {},
      n.changeByRange((a) =>
        a != i &&
        t != r &&
        n.sliceDoc(a.from + s, a.from + o) != n.sliceDoc(t, r)
          ? { range: a }
          : {
              changes: {
                from: a.from + s,
                to: r == i.from ? a.to : a.from + o,
                insert: e
              },
              range: C.cursor(a.from + s + e.length)
            }
      )
    ),
    { scrollIntoView: !0, userEvent: 'input.complete' }
  )
}
const QO = new WeakMap()
function RA(n) {
  if (!Array.isArray(n)) return n
  let e = QO.get(n)
  return e || QO.set(n, (e = Zv(n))), e
}
const ih = ee.define(),
  ls = ee.define()
class ZA {
  constructor(e) {
    ;(this.pattern = e),
      (this.chars = []),
      (this.folded = []),
      (this.any = []),
      (this.precise = []),
      (this.byWord = []),
      (this.score = 0),
      (this.matched = [])
    for (let t = 0; t < e.length; ) {
      let r = Le(e, t),
        i = $t(r)
      this.chars.push(r)
      let s = e.slice(t, t + i),
        o = s.toUpperCase()
      this.folded.push(Le(o == s ? s.toLowerCase() : o, 0)), (t += i)
    }
    this.astral = e.length != this.chars.length
  }
  ret(e, t) {
    return (this.score = e), (this.matched = t), !0
  }
  match(e) {
    if (this.pattern.length == 0) return this.ret(-100, [])
    if (e.length < this.pattern.length) return !1
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this
    if (t.length == 1) {
      let w = Le(e, 0),
        Q = $t(w),
        T = Q == e.length ? 0 : -100
      if (w != t[0])
        if (w == r[0]) T += -200
        else return !1
      return this.ret(T, [0, Q])
    }
    let a = e.indexOf(this.pattern)
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [
        0,
        this.pattern.length
      ])
    let l = t.length,
      c = 0
    if (a < 0) {
      for (let w = 0, Q = Math.min(e.length, 200); w < Q && c < l; ) {
        let T = Le(e, w)
        ;(T == t[c] || T == r[c]) && (i[c++] = w), (w += $t(T))
      }
      if (c < l) return !1
    }
    let u = 0,
      f = 0,
      p = !1,
      d = 0,
      O = -1,
      g = -1,
      b = /[a-z]/.test(e),
      x = !0
    for (let w = 0, Q = Math.min(e.length, 200), T = 0; w < Q && f < l; ) {
      let P = Le(e, w)
      a < 0 &&
        (u < l && P == t[u] && (s[u++] = w),
        d < l &&
          (P == t[d] || P == r[d]
            ? (d == 0 && (O = w), (g = w + 1), d++)
            : (d = 0)))
      let k,
        R =
          P < 255
            ? (P >= 48 && P <= 57) || (P >= 97 && P <= 122)
              ? 2
              : P >= 65 && P <= 90
                ? 1
                : 0
            : (k = _f(P)) != k.toLowerCase()
              ? 1
              : k != k.toUpperCase()
                ? 2
                : 0
      ;(!w || (R == 1 && b) || (T == 0 && R != 0)) &&
        (t[f] == P || (r[f] == P && (p = !0))
          ? (o[f++] = w)
          : o.length && (x = !1)),
        (T = R),
        (w += $t(P))
    }
    return f == l && o[0] == 0 && x
      ? this.result(-100 + (p ? -200 : 0), o, e)
      : d == l && O == 0
        ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g])
        : a > -1
          ? this.ret(-700 - e.length, [a, a + this.pattern.length])
          : d == l
            ? this.ret(-200 + -700 - e.length, [O, g])
            : f == l
              ? this.result(
                  -100 + (p ? -200 : 0) + -700 + (x ? 0 : -1100),
                  o,
                  e
                )
              : t.length == 2
                ? !1
                : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e)
  }
  result(e, t, r) {
    let i = [],
      s = 0
    for (let o of t) {
      let a = o + (this.astral ? $t(Le(r, o)) : 1)
      s && i[s - 1] == o ? (i[s - 1] = a) : ((i[s++] = o), (i[s++] = a))
    }
    return this.ret(e - r.length, i)
  }
}
const Ge = U.define({
  combine(n) {
    return on(
      n,
      {
        activateOnTyping: !0,
        selectOnOpen: !0,
        override: null,
        closeOnBlur: !0,
        maxRenderedOptions: 100,
        defaultKeymap: !0,
        tooltipClass: () => '',
        optionClass: () => '',
        aboveCursor: !1,
        icons: !0,
        addToOptions: [],
        positionInfo: AA,
        compareCompletions: (e, t) => e.label.localeCompare(t.label),
        interactionDelay: 75,
        updateSyncTime: 100
      },
      {
        defaultKeymap: (e, t) => e && t,
        closeOnBlur: (e, t) => e && t,
        icons: (e, t) => e && t,
        tooltipClass: (e, t) => (r) => kO(e(r), t(r)),
        optionClass: (e, t) => (r) => kO(e(r), t(r)),
        addToOptions: (e, t) => e.concat(t)
      }
    )
  }
})
function kO(n, e) {
  return n ? (e ? n + ' ' + e : n) : e
}
function AA(n, e, t, r, i, s) {
  let o = n.textDirection == we.RTL,
    a = o,
    l = !1,
    c = 'top',
    u,
    f,
    p = e.left - i.left,
    d = i.right - e.right,
    O = r.right - r.left,
    g = r.bottom - r.top
  if (
    (a && p < Math.min(O, d) ? (a = !1) : !a && d < Math.min(O, p) && (a = !0),
    O <= (a ? p : d))
  )
    (u = Math.max(i.top, Math.min(t.top, i.bottom - g)) - e.top),
      (f = Math.min(400, a ? p : d))
  else {
    ;(l = !0), (f = Math.min(400, (o ? e.right : i.right - e.left) - 30))
    let w = i.bottom - e.bottom
    w >= g || w > e.top
      ? (u = t.bottom - e.top)
      : ((c = 'bottom'), (u = e.bottom - t.top))
  }
  let b = (e.bottom - e.top) / s.offsetHeight,
    x = (e.right - e.left) / s.offsetWidth
  return {
    style: `${c}: ${u / b}px; max-width: ${f / x}px`,
    class:
      'cm-completionInfo-' +
      (l ? (o ? 'left-narrow' : 'right-narrow') : a ? 'left' : 'right')
  }
}
function EA(n) {
  let e = n.addToOptions.slice()
  return (
    n.icons &&
      e.push({
        render(t) {
          let r = document.createElement('div')
          return (
            r.classList.add('cm-completionIcon'),
            t.type &&
              r.classList.add(
                ...t.type.split(/\s+/g).map((i) => 'cm-completionIcon-' + i)
              ),
            r.setAttribute('aria-hidden', 'true'),
            r
          )
        },
        position: 20
      }),
    e.push(
      {
        render(t, r, i, s) {
          let o = document.createElement('span')
          o.className = 'cm-completionLabel'
          let a = t.displayLabel || t.label,
            l = 0
          for (let c = 0; c < s.length; ) {
            let u = s[c++],
              f = s[c++]
            u > l && o.appendChild(document.createTextNode(a.slice(l, u)))
            let p = o.appendChild(document.createElement('span'))
            p.appendChild(document.createTextNode(a.slice(u, f))),
              (p.className = 'cm-completionMatchedText'),
              (l = f)
          }
          return (
            l < a.length && o.appendChild(document.createTextNode(a.slice(l))),
            o
          )
        },
        position: 50
      },
      {
        render(t) {
          if (!t.detail) return null
          let r = document.createElement('span')
          return (
            (r.className = 'cm-completionDetail'), (r.textContent = t.detail), r
          )
        },
        position: 80
      }
    ),
    e.sort((t, r) => t.position - r.position).map((t) => t.render)
  )
}
function bc(n, e, t) {
  if (n <= t) return { from: 0, to: n }
  if ((e < 0 && (e = 0), e <= n >> 1)) {
    let i = Math.floor(e / t)
    return { from: i * t, to: (i + 1) * t }
  }
  let r = Math.floor((n - e) / t)
  return { from: n - (r + 1) * t, to: n - r * t }
}
class DA {
  constructor(e, t, r) {
    ;(this.view = e),
      (this.stateField = t),
      (this.applyCompletion = r),
      (this.info = null),
      (this.infoDestroy = null),
      (this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (l) => this.placeInfo(l),
        key: this
      }),
      (this.space = null),
      (this.currentClass = '')
    let i = e.state.field(t),
      { options: s, selected: o } = i.open,
      a = e.state.facet(Ge)
    ;(this.optionContent = EA(a)),
      (this.optionClass = a.optionClass),
      (this.tooltipClass = a.tooltipClass),
      (this.range = bc(s.length, o, a.maxRenderedOptions)),
      (this.dom = document.createElement('div')),
      (this.dom.className = 'cm-tooltip-autocomplete'),
      this.updateTooltipClass(e.state),
      this.dom.addEventListener('mousedown', (l) => {
        let { options: c } = e.state.field(t).open
        for (let u = l.target, f; u && u != this.dom; u = u.parentNode)
          if (
            u.nodeName == 'LI' &&
            (f = /-(\d+)$/.exec(u.id)) &&
            +f[1] < c.length
          ) {
            this.applyCompletion(e, c[+f[1]]), l.preventDefault()
            return
          }
      }),
      this.dom.addEventListener('focusout', (l) => {
        let c = e.state.field(this.stateField, !1)
        c &&
          c.tooltip &&
          e.state.facet(Ge).closeOnBlur &&
          l.relatedTarget != e.contentDOM &&
          e.dispatch({ effects: ls.of(null) })
      }),
      this.showOptions(s, i.id)
  }
  mount() {
    this.updateSel()
  }
  showOptions(e, t) {
    this.list && this.list.remove(),
      (this.list = this.dom.appendChild(this.createListBox(e, t, this.range))),
      this.list.addEventListener('scroll', () => {
        this.info && this.view.requestMeasure(this.placeInfoReq)
      })
  }
  update(e) {
    var t
    let r = e.state.field(this.stateField),
      i = e.startState.field(this.stateField)
    if ((this.updateTooltipClass(e.state), r != i)) {
      let { options: s, selected: o, disabled: a } = r.open
      ;(!i.open || i.open.options != s) &&
        ((this.range = bc(s.length, o, e.state.facet(Ge).maxRenderedOptions)),
        this.showOptions(s, r.id)),
        this.updateSel(),
        a != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) &&
          this.dom.classList.toggle('cm-tooltip-autocomplete-disabled', !!a)
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e)
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(' '))
        r && this.dom.classList.remove(r)
      for (let r of t.split(' ')) r && this.dom.classList.add(r)
      this.currentClass = t
    }
  }
  positioned(e) {
    ;(this.space = e), this.info && this.view.requestMeasure(this.placeInfoReq)
  }
  updateSel() {
    let e = this.view.state.field(this.stateField),
      t = e.open
    if (
      (((t.selected > -1 && t.selected < this.range.from) ||
        t.selected >= this.range.to) &&
        ((this.range = bc(
          t.options.length,
          t.selected,
          this.view.state.facet(Ge).maxRenderedOptions
        )),
        this.showOptions(t.options, e.id)),
      this.updateSelectedOption(t.selected))
    ) {
      this.destroyInfo()
      let { completion: r } = t.options[t.selected],
        { info: i } = r
      if (!i) return
      let s = typeof i == 'string' ? document.createTextNode(i) : i(r)
      if (!s) return
      'then' in s
        ? s
            .then((o) => {
              o &&
                this.view.state.field(this.stateField, !1) == e &&
                this.addInfoPane(o, r)
            })
            .catch((o) => _t(this.view.state, o, 'completion info'))
        : this.addInfoPane(s, r)
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo()
    let r = (this.info = document.createElement('div'))
    if (((r.className = 'cm-tooltip cm-completionInfo'), e.nodeType != null))
      r.appendChild(e), (this.infoDestroy = null)
    else {
      let { dom: i, destroy: s } = e
      r.appendChild(i), (this.infoDestroy = s || null)
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq)
  }
  updateSelectedOption(e) {
    let t = null
    for (
      let r = this.list.firstChild, i = this.range.from;
      r;
      r = r.nextSibling, i++
    )
      r.nodeName != 'LI' || !r.id
        ? i--
        : i == e
          ? r.hasAttribute('aria-selected') ||
            (r.setAttribute('aria-selected', 'true'), (t = r))
          : r.hasAttribute('aria-selected') &&
            r.removeAttribute('aria-selected')
    return t && YA(this.list, t), t
  }
  measureInfo() {
    let e = this.dom.querySelector('[aria-selected]')
    if (!e || !this.info) return null
    let t = this.dom.getBoundingClientRect(),
      r = this.info.getBoundingClientRect(),
      i = e.getBoundingClientRect(),
      s = this.space
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight }
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 ||
      i.bottom < Math.max(s.top, t.top) + 10
      ? null
      : this.view.state.facet(Ge).positionInfo(this.view, t, i, r, s, this.dom)
  }
  placeInfo(e) {
    this.info &&
      (e
        ? (e.style && (this.info.style.cssText = e.style),
          (this.info.className =
            'cm-tooltip cm-completionInfo ' + (e.class || '')))
        : (this.info.style.cssText = 'top: -1e6px'))
  }
  createListBox(e, t, r) {
    const i = document.createElement('ul')
    ;(i.id = t),
      i.setAttribute('role', 'listbox'),
      i.setAttribute('aria-expanded', 'true'),
      i.setAttribute('aria-label', this.view.state.phrase('Completions'))
    let s = null
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o],
        { section: c } = a
      if (c) {
        let p = typeof c == 'string' ? c : c.name
        if (p != s && (o > r.from || r.from == 0))
          if (((s = p), typeof c != 'string' && c.header))
            i.appendChild(c.header(c))
          else {
            let d = i.appendChild(document.createElement('completion-section'))
            d.textContent = p
          }
      }
      const u = i.appendChild(document.createElement('li'))
      ;(u.id = t + '-' + o), u.setAttribute('role', 'option')
      let f = this.optionClass(a)
      f && (u.className = f)
      for (let p of this.optionContent) {
        let d = p(a, this.view.state, this.view, l)
        d && u.appendChild(d)
      }
    }
    return (
      r.from && i.classList.add('cm-completionListIncompleteTop'),
      r.to < e.length && i.classList.add('cm-completionListIncompleteBottom'),
      i
    )
  }
  destroyInfo() {
    this.info &&
      (this.infoDestroy && this.infoDestroy(),
      this.info.remove(),
      (this.info = null))
  }
  destroy() {
    this.destroyInfo()
  }
}
function XA(n, e) {
  return (t) => new DA(t, n, e)
}
function YA(n, e) {
  let t = n.getBoundingClientRect(),
    r = e.getBoundingClientRect(),
    i = t.height / n.offsetHeight
  r.top < t.top
    ? (n.scrollTop -= (t.top - r.top) / i)
    : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i)
}
function CO(n) {
  return (
    (n.boost || 0) * 100 +
    (n.apply ? 10 : 0) +
    (n.info ? 5 : 0) +
    (n.type ? 1 : 0)
  )
}
function IA(n, e) {
  let t = [],
    r = null,
    i = (l) => {
      t.push(l)
      let { section: c } = l.completion
      if (c) {
        r || (r = [])
        let u = typeof c == 'string' ? c : c.name
        r.some((f) => f.name == u) ||
          r.push(typeof c == 'string' ? { name: u } : c)
      }
    }
  for (let l of n)
    if (l.hasResult()) {
      let c = l.result.getMatch
      if (l.result.filter === !1)
        for (let u of l.result.options)
          i(new $O(u, l.source, c ? c(u) : [], 1e9 - t.length))
      else {
        let u = new ZA(e.sliceDoc(l.from, l.to))
        for (let f of l.result.options)
          if (u.match(f.label)) {
            let p = f.displayLabel ? (c ? c(f, u.matched) : []) : u.matched
            i(new $O(f, l.source, p, u.score + (f.boost || 0)))
          }
      }
    }
  if (r) {
    let l = Object.create(null),
      c = 0,
      u = (f, p) => {
        var d, O
        return (
          ((d = f.rank) !== null && d !== void 0 ? d : 1e9) -
            ((O = p.rank) !== null && O !== void 0 ? O : 1e9) ||
          (f.name < p.name ? -1 : 1)
        )
      }
    for (let f of r.sort(u)) (c -= 1e5), (l[f.name] = c)
    for (let f of t) {
      let { section: p } = f.completion
      p && (f.score += l[typeof p == 'string' ? p : p.name])
    }
  }
  let s = [],
    o = null,
    a = e.facet(Ge).compareCompletions
  for (let l of t.sort(
    (c, u) => u.score - c.score || a(c.completion, u.completion)
  )) {
    let c = l.completion
    !o ||
    o.label != c.label ||
    o.detail != c.detail ||
    (o.type != null && c.type != null && o.type != c.type) ||
    o.apply != c.apply ||
    o.boost != c.boost
      ? s.push(l)
      : CO(l.completion) > CO(o) && (s[s.length - 1] = l),
      (o = l.completion)
  }
  return s
}
class Yr {
  constructor(e, t, r, i, s, o) {
    ;(this.options = e),
      (this.attrs = t),
      (this.tooltip = r),
      (this.timestamp = i),
      (this.selected = s),
      (this.disabled = o)
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length
      ? this
      : new Yr(
          this.options,
          _O(t, e),
          this.tooltip,
          this.timestamp,
          e,
          this.disabled
        )
  }
  static build(e, t, r, i, s) {
    let o = IA(e, t)
    if (!o.length)
      return i && e.some((l) => l.state == 1)
        ? new Yr(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0)
        : null
    let a = t.facet(Ge).selectOnOpen ? 0 : -1
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c
          break
        }
    }
    return new Yr(
      o,
      _O(r, a),
      {
        pos: e.reduce((l, c) => (c.hasResult() ? Math.min(l, c.from) : l), 1e8),
        create: WA,
        above: s.aboveCursor
      },
      i ? i.timestamp : Date.now(),
      a,
      !1
    )
  }
  map(e) {
    return new Yr(
      this.options,
      this.attrs,
      Object.assign(Object.assign({}, this.tooltip), {
        pos: e.mapPos(this.tooltip.pos)
      }),
      this.timestamp,
      this.selected,
      this.disabled
    )
  }
}
class Wa {
  constructor(e, t, r) {
    ;(this.active = e), (this.id = t), (this.open = r)
  }
  static start() {
    return new Wa(
      MA,
      'cm-ac-' + Math.floor(Math.random() * 2e6).toString(36),
      null
    )
  }
  update(e) {
    let { state: t } = e,
      r = t.facet(Ge),
      s = (r.override || t.languageDataAt('autocomplete', Nn(t)).map(RA)).map(
        (a) =>
          (
            this.active.find((c) => c.source == a) ||
            new at(a, this.active.some((c) => c.state != 0) ? 1 : 0)
          ).update(e, r)
      )
    s.length == this.active.length &&
      s.every((a, l) => a == this.active[l]) &&
      (s = this.active)
    let o = this.open
    o && e.docChanged && (o = o.map(e.changes)),
      e.selection ||
      s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) ||
      !jA(s, this.active)
        ? (o = Yr.build(s, t, this.id, o, r))
        : o && o.disabled && !s.some((a) => a.state == 1) && (o = null),
      !o &&
        s.every((a) => a.state != 1) &&
        s.some((a) => a.hasResult()) &&
        (s = s.map((a) => (a.hasResult() ? new at(a.source, 0) : a)))
    for (let a of e.effects)
      a.is(Xv) && (o = o && o.setSelected(a.value, this.id))
    return s == this.active && o == this.open ? this : new Wa(s, this.id, o)
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null
  }
  get attrs() {
    return this.open ? this.open.attrs : NA
  }
}
function jA(n, e) {
  if (n == e) return !0
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult; ) t++
    for (; r < e.length && !e[r].hasResult; ) r++
    let i = t == n.length,
      s = r == e.length
    if (i || s) return i == s
    if (n[t++].result != e[r++].result) return !1
  }
}
const NA = { 'aria-autocomplete': 'list' }
function _O(n, e) {
  let t = {
    'aria-autocomplete': 'list',
    'aria-haspopup': 'listbox',
    'aria-controls': n
  }
  return e > -1 && (t['aria-activedescendant'] = n + '-' + e), t
}
const MA = []
function sf(n) {
  return n.isUserEvent('input.type')
    ? 'input'
    : n.isUserEvent('delete.backward')
      ? 'delete'
      : null
}
class at {
  constructor(e, t, r = -1) {
    ;(this.source = e), (this.state = t), (this.explicitPos = r)
  }
  hasResult() {
    return !1
  }
  update(e, t) {
    let r = sf(e),
      i = this
    r
      ? (i = i.handleUserEvent(e, r, t))
      : e.docChanged
        ? (i = i.handleChange(e))
        : e.selection && i.state != 0 && (i = new at(i.source, 0))
    for (let s of e.effects)
      if (s.is(ih)) i = new at(i.source, 1, s.value ? Nn(e.state) : -1)
      else if (s.is(ls)) i = new at(i.source, 0)
      else if (s.is(Dv)) for (let o of s.value) o.source == i.source && (i = o)
    return i
  }
  handleUserEvent(e, t, r) {
    return t == 'delete' || !r.activateOnTyping
      ? this.map(e.changes)
      : new at(this.source, 1)
  }
  handleChange(e) {
    return e.changes.touchesRange(Nn(e.startState))
      ? new at(this.source, 0)
      : this.map(e.changes)
  }
  map(e) {
    return e.empty || this.explicitPos < 0
      ? this
      : new at(this.source, this.state, e.mapPos(this.explicitPos))
  }
}
class Wr extends at {
  constructor(e, t, r, i, s) {
    super(e, 2, t), (this.result = r), (this.from = i), (this.to = s)
  }
  hasResult() {
    return !0
  }
  handleUserEvent(e, t, r) {
    var i
    let s = e.changes.mapPos(this.from),
      o = e.changes.mapPos(this.to, 1),
      a = Nn(e.state)
    if (
      (this.explicitPos < 0 ? a <= s : a < this.from) ||
      a > o ||
      (t == 'delete' && Nn(e.startState) == this.from)
    )
      return new at(this.source, t == 'input' && r.activateOnTyping ? 1 : 0)
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos),
      c
    return VA(this.result.validFor, e.state, s, o)
      ? new Wr(this.source, l, this.result, s, o)
      : this.result.update &&
          (c = this.result.update(
            this.result,
            s,
            o,
            new Rv(e.state, a, l >= 0)
          ))
        ? new Wr(
            this.source,
            l,
            c,
            c.from,
            (i = c.to) !== null && i !== void 0 ? i : Nn(e.state)
          )
        : new at(this.source, 1, l)
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to)
      ? new at(this.source, 0)
      : this.map(e.changes)
  }
  map(e) {
    return e.empty
      ? this
      : new Wr(
          this.source,
          this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),
          this.result,
          e.mapPos(this.from),
          e.mapPos(this.to, 1)
        )
  }
}
function VA(n, e, t, r) {
  if (!n) return !1
  let i = e.sliceDoc(t, r)
  return typeof n == 'function' ? n(i, t, r, e) : Av(n, !0).test(i)
}
const Dv = ee.define({
    map(n, e) {
      return n.map((t) => t.map(e))
    }
  }),
  Xv = ee.define(),
  mt = je.define({
    create() {
      return Wa.start()
    },
    update(n, e) {
      return n.update(e)
    },
    provide: (n) => [
      jf.from(n, (e) => e.tooltip),
      j.contentAttributes.from(n, (e) => e.attrs)
    ]
  })
function Yv(n, e) {
  const t = e.completion.apply || e.completion.label
  let r = n.state.field(mt).active.find((i) => i.source == e.source)
  return r instanceof Wr
    ? (typeof t == 'string'
        ? n.dispatch(
            Object.assign(Object.assign({}, _A(n.state, t, r.from, r.to)), {
              annotations: Ev.of(e.completion)
            })
          )
        : t(n, e.completion, r.from, r.to),
      !0)
    : !1
}
const WA = XA(mt, Yv)
function uo(n, e = 'option') {
  return (t) => {
    let r = t.state.field(mt, !1)
    if (
      !r ||
      !r.open ||
      r.open.disabled ||
      Date.now() - r.open.timestamp < t.state.facet(Ge).interactionDelay
    )
      return !1
    let i = 1,
      s
    e == 'page' &&
      (s = db(t, r.open.tooltip)) &&
      (i = Math.max(
        2,
        Math.floor(
          s.dom.offsetHeight / s.dom.querySelector('li').offsetHeight
        ) - 1
      ))
    let { length: o } = r.open.options,
      a =
        r.open.selected > -1
          ? r.open.selected + i * (n ? 1 : -1)
          : n
            ? 0
            : o - 1
    return (
      a < 0
        ? (a = e == 'page' ? 0 : o - 1)
        : a >= o && (a = e == 'page' ? o - 1 : 0),
      t.dispatch({ effects: Xv.of(a) }),
      !0
    )
  }
}
const LA = (n) => {
    let e = n.state.field(mt, !1)
    return n.state.readOnly ||
      !e ||
      !e.open ||
      e.open.selected < 0 ||
      e.open.disabled ||
      Date.now() - e.open.timestamp < n.state.facet(Ge).interactionDelay
      ? !1
      : Yv(n, e.open.options[e.open.selected])
  },
  BA = (n) =>
    n.state.field(mt, !1) ? (n.dispatch({ effects: ih.of(!0) }), !0) : !1,
  UA = (n) => {
    let e = n.state.field(mt, !1)
    return !e || !e.active.some((t) => t.state != 0)
      ? !1
      : (n.dispatch({ effects: ls.of(null) }), !0)
  }
class qA {
  constructor(e, t) {
    ;(this.active = e),
      (this.context = t),
      (this.time = Date.now()),
      (this.updates = []),
      (this.done = void 0)
  }
}
const zA = 50,
  FA = 1e3,
  GA = _e.fromClass(
    class {
      constructor(n) {
        ;(this.view = n),
          (this.debounceUpdate = -1),
          (this.running = []),
          (this.debounceAccept = -1),
          (this.composing = 0)
        for (let e of n.state.field(mt).active)
          e.state == 1 && this.startQuery(e)
      }
      update(n) {
        let e = n.state.field(mt)
        if (!n.selectionSet && !n.docChanged && n.startState.field(mt) == e)
          return
        let t = n.transactions.some(
          (r) => (r.selection || r.docChanged) && !sf(r)
        )
        for (let r = 0; r < this.running.length; r++) {
          let i = this.running[r]
          if (
            t ||
            (i.updates.length + n.transactions.length > zA &&
              Date.now() - i.time > FA)
          ) {
            for (let s of i.context.abortListeners)
              try {
                s()
              } catch (o) {
                _t(this.view.state, o)
              }
            ;(i.context.abortListeners = null), this.running.splice(r--, 1)
          } else i.updates.push(...n.transactions)
        }
        if (
          (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
          (this.debounceUpdate = e.active.some(
            (r) =>
              r.state == 1 &&
              !this.running.some((i) => i.active.source == r.source)
          )
            ? setTimeout(() => this.startUpdate(), 50)
            : -1),
          this.composing != 0)
        )
          for (let r of n.transactions)
            sf(r) == 'input'
              ? (this.composing = 2)
              : this.composing == 2 && r.selection && (this.composing = 3)
      }
      startUpdate() {
        this.debounceUpdate = -1
        let { state: n } = this.view,
          e = n.field(mt)
        for (let t of e.active)
          t.state == 1 &&
            !this.running.some((r) => r.active.source == t.source) &&
            this.startQuery(t)
      }
      startQuery(n) {
        let { state: e } = this.view,
          t = Nn(e),
          r = new Rv(e, t, n.explicitPos == t),
          i = new qA(n, r)
        this.running.push(i),
          Promise.resolve(n.source(r)).then(
            (s) => {
              i.context.aborted || ((i.done = s || null), this.scheduleAccept())
            },
            (s) => {
              this.view.dispatch({ effects: ls.of(null) }),
                _t(this.view.state, s)
            }
          )
      }
      scheduleAccept() {
        this.running.every((n) => n.done !== void 0)
          ? this.accept()
          : this.debounceAccept < 0 &&
            (this.debounceAccept = setTimeout(
              () => this.accept(),
              this.view.state.facet(Ge).updateSyncTime
            ))
      }
      accept() {
        var n
        this.debounceAccept > -1 && clearTimeout(this.debounceAccept),
          (this.debounceAccept = -1)
        let e = [],
          t = this.view.state.facet(Ge)
        for (let r = 0; r < this.running.length; r++) {
          let i = this.running[r]
          if (i.done === void 0) continue
          if ((this.running.splice(r--, 1), i.done)) {
            let o = new Wr(
              i.active.source,
              i.active.explicitPos,
              i.done,
              i.done.from,
              (n = i.done.to) !== null && n !== void 0
                ? n
                : Nn(
                    i.updates.length ? i.updates[0].startState : this.view.state
                  )
            )
            for (let a of i.updates) o = o.update(a, t)
            if (o.hasResult()) {
              e.push(o)
              continue
            }
          }
          let s = this.view.state
            .field(mt)
            .active.find((o) => o.source == i.active.source)
          if (s && s.state == 1)
            if (i.done == null) {
              let o = new at(i.active.source, 0)
              for (let a of i.updates) o = o.update(a, t)
              o.state != 1 && e.push(o)
            } else this.startQuery(s)
        }
        e.length && this.view.dispatch({ effects: Dv.of(e) })
      }
    },
    {
      eventHandlers: {
        blur(n) {
          let e = this.view.state.field(mt, !1)
          if (e && e.tooltip && this.view.state.facet(Ge).closeOnBlur) {
            let t = e.open && db(this.view, e.open.tooltip)
            ;(!t || !t.dom.contains(n.relatedTarget)) &&
              this.view.dispatch({ effects: ls.of(null) })
          }
        },
        compositionstart() {
          this.composing = 1
        },
        compositionend() {
          this.composing == 3 &&
            setTimeout(() => this.view.dispatch({ effects: ih.of(!1) }), 20),
            (this.composing = 0)
        }
      }
    }
  ),
  Iv = j.baseTheme({
    '.cm-tooltip.cm-tooltip-autocomplete': {
      '& > ul': {
        fontFamily: 'monospace',
        whiteSpace: 'nowrap',
        overflow: 'hidden auto',
        maxWidth_fallback: '700px',
        maxWidth: 'min(700px, 95vw)',
        minWidth: '250px',
        maxHeight: '10em',
        height: '100%',
        listStyle: 'none',
        margin: 0,
        padding: 0,
        '& > li, & > completion-section': {
          padding: '1px 3px',
          lineHeight: 1.2
        },
        '& > li': {
          overflowX: 'hidden',
          textOverflow: 'ellipsis',
          cursor: 'pointer'
        },
        '& > completion-section': {
          display: 'list-item',
          borderBottom: '1px solid silver',
          paddingLeft: '0.5em',
          opacity: 0.7
        }
      }
    },
    '&light .cm-tooltip-autocomplete ul li[aria-selected]': {
      background: '#17c',
      color: 'white'
    },
    '&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
      background: '#777'
    },
    '&dark .cm-tooltip-autocomplete ul li[aria-selected]': {
      background: '#347',
      color: 'white'
    },
    '&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]': {
      background: '#444'
    },
    '.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after':
      { content: '""', opacity: 0.5, display: 'block', textAlign: 'center' },
    '.cm-tooltip.cm-completionInfo': {
      position: 'absolute',
      padding: '3px 9px',
      width: 'max-content',
      maxWidth: '400px',
      boxSizing: 'border-box'
    },
    '.cm-completionInfo.cm-completionInfo-left': { right: '100%' },
    '.cm-completionInfo.cm-completionInfo-right': { left: '100%' },
    '.cm-completionInfo.cm-completionInfo-left-narrow': { right: '30px' },
    '.cm-completionInfo.cm-completionInfo-right-narrow': { left: '30px' },
    '&light .cm-snippetField': { backgroundColor: '#00000022' },
    '&dark .cm-snippetField': { backgroundColor: '#ffffff22' },
    '.cm-snippetFieldPosition': {
      verticalAlign: 'text-top',
      width: 0,
      height: '1.15em',
      display: 'inline-block',
      margin: '0 -0.7px -.7em',
      borderLeft: '1.4px dotted #888'
    },
    '.cm-completionMatchedText': { textDecoration: 'underline' },
    '.cm-completionDetail': { marginLeft: '0.5em', fontStyle: 'italic' },
    '.cm-completionIcon': {
      fontSize: '90%',
      width: '.8em',
      display: 'inline-block',
      textAlign: 'center',
      paddingRight: '.6em',
      opacity: '0.6',
      boxSizing: 'content-box'
    },
    '.cm-completionIcon-function, .cm-completionIcon-method': {
      '&:after': { content: "''" }
    },
    '.cm-completionIcon-class': { '&:after': { content: "''" } },
    '.cm-completionIcon-interface': { '&:after': { content: "''" } },
    '.cm-completionIcon-variable': { '&:after': { content: "''" } },
    '.cm-completionIcon-constant': { '&:after': { content: "''" } },
    '.cm-completionIcon-type': { '&:after': { content: "''" } },
    '.cm-completionIcon-enum': { '&:after': { content: "''" } },
    '.cm-completionIcon-property': { '&:after': { content: "''" } },
    '.cm-completionIcon-keyword': { '&:after': { content: "''" } },
    '.cm-completionIcon-namespace': { '&:after': { content: "''" } },
    '.cm-completionIcon-text': {
      '&:after': { content: "'abc'", fontSize: '50%', verticalAlign: 'middle' }
    }
  })
class HA {
  constructor(e, t, r, i) {
    ;(this.field = e), (this.line = t), (this.from = r), (this.to = i)
  }
}
class sh {
  constructor(e, t, r) {
    ;(this.field = e), (this.from = t), (this.to = r)
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Ue.TrackDel),
      r = e.mapPos(this.to, 1, Ue.TrackDel)
    return t == null || r == null ? null : new sh(this.field, t, r)
  }
}
class oh {
  constructor(e, t) {
    ;(this.lines = e), (this.fieldPositions = t)
  }
  instantiate(e, t) {
    let r = [],
      i = [t],
      s = e.doc.lineAt(t),
      o = /^\s*/.exec(s.text)[0]
    for (let l of this.lines) {
      if (r.length) {
        let c = o,
          u = /^\t*/.exec(l)[0].length
        for (let f = 0; f < u; f++) c += e.facet($s)
        i.push(t + c.length - u), (l = c + l.slice(u))
      }
      r.push(l), (t += l.length + 1)
    }
    let a = this.fieldPositions.map(
      (l) => new sh(l.field, i[l.line] + l.from, i[l.line] + l.to)
    )
    return { text: r, ranges: a }
  }
  static parse(e) {
    let t = [],
      r = [],
      i = [],
      s
    for (let o of e.split(/\r\n?|\n/)) {
      for (; (s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o)); ) {
        let a = s[1] ? +s[1] : null,
          l = s[2] || s[3] || '',
          c = -1
        for (let u = 0; u < t.length; u++)
          (a != null ? t[u].seq == a : l && t[u].name == l) && (c = u)
        if (c < 0) {
          let u = 0
          for (
            ;
            u < t.length && (a == null || (t[u].seq != null && t[u].seq < a));

          )
            u++
          t.splice(u, 0, { seq: a, name: l }), (c = u)
          for (let f of i) f.field >= c && f.field++
        }
        i.push(new HA(c, r.length, s.index, s.index + l.length)),
          (o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length))
      }
      for (let a; (a = /\\([{}])/.exec(o)); ) {
        o = o.slice(0, a.index) + a[1] + o.slice(a.index + a[0].length)
        for (let l of i)
          l.line == r.length && l.from > a.index && (l.from--, l.to--)
      }
      r.push(o)
    }
    return new oh(r, i)
  }
}
let KA = G.widget({
    widget: new (class extends an {
      toDOM() {
        let n = document.createElement('span')
        return (n.className = 'cm-snippetFieldPosition'), n
      }
      ignoreEvent() {
        return !1
      }
    })()
  }),
  JA = G.mark({ class: 'cm-snippetField' })
class ui {
  constructor(e, t) {
    ;(this.ranges = e),
      (this.active = t),
      (this.deco = G.set(
        e.map((r) => (r.from == r.to ? KA : JA).range(r.from, r.to))
      ))
  }
  map(e) {
    let t = []
    for (let r of this.ranges) {
      let i = r.map(e)
      if (!i) return null
      t.push(i)
    }
    return new ui(t, this.active)
  }
  selectionInsideField(e) {
    return e.ranges.every((t) =>
      this.ranges.some(
        (r) => r.field == this.active && r.from <= t.from && r.to >= t.to
      )
    )
  }
}
const _s = ee.define({
    map(n, e) {
      return n && n.map(e)
    }
  }),
  eE = ee.define(),
  cs = je.define({
    create() {
      return null
    },
    update(n, e) {
      for (let t of e.effects) {
        if (t.is(_s)) return t.value
        if (t.is(eE) && n) return new ui(n.ranges, t.value)
      }
      return (
        n && e.docChanged && (n = n.map(e.changes)),
        n && e.selection && !n.selectionInsideField(e.selection) && (n = null),
        n
      )
    },
    provide: (n) => j.decorations.from(n, (e) => (e ? e.deco : G.none))
  })
function ah(n, e) {
  return C.create(
    n.filter((t) => t.field == e).map((t) => C.range(t.from, t.to))
  )
}
function tE(n) {
  let e = oh.parse(n)
  return (t, r, i, s) => {
    let { text: o, ranges: a } = e.instantiate(t.state, i),
      l = {
        changes: { from: i, to: s, insert: le.of(o) },
        scrollIntoView: !0,
        annotations: r ? Ev.of(r) : void 0
      }
    if ((a.length && (l.selection = ah(a, 0)), a.length > 1)) {
      let c = new ui(a, 0),
        u = (l.effects = [_s.of(c)])
      t.state.field(cs, !1) === void 0 &&
        u.push(ee.appendConfig.of([cs, oE, aE, Iv]))
    }
    t.dispatch(t.state.update(l))
  }
}
function jv(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(cs, !1)
    if (!r || (n < 0 && r.active == 0)) return !1
    let i = r.active + n,
      s = n > 0 && !r.ranges.some((o) => o.field == i + n)
    return (
      t(
        e.update({
          selection: ah(r.ranges, i),
          effects: _s.of(s ? null : new ui(r.ranges, i)),
          scrollIntoView: !0
        })
      ),
      !0
    )
  }
}
const nE = ({ state: n, dispatch: e }) =>
    n.field(cs, !1) ? (e(n.update({ effects: _s.of(null) })), !0) : !1,
  rE = jv(1),
  iE = jv(-1),
  sE = [
    { key: 'Tab', run: rE, shift: iE },
    { key: 'Escape', run: nE }
  ],
  RO = U.define({
    combine(n) {
      return n.length ? n[0] : sE
    }
  }),
  oE = vr.highest(Ps.compute([RO], (n) => n.facet(RO)))
function ot(n, e) {
  return Object.assign(Object.assign({}, e), { apply: tE(n) })
}
const aE = j.domEventHandlers({
    mousedown(n, e) {
      let t = e.state.field(cs, !1),
        r
      if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
        return !1
      let i = t.ranges.find((s) => s.from <= r && s.to >= r)
      return !i || i.field == t.active
        ? !1
        : (e.dispatch({
            selection: ah(t.ranges, i.field),
            effects: _s.of(
              t.ranges.some((s) => s.field > i.field)
                ? new ui(t.ranges, i.field)
                : null
            ),
            scrollIntoView: !0
          }),
          !0)
    }
  }),
  us = {
    brackets: ['(', '[', '{', "'", '"'],
    before: ')]}:;>',
    stringPrefixes: []
  },
  pr = ee.define({
    map(n, e) {
      let t = e.mapPos(n, -1, Ue.TrackAfter)
      return t ?? void 0
    }
  }),
  lh = new (class extends Or {})()
lh.startSide = 1
lh.endSide = -1
const Nv = je.define({
  create() {
    return ce.empty
  },
  update(n, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head)
      n = n.update({ filter: (r) => r >= t.from && r <= t.to })
    }
    n = n.map(e.changes)
    for (let t of e.effects)
      t.is(pr) && (n = n.update({ add: [lh.range(t.value, t.value + 1)] }))
    return n
  }
})
function lE() {
  return [uE, Nv]
}
const vc = '()[]{}<>'
function Mv(n) {
  for (let e = 0; e < vc.length; e += 2)
    if (vc.charCodeAt(e) == n) return vc.charAt(e + 1)
  return _f(n < 128 ? n : n + 1)
}
function Vv(n, e) {
  return n.languageDataAt('closeBrackets', e)[0] || us
}
const cE =
    typeof navigator == 'object' && /Android\b/.test(navigator.userAgent),
  uE = j.inputHandler.of((n, e, t, r) => {
    if ((cE ? n.composing : n.compositionStarted) || n.state.readOnly) return !1
    let i = n.state.selection.main
    if (
      r.length > 2 ||
      (r.length == 2 && $t(Le(r, 0)) == 1) ||
      e != i.from ||
      t != i.to
    )
      return !1
    let s = pE(n.state, r)
    return s ? (n.dispatch(s), !0) : !1
  }),
  fE = ({ state: n, dispatch: e }) => {
    if (n.readOnly) return !1
    let r = Vv(n, n.selection.main.head).brackets || us.brackets,
      i = null,
      s = n.changeByRange((o) => {
        if (o.empty) {
          let a = dE(n.doc, o.head)
          for (let l of r)
            if (l == a && Cl(n.doc, o.head) == Mv(Le(l, 0)))
              return {
                changes: { from: o.head - l.length, to: o.head + l.length },
                range: C.cursor(o.head - l.length)
              }
        }
        return { range: (i = o) }
      })
    return (
      i || e(n.update(s, { scrollIntoView: !0, userEvent: 'delete.backward' })),
      !i
    )
  },
  hE = [{ key: 'Backspace', run: fE }]
function pE(n, e) {
  let t = Vv(n, n.selection.main.head),
    r = t.brackets || us.brackets
  for (let i of r) {
    let s = Mv(Le(i, 0))
    if (e == i)
      return s == i
        ? gE(n, i, r.indexOf(i + i + i) > -1, t)
        : OE(n, i, s, t.before || us.before)
    if (e == s && Wv(n, n.selection.main.from)) return mE(n, i, s)
  }
  return null
}
function Wv(n, e) {
  let t = !1
  return (
    n.field(Nv).between(0, n.doc.length, (r) => {
      r == e && (t = !0)
    }),
    t
  )
}
function Cl(n, e) {
  let t = n.sliceString(e, e + 2)
  return t.slice(0, $t(Le(t, 0)))
}
function dE(n, e) {
  let t = n.sliceString(e - 2, e)
  return $t(Le(t, 0)) == t.length ? t : t.slice(1)
}
function OE(n, e, t, r) {
  let i = null,
    s = n.changeByRange((o) => {
      if (!o.empty)
        return {
          changes: [
            { insert: e, from: o.from },
            { insert: t, from: o.to }
          ],
          effects: pr.of(o.to + e.length),
          range: C.range(o.anchor + e.length, o.head + e.length)
        }
      let a = Cl(n.doc, o.head)
      return !a || /\s/.test(a) || r.indexOf(a) > -1
        ? {
            changes: { insert: e + t, from: o.head },
            effects: pr.of(o.head + e.length),
            range: C.cursor(o.head + e.length)
          }
        : { range: (i = o) }
    })
  return i ? null : n.update(s, { scrollIntoView: !0, userEvent: 'input.type' })
}
function mE(n, e, t) {
  let r = null,
    i = n.changeByRange((s) =>
      s.empty && Cl(n.doc, s.head) == t
        ? {
            changes: { from: s.head, to: s.head + t.length, insert: t },
            range: C.cursor(s.head + t.length)
          }
        : (r = { range: s })
    )
  return r ? null : n.update(i, { scrollIntoView: !0, userEvent: 'input.type' })
}
function gE(n, e, t, r) {
  let i = r.stringPrefixes || us.stringPrefixes,
    s = null,
    o = n.changeByRange((a) => {
      if (!a.empty)
        return {
          changes: [
            { insert: e, from: a.from },
            { insert: e, from: a.to }
          ],
          effects: pr.of(a.to + e.length),
          range: C.range(a.anchor + e.length, a.head + e.length)
        }
      let l = a.head,
        c = Cl(n.doc, l),
        u
      if (c == e) {
        if (ZO(n, l))
          return {
            changes: { insert: e + e, from: l },
            effects: pr.of(l + e.length),
            range: C.cursor(l + e.length)
          }
        if (Wv(n, l)) {
          let p =
            t && n.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e
          return {
            changes: { from: l, to: l + p.length, insert: p },
            range: C.cursor(l + p.length)
          }
        }
      } else {
        if (
          t &&
          n.sliceDoc(l - 2 * e.length, l) == e + e &&
          (u = AO(n, l - 2 * e.length, i)) > -1 &&
          ZO(n, u)
        )
          return {
            changes: { insert: e + e + e + e, from: l },
            effects: pr.of(l + e.length),
            range: C.cursor(l + e.length)
          }
        if (
          n.charCategorizer(l)(c) != Se.Word &&
          AO(n, l, i) > -1 &&
          !yE(n, l, e, i)
        )
          return {
            changes: { insert: e + e, from: l },
            effects: pr.of(l + e.length),
            range: C.cursor(l + e.length)
          }
      }
      return { range: (s = a) }
    })
  return s ? null : n.update(o, { scrollIntoView: !0, userEvent: 'input.type' })
}
function ZO(n, e) {
  let t = ke(n).resolveInner(e + 1)
  return t.parent && t.from == e
}
function yE(n, e, t, r) {
  let i = ke(n).resolveInner(e, -1),
    s = r.reduce((o, a) => Math.max(o, a.length), 0)
  for (let o = 0; o < 5; o++) {
    let a = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)),
      l = a.indexOf(t)
    if (!l || (l > -1 && r.indexOf(a.slice(0, l)) > -1)) {
      let u = i.firstChild
      for (; u && u.from == i.from && u.to - u.from > t.length + l; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t) return !1
        u = u.firstChild
      }
      return !0
    }
    let c = i.to == e && i.parent
    if (!c) break
    i = c
  }
  return !1
}
function AO(n, e, t) {
  let r = n.charCategorizer(e)
  if (r(n.sliceDoc(e - 1, e)) != Se.Word) return e
  for (let i of t) {
    let s = e - i.length
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != Se.Word) return s
  }
  return -1
}
function bE(n = {}) {
  return [mt, Ge.of(n), GA, vE, Iv]
}
const Lv = [
    { key: 'Ctrl-Space', run: BA },
    { key: 'Escape', run: UA },
    { key: 'ArrowDown', run: uo(!0) },
    { key: 'ArrowUp', run: uo(!1) },
    { key: 'PageDown', run: uo(!0, 'page') },
    { key: 'PageUp', run: uo(!1, 'page') },
    { key: 'Enter', run: LA }
  ],
  vE = vr.highest(
    Ps.computeN([Ge], (n) => (n.facet(Ge).defaultKeymap ? [Lv] : []))
  )
class SE {
  constructor(e, t, r) {
    ;(this.from = e), (this.to = t), (this.diagnostic = r)
  }
}
class ur {
  constructor(e, t, r) {
    ;(this.diagnostics = e), (this.panel = t), (this.selected = r)
  }
  static init(e, t, r) {
    let i = e,
      s = r.facet(qv).markerFilter
    s && (i = s(i))
    let o = G.set(
      i.map((a) =>
        a.from == a.to ||
        (a.from == a.to - 1 && r.doc.lineAt(a.from).to == a.from)
          ? G.widget({ widget: new _E(a), diagnostic: a }).range(a.from)
          : G.mark({
              attributes: {
                class:
                  'cm-lintRange cm-lintRange-' +
                  a.severity +
                  (a.markClass ? ' ' + a.markClass : '')
              },
              diagnostic: a
            }).range(a.from, a.to)
      ),
      !0
    )
    return new ur(o, t, ti(o))
  }
}
function ti(n, e = null, t = 0) {
  let r = null
  return (
    n.between(t, 1e9, (i, s, { spec: o }) => {
      if (!(e && o.diagnostic != e)) return (r = new SE(i, s, o.diagnostic)), !1
    }),
    r
  )
}
function xE(n, e) {
  let t = n.startState.doc.lineAt(e.pos)
  return !!(
    n.effects.some((r) => r.is(Bv)) || n.changes.touchesRange(t.from, t.to)
  )
}
function wE(n, e) {
  return n.field(yt, !1) ? e : e.concat(ee.appendConfig.of(AE))
}
const Bv = ee.define(),
  ch = ee.define(),
  Uv = ee.define(),
  yt = je.define({
    create() {
      return new ur(G.none, null, null)
    },
    update(n, e) {
      if (e.docChanged) {
        let t = n.diagnostics.map(e.changes),
          r = null
        if (n.selected) {
          let i = e.changes.mapPos(n.selected.from, 1)
          r = ti(t, n.selected.diagnostic, i) || ti(t, null, i)
        }
        n = new ur(t, n.panel, r)
      }
      for (let t of e.effects)
        t.is(Bv)
          ? (n = ur.init(t.value, n.panel, e.state))
          : t.is(ch)
            ? (n = new ur(n.diagnostics, t.value ? _l.open : null, n.selected))
            : t.is(Uv) && (n = new ur(n.diagnostics, n.panel, t.value))
      return n
    },
    provide: (n) => [
      rs.from(n, (e) => e.panel),
      j.decorations.from(n, (e) => e.diagnostics)
    ]
  }),
  PE = G.mark({ class: 'cm-lintRange cm-lintRange-active' })
function TE(n, e, t) {
  let { diagnostics: r } = n.state.field(yt),
    i = [],
    s = 2e8,
    o = 0
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l &&
      e <= c &&
      (l == c || ((e > l || t > 0) && (e < c || t < 0))) &&
      (i.push(u.diagnostic), (s = Math.min(l, s)), (o = Math.max(c, o)))
  })
  let a = n.state.facet(qv).tooltipFilter
  return (
    a && (i = a(i)),
    i.length
      ? {
          pos: s,
          end: o,
          above: n.state.doc.lineAt(s).to < o,
          create() {
            return { dom: $E(n, i) }
          }
        }
      : null
  )
}
function $E(n, e) {
  return de(
    'ul',
    { class: 'cm-tooltip-lint' },
    e.map((t) => Fv(n, t, !1))
  )
}
const QE = (n) => {
    let e = n.state.field(yt, !1)
    ;(!e || !e.panel) && n.dispatch({ effects: wE(n.state, [ch.of(!0)]) })
    let t = ns(n, _l.open)
    return t && t.dom.querySelector('.cm-panel-lint ul').focus(), !0
  },
  EO = (n) => {
    let e = n.state.field(yt, !1)
    return !e || !e.panel ? !1 : (n.dispatch({ effects: ch.of(!1) }), !0)
  },
  kE = (n) => {
    let e = n.state.field(yt, !1)
    if (!e) return !1
    let t = n.state.selection.main,
      r = e.diagnostics.iter(t.to + 1)
    return !r.value &&
      ((r = e.diagnostics.iter(0)),
      !r.value || (r.from == t.from && r.to == t.to))
      ? !1
      : (n.dispatch({
          selection: { anchor: r.from, head: r.to },
          scrollIntoView: !0
        }),
        !0)
  },
  CE = [
    { key: 'Mod-Shift-m', run: QE, preventDefault: !0 },
    { key: 'F8', run: kE }
  ],
  qv = U.define({
    combine(n) {
      return Object.assign(
        { sources: n.map((e) => e.source) },
        on(
          n.map((e) => e.config),
          {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
            needsRefresh: null
          },
          { needsRefresh: (e, t) => (e ? (t ? (r) => e(r) || t(r) : e) : t) }
        )
      )
    }
  })
function zv(n) {
  let e = []
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r]
        if (
          /[a-zA-Z]/.test(i) &&
          !e.some((s) => s.toLowerCase() == i.toLowerCase())
        ) {
          e.push(i)
          continue e
        }
      }
      e.push('')
    }
  return e
}
function Fv(n, e, t) {
  var r
  let i = t ? zv(e.actions) : []
  return de(
    'li',
    { class: 'cm-diagnostic cm-diagnostic-' + e.severity },
    de(
      'span',
      { class: 'cm-diagnosticText' },
      e.renderMessage ? e.renderMessage() : e.message
    ),
    (r = e.actions) === null || r === void 0
      ? void 0
      : r.map((s, o) => {
          let a = !1,
            l = (p) => {
              if ((p.preventDefault(), a)) return
              a = !0
              let d = ti(n.state.field(yt).diagnostics, e)
              d && s.apply(n, d.from, d.to)
            },
            { name: c } = s,
            u = i[o] ? c.indexOf(i[o]) : -1,
            f =
              u < 0
                ? c
                : [c.slice(0, u), de('u', c.slice(u, u + 1)), c.slice(u + 1)]
          return de(
            'button',
            {
              type: 'button',
              class: 'cm-diagnosticAction',
              onclick: l,
              onmousedown: l,
              'aria-label': ` Action: ${c}${
                u < 0 ? '' : ` (access key "${i[o]})"`
              }.`
            },
            f
          )
        }),
    e.source && de('div', { class: 'cm-diagnosticSource' }, e.source)
  )
}
class _E extends an {
  constructor(e) {
    super(), (this.diagnostic = e)
  }
  eq(e) {
    return e.diagnostic == this.diagnostic
  }
  toDOM() {
    return de('span', {
      class: 'cm-lintPoint cm-lintPoint-' + this.diagnostic.severity
    })
  }
}
class DO {
  constructor(e, t) {
    ;(this.diagnostic = t),
      (this.id = 'item_' + Math.floor(Math.random() * 4294967295).toString(16)),
      (this.dom = Fv(e, t, !0)),
      (this.dom.id = this.id),
      this.dom.setAttribute('role', 'option')
  }
}
class _l {
  constructor(e) {
    ;(this.view = e), (this.items = [])
    let t = (i) => {
        if (i.keyCode == 27) EO(this.view), this.view.focus()
        else if (i.keyCode == 38 || i.keyCode == 33)
          this.moveSelection(
            (this.selectedIndex - 1 + this.items.length) % this.items.length
          )
        else if (i.keyCode == 40 || i.keyCode == 34)
          this.moveSelection((this.selectedIndex + 1) % this.items.length)
        else if (i.keyCode == 36) this.moveSelection(0)
        else if (i.keyCode == 35) this.moveSelection(this.items.length - 1)
        else if (i.keyCode == 13) this.view.focus()
        else if (
          i.keyCode >= 65 &&
          i.keyCode <= 90 &&
          this.selectedIndex >= 0
        ) {
          let { diagnostic: s } = this.items[this.selectedIndex],
            o = zv(s.actions)
          for (let a = 0; a < o.length; a++)
            if (o[a].toUpperCase().charCodeAt(0) == i.keyCode) {
              let l = ti(this.view.state.field(yt).diagnostics, s)
              l && s.actions[a].apply(e, l.from, l.to)
            }
        } else return
        i.preventDefault()
      },
      r = (i) => {
        for (let s = 0; s < this.items.length; s++)
          this.items[s].dom.contains(i.target) && this.moveSelection(s)
      }
    ;(this.list = de('ul', {
      tabIndex: 0,
      role: 'listbox',
      'aria-label': this.view.state.phrase('Diagnostics'),
      onkeydown: t,
      onclick: r
    })),
      (this.dom = de(
        'div',
        { class: 'cm-panel-lint' },
        this.list,
        de(
          'button',
          {
            type: 'button',
            name: 'close',
            'aria-label': this.view.state.phrase('close'),
            onclick: () => EO(this.view)
          },
          ''
        )
      )),
      this.update()
  }
  get selectedIndex() {
    let e = this.view.state.field(yt).selected
    if (!e) return -1
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic) return t
    return -1
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(yt),
      r = 0,
      i = !1,
      s = null
    for (
      e.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
        let c = -1,
          u
        for (let f = r; f < this.items.length; f++)
          if (this.items[f].diagnostic == l.diagnostic) {
            c = f
            break
          }
        c < 0
          ? ((u = new DO(this.view, l.diagnostic)),
            this.items.splice(r, 0, u),
            (i = !0))
          : ((u = this.items[c]),
            c > r && (this.items.splice(r, c - r), (i = !0))),
          t && u.diagnostic == t.diagnostic
            ? u.dom.hasAttribute('aria-selected') ||
              (u.dom.setAttribute('aria-selected', 'true'), (s = u))
            : u.dom.hasAttribute('aria-selected') &&
              u.dom.removeAttribute('aria-selected'),
          r++
      });
      r < this.items.length &&
      !(this.items.length == 1 && this.items[0].diagnostic.from < 0);

    )
      (i = !0), this.items.pop()
    this.items.length == 0 &&
      (this.items.push(
        new DO(this.view, {
          from: -1,
          to: -1,
          severity: 'info',
          message: this.view.state.phrase('No diagnostics')
        })
      ),
      (i = !0)),
      s
        ? (this.list.setAttribute('aria-activedescendant', s.id),
          this.view.requestMeasure({
            key: this,
            read: () => ({
              sel: s.dom.getBoundingClientRect(),
              panel: this.list.getBoundingClientRect()
            }),
            write: ({ sel: o, panel: a }) => {
              let l = a.height / this.list.offsetHeight
              o.top < a.top
                ? (this.list.scrollTop -= (a.top - o.top) / l)
                : o.bottom > a.bottom &&
                  (this.list.scrollTop += (o.bottom - a.bottom) / l)
            }
          }))
        : this.selectedIndex < 0 &&
          this.list.removeAttribute('aria-activedescendant'),
      i && this.sync()
  }
  sync() {
    let e = this.list.firstChild
    function t() {
      let r = e
      ;(e = r.nextSibling), r.remove()
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; ) t()
        e = r.dom.nextSibling
      } else this.list.insertBefore(r.dom, e)
    for (; e; ) t()
  }
  moveSelection(e) {
    if (this.selectedIndex < 0) return
    let t = this.view.state.field(yt),
      r = ti(t.diagnostics, this.items[e].diagnostic)
    r &&
      this.view.dispatch({
        selection: { anchor: r.from, head: r.to },
        scrollIntoView: !0,
        effects: Uv.of(r)
      })
  }
  static open(e) {
    return new _l(e)
  }
}
function RE(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(
    n
  )}</svg>')`
}
function fo(n) {
  return RE(
    `<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`,
    'width="6" height="3"'
  )
}
const ZE = j.baseTheme({
    '.cm-diagnostic': {
      padding: '3px 6px 3px 8px',
      marginLeft: '-1px',
      display: 'block',
      whiteSpace: 'pre-wrap'
    },
    '.cm-diagnostic-error': { borderLeft: '5px solid #d11' },
    '.cm-diagnostic-warning': { borderLeft: '5px solid orange' },
    '.cm-diagnostic-info': { borderLeft: '5px solid #999' },
    '.cm-diagnostic-hint': { borderLeft: '5px solid #66d' },
    '.cm-diagnosticAction': {
      font: 'inherit',
      border: 'none',
      padding: '2px 4px',
      backgroundColor: '#444',
      color: 'white',
      borderRadius: '3px',
      marginLeft: '8px',
      cursor: 'pointer'
    },
    '.cm-diagnosticSource': { fontSize: '70%', opacity: 0.7 },
    '.cm-lintRange': {
      backgroundPosition: 'left bottom',
      backgroundRepeat: 'repeat-x',
      paddingBottom: '0.7px'
    },
    '.cm-lintRange-error': { backgroundImage: fo('#d11') },
    '.cm-lintRange-warning': { backgroundImage: fo('orange') },
    '.cm-lintRange-info': { backgroundImage: fo('#999') },
    '.cm-lintRange-hint': { backgroundImage: fo('#66d') },
    '.cm-lintRange-active': { backgroundColor: '#ffdd9980' },
    '.cm-tooltip-lint': { padding: 0, margin: 0 },
    '.cm-lintPoint': {
      position: 'relative',
      '&:after': {
        content: '""',
        position: 'absolute',
        bottom: 0,
        left: '-2px',
        borderLeft: '3px solid transparent',
        borderRight: '3px solid transparent',
        borderBottom: '4px solid #d11'
      }
    },
    '.cm-lintPoint-warning': { '&:after': { borderBottomColor: 'orange' } },
    '.cm-lintPoint-info': { '&:after': { borderBottomColor: '#999' } },
    '.cm-lintPoint-hint': { '&:after': { borderBottomColor: '#66d' } },
    '.cm-panel.cm-panel-lint': {
      position: 'relative',
      '& ul': {
        maxHeight: '100px',
        overflowY: 'auto',
        '& [aria-selected]': {
          backgroundColor: '#ddd',
          '& u': { textDecoration: 'underline' }
        },
        '&:focus [aria-selected]': {
          background_fallback: '#bdf',
          backgroundColor: 'Highlight',
          color_fallback: 'white',
          color: 'HighlightText'
        },
        '& u': { textDecoration: 'none' },
        padding: 0,
        margin: 0
      },
      '& [name=close]': {
        position: 'absolute',
        top: '0',
        right: '2px',
        background: 'inherit',
        border: 'none',
        font: 'inherit',
        padding: 0,
        margin: 0
      }
    }
  }),
  AE = [
    yt,
    j.decorations.compute([yt], (n) => {
      let { selected: e, panel: t } = n.field(yt)
      return !e || !t || e.from == e.to
        ? G.none
        : G.set([PE.range(e.from, e.to)])
    }),
    v_(TE, { hideOn: xE }),
    ZE
  ]
var XO = function (e) {
  e === void 0 && (e = {})
  var { crosshairCursor: t = !1 } = e,
    r = []
  e.closeBracketsKeymap !== !1 && (r = r.concat(hE)),
    e.defaultKeymap !== !1 && (r = r.concat(JZ)),
    e.searchKeymap !== !1 && (r = r.concat(PA)),
    e.historyKeymap !== !1 && (r = r.concat(lZ)),
    e.foldKeymap !== !1 && (r = r.concat(xR)),
    e.completionKeymap !== !1 && (r = r.concat(Lv)),
    e.lintKeymap !== !1 && (r = r.concat(CE))
  var i = []
  return (
    e.lineNumbers !== !1 && i.push(C_()),
    e.highlightActiveLineGutter !== !1 && i.push(Z_()),
    e.highlightSpecialChars !== !1 && i.push(GC()),
    e.history !== !1 && i.push(JR()),
    e.foldGutter !== !1 && i.push($R()),
    e.drawSelection !== !1 && i.push(jC()),
    e.dropCursor !== !1 && i.push(LC()),
    e.allowMultipleSelections !== !1 &&
      i.push(ie.allowMultipleSelections.of(!0)),
    e.indentOnInput !== !1 && i.push(pR()),
    e.syntaxHighlighting !== !1 && i.push(Gf(_R, { fallback: !0 })),
    e.bracketMatching !== !1 && i.push(YR()),
    e.closeBrackets !== !1 && i.push(lE()),
    e.autocompletion !== !1 && i.push(bE()),
    e.rectangularSelection !== !1 && i.push(u_()),
    t !== !1 && i.push(p_()),
    e.highlightActiveLine !== !1 && i.push(n_()),
    e.highlightSelectionMatches !== !1 && i.push(sA()),
    e.tabSize &&
      typeof e.tabSize == 'number' &&
      i.push($s.of(' '.repeat(e.tabSize))),
    i.concat([Ps.of(r.flat())]).filter(Boolean)
  )
}
const EE = '#e5c07b',
  YO = '#e06c75',
  DE = '#56b6c2',
  XE = '#ffffff',
  Lo = '#abb2bf',
  of = '#7d8799',
  YE = '#61afef',
  IE = '#98c379',
  IO = '#d19a66',
  jE = '#c678dd',
  NE = '#21252b',
  jO = '#2c313a',
  NO = '#282c34',
  Sc = '#353a42',
  ME = '#3E4451',
  MO = '#528bff',
  VE = j.theme(
    {
      '&': { color: Lo, backgroundColor: NO },
      '.cm-content': { caretColor: MO },
      '.cm-cursor, .cm-dropCursor': { borderLeftColor: MO },
      '&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection':
        { backgroundColor: ME },
      '.cm-panels': { backgroundColor: NE, color: Lo },
      '.cm-panels.cm-panels-top': { borderBottom: '2px solid black' },
      '.cm-panels.cm-panels-bottom': { borderTop: '2px solid black' },
      '.cm-searchMatch': {
        backgroundColor: '#72a1ff59',
        outline: '1px solid #457dff'
      },
      '.cm-searchMatch.cm-searchMatch-selected': {
        backgroundColor: '#6199ff2f'
      },
      '.cm-activeLine': { backgroundColor: '#6699ff0b' },
      '.cm-selectionMatch': { backgroundColor: '#aafe661a' },
      '&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket': {
        backgroundColor: '#bad0f847'
      },
      '.cm-gutters': { backgroundColor: NO, color: of, border: 'none' },
      '.cm-activeLineGutter': { backgroundColor: jO },
      '.cm-foldPlaceholder': {
        backgroundColor: 'transparent',
        border: 'none',
        color: '#ddd'
      },
      '.cm-tooltip': { border: 'none', backgroundColor: Sc },
      '.cm-tooltip .cm-tooltip-arrow:before': {
        borderTopColor: 'transparent',
        borderBottomColor: 'transparent'
      },
      '.cm-tooltip .cm-tooltip-arrow:after': {
        borderTopColor: Sc,
        borderBottomColor: Sc
      },
      '.cm-tooltip-autocomplete': {
        '& > ul > li[aria-selected]': { backgroundColor: jO, color: Lo }
      }
    },
    { dark: !0 }
  ),
  WE = ai.define([
    { tag: m.keyword, color: jE },
    {
      tag: [m.name, m.deleted, m.character, m.propertyName, m.macroName],
      color: YO
    },
    { tag: [m.function(m.variableName), m.labelName], color: YE },
    { tag: [m.color, m.constant(m.name), m.standard(m.name)], color: IO },
    { tag: [m.definition(m.name), m.separator], color: Lo },
    {
      tag: [
        m.typeName,
        m.className,
        m.number,
        m.changed,
        m.annotation,
        m.modifier,
        m.self,
        m.namespace
      ],
      color: EE
    },
    {
      tag: [
        m.operator,
        m.operatorKeyword,
        m.url,
        m.escape,
        m.regexp,
        m.link,
        m.special(m.string)
      ],
      color: DE
    },
    { tag: [m.meta, m.comment], color: of },
    { tag: m.strong, fontWeight: 'bold' },
    { tag: m.emphasis, fontStyle: 'italic' },
    { tag: m.strikethrough, textDecoration: 'line-through' },
    { tag: m.link, color: of, textDecoration: 'underline' },
    { tag: m.heading, fontWeight: 'bold', color: YO },
    { tag: [m.atom, m.bool, m.special(m.variableName)], color: IO },
    { tag: [m.processingInstruction, m.string, m.inserted], color: IE },
    { tag: m.invalid, color: XE }
  ]),
  LE = [VE, Gf(WE)]
var BE = j.theme({ '&': { backgroundColor: '#fff' } }, { dark: !1 }),
  UE = function (e) {
    e === void 0 && (e = {})
    var {
        indentWithTab: t = !0,
        editable: r = !0,
        readOnly: i = !1,
        theme: s = 'light',
        placeholder: o = '',
        basicSetup: a = !0
      } = e,
      l = []
    switch (
      (t && l.unshift(Ps.of([eA])),
      a && (typeof a == 'boolean' ? l.unshift(XO()) : l.unshift(XO(a))),
      o && l.unshift(o_(o)),
      s)
    ) {
      case 'light':
        l.push(BE)
        break
      case 'dark':
        l.push(LE)
        break
      case 'none':
        break
      default:
        l.push(s)
        break
    }
    return (
      r === !1 && l.push(j.editable.of(!1)),
      i && l.push(ie.readOnly.of(!0)),
      [...l]
    )
  },
  qE = (n) => ({
    line: n.state.doc.lineAt(n.state.selection.main.from),
    lineCount: n.state.doc.lines,
    lineBreak: n.state.lineBreak,
    length: n.state.doc.length,
    readOnly: n.state.readOnly,
    tabSize: n.state.tabSize,
    selection: n.state.selection,
    selectionAsSingle: n.state.selection.asSingle().main,
    ranges: n.state.selection.ranges,
    selectionCode: n.state.sliceDoc(
      n.state.selection.main.from,
      n.state.selection.main.to
    ),
    selections: n.state.selection.ranges.map((e) =>
      n.state.sliceDoc(e.from, e.to)
    ),
    selectedText: n.state.selection.ranges.some((e) => !e.empty)
  }),
  VO = sn.define(),
  zE = []
function FE(n) {
  var {
      value: e,
      selection: t,
      onChange: r,
      onStatistics: i,
      onCreateEditor: s,
      onUpdate: o,
      extensions: a = zE,
      autoFocus: l,
      theme: c = 'light',
      height: u = null,
      minHeight: f = null,
      maxHeight: p = null,
      width: d = null,
      minWidth: O = null,
      maxWidth: g = null,
      placeholder: b = '',
      editable: x = !0,
      readOnly: w = !1,
      indentWithTab: Q = !0,
      basicSetup: T = !0,
      root: P,
      initialState: k
    } = n,
    [R, V] = h.reactExports.useState(),
    [D, L] = h.reactExports.useState(),
    [B, A] = h.reactExports.useState(),
    Y = j.theme({
      '&': {
        height: u,
        minHeight: f,
        maxHeight: p,
        width: d,
        minWidth: O,
        maxWidth: g
      },
      '& .cm-scroller': { height: '100% !important' }
    }),
    W = j.updateListener.of((J) => {
      if (
        J.docChanged &&
        typeof r == 'function' &&
        !J.transactions.some((ue) => ue.annotation(VO))
      ) {
        var ae = J.state.doc,
          me = ae.toString()
        r(me, J)
      }
      i && i(qE(J))
    }),
    K = UE({
      theme: c,
      editable: x,
      readOnly: w,
      placeholder: b,
      indentWithTab: Q,
      basicSetup: T
    }),
    te = [W, Y, ...K]
  return (
    o && typeof o == 'function' && te.push(j.updateListener.of(o)),
    (te = te.concat(a)),
    h.reactExports.useEffect(() => {
      if (R && !B) {
        var J = { doc: e, selection: t, extensions: te },
          ae = k ? ie.fromJSON(k.json, J, k.fields) : ie.create(J)
        if ((A(ae), !D)) {
          var me = new j({ state: ae, parent: R, root: P })
          L(me), s && s(me, ae)
        }
      }
      return () => {
        D && (A(void 0), L(void 0))
      }
    }, [R, B]),
    h.reactExports.useEffect(() => V(n.container), [n.container]),
    h.reactExports.useEffect(
      () => () => {
        D && (D.destroy(), L(void 0))
      },
      [D]
    ),
    h.reactExports.useEffect(() => {
      l && D && D.focus()
    }, [l, D]),
    h.reactExports.useEffect(() => {
      D && D.dispatch({ effects: ee.reconfigure.of(te) })
    }, [c, a, u, f, p, d, O, g, b, x, w, Q, T, r, o]),
    h.reactExports.useEffect(() => {
      if (e !== void 0) {
        var J = D ? D.state.doc.toString() : ''
        D &&
          e !== J &&
          D.dispatch({
            changes: { from: 0, to: J.length, insert: e || '' },
            annotations: [VO.of(!0)]
          })
      }
    }, [e, D]),
    {
      state: B,
      setState: A,
      view: D,
      setView: L,
      container: R,
      setContainer: V
    }
  )
}
var GE = [
    'className',
    'value',
    'selection',
    'extensions',
    'onChange',
    'onStatistics',
    'onCreateEditor',
    'onUpdate',
    'autoFocus',
    'theme',
    'height',
    'minHeight',
    'maxHeight',
    'width',
    'minWidth',
    'maxWidth',
    'basicSetup',
    'placeholder',
    'indentWithTab',
    'editable',
    'readOnly',
    'root',
    'initialState'
  ],
  af = h.reactExports.forwardRef((n, e) => {
    var {
        className: t,
        value: r = '',
        selection: i,
        extensions: s = [],
        onChange: o,
        onStatistics: a,
        onCreateEditor: l,
        onUpdate: c,
        autoFocus: u,
        theme: f = 'light',
        height: p,
        minHeight: d,
        maxHeight: O,
        width: g,
        minWidth: b,
        maxWidth: x,
        basicSetup: w,
        placeholder: Q,
        indentWithTab: T,
        editable: P,
        readOnly: k,
        root: R,
        initialState: V
      } = n,
      D = h._objectWithoutPropertiesLoose(n, GE),
      L = h.reactExports.useRef(null),
      {
        state: B,
        view: A,
        container: Y
      } = FE({
        container: L.current,
        root: R,
        value: r,
        autoFocus: u,
        theme: f,
        height: p,
        minHeight: d,
        maxHeight: O,
        width: g,
        minWidth: b,
        maxWidth: x,
        basicSetup: w,
        placeholder: Q,
        indentWithTab: T,
        editable: P,
        readOnly: k,
        selection: i,
        onChange: o,
        onStatistics: a,
        onCreateEditor: l,
        onUpdate: c,
        extensions: s,
        initialState: V
      })
    if (
      (h.reactExports.useImperativeHandle(
        e,
        () => ({ editor: L.current, state: B, view: A }),
        [L, Y, B, A]
      ),
      typeof r != 'string')
    )
      throw new Error('value must be typeof string but got ' + typeof r)
    var W = typeof f == 'string' ? 'cm-theme-' + f : 'cm-theme'
    return h.jsxRuntimeExports.jsx(
      'div',
      h._extends({ ref: L, className: '' + W + (t ? ' ' + t : '') }, D)
    )
  })
af.displayName = 'CodeMirror'
class La {
  constructor(e, t, r, i, s, o, a, l, c, u = 0, f) {
    ;(this.p = e),
      (this.stack = t),
      (this.state = r),
      (this.reducePos = i),
      (this.pos = s),
      (this.score = o),
      (this.buffer = a),
      (this.bufferBase = l),
      (this.curContext = c),
      (this.lookAhead = u),
      (this.parent = f)
  }
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${
      this.pos
    }${this.score ? '!' + this.score : ''}`
  }
  static start(e, t, r = 0) {
    let i = e.parser.context
    return new La(
      e,
      [],
      t,
      r,
      r,
      0,
      [],
      0,
      i ? new WO(i, i.start) : null,
      0,
      null
    )
  }
  get context() {
    return this.curContext ? this.curContext.context : null
  }
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length),
      (this.state = e)
  }
  reduce(e) {
    var t
    let r = e >> 19,
      i = e & 65535,
      { parser: s } = this.p,
      o = s.dynamicPrecedence(i)
    if ((o && (this.score += o), r == 0)) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos),
        i < s.minRepeatTerm &&
          this.storeNode(i, this.reducePos, this.reducePos, 4, !0),
        this.reduceContext(i, this.reducePos)
      return
    }
    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0),
      l = a ? this.stack[a - 2] : this.p.ranges[0].from,
      c = this.reducePos - l
    c >= 2e3 &&
      !(
        !((t = this.p.parser.nodeSet.types[i]) === null || t === void 0) &&
        t.isAnonymous
      ) &&
      (l == this.p.lastBigReductionStart
        ? (this.p.bigReductionCount++, (this.p.lastBigReductionSize = c))
        : this.p.lastBigReductionSize < c &&
          ((this.p.bigReductionCount = 1),
          (this.p.lastBigReductionStart = l),
          (this.p.lastBigReductionSize = c)))
    let u = a ? this.stack[a - 1] : 0,
      f = this.bufferBase + this.buffer.length - u
    if (i < s.minRepeatTerm || e & 131072) {
      let p = s.stateFlag(this.state, 1) ? this.pos : this.reducePos
      this.storeNode(i, l, p, f + 4, !0)
    }
    if (e & 262144) this.state = this.stack[a]
    else {
      let p = this.stack[a - 3]
      this.state = s.getGoto(p, i, !0)
    }
    for (; this.stack.length > a; ) this.stack.pop()
    this.reduceContext(i, l)
  }
  storeNode(e, t, r, i = 4, s = !1) {
    if (
      e == 0 &&
      (!this.stack.length ||
        this.stack[this.stack.length - 1] <
          this.buffer.length + this.bufferBase)
    ) {
      let o = this,
        a = this.buffer.length
      if (
        (a == 0 &&
          o.parent &&
          ((a = o.bufferBase - o.parent.bufferBase), (o = o.parent)),
        a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1)
      ) {
        if (t == r) return
        if (o.buffer[a - 2] >= t) {
          o.buffer[a - 2] = r
          return
        }
      }
    }
    if (!s || this.pos == r) this.buffer.push(e, t, r, i)
    else {
      let o = this.buffer.length
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > r; )
          (this.buffer[o] = this.buffer[o - 4]),
            (this.buffer[o + 1] = this.buffer[o - 3]),
            (this.buffer[o + 2] = this.buffer[o - 2]),
            (this.buffer[o + 3] = this.buffer[o - 1]),
            (o -= 4),
            i > 4 && (i -= 4)
      ;(this.buffer[o] = e),
        (this.buffer[o + 1] = t),
        (this.buffer[o + 2] = r),
        (this.buffer[o + 3] = i)
    }
  }
  shift(e, t, r, i) {
    if (e & 131072) this.pushState(e & 65535, this.pos)
    else if (e & 262144)
      (this.pos = i),
        this.shiftContext(t, r),
        t <= this.p.parser.maxNode && this.buffer.push(t, r, i, 4)
    else {
      let s = e,
        { parser: o } = this.p
      ;(i > this.pos || t <= o.maxNode) &&
        ((this.pos = i), o.stateFlag(s, 1) || (this.reducePos = i)),
        this.pushState(s, r),
        this.shiftContext(t, r),
        t <= o.maxNode && this.buffer.push(t, r, i, 4)
    }
  }
  apply(e, t, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, r, i)
  }
  useNode(e, t) {
    let r = this.p.reused.length - 1
    ;(r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++)
    let i = this.pos
    ;(this.reducePos = this.pos = i + e.length),
      this.pushState(t, i),
      this.buffer.push(r, i, this.reducePos, -1),
      this.curContext &&
        this.updateContext(
          this.curContext.tracker.reuse(
            this.curContext.context,
            e,
            this,
            this.p.stream.reset(this.pos - e.length)
          )
        )
  }
  split() {
    let e = this,
      t = e.buffer.length
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; ) t -= 4
    let r = e.buffer.slice(t),
      i = e.bufferBase + t
    for (; e && i == e.bufferBase; ) e = e.parent
    return new La(
      this.p,
      this.stack.slice(),
      this.state,
      this.reducePos,
      this.pos,
      this.score,
      r,
      i,
      this.curContext,
      this.lookAhead,
      e
    )
  }
  recoverByDelete(e, t) {
    let r = e <= this.p.parser.maxNode
    r && this.storeNode(e, this.pos, t, 4),
      this.storeNode(0, this.pos, t, r ? 8 : 4),
      (this.pos = this.reducePos = t),
      (this.score -= 190)
  }
  canShift(e) {
    for (let t = new HE(this); ; ) {
      let r =
        this.p.parser.stateSlot(t.state, 4) ||
        this.p.parser.hasAction(t.state, e)
      if (r == 0) return !1
      if (!(r & 65536)) return !0
      t.reduce(r)
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300) return []
    let t = this.p.parser.nextStates(this.state)
    if (t.length > 8 || this.stack.length >= 120) {
      let i = []
      for (let s = 0, o; s < t.length; s += 2)
        (o = t[s + 1]) != this.state &&
          this.p.parser.hasAction(o, e) &&
          i.push(t[s], o)
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < t.length; s += 2) {
          let o = t[s + 1]
          i.some((a, l) => l & 1 && a == o) || i.push(t[s], o)
        }
      t = i
    }
    let r = []
    for (let i = 0; i < t.length && r.length < 4; i += 2) {
      let s = t[i + 1]
      if (s == this.state) continue
      let o = this.split()
      o.pushState(s, this.pos),
        o.storeNode(0, o.pos, o.pos, 4, !0),
        o.shiftContext(t[i], this.pos),
        (o.reducePos = this.pos),
        (o.score -= 200),
        r.push(o)
    }
    return r
  }
  forceReduce() {
    let { parser: e } = this.p,
      t = e.stateSlot(this.state, 5)
    if (!(t & 65536)) return !1
    if (!e.validAction(this.state, t)) {
      let r = t >> 19,
        i = t & 65535,
        s = this.stack.length - r * 3
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction()
        if (o == null) return !1
        t = o
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), (this.score -= 100)
    }
    return (this.reducePos = this.pos), this.reduce(t), !0
  }
  findForcedReduction() {
    let { parser: e } = this.p,
      t = [],
      r = (i, s) => {
        if (!t.includes(i))
          return (
            t.push(i),
            e.allActions(i, (o) => {
              if (!(o & 393216))
                if (o & 65536) {
                  let a = (o >> 19) - s
                  if (a > 1) {
                    let l = o & 65535,
                      c = this.stack.length - a * 3
                    if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                      return (a << 19) | 65536 | l
                  }
                } else {
                  let a = r(o, s + 1)
                  if (a != null) return a
                }
            })
          )
      }
    return r(this.state, 0)
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0)
        break
      }
    return this
  }
  get deadEnd() {
    if (this.stack.length != 3) return !1
    let { parser: e } = this.p
    return (
      e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4)
    )
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0),
      (this.state = this.stack[0]),
      (this.stack.length = 0)
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length) return !1
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t]) return !1
    return !0
  }
  get parser() {
    return this.p.parser
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e]
  }
  shiftContext(e, t) {
    this.curContext &&
      this.updateContext(
        this.curContext.tracker.shift(
          this.curContext.context,
          e,
          this,
          this.p.stream.reset(t)
        )
      )
  }
  reduceContext(e, t) {
    this.curContext &&
      this.updateContext(
        this.curContext.tracker.reduce(
          this.curContext.context,
          e,
          this,
          this.p.stream.reset(t)
        )
      )
  }
  emitContext() {
    let e = this.buffer.length - 1
    ;(e < 0 || this.buffer[e] != -3) &&
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
  }
  emitLookAhead() {
    let e = this.buffer.length - 1
    ;(e < 0 || this.buffer[e] != -4) &&
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new WO(this.curContext.tracker, e)
      t.hash != this.curContext.hash && this.emitContext(),
        (this.curContext = t)
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), (this.lookAhead = e))
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(),
      this.lookAhead > 0 && this.emitLookAhead()
  }
}
class WO {
  constructor(e, t) {
    ;(this.tracker = e),
      (this.context = t),
      (this.hash = e.strict ? e.hash(t) : 0)
  }
}
class HE {
  constructor(e) {
    ;(this.start = e),
      (this.state = e.state),
      (this.stack = e.stack),
      (this.base = this.stack.length)
  }
  reduce(e) {
    let t = e & 65535,
      r = e >> 19
    r == 0
      ? (this.stack == this.start.stack && (this.stack = this.stack.slice()),
        this.stack.push(this.state, 0, 0),
        (this.base += 3))
      : (this.base -= (r - 1) * 3)
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0)
    this.state = i
  }
}
class Ba {
  constructor(e, t, r) {
    ;(this.stack = e),
      (this.pos = t),
      (this.index = r),
      (this.buffer = e.buffer),
      this.index == 0 && this.maybeNext()
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Ba(e, t, t - e.bufferBase)
  }
  maybeNext() {
    let e = this.stack.parent
    e != null &&
      ((this.index = this.stack.bufferBase - e.bufferBase),
      (this.stack = e),
      (this.buffer = e.buffer))
  }
  get id() {
    return this.buffer[this.index - 4]
  }
  get start() {
    return this.buffer[this.index - 3]
  }
  get end() {
    return this.buffer[this.index - 2]
  }
  get size() {
    return this.buffer[this.index - 1]
  }
  next() {
    ;(this.index -= 4), (this.pos -= 4), this.index == 0 && this.maybeNext()
  }
  fork() {
    return new Ba(this.stack, this.pos, this.index)
  }
}
function Mi(n, e = Uint16Array) {
  if (typeof n != 'string') return n
  let t = null
  for (let r = 0, i = 0; r < n.length; ) {
    let s = 0
    for (;;) {
      let o = n.charCodeAt(r++),
        a = !1
      if (o == 126) {
        s = 65535
        break
      }
      o >= 92 && o--, o >= 34 && o--
      let l = o - 32
      if ((l >= 46 && ((l -= 46), (a = !0)), (s += l), a)) break
      s *= 46
    }
    t ? (t[i++] = s) : (t = new e(s))
  }
  return t
}
class Bo {
  constructor() {
    ;(this.start = -1),
      (this.value = -1),
      (this.end = -1),
      (this.extended = -1),
      (this.lookAhead = 0),
      (this.mask = 0),
      (this.context = 0)
  }
}
const LO = new Bo()
class KE {
  constructor(e, t) {
    ;(this.input = e),
      (this.ranges = t),
      (this.chunk = ''),
      (this.chunkOff = 0),
      (this.chunk2 = ''),
      (this.chunk2Pos = 0),
      (this.next = -1),
      (this.token = LO),
      (this.rangeIndex = 0),
      (this.pos = this.chunkPos = t[0].from),
      (this.range = t[0]),
      (this.end = t[t.length - 1].to),
      this.readNext()
  }
  resolveOffset(e, t) {
    let r = this.range,
      i = this.rangeIndex,
      s = this.pos + e
    for (; s < r.from; ) {
      if (!i) return null
      let o = this.ranges[--i]
      ;(s -= r.from - o.to), (r = o)
    }
    for (; t < 0 ? s > r.to : s >= r.to; ) {
      if (i == this.ranges.length - 1) return null
      let o = this.ranges[++i]
      ;(s += o.from - r.to), (r = o)
    }
    return s
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to) return e
    for (let t of this.ranges) if (t.to > e) return Math.max(e, t.from)
    return this.end
  }
  peek(e) {
    let t = this.chunkOff + e,
      r,
      i
    if (t >= 0 && t < this.chunk.length)
      (r = this.pos + e), (i = this.chunk.charCodeAt(t))
    else {
      let s = this.resolveOffset(e, 1)
      if (s == null) return -1
      if (
        ((r = s),
        r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
      )
        i = this.chunk2.charCodeAt(r - this.chunk2Pos)
      else {
        let o = this.rangeIndex,
          a = this.range
        for (; a.to <= r; ) a = this.ranges[++o]
        ;(this.chunk2 = this.input.chunk((this.chunk2Pos = r))),
          r + this.chunk2.length > a.to &&
            (this.chunk2 = this.chunk2.slice(0, a.to - r)),
          (i = this.chunk2.charCodeAt(0))
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i
  }
  acceptToken(e, t = 0) {
    let r = t ? this.resolveOffset(t, -1) : this.pos
    if (r == null || r < this.token.start)
      throw new RangeError('Token end out of bounds')
    ;(this.token.value = e), (this.token.end = r)
  }
  getChunk() {
    if (
      this.pos >= this.chunk2Pos &&
      this.pos < this.chunk2Pos + this.chunk2.length
    ) {
      let { chunk: e, chunkPos: t } = this
      ;(this.chunk = this.chunk2),
        (this.chunkPos = this.chunk2Pos),
        (this.chunk2 = e),
        (this.chunk2Pos = t),
        (this.chunkOff = this.pos - this.chunkPos)
    } else {
      ;(this.chunk2 = this.chunk), (this.chunk2Pos = this.chunkPos)
      let e = this.input.chunk(this.pos),
        t = this.pos + e.length
      ;(this.chunk =
        t > this.range.to ? e.slice(0, this.range.to - this.pos) : e),
        (this.chunkPos = this.pos),
        (this.chunkOff = 0)
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length &&
      (this.getChunk(), this.chunkOff == this.chunk.length)
      ? (this.next = -1)
      : (this.next = this.chunk.charCodeAt(this.chunkOff))
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone()
      ;(e -= this.range.to - this.pos),
        (this.range = this.ranges[++this.rangeIndex]),
        (this.pos = this.range.from)
    }
    return (
      (this.pos += e),
      this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1),
      this.readNext()
    )
  }
  setDone() {
    return (
      (this.pos = this.chunkPos = this.end),
      (this.range = this.ranges[(this.rangeIndex = this.ranges.length - 1)]),
      (this.chunk = ''),
      (this.next = -1)
    )
  }
  reset(e, t) {
    if (
      (t
        ? ((this.token = t),
          (t.start = e),
          (t.lookAhead = e + 1),
          (t.value = t.extended = -1))
        : (this.token = LO),
      this.pos != e)
    ) {
      if (((this.pos = e), e == this.end)) return this.setDone(), this
      for (; e < this.range.from; ) this.range = this.ranges[--this.rangeIndex]
      for (; e >= this.range.to; ) this.range = this.ranges[++this.rangeIndex]
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length
        ? (this.chunkOff = e - this.chunkPos)
        : ((this.chunk = ''), (this.chunkOff = 0)),
        this.readNext()
    }
    return this
  }
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos)
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos)
    if (e >= this.range.from && t <= this.range.to) return this.input.read(e, t)
    let r = ''
    for (let i of this.ranges) {
      if (i.from >= t) break
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, t)))
    }
    return r
  }
}
class Lr {
  constructor(e, t) {
    ;(this.data = e), (this.id = t)
  }
  token(e, t) {
    let { parser: r } = t.p
    Gv(this.data, e, t, this.id, r.data, r.tokenPrecTable)
  }
}
Lr.prototype.contextual = Lr.prototype.fallback = Lr.prototype.extend = !1
class Ua {
  constructor(e, t, r) {
    ;(this.precTable = t),
      (this.elseToken = r),
      (this.data = typeof e == 'string' ? Mi(e) : e)
  }
  token(e, t) {
    let r = e.pos,
      i = 0
    for (;;) {
      let s = e.next < 0,
        o = e.resolveOffset(1, 1)
      if (
        (Gv(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
      )
        break
      if (this.elseToken == null) return
      if ((s || i++, o == null)) break
      e.reset(o, e.token)
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i))
  }
}
Ua.prototype.contextual = Lr.prototype.fallback = Lr.prototype.extend = !1
class cn {
  constructor(e, t = {}) {
    ;(this.token = e),
      (this.contextual = !!t.contextual),
      (this.fallback = !!t.fallback),
      (this.extend = !!t.extend)
  }
}
function Gv(n, e, t, r, i, s) {
  let o = 0,
    a = 1 << r,
    { dialect: l } = t.p.parser
  e: for (; a & n[o]; ) {
    let c = n[o + 1]
    for (let d = o + 3; d < c; d += 2)
      if ((n[d + 1] & a) > 0) {
        let O = n[d]
        if (
          l.allows(O) &&
          (e.token.value == -1 ||
            e.token.value == O ||
            JE(O, e.token.value, i, s))
        ) {
          e.acceptToken(O)
          break
        }
      }
    let u = e.next,
      f = 0,
      p = n[o + 2]
    if (e.next < 0 && p > f && n[c + p * 3 - 3] == 65535) {
      o = n[c + p * 3 - 1]
      continue e
    }
    for (; f < p; ) {
      let d = (f + p) >> 1,
        O = c + d + (d << 1),
        g = n[O],
        b = n[O + 1] || 65536
      if (u < g) p = d
      else if (u >= b) f = d + 1
      else {
        ;(o = n[O + 2]), e.advance()
        continue e
      }
    }
    break
  }
}
function BO(n, e, t) {
  for (let r = e, i; (i = n[r]) != 65535; r++) if (i == t) return r - e
  return -1
}
function JE(n, e, t, r) {
  let i = BO(t, r, e)
  return i < 0 || BO(t, r, n) < i
}
const ht =
  typeof process < 'u' && process.env && /\bparse\b/.test(process.env.LOG)
let xc = null
function UO(n, e, t) {
  let r = n.cursor(Oe.IncludeAnonymous)
  for (r.moveTo(e); ; )
    if (!(t < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (;;) {
        if ((t < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return t < 0
            ? Math.max(0, Math.min(r.to - 1, e - 25))
            : Math.min(n.length, Math.max(r.from + 1, e + 25))
        if (t < 0 ? r.prevSibling() : r.nextSibling()) break
        if (!r.parent()) return t < 0 ? 0 : n.length
      }
}
class e2 {
  constructor(e, t) {
    ;(this.fragments = e),
      (this.nodeSet = t),
      (this.i = 0),
      (this.fragment = null),
      (this.safeFrom = -1),
      (this.safeTo = -1),
      (this.trees = []),
      (this.start = []),
      (this.index = []),
      this.nextFragment()
  }
  nextFragment() {
    let e = (this.fragment =
      this.i == this.fragments.length ? null : this.fragments[this.i++])
    if (e) {
      for (
        this.safeFrom = e.openStart
          ? UO(e.tree, e.from + e.offset, 1) - e.offset
          : e.from,
          this.safeTo = e.openEnd
            ? UO(e.tree, e.to + e.offset, -1) - e.offset
            : e.to;
        this.trees.length;

      )
        this.trees.pop(), this.start.pop(), this.index.pop()
      this.trees.push(e.tree),
        this.start.push(-e.offset),
        this.index.push(0),
        (this.nextStart = this.safeFrom)
    } else this.nextStart = 1e9
  }
  nodeAt(e) {
    if (e < this.nextStart) return null
    for (; this.fragment && this.safeTo <= e; ) this.nextFragment()
    if (!this.fragment) return null
    for (;;) {
      let t = this.trees.length - 1
      if (t < 0) return this.nextFragment(), null
      let r = this.trees[t],
        i = this.index[t]
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop()
        continue
      }
      let s = r.children[i],
        o = this.start[t] + r.positions[i]
      if (o > e) return (this.nextStart = o), null
      if (s instanceof Pe) {
        if (o == e) {
          if (o < this.safeFrom) return null
          let a = o + s.length
          if (a <= this.safeTo) {
            let l = s.prop(re.lookAhead)
            if (!l || a + l < this.fragment.to) return s
          }
        }
        this.index[t]++,
          o + s.length >= Math.max(this.safeFrom, e) &&
            (this.trees.push(s), this.start.push(o), this.index.push(0))
      } else this.index[t]++, (this.nextStart = o + s.length)
    }
  }
}
class t2 {
  constructor(e, t) {
    ;(this.stream = t),
      (this.tokens = []),
      (this.mainToken = null),
      (this.actions = []),
      (this.tokens = e.tokenizers.map((r) => new Bo()))
  }
  getActions(e) {
    let t = 0,
      r = null,
      { parser: i } = e.p,
      { tokenizers: s } = i,
      o = i.stateSlot(e.state, 3),
      a = e.curContext ? e.curContext.hash : 0,
      l = 0
    for (let c = 0; c < s.length; c++) {
      if (!((1 << c) & o)) continue
      let u = s[c],
        f = this.tokens[c]
      if (
        !(r && !u.fallback) &&
        ((u.contextual || f.start != e.pos || f.mask != o || f.context != a) &&
          (this.updateCachedToken(f, u, e), (f.mask = o), (f.context = a)),
        f.lookAhead > f.end + 25 && (l = Math.max(f.lookAhead, l)),
        f.value != 0)
      ) {
        let p = t
        if (
          (f.extended > -1 && (t = this.addActions(e, f.extended, f.end, t)),
          (t = this.addActions(e, f.value, f.end, t)),
          !u.extend && ((r = f), t > p))
        )
          break
      }
    }
    for (; this.actions.length > t; ) this.actions.pop()
    return (
      l && e.setLookAhead(l),
      !r &&
        e.pos == this.stream.end &&
        ((r = new Bo()),
        (r.value = e.p.parser.eofTerm),
        (r.start = r.end = e.pos),
        (t = this.addActions(e, r.value, r.end, t))),
      (this.mainToken = r),
      this.actions
    )
  }
  getMainToken(e) {
    if (this.mainToken) return this.mainToken
    let t = new Bo(),
      { pos: r, p: i } = e
    return (
      (t.start = r),
      (t.end = Math.min(r + 1, i.stream.end)),
      (t.value = r == i.stream.end ? i.parser.eofTerm : 0),
      t
    )
  }
  updateCachedToken(e, t, r) {
    let i = this.stream.clipPos(r.pos)
    if ((t.token(this.stream.reset(i, e), r), e.value > -1)) {
      let { parser: s } = r.p
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), r)
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? (e.extended = a >> 1) : (e.value = a >> 1)
            break
          }
        }
    } else (e.value = 0), (e.end = this.stream.clipPos(i + 1))
  }
  putAction(e, t, r, i) {
    for (let s = 0; s < i; s += 3) if (this.actions[s] == e) return i
    return (
      (this.actions[i++] = e),
      (this.actions[i++] = t),
      (this.actions[i++] = r),
      i
    )
  }
  addActions(e, t, r, i) {
    let { state: s } = e,
      { parser: o } = e.p,
      { data: a } = o
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(s, l ? 2 : 1); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1) c = gn(a, c + 2)
          else {
            i == 0 &&
              a[c + 1] == 2 &&
              (i = this.putAction(gn(a, c + 2), t, r, i))
            break
          }
        a[c] == t && (i = this.putAction(gn(a, c + 1), t, r, i))
      }
    return i
  }
}
class n2 {
  constructor(e, t, r, i) {
    ;(this.parser = e),
      (this.input = t),
      (this.ranges = i),
      (this.recovering = 0),
      (this.nextStackID = 9812),
      (this.minStackPos = 0),
      (this.reused = []),
      (this.stoppedAt = null),
      (this.lastBigReductionStart = -1),
      (this.lastBigReductionSize = 0),
      (this.bigReductionCount = 0),
      (this.stream = new KE(t, i)),
      (this.tokens = new t2(e, this.stream)),
      (this.topTerm = e.top[1])
    let { from: s } = i[0]
    ;(this.stacks = [La.start(this, e.top[0], s)]),
      (this.fragments =
        r.length && this.stream.end - s > e.bufferLength * 4
          ? new e2(r, e.nodeSet)
          : null)
  }
  get parsedPos() {
    return this.minStackPos
  }
  advance() {
    let e = this.stacks,
      t = this.minStackPos,
      r = (this.stacks = []),
      i,
      s
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e
      for (
        ;
        o.forceReduce() &&
        o.stack.length &&
        o.stack[o.stack.length - 2] >= this.lastBigReductionStart;

      );
      this.bigReductionCount = this.lastBigReductionSize = 0
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o]
      for (;;) {
        if (((this.tokens.mainToken = null), a.pos > t)) r.push(a)
        else {
          if (this.advanceStack(a, r, e)) continue
          {
            i || ((i = []), (s = [])), i.push(a)
            let l = this.tokens.getMainToken(a)
            s.push(l.value, l.end)
          }
        }
        break
      }
    }
    if (!r.length) {
      let o = i && i2(i)
      if (o)
        return (
          ht && console.log('Finish with ' + this.stackID(o)),
          this.stackToTree(o)
        )
      if (this.parser.strict)
        throw (
          (ht &&
            i &&
            console.log(
              'Stuck with token ' +
                (this.tokens.mainToken
                  ? this.parser.getName(this.tokens.mainToken.value)
                  : 'none')
            ),
          new SyntaxError('No parse at ' + t))
        )
      this.recovering || (this.recovering = 5)
    }
    if (this.recovering && i) {
      let o =
        this.stoppedAt != null && i[0].pos > this.stoppedAt
          ? i[0]
          : this.runRecovery(i, s, r)
      if (o)
        return (
          ht && console.log('Force-finish ' + this.stackID(o)),
          this.stackToTree(o.forceAll())
        )
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3
      if (r.length > o)
        for (r.sort((a, l) => l.score - a.score); r.length > o; ) r.pop()
      r.some((a) => a.reducePos > t) && this.recovering--
    } else if (r.length > 1) {
      e: for (let o = 0; o < r.length - 1; o++) {
        let a = r[o]
        for (let l = o + 1; l < r.length; l++) {
          let c = r[l]
          if (
            a.sameState(c) ||
            (a.buffer.length > 500 && c.buffer.length > 500)
          )
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              r.splice(l--, 1)
            else {
              r.splice(o--, 1)
              continue e
            }
        }
      }
      r.length > 12 && r.splice(12, r.length - 12)
    }
    this.minStackPos = r[0].pos
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos)
    return null
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward")
    this.stoppedAt = e
  }
  advanceStack(e, t, r) {
    let i = e.pos,
      { parser: s } = this,
      o = ht ? this.stackID(e) + ' -> ' : ''
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict,
        u = c ? e.curContext.hash : 0
      for (let f = this.fragments.nodeAt(i); f; ) {
        let p =
          this.parser.nodeSet.types[f.type.id] == f.type
            ? s.getGoto(e.state, f.type.id)
            : -1
        if (p > -1 && f.length && (!c || (f.prop(re.contextHash) || 0) == u))
          return (
            e.useNode(f, p),
            ht &&
              console.log(
                o + this.stackID(e) + ` (via reuse of ${s.getName(f.type.id)})`
              ),
            !0
          )
        if (!(f instanceof Pe) || f.children.length == 0 || f.positions[0] > 0)
          break
        let d = f.children[0]
        if (d instanceof Pe && f.positions[0] == 0) f = d
        else break
      }
    }
    let a = s.stateSlot(e.state, 4)
    if (a > 0)
      return (
        e.reduce(a),
        ht &&
          console.log(
            o + this.stackID(e) + ` (via always-reduce ${s.getName(a & 65535)})`
          ),
        !0
      )
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); );
    let l = this.tokens.getActions(e)
    for (let c = 0; c < l.length; ) {
      let u = l[c++],
        f = l[c++],
        p = l[c++],
        d = c == l.length || !r,
        O = d ? e : e.split(),
        g = this.tokens.mainToken
      if (
        (O.apply(u, f, g ? g.start : O.pos, p),
        ht &&
          console.log(
            o +
              this.stackID(O) +
              ` (via ${
                u & 65536 ? `reduce of ${s.getName(u & 65535)}` : 'shift'
              } for ${s.getName(f)} @ ${i}${O == e ? '' : ', split'})`
          ),
        d)
      )
        return !0
      O.pos > i ? t.push(O) : r.push(O)
    }
    return !1
  }
  advanceFully(e, t) {
    let r = e.pos
    for (;;) {
      if (!this.advanceStack(e, null, null)) return !1
      if (e.pos > r) return qO(e, t), !0
    }
  }
  runRecovery(e, t, r) {
    let i = null,
      s = !1
    for (let o = 0; o < e.length; o++) {
      let a = e[o],
        l = t[o << 1],
        c = t[(o << 1) + 1],
        u = ht ? this.stackID(a) + ' -> ' : ''
      if (
        a.deadEnd &&
        (s ||
          ((s = !0),
          a.restart(),
          ht && console.log(u + this.stackID(a) + ' (restarted)'),
          this.advanceFully(a, r)))
      )
        continue
      let f = a.split(),
        p = u
      for (
        let d = 0;
        f.forceReduce() &&
        d < 10 &&
        (ht && console.log(p + this.stackID(f) + ' (via force-reduce)'),
        !this.advanceFully(f, r));
        d++
      )
        ht && (p = this.stackID(f) + ' -> ')
      for (let d of a.recoverByInsert(l))
        ht && console.log(u + this.stackID(d) + ' (via recover-insert)'),
          this.advanceFully(d, r)
      this.stream.end > a.pos
        ? (c == a.pos && (c++, (l = 0)),
          a.recoverByDelete(l, c),
          ht &&
            console.log(
              u +
                this.stackID(a) +
                ` (via recover-delete ${this.parser.getName(l)})`
            ),
          qO(a, r))
        : (!i || i.score < a.score) && (i = a)
    }
    return i
  }
  stackToTree(e) {
    return (
      e.close(),
      Pe.build({
        buffer: Ba.create(e),
        nodeSet: this.parser.nodeSet,
        topID: this.topTerm,
        maxBufferLength: this.parser.bufferLength,
        reused: this.reused,
        start: this.ranges[0].from,
        length: e.pos - this.ranges[0].from,
        minRepeatType: this.parser.minRepeatTerm
      })
    )
  }
  stackID(e) {
    let t = (xc || (xc = new WeakMap())).get(e)
    return t || xc.set(e, (t = String.fromCodePoint(this.nextStackID++))), t + e
  }
}
function qO(n, e) {
  for (let t = 0; t < e.length; t++) {
    let r = e[t]
    if (r.pos == n.pos && r.sameState(n)) {
      e[t].score < n.score && (e[t] = n)
      return
    }
  }
  e.push(n)
}
class r2 {
  constructor(e, t, r) {
    ;(this.source = e), (this.flags = t), (this.disabled = r)
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0
  }
}
const wc = (n) => n
class Hv {
  constructor(e) {
    ;(this.start = e.start),
      (this.shift = e.shift || wc),
      (this.reduce = e.reduce || wc),
      (this.reuse = e.reuse || wc),
      (this.hash = e.hash || (() => 0)),
      (this.strict = e.strict !== !1)
  }
}
class ni extends wb {
  constructor(e) {
    if ((super(), (this.wrappers = []), e.version != 14))
      throw new RangeError(
        `Parser version (${e.version}) doesn't match runtime version (14)`
      )
    let t = e.nodeNames.split(' ')
    this.minRepeatTerm = t.length
    for (let a = 0; a < e.repeatNodeCount; a++) t.push('')
    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]),
      i = []
    for (let a = 0; a < t.length; a++) i.push([])
    function s(a, l, c) {
      i[a].push([l, l.deserialize(String(c))])
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0]
        typeof l == 'string' && (l = re[l])
        for (let c = 1; c < a.length; ) {
          let u = a[c++]
          if (u >= 0) s(u, l, a[c++])
          else {
            let f = a[c + -u]
            for (let p = -u; p > 0; p--) s(a[c++], l, f)
            c++
          }
        }
      }
    ;(this.nodeSet = new Mf(
      t.map((a, l) =>
        it.define({
          name: l >= this.minRepeatTerm ? void 0 : a,
          id: l,
          props: i[l],
          top: r.indexOf(l) > -1,
          error: l == 0,
          skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
        })
      )
    )),
      e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
      (this.strict = !1),
      (this.bufferLength = yb)
    let o = Mi(e.tokenData)
    ;(this.context = e.context),
      (this.specializerSpecs = e.specialized || []),
      (this.specialized = new Uint16Array(this.specializerSpecs.length))
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term
    ;(this.specializers = this.specializerSpecs.map(zO)),
      (this.states = Mi(e.states, Uint32Array)),
      (this.data = Mi(e.stateData)),
      (this.goto = Mi(e.goto)),
      (this.maxTerm = e.maxTerm),
      (this.tokenizers = e.tokenizers.map((a) =>
        typeof a == 'number' ? new Lr(o, a) : a
      )),
      (this.topRules = e.topRules),
      (this.dialects = e.dialects || {}),
      (this.dynamicPrecedences = e.dynamicPrecedences || null),
      (this.tokenPrecTable = e.tokenPrec),
      (this.termNames = e.termNames || null),
      (this.maxNode = this.nodeSet.types.length - 1),
      (this.dialect = this.parseDialect()),
      (this.top = this.topRules[Object.keys(this.topRules)[0]])
  }
  createParse(e, t, r) {
    let i = new n2(this, e, t, r)
    for (let s of this.wrappers) i = s(i, e, t, r)
    return i
  }
  getGoto(e, t, r = !1) {
    let i = this.goto
    if (t >= i[0]) return -1
    for (let s = i[t + 1]; ; ) {
      let o = i[s++],
        a = o & 1,
        l = i[s++]
      if (a && r) return l
      for (let c = s + (o >> 1); s < c; s++) if (i[s] == e) return l
      if (a) return -1
    }
  }
  hasAction(e, t) {
    let r = this.data
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(e, i ? 2 : 1), o; ; s += 3) {
        if ((o = r[s]) == 65535)
          if (r[s + 1] == 1) o = r[(s = gn(r, s + 2))]
          else {
            if (r[s + 1] == 2) return gn(r, s + 2)
            break
          }
        if (o == t || o == 0) return gn(r, s + 1)
      }
    return 0
  }
  stateSlot(e, t) {
    return this.states[e * 6 + t]
  }
  stateFlag(e, t) {
    return (this.stateSlot(e, 0) & t) > 0
  }
  validAction(e, t) {
    return !!this.allActions(e, (r) => (r == t ? !0 : null))
  }
  allActions(e, t) {
    let r = this.stateSlot(e, 4),
      i = r ? t(r) : void 0
    for (let s = this.stateSlot(e, 1); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1) s = gn(this.data, s + 2)
        else break
      i = t(gn(this.data, s + 1))
    }
    return i
  }
  nextStates(e) {
    let t = []
    for (let r = this.stateSlot(e, 1); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1) r = gn(this.data, r + 2)
        else break
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1]
        t.some((s, o) => o & 1 && s == i) || t.push(this.data[r], i)
      }
    }
    return t
  }
  configure(e) {
    let t = Object.assign(Object.create(ni.prototype), this)
    if ((e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top)) {
      let r = this.topRules[e.top]
      if (!r) throw new RangeError(`Invalid top rule name ${e.top}`)
      t.top = r
    }
    return (
      e.tokenizers &&
        (t.tokenizers = this.tokenizers.map((r) => {
          let i = e.tokenizers.find((s) => s.from == r)
          return i ? i.to : r
        })),
      e.specializers &&
        ((t.specializers = this.specializers.slice()),
        (t.specializerSpecs = this.specializerSpecs.map((r, i) => {
          let s = e.specializers.find((a) => a.from == r.external)
          if (!s) return r
          let o = Object.assign(Object.assign({}, r), { external: s.to })
          return (t.specializers[i] = zO(o)), o
        }))),
      e.contextTracker && (t.context = e.contextTracker),
      e.dialect && (t.dialect = this.parseDialect(e.dialect)),
      e.strict != null && (t.strict = e.strict),
      e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)),
      e.bufferLength != null && (t.bufferLength = e.bufferLength),
      t
    )
  }
  hasWrappers() {
    return this.wrappers.length > 0
  }
  getName(e) {
    return this.termNames
      ? this.termNames[e]
      : String((e <= this.maxNode && this.nodeSet.types[e].name) || e)
  }
  get eofTerm() {
    return this.maxNode + 1
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]]
  }
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences
    return t == null ? 0 : t[e] || 0
  }
  parseDialect(e) {
    let t = Object.keys(this.dialects),
      r = t.map(() => !1)
    if (e)
      for (let s of e.split(' ')) {
        let o = t.indexOf(s)
        o >= 0 && (r[o] = !0)
      }
    let i = null
    for (let s = 0; s < t.length; s++)
      if (!r[s])
        for (let o = this.dialects[t[s]], a; (a = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1
    return new r2(e, r, i)
  }
  static deserialize(e) {
    return new ni(e)
  }
}
function gn(n, e) {
  return n[e] | (n[e + 1] << 16)
}
function i2(n) {
  let e = null
  for (let t of n) {
    let r = t.p.stoppedAt
    ;(t.pos == t.p.stream.end || (r != null && t.pos > r)) &&
      t.p.parser.stateFlag(t.state, 2) &&
      (!e || e.score < t.score) &&
      (e = t)
  }
  return e
}
function zO(n) {
  if (n.external) {
    let e = n.extend ? 1 : 0
    return (t, r) => (n.external(t, r) << 1) | e
  }
  return n.get
}
const s2 = 304,
  FO = 1,
  o2 = 2,
  a2 = 305,
  l2 = 307,
  c2 = 308,
  u2 = 3,
  f2 = 4,
  h2 = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,
    8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288
  ],
  Kv = 125,
  p2 = 59,
  GO = 47,
  d2 = 42,
  O2 = 43,
  m2 = 45,
  g2 = new Hv({
    start: !1,
    shift(n, e) {
      return e == u2 || e == f2 || e == l2 ? n : e == c2
    },
    strict: !1
  }),
  y2 = new cn(
    (n, e) => {
      let { next: t } = n
      ;(t == Kv || t == -1 || e.context) && n.acceptToken(a2)
    },
    { contextual: !0, fallback: !0 }
  ),
  b2 = new cn(
    (n, e) => {
      let { next: t } = n,
        r
      h2.indexOf(t) > -1 ||
        (t == GO && ((r = n.peek(1)) == GO || r == d2)) ||
        (t != Kv && t != p2 && t != -1 && !e.context && n.acceptToken(s2))
    },
    { contextual: !0 }
  ),
  v2 = new cn(
    (n, e) => {
      let { next: t } = n
      if ((t == O2 || t == m2) && (n.advance(), t == n.next)) {
        n.advance()
        let r = !e.context && e.canShift(FO)
        n.acceptToken(r ? FO : o2)
      }
    },
    { contextual: !0 }
  ),
  S2 = vl({
    'get set async static': m.modifier,
    'for while do if else switch try catch finally return throw break continue default case':
      m.controlKeyword,
    'in of await yield void typeof delete instanceof': m.operatorKeyword,
    'let var const using function class extends': m.definitionKeyword,
    'import export from': m.moduleKeyword,
    'with debugger as new': m.keyword,
    TemplateString: m.special(m.string),
    super: m.atom,
    BooleanLiteral: m.bool,
    this: m.self,
    null: m.null,
    Star: m.modifier,
    VariableName: m.variableName,
    'CallExpression/VariableName TaggedTemplateExpression/VariableName':
      m.function(m.variableName),
    VariableDefinition: m.definition(m.variableName),
    Label: m.labelName,
    PropertyName: m.propertyName,
    PrivatePropertyName: m.special(m.propertyName),
    'CallExpression/MemberExpression/PropertyName': m.function(m.propertyName),
    'FunctionDeclaration/VariableDefinition': m.function(
      m.definition(m.variableName)
    ),
    'ClassDeclaration/VariableDefinition': m.definition(m.className),
    PropertyDefinition: m.definition(m.propertyName),
    PrivatePropertyDefinition: m.definition(m.special(m.propertyName)),
    UpdateOp: m.updateOperator,
    'LineComment Hashbang': m.lineComment,
    BlockComment: m.blockComment,
    Number: m.number,
    String: m.string,
    Escape: m.escape,
    ArithOp: m.arithmeticOperator,
    LogicOp: m.logicOperator,
    BitOp: m.bitwiseOperator,
    CompareOp: m.compareOperator,
    RegExp: m.regexp,
    Equals: m.definitionOperator,
    Arrow: m.function(m.punctuation),
    ': Spread': m.punctuation,
    '( )': m.paren,
    '[ ]': m.squareBracket,
    '{ }': m.brace,
    'InterpolationStart InterpolationEnd': m.special(m.brace),
    '.': m.derefOperator,
    ', ;': m.separator,
    '@': m.meta,
    TypeName: m.typeName,
    TypeDefinition: m.definition(m.typeName),
    'type enum interface implements namespace module declare':
      m.definitionKeyword,
    'abstract global Privacy readonly override': m.modifier,
    'is keyof unique infer': m.operatorKeyword,
    JSXAttributeValue: m.attributeValue,
    JSXText: m.content,
    'JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag': m.angleBracket,
    'JSXIdentifier JSXNameSpacedName': m.tagName,
    'JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName':
      m.attributeName,
    'JSXBuiltin/JSXIdentifier': m.standard(m.tagName)
  }),
  x2 = {
    __proto__: null,
    export: 16,
    as: 21,
    from: 29,
    default: 32,
    async: 37,
    function: 38,
    extends: 48,
    this: 52,
    true: 60,
    false: 60,
    null: 72,
    void: 76,
    typeof: 80,
    super: 98,
    new: 132,
    delete: 148,
    yield: 157,
    await: 161,
    class: 166,
    public: 223,
    private: 223,
    protected: 223,
    readonly: 225,
    instanceof: 244,
    satisfies: 247,
    in: 248,
    const: 250,
    import: 282,
    keyof: 337,
    unique: 341,
    infer: 347,
    is: 383,
    abstract: 403,
    implements: 405,
    type: 407,
    let: 410,
    var: 412,
    using: 415,
    interface: 421,
    enum: 425,
    namespace: 431,
    module: 433,
    declare: 437,
    global: 441,
    for: 460,
    of: 469,
    while: 472,
    with: 476,
    do: 480,
    if: 484,
    else: 486,
    switch: 490,
    case: 496,
    try: 502,
    catch: 506,
    finally: 510,
    return: 514,
    throw: 518,
    break: 522,
    continue: 526,
    debugger: 530
  },
  w2 = {
    __proto__: null,
    async: 119,
    get: 121,
    set: 123,
    declare: 183,
    public: 185,
    private: 185,
    protected: 185,
    static: 187,
    abstract: 189,
    override: 191,
    readonly: 197,
    accessor: 199,
    new: 387
  },
  P2 = { __proto__: null, '<': 139 },
  T2 = ni.deserialize({
    version: 14,
    states:
      "$6zO%TQUOOO%[QUOOO'_QWOOP(lOSOOO*zQ(CjO'#CgO+ROpO'#ChO+aO!bO'#ChO+oO07`O'#D[O.QQUO'#DbO.bQUO'#DmO%[QUO'#DwO0fQUO'#EPOOQ(CY'#EX'#EXO1PQSO'#EUOOQO'#Ej'#EjOOQO'#Id'#IdO1XQSO'#GlO1dQSO'#EiO1iQSO'#EiO3kQ(CjO'#JeO6[Q(CjO'#JfO6xQSO'#FXO6}Q#tO'#FpOOQ(CY'#Fa'#FaO7YO&jO'#FaO7hQ,UO'#FwO9OQSO'#FvOOQ(CY'#Jf'#JfOOQ(CW'#Je'#JeO9TQSO'#GpOOQQ'#KQ'#KQO9`QSO'#IQO9eQ(C[O'#IROOQQ'#JR'#JROOQQ'#IV'#IVQ`QUOOO`QUOOO%[QUO'#DoO9mQUO'#D{O9tQUO'#D}O9ZQSO'#GlO9{Q,UO'#CmO:ZQSO'#EhO:fQSO'#EsO:kQ,UO'#F`O;YQSO'#GlOOQO'#KR'#KRO;_QSO'#KRO;mQSO'#GtO;mQSO'#GuO;mQSO'#GwO9ZQSO'#GzO<dQSO'#G}O={QSO'#CcO>]QSO'#HZO>eQSO'#HaO>eQSO'#HcO`QUO'#HeO>eQSO'#HgO>eQSO'#HjO>jQSO'#HpO>oQ(C]O'#HvO%[QUO'#HxO>zQ(C]O'#HzO?VQ(C]O'#H|O9eQ(C[O'#IOO?bQ(CjO'#CgO@dQWO'#DgQOQSOOO%[QUO'#D}O@zQSO'#EQO9{Q,UO'#EhOAVQSO'#EhOAbQ`O'#F`OOQQ'#Ce'#CeOOQ(CW'#Dl'#DlOOQ(CW'#Ji'#JiO%[QUO'#JiOOQO'#Jm'#JmOOQO'#Ia'#IaOBbQWO'#EaOOQ(CW'#E`'#E`OC^Q(C`O'#EaOChQWO'#ETOOQO'#Jl'#JlOC|QWO'#JmOEZQWO'#ETOChQWO'#EaPEhO?MpO'#C`POOO)CDp)CDpOOOO'#IW'#IWOEsOpO,59SOOQ(CY,59S,59SOOOO'#IX'#IXOFRO!bO,59SO%[QUO'#D^OOOO'#IZ'#IZOFaO07`O,59vOOQ(CY,59v,59vOFoQUO'#I[OGSQSO'#JgOIUQbO'#JgO+}QUO'#JgOI]QSO,59|OIsQSO'#EjOJQQSO'#JuOJ]QSO'#JtOJ]QSO'#JtOJeQSO,5;WOJjQSO'#JsOOQ(CY,5:X,5:XOJqQUO,5:XOLrQ(CjO,5:cOMcQSO,5:kOM|Q(C[O'#JrONTQSO'#JqO9TQSO'#JqONiQSO'#JqONqQSO,5;VONvQSO'#JqO!#OQbO'#JfOOQ(CY'#Cg'#CgO%[QUO'#EPO!#nQ`O,5:pOOQO'#Jn'#JnOOQO-E<b-E<bO9ZQSO,5=WO!$UQSO,5=WO!$ZQUO,5;TO!&^Q,UO'#EeO!'qQSO,5;TO!)ZQ,UO'#DqO!)bQUO'#DvO!)lQWO,5;^O!)tQWO,5;^O%[QUO,5;^OOQQ'#FP'#FPOOQQ'#FR'#FRO%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_O%[QUO,5;_OOQQ'#FV'#FVO!*SQUO,5;pOOQ(CY,5;u,5;uOOQ(CY,5;v,5;vO!,VQSO,5;vOOQ(CY,5;w,5;wO%[QUO'#IhO!,_Q(C[O,5<dO!&^Q,UO,5;_O!,|Q,UO,5;_O%[QUO,5;sO!-TQ#tO'#FfO!.QQ#tO'#JyO!-lQ#tO'#JyO!.XQ#tO'#JyOOQO'#Jy'#JyO!.mQ#tO,5<OOOOO,5<[,5<[O!/OQUO'#FrOOOO'#Ig'#IgO7YO&jO,5;{O!/VQ#tO'#FtOOQ(CY,5;{,5;{O!/vQ7[O'#CsOOQ(CY'#Cw'#CwO!0ZQSO'#CwO!0`O07`O'#C{O!0|Q,UO,5<aO!1TQSO,5<cO!2jQMhO'#GRO!2wQSO'#GSO!2|QSO'#GSO!3RQMhO'#GWO!4QQWO'#G[O!4sQ7[O'#J`OOQ(CY'#J`'#J`O!4}QSO'#J_O!5]QSO'#J^O!5eQSO'#CrOOQ(CY'#Cu'#CuOOQ(CY'#DP'#DPOOQ(CY'#DR'#DRO1SQSO'#DTO!'vQ,UO'#FyO!'vQ,UO'#F{O!5mQSO'#F}O!5rQSO'#GOO!2|QSO'#GUO!'vQ,UO'#GZO!5wQSO'#EkO!6fQSO,5<bOOQ(CW'#Cp'#CpO!6nQSO'#ElO!7hQWO'#EmOOQ(CW'#Js'#JsO!7oQ(C[O'#KSO9eQ(C[O,5=[O`QUO,5>lOOQQ'#JZ'#JZOOQQ,5>m,5>mOOQQ-E<T-E<TO!9qQ(CjO,5:ZO!<_Q(CjO,5:gO%[QUO,5:gO!>xQ(CjO,5:iOOQO,5@m,5@mO!?iQ,UO,5=WO!?wQ(C[O'#J[O9OQSO'#J[O!@YQ(C[O,59XO!@eQWO,59XO!@mQ,UO,59XO9{Q,UO,59XO!@xQSO,5;TO!AQQSO'#HYO!AfQSO'#KVO%[QUO,5;xO!7cQWO,5;zO!AnQSO,5=sO!AsQSO,5=sO!AxQSO,5=sO9eQ(C[O,5=sO;mQSO,5=cOOQO'#Cs'#CsO!BWQWO,5=`O!B`Q,UO,5=aO!BkQSO,5=cO!BpQ`O,5=fO!BxQSO'#KRO>jQSO'#HPO9ZQSO'#HRO!B}QSO'#HRO9{Q,UO'#HTO!CSQSO'#HTOOQQ,5=i,5=iO!CXQSO'#HUO!CjQSO'#CmO!CoQSO,58}O!CyQSO,58}O!FOQUO,58}OOQQ,58},58}O!F`Q(C[O,58}O%[QUO,58}O!HkQUO'#H]OOQQ'#H^'#H^OOQQ'#H_'#H_O`QUO,5=uO!IRQSO,5=uO`QUO,5={O`QUO,5=}O!IWQSO,5>PO`QUO,5>RO!I]QSO,5>UO!IbQUO,5>[OOQQ,5>b,5>bO%[QUO,5>bO9eQ(C[O,5>dOOQQ,5>f,5>fO!MlQSO,5>fOOQQ,5>h,5>hO!MlQSO,5>hOOQQ,5>j,5>jO!MqQWO'#DYO%[QUO'#JiO!N`QWO'#JiO!N}QWO'#DhO# `QWO'#DhO##qQUO'#DhO##xQSO'#JhO#$QQSO,5:RO#$VQSO'#EnO#$eQSO'#JvO#$mQSO,5;XO#$rQWO'#DhO#%PQWO'#ESOOQ(CY,5:l,5:lO%[QUO,5:lO#%WQSO,5:lO>jQSO,5;SO!@eQWO,5;SO!@mQ,UO,5;SO9{Q,UO,5;SO#%`QSO,5@TO#%eQ!LQO,5:pOOQO-E<_-E<_O#&kQ(C`O,5:{OChQWO,5:oO#&uQWO,5:oOChQWO,5:{O!@YQ(C[O,5:oOOQ(CW'#Ed'#EdOOQO,5:{,5:{O%[QUO,5:{O#'SQ(C[O,5:{O#'_Q(C[O,5:{O!@eQWO,5:oOOQO,5;R,5;RO#'mQ(C[O,5:{POOO'#IU'#IUP#(RO?MpO,58zPOOO,58z,58zOOOO-E<U-E<UOOQ(CY1G.n1G.nOOOO-E<V-E<VO#(^Q`O,59xOOOO-E<X-E<XOOQ(CY1G/b1G/bO#(cQbO,5>vO+}QUO,5>vOOQO,5>|,5>|O#(mQUO'#I[OOQO-E<Y-E<YO#(zQSO,5@RO#)SQbO,5@RO#)ZQSO,5@`OOQ(CY1G/h1G/hO%[QUO,5@aO#)cQSO'#IbOOQO-E<`-E<`O#)ZQSO,5@`OOQ(CW1G0r1G0rOOQ(CY1G/s1G/sOOQ(CY1G0V1G0VO%[QUO,5@^O#)wQ(C[O,5@^O#*YQ(C[O,5@^O#*aQSO,5@]O9TQSO,5@]O#*iQSO,5@]O#*wQSO'#IeO#*aQSO,5@]OOQ(CW1G0q1G0qO!)lQWO,5:rO!)wQWO,5:rOOQO,5:t,5:tO#+iQSO,5:tO#+qQ,UO1G2rO9ZQSO1G2rOOQ(CY1G0o1G0oO#,PQ(CjO1G0oO#-UQ(ChO,5;POOQ(CY'#GQ'#GQO#-rQ(CjO'#J`O!$ZQUO1G0oO#/zQ,UO'#JjO#0UQSO,5:]O#0ZQbO'#JkO%[QUO'#JkO#0eQSO,5:bOOQ(CY'#DY'#DYOOQ(CY1G0x1G0xO%[QUO1G0xOOQ(CY1G1b1G1bO#0jQSO1G0xO#3RQ(CjO1G0yO#3YQ(CjO1G0yO#5sQ(CjO1G0yO#5zQ(CjO1G0yO#8UQ(CjO1G0yO#8lQ(CjO1G0yO#;fQ(CjO1G0yO#;mQ(CjO1G0yO#>WQ(CjO1G0yO#>_Q(CjO1G0yO#@VQ(CjO1G0yO#CVQ$IUO'#CgO#ETQ$IUO1G1[O#E[Q$IUO'#JfO!,YQSO1G1bO#ElQ(CjO,5?SOOQ(CW-E<f-E<fO#F`Q(CjO1G0yOOQ(CY1G0y1G0yO#HkQ(CjO1G1_O#I_Q#tO,5<SO#IgQ#tO,5<TO#IoQ#tO'#FkO#JWQSO'#FjOOQO'#Jz'#JzOOQO'#If'#IfO#J]Q#tO1G1jOOQ(CY1G1j1G1jOOOO1G1u1G1uO#JnQ$IUO'#JeO#JxQSO,5<^O!*SQUO,5<^OOOO-E<e-E<eOOQ(CY1G1g1G1gO#J}QWO'#JyOOQ(CY,5<`,5<`O#KVQWO,5<`OOQ(CY,59c,59cO!&^Q,UO'#C}OOOO'#IY'#IYO#K[O07`O,59gOOQ(CY,59g,59gO%[QUO1G1{O!5rQSO'#IjO#KgQ,UO,5<tOOQ(CY,5<q,5<qOOQO'#Gg'#GgO!'vQ,UO,5=QOOQO'#Gi'#GiO!'vQ,UO,5=SO!&^Q,UO,5=UOOQO1G1}1G1}O#KnQ`O'#CpO#LRQ`O,5<mO#LYQSO'#J}O9ZQSO'#J}O#LhQSO,5<oO!'vQ,UO,5<nO#LmQSO'#GTO#LxQSO,5<nO#L}Q`O'#GQO#M[Q`O'#KOO#MfQSO'#KOO!&^Q,UO'#KOO#MkQSO,5<rO#MpQWO'#G]O!3{QWO'#G]O#NRQSO'#G_O#NWQSO'#GaO!2|QSO'#GdO#N]Q(C[O'#IlO#NhQWO,5<vOOQ(CY,5<v,5<vO#NoQWO'#G]O#N}QWO'#G^O$ VQWO'#G^OOQ(CY,5=V,5=VO!'vQ,UO,5?yO!'vQ,UO,5?yO$ [QSO'#ImO$ gQSO,5?xO$ oQSO,59^O$!`Q,UO,59oOOQ(CY,59o,59oO$#RQ,UO,5<eO$#tQ,UO,5<gO@[QSO,5<iOOQ(CY,5<j,5<jO$$OQSO,5<pO$$TQ,UO,5<uO$$eQSO'#JqO!$ZQUO1G1|O$$jQSO1G1|O9TQSO'#JtO9TQSO'#EnO%[QUO'#EnO9TQSO'#IoO$$oQ(C[O,5@nOOQQ1G2v1G2vOOQQ1G4W1G4WOOQ(CY1G/u1G/uO!,VQSO1G/uO$&tQ(CjO1G0ROOQQ1G2r1G2rO!&^Q,UO1G2rO%[QUO1G2rO$'eQSO1G2rO$'pQ,UO'#EeOOQ(CW,5?v,5?vO$'zQ(C[O,5?vOOQQ1G.s1G.sO!@YQ(C[O1G.sO!@eQWO1G.sO!@mQ,UO1G.sO$(]QSO1G0oO$(bQSO'#CgO$(mQSO'#KWO$(uQSO,5=tO$(zQSO'#KWO$)PQSO'#KWO$)_QSO'#IuO$)mQSO,5@qO$)uQbO1G1dOOQ(CY1G1f1G1fO9ZQSO1G3_O@[QSO1G3_O$)|QSO1G3_O$*RQSO1G3_OOQQ1G3_1G3_O!BkQSO1G2}O!&^Q,UO1G2zO$*WQSO1G2zOOQQ1G2{1G2{O!&^Q,UO1G2{O$*]QSO1G2{O$*eQWO'#GyOOQQ1G2}1G2}O!3{QWO'#IqO!BpQ`O1G3QOOQQ1G3Q1G3QOOQQ,5=k,5=kO$*mQ,UO,5=mO9ZQSO,5=mO#NWQSO,5=oO9OQSO,5=oO!@eQWO,5=oO!@mQ,UO,5=oO9{Q,UO,5=oO$*{QSO'#KUO$+WQSO,5=pOOQQ1G.i1G.iO$+]Q(C[O1G.iO@[QSO1G.iO$+hQSO1G.iO9eQ(C[O1G.iO$-mQbO,5@sO$-}QSO,5@sO9TQSO,5@sO$.YQUO,5=wO$.aQSO,5=wOOQQ1G3a1G3aO`QUO1G3aOOQQ1G3g1G3gOOQQ1G3i1G3iO>eQSO1G3kO$.fQUO1G3mO$2jQUO'#HlOOQQ1G3p1G3pO$2wQSO'#HrO>jQSO'#HtOOQQ1G3v1G3vO$3PQUO1G3vO9eQ(C[O1G3|OOQQ1G4O1G4OOOQ(CW'#GX'#GXO9eQ(C[O1G4QO9eQ(C[O1G4SO$7WQSO,5@TO!*SQUO,5;YO9TQSO,5;YO>jQSO,5:SO!*SQUO,5:SO!@eQWO,5:SO$7]Q$IUO,5:SOOQO,5;Y,5;YO$7gQWO'#I]O$7}QSO,5@SOOQ(CY1G/m1G/mO$8VQWO'#IcO$8aQSO,5@bOOQ(CW1G0s1G0sO# `QWO,5:SOOQO'#I`'#I`O$8iQWO,5:nOOQ(CY,5:n,5:nO#%ZQSO1G0WOOQ(CY1G0W1G0WO%[QUO1G0WOOQ(CY1G0n1G0nO>jQSO1G0nO!@eQWO1G0nO!@mQ,UO1G0nOOQ(CW1G5o1G5oO!@YQ(C[O1G0ZOOQO1G0g1G0gO%[QUO1G0gO$8pQ(C[O1G0gO$8{Q(C[O1G0gO!@eQWO1G0ZOChQWO1G0ZO$9ZQ(C[O1G0gOOQO1G0Z1G0ZO$9oQ(CjO1G0gPOOO-E<S-E<SPOOO1G.f1G.fOOOO1G/d1G/dO$9yQ`O,5<dO$:RQbO1G4bOOQO1G4h1G4hO%[QUO,5>vO$:]QSO1G5mO$:eQSO1G5zO$:mQbO1G5{O9TQSO,5>|O$:wQ(CjO1G5xO%[QUO1G5xO$;XQ(C[O1G5xO$;jQSO1G5wO$;jQSO1G5wO9TQSO1G5wO$;rQSO,5?PO9TQSO,5?POOQO,5?P,5?PO$<WQSO,5?PO$$eQSO,5?POOQO-E<c-E<cOOQO1G0^1G0^OOQO1G0`1G0`O!,YQSO1G0`OOQQ7+(^7+(^O!&^Q,UO7+(^O%[QUO7+(^O$<fQSO7+(^O$<qQ,UO7+(^O$=PQ(CjO,59oO$?XQ(CjO,5<eO$AdQ(CjO,5<gO$CoQ(CjO,5<uOOQ(CY7+&Z7+&ZO$FQQ(CjO7+&ZO$FtQ,UO'#I^O$GOQSO,5@UOOQ(CY1G/w1G/wO$GWQUO'#I_O$GeQSO,5@VO$GmQbO,5@VOOQ(CY1G/|1G/|O$GwQSO7+&dOOQ(CY7+&d7+&dO$G|Q$IUO,5:cO%[QUO7+&vO$HWQ$IUO,5:ZO$HeQ$IUO,5:gO$HoQ$IUO,5:iOOQ(CY7+&|7+&|OOQO1G1n1G1nOOQO1G1o1G1oO$HyQ#tO,5<VO!*SQUO,5<UOOQO-E<d-E<dOOQ(CY7+'U7+'UOOOO7+'a7+'aOOOO1G1x1G1xO$IUQSO1G1xOOQ(CY1G1z1G1zO$IZQ`O,59iOOOO-E<W-E<WOOQ(CY1G/R1G/RO$IbQ(CjO7+'gOOQ(CY,5?U,5?UO$JUQ`O,5?UOOQ(CY1G2`1G2`P!&^Q,UO'#IjPOQ(CY-E<h-E<hO$JtQ,UO1G2lO$KgQ,UO1G2nO$KqQ`O1G2pOOQ(CY1G2X1G2XO$KxQSO'#IiO$LWQSO,5@iO$LWQSO,5@iO$L`QSO,5@iO$LkQSO,5@iOOQO1G2Z1G2ZO$LyQ,UO1G2YO!'vQ,UO1G2YO$MZQMhO'#IkO$MkQSO,5@jO!&^Q,UO,5@jO$MsQ`O,5@jOOQ(CY1G2^1G2^OOQ(CW,5<w,5<wOOQ(CW,5<x,5<xO$$eQSO,5<xOCXQSO,5<xO!@eQWO,5<wOOQO'#G`'#G`O$M}QSO,5<yOOQ(CW,5<{,5<{O$$eQSO,5=OOOQO,5?W,5?WOOQO-E<j-E<jOOQ(CY1G2b1G2bO!3{QWO,5<wO$NVQSO,5<xO#NRQSO,5<yO!3{QWO,5<xO$NbQ,UO1G5eO$NlQ,UO1G5eOOQO,5?X,5?XOOQO-E<k-E<kOOQO1G.x1G.xO!7cQWO,59qO%[QUO,59qO$NyQSO1G2TO!'vQ,UO1G2[O% OQ(CjO7+'hOOQ(CY7+'h7+'hO!$ZQUO7+'hO% rQSO,5;YOOQ(CW,5?Z,5?ZOOQ(CW-E<m-E<mOOQ(CY7+%a7+%aO% wQ`O'#KPO#%ZQSO7+(^O%!RQbO7+(^O$<iQSO7+(^O%!YQ(ChO'#CgO%!mQ(ChO,5<|O%#_QSO,5<|OOQ(CW1G5b1G5bOOQQ7+$_7+$_O!@YQ(C[O7+$_O!@eQWO7+$_O!$ZQUO7+&ZO%#dQSO'#ItO%#{QSO,5@rOOQO1G3`1G3`O9ZQSO,5@rO%#{QSO,5@rO%$TQSO,5@rOOQO,5?a,5?aOOQO-E<s-E<sOOQ(CY7+'O7+'OO%$YQSO7+(yO9eQ(C[O7+(yO9ZQSO7+(yO@[QSO7+(yOOQQ7+(i7+(iO%$_Q(ChO7+(fO!&^Q,UO7+(fO%$iQ`O7+(gOOQQ7+(g7+(gO!&^Q,UO7+(gO%$pQSO'#KTO%${QSO,5=eOOQO,5?],5?]OOQO-E<o-E<oOOQQ7+(l7+(lO%&[QWO'#HSOOQQ1G3X1G3XO!&^Q,UO1G3XO%[QUO1G3XO%&cQSO1G3XO%&nQ,UO1G3XO9eQ(C[O1G3ZO#NWQSO1G3ZO9OQSO1G3ZO!@eQWO1G3ZO!@mQ,UO1G3ZO%&|QSO'#IsO%'bQSO,5@pO%'jQWO,5@pOOQ(CW1G3[1G3[OOQQ7+$T7+$TO@[QSO7+$TO9eQ(C[O7+$TO%'uQSO7+$TO%[QUO1G6_O%[QUO1G6`O%'zQ(C[O1G6_O%(UQUO1G3cO%(]QSO1G3cO%(bQUO1G3cOOQQ7+({7+({O9eQ(C[O7+)VO`QUO7+)XOOQQ'#KZ'#KZOOQQ'#Iv'#IvO%(iQUO,5>WOOQQ,5>W,5>WO%[QUO'#HmO%(vQSO'#HoOOQQ,5>^,5>^O9TQSO,5>^OOQQ,5>`,5>`OOQQ7+)b7+)bOOQQ7+)h7+)hOOQQ7+)l7+)lOOQQ7+)n7+)nO%({QWO1G5oO%)aQ$IUO1G0tO%)kQSO1G0tOOQO1G/n1G/nO%)vQ$IUO1G/nO>jQSO1G/nO!*SQUO'#DhOOQO,5>w,5>wOOQO-E<Z-E<ZOOQO,5>},5>}OOQO-E<a-E<aO!@eQWO1G/nOOQO-E<^-E<^OOQ(CY1G0Y1G0YOOQ(CY7+%r7+%rO#%ZQSO7+%rOOQ(CY7+&Y7+&YO>jQSO7+&YO!@eQWO7+&YOOQO7+%u7+%uO$9oQ(CjO7+&ROOQO7+&R7+&RO%[QUO7+&RO%*QQ(C[O7+&RO!@YQ(C[O7+%uO!@eQWO7+%uO%*]Q(C[O7+&RO%*kQ(CjO7++dO%[QUO7++dO%*{QSO7++cO%*{QSO7++cOOQO1G4k1G4kO9TQSO1G4kO%+TQSO1G4kOOQO7+%z7+%zO#%ZQSO<<KxO%!RQbO<<KxO%+cQSO<<KxOOQQ<<Kx<<KxO!&^Q,UO<<KxO%[QUO<<KxO%+kQSO<<KxO%+vQ(CjO1G2lO%.RQ(CjO1G2nO%0^Q(CjO1G2YO%2oQ,UO,5>xOOQO-E<[-E<[O%2yQbO,5>yO%[QUO,5>yOOQO-E<]-E<]O%3TQSO1G5qOOQ(CY<<JO<<JOO%3]Q$IUO1G0oO%5gQ$IUO1G0yO%5nQ$IUO1G0yO%7rQ$IUO1G0yO%7yQ$IUO1G0yO%9nQ$IUO1G0yO%:UQ$IUO1G0yO%<iQ$IUO1G0yO%<pQ$IUO1G0yO%>tQ$IUO1G0yO%>{Q$IUO1G0yO%@sQ$IUO1G0yO%AWQ(CjO<<JbO%B]Q$IUO1G0yO%DRQ$IUO'#J`O%FUQ$IUO1G1_O%FcQ$IUO1G0RO!*SQUO'#FmOOQO'#J{'#J{OOQO1G1q1G1qO%FmQSO1G1pO%FrQ$IUO,5?SOOOO7+'d7+'dOOOO1G/T1G/TOOQ(CY1G4p1G4pO!'vQ,UO7+([O%F|QSO,5?TO9ZQSO,5?TOOQO-E<g-E<gO%G[QSO1G6TO%G[QSO1G6TO%GdQSO1G6TO%GoQ,UO7+'tO%HPQ`O,5?VO%HZQSO,5?VO!&^Q,UO,5?VOOQO-E<i-E<iO%H`Q`O1G6UO%HjQSO1G6UOOQ(CW1G2d1G2dO$$eQSO1G2dOOQ(CW1G2c1G2cO%HrQSO1G2eO!&^Q,UO1G2eOOQ(CW1G2j1G2jO!@eQWO1G2cOCXQSO1G2dO%HwQSO1G2eO%IPQSO1G2dO!'vQ,UO7++POOQ(CY1G/]1G/]O%I[QSO1G/]OOQ(CY7+'o7+'oO%IaQ,UO7+'vO%IqQ(CjO<<KSOOQ(CY<<KS<<KSO%JeQSO1G0tO!&^Q,UO'#InO%JjQSO,5@kO!&^Q,UO1G2hOOQQ<<Gy<<GyO!@YQ(C[O<<GyO%JrQ(CjO<<IuOOQ(CY<<Iu<<IuOOQO,5?`,5?`O%KfQSO,5?`O%KkQSO,5?`OOQO-E<r-E<rO%KyQSO1G6^O%KyQSO1G6^O9ZQSO1G6^O@[QSO<<LeOOQQ<<Le<<LeO%LRQSO<<LeO9eQ(C[O<<LeOOQQ<<LQ<<LQO%$_Q(ChO<<LQOOQQ<<LR<<LRO%$iQ`O<<LRO%LWQWO'#IpO%LcQSO,5@oO!*SQUO,5@oOOQQ1G3P1G3PO%LkQUO'#JiOOQO'#Ir'#IrO9eQ(C[O'#IrO%LuQWO,5=nOOQQ,5=n,5=nO%L|QWO'#EaO%MbQSO7+(sO%MgQSO7+(sOOQQ7+(s7+(sO!&^Q,UO7+(sO%[QUO7+(sO%MoQSO7+(sOOQQ7+(u7+(uO9eQ(C[O7+(uO#NWQSO7+(uO9OQSO7+(uO!@eQWO7+(uO%MzQSO,5?_OOQO-E<q-E<qOOQO'#HV'#HVO%NVQSO1G6[O9eQ(C[O<<GoOOQQ<<Go<<GoO@[QSO<<GoO%N_QSO7++yO%NdQSO7++zO%[QUO7++yO%[QUO7++zOOQQ7+(}7+(}O%NiQSO7+(}O%NnQUO7+(}O%NuQSO7+(}OOQQ<<Lq<<LqOOQQ<<Ls<<LsOOQQ-E<t-E<tOOQQ1G3r1G3rO%NzQSO,5>XOOQQ,5>Z,5>ZO& PQSO1G3xO9TQSO7+&`O!*SQUO7+&`OOQO7+%Y7+%YO& UQ$IUO1G5{O>jQSO7+%YOOQ(CY<<I^<<I^OOQ(CY<<It<<ItO>jQSO<<ItOOQO<<Im<<ImO$9oQ(CjO<<ImO%[QUO<<ImOOQO<<Ia<<IaO!@YQ(C[O<<IaO& `Q(C[O<<ImO& kQ(CjO<= OO& {QSO<<N}OOQO7+*V7+*VO9TQSO7+*VOOQQANAdANAdO&!TQSOANAdO!&^Q,UOANAdO#%ZQSOANAdO%!RQbOANAdO%[QUOANAdO&!]Q(CjO7+'tO&$nQ(CjO7+'vO&'PQbO1G4eO&'ZQ$IUO7+&ZO&'hQ$IUO,59oO&)kQ$IUO,5<eO&+nQ$IUO,5<gO&-qQ$IUO,5<uO&/gQ$IUO7+'gO&/tQ$IUO7+'hO&0RQSO,5<XOOQO7+'[7+'[O&0WQ,UO<<KvOOQO1G4o1G4oO&0_QSO1G4oO&0jQSO1G4oO&0xQSO7++oO&0xQSO7++oO!&^Q,UO1G4qO&1QQ`O1G4qO&1[QSO7++pOOQ(CW7+(O7+(OO$$eQSO7+(PO&1dQ`O7+(POOQ(CW7+'}7+'}O$$eQSO7+(OO&1kQSO7+(PO!&^Q,UO7+(POCXQSO7+(OO&1pQ,UO<<NkOOQ(CY7+$w7+$wO&1zQ`O,5?YOOQO-E<l-E<lO&2UQ(ChO7+(SOOQQAN=eAN=eO9ZQSO1G4zOOQO1G4z1G4zO&2fQSO1G4zO&2kQSO7++xO&2kQSO7++xO9eQ(C[OANBPO@[QSOANBPOOQQANBPANBPOOQQANAlANAlOOQQANAmANAmO&2sQSO,5?[OOQO-E<n-E<nO&3OQ$IUO1G6ZO&5`QbO'#CgOOQO,5?^,5?^OOQO-E<p-E<pOOQQ1G3Y1G3YO%LkQUO,5<yOOQQ<<L_<<L_O!&^Q,UO<<L_O%MbQSO<<L_O&5jQSO<<L_O%[QUO<<L_OOQQ<<La<<LaO9eQ(C[O<<LaO#NWQSO<<LaO9OQSO<<LaO&5rQWO1G4yO&5}QSO7++vOOQQAN=ZAN=ZO9eQ(C[OAN=ZOOQQ<= e<= eOOQQ<= f<= fO&6VQSO<= eO&6[QSO<= fOOQQ<<Li<<LiO&6aQSO<<LiO&6fQUO<<LiOOQQ1G3s1G3sO>jQSO7+)dO&6mQSO<<IzO&6xQ$IUO<<IzOOQO<<Ht<<HtOOQ(CYAN?`AN?`OOQOAN?XAN?XO$9oQ(CjOAN?XOOQOAN>{AN>{O%[QUOAN?XOOQO<<Mq<<MqOOQQG27OG27OO!&^Q,UOG27OO#%ZQSOG27OO&7SQSOG27OO%!RQbOG27OO&7[Q$IUO<<JbO&7iQ$IUO1G2YO&9_Q$IUO1G2lO&;bQ$IUO1G2nO&=eQ$IUO<<KSO&=rQ$IUO<<IuOOQO1G1s1G1sO!'vQ,UOANAbOOQO7+*Z7+*ZO&>PQSO7+*ZO&>[QSO<= ZO&>dQ`O7+*]OOQ(CW<<Kk<<KkO$$eQSO<<KkOOQ(CW<<Kj<<KjO&>nQ`O<<KkO$$eQSO<<KjOOQO7+*f7+*fO9ZQSO7+*fO&>uQSO<= dOOQQG27kG27kO9eQ(C[OG27kO!*SQUO1G4vO&>}QSO7++uO%MbQSOANAyOOQQANAyANAyO!&^Q,UOANAyO&?VQSOANAyOOQQANA{ANA{O9eQ(C[OANA{O#NWQSOANA{OOQO'#HW'#HWOOQO7+*e7+*eOOQQG22uG22uOOQQANEPANEPOOQQANEQANEQOOQQANBTANBTO&?_QSOANBTOOQQ<<MO<<MOO!*SQUOAN?fOOQOG24sG24sO$9oQ(CjOG24sO#%ZQSOLD,jOOQQLD,jLD,jO!&^Q,UOLD,jO&?dQSOLD,jO&?lQ$IUO7+'tO&AbQ$IUO7+'vO&CWQ,UOG26|OOQO<<Mu<<MuOOQ(CWANAVANAVO$$eQSOANAVOOQ(CWANAUANAUOOQO<<NQ<<NQOOQQLD-VLD-VO&ChQ$IUO7+*bOOQQG27eG27eO%MbQSOG27eO!&^Q,UOG27eOOQQG27gG27gO9eQ(C[OG27gOOQQG27oG27oO&CrQ$IUOG25QOOQOLD*_LD*_OOQQ!$(!U!$(!UO#%ZQSO!$(!UO!&^Q,UO!$(!UO&C|Q(CjOG26|OOQ(CWG26qG26qOOQQLD-PLD-PO%MbQSOLD-POOQQLD-RLD-ROOQQ!)9Ep!)9EpO#%ZQSO!)9EpOOQQ!$(!k!$(!kOOQQ!.K;[!.K;[O&F_Q$IUOG26|O!*SQUO'#DwO1PQSO'#EUO&HTQbO'#JeO!*SQUO'#DoO&H[QUO'#D{O&HcQbO'#CgO&JyQbO'#CgO!*SQUO'#D}O&KZQUO,5;TO!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO,5;_O!*SQUO'#IhO&M^QSO,5<dO&MfQ,UO,5;_O&NyQ,UO,5;_O!*SQUO,5;sO1SQSO'#DTO1SQSO'#DTO!&^Q,UO'#FyO&MfQ,UO'#FyO!&^Q,UO'#F{O&MfQ,UO'#F{O!&^Q,UO'#GZO&MfQ,UO'#GZO!*SQUO,5:gO!*SQUO,5@aO&KZQUO1G0oO' QQ$IUO'#CgO!*SQUO1G1{O!&^Q,UO,5=QO&MfQ,UO,5=QO!&^Q,UO,5=SO&MfQ,UO,5=SO!&^Q,UO,5<nO&MfQ,UO,5<nO&KZQUO1G1|O!*SQUO7+&vO!&^Q,UO1G2YO&MfQ,UO1G2YO!&^Q,UO1G2[O&MfQ,UO1G2[O&KZQUO7+'hO&KZQUO7+&ZO!&^Q,UOANAbO&MfQ,UOANAbO' [QSO'#EiO' aQSO'#EiO' iQSO'#FXO' nQSO'#EsO' sQSO'#JuO'!OQSO'#JsO'!ZQSO,5;TO'!`Q,UO,5<aO'!gQSO'#GSO'!lQSO'#GSO'!qQSO,5<bO'!yQSO,5;TO'#RQ$IUO1G1[O'#YQSO,5<nO'#_QSO,5<nO'#dQSO,5<pO'#iQSO,5<pO'#nQSO1G1|O'#sQSO1G0oO'#xQ,UO<<KvO'$PQ,UO<<KvO7hQ,UO'#FwO9OQSO'#FvOAVQSO'#EhO!*SQUO,5;pO!2|QSO'#GSO!2|QSO'#GSO!2|QSO'#GUO!2|QSO'#GUO!'vQ,UO7+([O!'vQ,UO7+([O$KqQ`O1G2pO$KqQ`O1G2pO!&^Q,UO,5=UO!&^Q,UO,5=U",
    stateData:
      "'%Y~O'oOS'pOSROS'qRQ~OPYOQYOW!VO_qObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#q!PO$R|O$VfO%a}O%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO&O!WO&U!XO&W!YO&Y!ZO&[![O&_!]O&e!^O&k!_O&m!`O&o!aO&q!bO&s!cO'vSO'xTO'{UO(TVO(c[O(piO~OUtO~P`OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~O_!vOm!nO}!oO!]!xO!^!uO!_!uO!y9rO!}!pO#O!pO#P!wO#Q!pO#R!pO#U!yO#V!yO'w!lO'xTO'{UO(W!mO(c!sO~O'q!zO~OPZXYZX_ZXlZXzZX{ZX}ZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX'mZX(TZX(dZX(kZX(lZX~O!b${X~P(qO]!|O'x#OO'y!|O'z#OO~O]#PO'z#OO'{#OO'|#PO~Or#RO!P#SO(U#SO(V#UO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v9vO'xTO'{UO(TVO(c[O(piO~O!V#YO!W#VO!T(ZP!T(hP~P+}O!X#bO~P`OPYOQYOb!jOc!iOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'xTO'{UO(TVO(c[O(piO~Oj#lO!V#hO!y]O#c#kO#d#hO'v9wO!h(eP~P.iO!i#nO'v#mO~O!u#rO!y]O%a#sO~O#e#tO~O!b#uO#e#tO~OP$]OY$dOl$QOz#yO{#zO}#{O!W$aO!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O_(XX'm(XX'k(XX!h(XX!T(XX!Y(XX%b(XX!b(XX~P1qO#Y$eO#|$eOP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#p(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX!Y(YX%b(YX~O_(YX!g(YX'm(YX'k(YX!T(YX!h(YXp(YX!b(YX~P4XO#Y$eO~O$X$gO$Z$fO$b$lO~O!Y$mO$VfO$e$nO$g$pO~Oj%SOl$tOm$sOn$sOt%TOv%UOx%VO}${O!Y$|O!d%[O!i$xO#d%]O$R%YO$n%WO$p%XO$s%ZO'v$rO'xTO'{UO(P%RO(T$uOe(QP~O!i%^O~O}%aO!Y%bO'v%`O~O!b%fO~O_%gO'm%gO~O'w!lO~P%[O%g%nO~P%[O!i%^O'v%`O'w!lO(P%RO~Oc%uO!i%^O'v%`O~O#p$SO~Oz%zO!Y%wO!i%yO%c%}O'v%`O'w!lO'xTO'{UO^(yP~O!u#rO~O%l&PO}(uX!Y(uX'v(uX~O'v&QO~O!r&VO#q!PO%c!QO%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO~Ob&[Oc&ZO!u&XO%a&YO%t&WO~P;rOb&_OcyO!Y&^O!r&VO!uxO!y]O#q!PO%a}O%e!OO%f!OO%g!OO%j!RO%l!SO%o!TO%p!TO%r!UO~O`&bO#Y&eO%c&`O'w!lO~P<wO!i&fO!r&jO~O!i#nO~O!YXO~O_%gO'l&rO'm%gO~O_%gO'l&uO'm%gO~O_%gO'l&wO'm%gO~O'kZX!TZXpZX!hZX&SZX!YZX%bZX!bZX~P(qO!]'UO!^&}O!_&}O'w!lO'xTO'{UO~Om&{O}&zO!V'OO(W&yO!X([P!X(jP~P@OOh'XO!Y'VO'v%`O~Oc'^O!i%^O'v%`O~Oz%zO!i%yO~Om!nO}!oO!y9rO!}!pO#O!pO#Q!pO#R!pO'w!lO'xTO'{UO(W!mO(c!sO~O!]'dO!^'cO!_'cO#P!pO#U'eO#V'eO~PAjO_%gO!b#uO!i%^O'm%gO(P%RO(d'gO~O!m'kO#Y'iO~PBxOm!nO}!oO'xTO'{UO(W!mO(c!sO~O!YXOm(aX}(aX!](aX!^(aX!_(aX!y(aX!}(aX#O(aX#P(aX#Q(aX#R(aX#U(aX#V(aX'w(aX'x(aX'{(aX(W(aX(c(aX~O!^'cO!_'cO'w!lO~PChO'r'oO's'oO't'qO~O]!|O'x'sO'y!|O'z'sO~O]#PO'z'sO'{'sO'|#PO~Or#RO!P#SO(U#SO(V'wO~O!V'yO!T'OX!T'UX!W'OX!W'UX~P+}O!W'{O!T(ZX~OP$]OY$dOl$QOz#yO{#zO}#{O!W'{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O!T(ZX~PG[O!T(QO~O!T(gX!W(gX!b(gX!h(gX(d(gX~O#Y(gX#e#^X!X(gX~PIbO#Y(RO!T(iX!W(iX~O!W(SO!T(hX~O!T(VO~O#Y$eO~PIbO!X(WO~P`Oz#yO{#zO}#{O!g#wO!i#xO(TVOP!kaY!kal!ka!W!ka!f!ka!m!ka#h!ka#i!ka#j!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#r!ka#t!ka#v!ka#w!ka(d!ka(k!ka(l!ka~O_!ka'm!ka'k!ka!T!ka!h!kap!ka!Y!ka%b!ka!b!ka~PJxO!h(XO~O!b#uO#Y(YO(d'gO!W(fX_(fX'm(fX~O!h(fX~PMhO}%aO!Y%bO!y]O#c(_O#d(^O'v%`O~O!W(`O!h(eX~O!h(bO~O}%aO!Y%bO#d(^O'v%`O~OP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!g(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#p(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX~O!b#uO!h(YX~P! UOz(cO{(dO!g#wO!i#xO!y!xa}!xa~O!u!xa%a!xa!Y!xa#c!xa#d!xa'v!xa~P!#YO!u(hO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!YXO!duO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~Oj%SOl$tOm$sOn$sOt%TOv%UOx:[O}${O!Y$|O!d;fO!i$xO#d:bO$R%YO$n:^O$p:`O$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~O#e(nO~Oj%SOl$tOm$sOn$sOt%TOv%UOx%VO}${O!Y$|O!d%[O!i$xO#d%]O$R%YO$n%WO$p%XO$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~Oe(^P~P!'vO!V(rO!h(_P~P%[O(W(tO(c[O~O}(vO!i#xO(W(tO(c[O~OP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!Y!eO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'v)UO'xTO'{UO(TVO(c[O(p;`O~O{)XO!i#xO~O!W$aO_$la'm$la'k$la!h$la!T$la!Y$la%b$la!b$la~O#q)]O~P!&^Oz)`O!b)_O!Y$YX$U$YX$X$YX$Z$YX$b$YX~O!b)_O!Y(mX$U(mX$X(mX$Z(mX$b(mX~Oz)`O~P!-lOz)`O!Y(mX$U(mX$X(mX$Z(mX$b(mX~O!Y)bO$U)fO$X)aO$Z)aO$b)gO~O!V)jO~P!*SO$X$gO$Z$fO$b)nO~Oh$tXz$tX}$tX!g$tX(k$tX(l$tX~OegXe$tXhgX!WgX#YgX~P!/bOm)pO~Or)qO(U)rO(V)tO~Oh)}Oz)vO})wO(k)yO(l){O~Oe)uO~P!0kOe*OO~Oj%SOl$tOm$sOn$sOt%TOv%UOx:[O}${O!Y$|O!d;fO!i$xO#d:bO$R%YO$n:^O$p:`O$s%ZO'xTO'{UO(P%RO(T$uO~O!V*SO'v*PO!h(qP~P!1YO#e*UO~O!i*VO~O!V*[O'v*XO!T(rP~P!1YOl*hO}*`O!]*fO!^*_O!_*_O!i*VO#U*gO%X*bO'w!lO(W!mO~O!X*eO~P!3`O!g#wOh(SXz(SX}(SX(k(SX(l(SX!W(SX#Y(SX~Oe(SX#z(SX~P!4XOh*kO#Y*jOe(RX!W(RX~O!W*lOe(QX~O'v&QOe(QP~O!i*sO~O'v(lO~Oj*wO}%aO!V#hO!Y%bO!y]O#c#kO#d#hO'v%`O!h(eP~O!b#uO#e*xO~O}%aO!V*zO!W(SO!Y%bO'v%`O!T(hP~Om'RO}*|O!V*{O'xTO'{UO(W(tO~O!X(jP~P!7SO!W*}O_(vX'm(vX~OP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO#w$YO(TVO(d$ZO(k#|O(l#}O~O_!ca!W!ca'm!ca'k!ca!T!ca!h!cap!ca!Y!ca%b!ca!b!ca~P!7zOz#yO{#zO}#{O!g#wO!i#xO(TVOP!oaY!oal!oa!W!oa!f!oa!m!oa#h!oa#i!oa#j!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#r!oa#t!oa#v!oa#w!oa(d!oa(k!oa(l!oa~O_!oa'm!oa'k!oa!T!oa!h!oap!oa!Y!oa%b!oa!b!oa~P!:eOz#yO{#zO}#{O!g#wO!i#xO(TVOP!qaY!qal!qa!W!qa!f!qa!m!qa#h!qa#i!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#r!qa#t!qa#v!qa#w!qa(d!qa(k!qa(l!qa~O_!qa'm!qa'k!qa!T!qa!h!qap!qa!Y!qa%b!qa!b!qa~P!=OOh+WO!Y'VO%b+VO(P%RO~O!b+YO_(OX!Y(OX'm(OX!W(OX~O_%gO!YXO'm%gO~O!i%^O(P%RO~O!i%^O'v%`O(P%RO~O!b#uO#e(nO~O`+eO%c+fO'v+bO'xTO'{UO!X(zP~O!W+gO^(yX~OY+kO~O^+lO~O!Y%wO'v%`O'w!lO^(yP~O#Y+qO(P%RO~Oh+tO!Y$|O(P%RO~O!Y+vO~Oz+xO!YXO~O%g%nO~O!u+}O~Oc,SO~O`,TO'v#mO'xTO'{UO!X(xP~Oc%uO~O%c!QO'v&QO~P<wOY,YO^,XO~OPYOQYObzOcyOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!duO!iZO!lYO!mYO!nYO!pvO!uxO!y]O$VfO%a}O'xTO'{UO(TVO(c[O(piO~O!Y!eO!r!gO$R!kO'v!dO~P!DRO^,XO_%gO'm%gO~OPYOQYOb!jOc!iOjkOlYOmkOnkOtkOvYOxYO}WO!RkO!SkO!Y!eO!duO!iZO!lYO!mYO!nYO!pvO!u!hO$R!kO$VfO'v!dO'xTO'{UO(TVO(c[O(piO~O_,_O!rwO#q!OO%e!OO%f!OO%g!OO~P!FkO!i&fO~O&U,eO~O!Y,gO~O&g,iO&i,jOP&daQ&daW&da_&dab&dac&daj&dal&dam&dan&dat&dav&dax&da}&da!R&da!S&da!Y&da!d&da!i&da!l&da!m&da!n&da!p&da!r&da!u&da!y&da#q&da$R&da$V&da%a&da%c&da%e&da%f&da%g&da%j&da%l&da%o&da%p&da%r&da&O&da&U&da&W&da&Y&da&[&da&_&da&e&da&k&da&m&da&o&da&q&da&s&da'k&da'v&da'x&da'{&da(T&da(c&da(p&da!X&da&]&da`&da&b&da~O'v,oO~O!W|X!W!`X!X|X!X!`X!b|X!b!`X!i!`X#Y|X(P!`X~O!b,tO#Y,sO!W#bX!W(]X!X#bX!X(]X!b(]X!i(]X(P(]X~O!b,vO!i%^O(P%RO!W![X!X![X~Om!nO}!oO'xTO'{UO(W!mO~OP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!Y!eO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'xTO'{UO(TVO(c[O(p;`O~O'v:gO~P# qO!W,zO!X([X~O!X,|O~O!b,tO#Y,sO!W#bX!X#bX~O!W,}O!X(jX~O!X-PO~O!^-QO!_-QO'w!lO~P# `O!X-TO~P'_Oh-WO!Y'VO~O!T-]O~Om!xa!]!xa!^!xa!_!xa!}!xa#O!xa#P!xa#Q!xa#R!xa#U!xa#V!xa'w!xa'x!xa'{!xa(W!xa(c!xa~P!#YO!m-bO#Y-`O~PBxO!^-dO!_-dO'w!lO~PChO_%gO#Y-`O'm%gO~O_%gO!b#uO#Y-`O'm%gO~O_%gO!b#uO!m-bO#Y-`O'm%gO(d'gO~O'r'oO's'oO't-iO~Op-jO~O!T'Oa!W'Oa~P!7zO!V-nO!T'OX!W'OX~P%[O!W'{O!T(Za~O!T(Za~PG[O!W(SO!T(ha~O}%aO!V-rO!Y%bO'v%`O!T'UX!W'UX~O#Y-tO!W(fa!h(fa_(fa'm(fa~O!b#uO~P#)wO!W(`O!h(ea~O}%aO!Y%bO#d-xO'v%`O~Oj-}O}%aO!V-zO!Y%bO!y]O#c-|O#d-zO'v%`O!W'XX!h'XX~O{.RO!i#xO~Oh.UO!Y'VO%b.TO(P%RO~O_#]i!W#]i'm#]i'k#]i!T#]i!h#]ip#]i!Y#]i%b#]i!b#]i~P!7zOh;lOz)vO})wO(k)yO(l){O~O#e#Xa_#Xa#Y#Xa'm#Xa!W#Xa!h#Xa!Y#Xa!T#Xa~P#,sO#e(SXP(SXY(SX_(SXl(SX{(SX!f(SX!i(SX!m(SX#h(SX#i(SX#j(SX#k(SX#l(SX#m(SX#n(SX#o(SX#p(SX#r(SX#t(SX#v(SX#w(SX'm(SX(T(SX(d(SX!h(SX!T(SX'k(SXp(SX!Y(SX%b(SX!b(SX~P!4XO!W._Oe(^X~P!0kOe.aO~O!W.bO!h(_X~P!7zO!h.eO~O!T.gO~OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(TVOY#gi_#gil#gi!W#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O#h#gi~P#0oO#h$OO~P#0oOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO(TVOY#gi_#gi!W#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~Ol#gi~P#3aOl$QO~P#3aOP$]Ol$QOz#yO{#zO}#{O!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO(TVO_#gi!W#gi#r#gi#t#gi#v#gi#w#gi'm#gi(d#gi(k#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P#6ROY$dO!f$SO#m$SO#n$SO#o$cO#p$SO~P#6ROP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO(TVO_#gi!W#gi#t#gi#v#gi#w#gi'm#gi(d#gi(l#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(k#gi~P#9SO(k#|O~P#9SOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO(TVO(k#|O_#gi!W#gi#v#gi#w#gi'm#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~O(l#gi~P#;tO(l#}O~P#;tOP$]OY$dOl$QOz#yO{#zO}#{O!f$SO!g#wO!i#xO!m$]O#h$OO#i$PO#j$PO#k$PO#l$RO#m$SO#n$SO#o$cO#p$SO#r$TO#t$VO#v$XO(TVO(k#|O(l#}O~O_#gi!W#gi#w#gi'm#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#>fOPZXYZXlZXzZX{ZX}ZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX!WZX!XZX~O#zZX~P#APOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO#v:TO#w:UO(TVO(d$ZO(k#|O(l#}O~O#z.iO~P#C^O#Y:ZO#|:ZO#z(YX!X(YX~P! UO_'[a!W'[a'm'[a'k'[a!h'[a!T'[ap'[a!Y'[a%b'[a!b'[a~P!7zOP#giY#gi_#gil#gi{#gi!W#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi'm#gi(T#gi(d#gi'k#gi!T#gi!h#gip#gi!Y#gi%b#gi!b#gi~P#,sO_#{i!W#{i'm#{i'k#{i!T#{i!h#{ip#{i!Y#{i%b#{i!b#{i~P!7zO$X.nO$Z.nO~O$X.oO$Z.oO~O!b)_O#Y.pO!Y$_X$U$_X$X$_X$Z$_X$b$_X~O!V.qO~O!Y)bO$U.sO$X)aO$Z)aO$b.tO~O!W:VO!X(XX~P#C^O!X.uO~O!b)_O$b(mX~O$b.wO~Or)qO(U)rO(V.zO~O!T/OO~P!&^O!WdX!bdX!hdX!h$tX(ddX~P!/bO!h/UO~P#,sO!W/VO!b#uO(d'gO!h(qX~O!h/[O~O!V*SO'v%`O!h(qP~O#e/^O~O!T$tX!W$tX!b${X~P!/bO!W/_O!T(rX~P#,sO!b/aO~O!T/cO~Ol/gO!b#uO!i%^O(P%RO(d'gO~O'v/iO~O!b+YO~O_%gO!W/mO'm%gO~O!X/oO~P!3`O!^/pO!_/pO'w!lO(W!mO~O}/rO(W!mO~O#U/sO~O'v&QOe'aX!W'aX~O!W*lOe(Qa~Oe/xO~Oz/yO{/yO}/zOhwa(kwa(lwa!Wwa#Ywa~Oewa#zwa~P$ tOz)vO})wOh$ma(k$ma(l$ma!W$ma#Y$ma~Oe$ma#z$ma~P$!jOz)vO})wOh$oa(k$oa(l$oa!W$oa#Y$oa~Oe$oa#z$oa~P$#]O#e/|O~Oe$}a!W$}a#Y$}a#z$}a~P!0kO!b#uO~O#e0PO~O!W*}O_(va'm(va~Oz#yO{#zO}#{O!g#wO!i#xO(TVOP!oiY!oil!oi!W!oi!f!oi!m!oi#h!oi#i!oi#j!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#r!oi#t!oi#v!oi#w!oi(d!oi(k!oi(l!oi~O_!oi'm!oi'k!oi!T!oi!h!oip!oi!Y!oi%b!oi!b!oi~P$$zOh.UO!Y'VO%b.TO~Oj0ZO'v0YO~P!1]O!b+YO_(Oa!Y(Oa'm(Oa!W(Oa~O#e0aO~OYZX!WdX!XdX~O!W0bO!X(zX~O!X0dO~OY0eO~O`0gO'v+bO'xTO'{UO~O!Y%wO'v%`O^'iX!W'iX~O!W+gO^(ya~O!h0jO~P!7zOY0mO~O^0nO~O#Y0qO~Oh0tO!Y$|O~O(W(tO!X(wP~Oh0}O!Y0zO%b0|O(P%RO~OY1XO!W1VO!X(xX~O!X1YO~O^1[O_%gO'm%gO~O'v#mO'xTO'{UO~O#Y$eO#|$eOP(YXY(YXl(YXz(YX{(YX}(YX!W(YX!f(YX!i(YX!m(YX#h(YX#i(YX#j(YX#k(YX#l(YX#m(YX#n(YX#o(YX#r(YX#t(YX#v(YX#w(YX(T(YX(d(YX(k(YX(l(YX~O#p1_O&S1`O_(YX!g(YX~P$+sO#Y$eO#p1_O&S1`O~O_1bO~P%[O_1dO~O&]1gOP&ZiQ&ZiW&Zi_&Zib&Zic&Zij&Zil&Zim&Zin&Zit&Ziv&Zix&Zi}&Zi!R&Zi!S&Zi!Y&Zi!d&Zi!i&Zi!l&Zi!m&Zi!n&Zi!p&Zi!r&Zi!u&Zi!y&Zi#q&Zi$R&Zi$V&Zi%a&Zi%c&Zi%e&Zi%f&Zi%g&Zi%j&Zi%l&Zi%o&Zi%p&Zi%r&Zi&O&Zi&U&Zi&W&Zi&Y&Zi&[&Zi&_&Zi&e&Zi&k&Zi&m&Zi&o&Zi&q&Zi&s&Zi'k&Zi'v&Zi'x&Zi'{&Zi(T&Zi(c&Zi(p&Zi!X&Zi`&Zi&b&Zi~O`1mO!X1kO&b1lO~P`O!YXO!i1oO~O&i,jOP&diQ&diW&di_&dib&dic&dij&dil&dim&din&dit&div&dix&di}&di!R&di!S&di!Y&di!d&di!i&di!l&di!m&di!n&di!p&di!r&di!u&di!y&di#q&di$R&di$V&di%a&di%c&di%e&di%f&di%g&di%j&di%l&di%o&di%p&di%r&di&O&di&U&di&W&di&Y&di&[&di&_&di&e&di&k&di&m&di&o&di&q&di&s&di'k&di'v&di'x&di'{&di(T&di(c&di(p&di!X&di&]&di`&di&b&di~O!T1uO~O!W![a!X![a~P#C^Om!nO}!oO!V1{O(W!mO!W'PX!X'PX~P@OO!W,zO!X([a~O!W'VX!X'VX~P!7SO!W,}O!X(ja~O!X2SO~P'_O_%gO#Y2]O'm%gO~O_%gO!b#uO#Y2]O'm%gO~O_%gO!b#uO!m2aO#Y2]O'm%gO(d'gO~O_%gO'm%gO~P!7zO!W$aOp$la~O!T'Oi!W'Oi~P!7zO!W'{O!T(Zi~O!W(SO!T(hi~O!T(ii!W(ii~P!7zO!W(fi!h(fi_(fi'm(fi~P!7zO#Y2cO!W(fi!h(fi_(fi'm(fi~O!W(`O!h(ei~O}%aO!Y%bO!y]O#c2hO#d2gO'v%`O~O}%aO!Y%bO#d2gO'v%`O~Oh2oO!Y'VO%b2nO~Oh2oO!Y'VO%b2nO(P%RO~O#ewaPwaYwa_walwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa'mwa(Twa(dwa!hwa!Twa'kwapwa!Ywa%bwa!bwa~P$ tO#e$maP$maY$ma_$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma'm$ma(T$ma(d$ma!h$ma!T$ma'k$map$ma!Y$ma%b$ma!b$ma~P$!jO#e$oaP$oaY$oa_$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa'm$oa(T$oa(d$oa!h$oa!T$oa'k$oap$oa!Y$oa%b$oa!b$oa~P$#]O#e$}aP$}aY$}a_$}al$}a{$}a!W$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a'm$}a(T$}a(d$}a!h$}a!T$}a'k$}a#Y$}ap$}a!Y$}a%b$}a!b$}a~P#,sO_#]q!W#]q'm#]q'k#]q!T#]q!h#]qp#]q!Y#]q%b#]q!b#]q~P!7zOe'QX!W'QX~P!'vO!W._Oe(^a~O!V2wO!W'RX!h'RX~P%[O!W.bO!h(_a~O!W.bO!h(_a~P!7zO!T2zO~O#z!ka!X!ka~PJxO#z!ca!W!ca!X!ca~P#C^O#z!oa!X!oa~P!:eO#z!qa!X!qa~P!=OO!Y3^O$VfO$`3_O~O!X3cO~Op3dO~P#,sO_$iq!W$iq'm$iq'k$iq!T$iq!h$iqp$iq!Y$iq%b$iq!b$iq~P!7zO!T3eO~P#,sOz)vO})wO(l){Oh%Yi(k%Yi!W%Yi#Y%Yi~Oe%Yi#z%Yi~P$J]Oz)vO})wOh%[i(k%[i(l%[i!W%[i#Y%[i~Oe%[i#z%[i~P$KOO(d$ZO~P#,sO!V3hO'v%`O!W']X!h']X~O!W/VO!h(qa~O!W/VO!b#uO!h(qa~O!W/VO!b#uO(d'gO!h(qa~Oe$vi!W$vi#Y$vi#z$vi~P!0kO!V3pO'v*XO!T'_X!W'_X~P!1YO!W/_O!T(ra~O!W/_O!T(ra~P#,sO!b#uO#p3xO~Ol3{O!b#uO(d'gO~Oe(Ri!W(Ri~P!0kO#Y4OOe(Ri!W(Ri~P!0kO!h4RO~O_$jq!W$jq'm$jq'k$jq!T$jq!h$jqp$jq!Y$jq%b$jq!b$jq~P!7zO!T4VO~O!W4WO!Y(sX~P#,sO!g#wO~P4XO_$tX!Y$tX%VZX'm$tX!W$tX~P!/bO%V4YO_iXhiXziX}iX!YiX'miX(kiX(liX!WiX~O%V4YO~O`4`O%c4aO'v+bO'xTO'{UO!W'hX!X'hX~O!W0bO!X(za~OY4eO~O^4fO~O_%gO'm%gO~P#,sO!Y$|O~P#,sO!W4nO#Y4pO!X(wX~O!X4qO~Om!nO}4rO!]!xO!^!uO!_!uO!y9rO!}!pO#O!pO#P!pO#Q!pO#R!pO#U4wO#V!yO'w!lO'xTO'{UO(W!mO(c!sO~O!X4vO~P%%QOh4|O!Y0zO%b4{O~Oh4|O!Y0zO%b4{O(P%RO~O`5TO'v#mO'xTO'{UO!W'gX!X'gX~O!W1VO!X(xa~O'xTO'{UO(W5VO~O^5ZO~O#p5^O&S5_O~PMhO!h5`O~P%[O_5bO~O_5bO~P%[O`1mO!X5gO&b1lO~P`O!b5iO~O!b5kO!W(]i!X(]i!b(]i!i(]i(P(]i~O!W#bi!X#bi~P#C^O#Y5lO!W#bi!X#bi~O!W![i!X![i~P#C^O_%gO#Y5uO'm%gO~O_%gO!b#uO#Y5uO'm%gO~O!W(fq!h(fq_(fq'm(fq~P!7zO!W(`O!h(eq~O}%aO!Y%bO#d5|O'v%`O~O!Y'VO%b6PO~Oh6SO!Y'VO%b6PO~O#e%YiP%YiY%Yi_%Yil%Yi{%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi'm%Yi(T%Yi(d%Yi!h%Yi!T%Yi'k%Yip%Yi!Y%Yi%b%Yi!b%Yi~P$J]O#e%[iP%[iY%[i_%[il%[i{%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i'm%[i(T%[i(d%[i!h%[i!T%[i'k%[ip%[i!Y%[i%b%[i!b%[i~P$KOO#e$viP$viY$vi_$vil$vi{$vi!W$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi'm$vi(T$vi(d$vi!h$vi!T$vi'k$vi#Y$vip$vi!Y$vi%b$vi!b$vi~P#,sOe'Qa!W'Qa~P!0kO!W'Ra!h'Ra~P!7zO!W.bO!h(_i~O#z#]i!W#]i!X#]i~P#C^OP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O(TVOY#gil#gi!f#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~O#h#gi~P%3jO#h9zO~P%3jOP$]Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O(TVOY#gi!f#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~Ol#gi~P%5uOl9|O~P%5uOP$]Ol9|Oz#yO{#zO}#{O!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O(TVO#r#gi#t#gi#v#gi#w#gi#z#gi(d#gi(k#gi(l#gi!W#gi!X#gi~OY#gi!f#gi#m#gi#n#gi#o#gi#p#gi~P%8QOY:YO!f:OO#m:OO#n:OO#o:XO#p:OO~P%8QOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO(TVO#t#gi#v#gi#w#gi#z#gi(d#gi(l#gi!W#gi!X#gi~O(k#gi~P%:lO(k#|O~P%:lOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO(TVO(k#|O#v#gi#w#gi#z#gi(d#gi!W#gi!X#gi~O(l#gi~P%<wO(l#}O~P%<wOP$]OY:YOl9|Oz#yO{#zO}#{O!f:OO!g#wO!i#xO!m$]O#h9zO#i9{O#j9{O#k9{O#l9}O#m:OO#n:OO#o:XO#p:OO#r:PO#t:RO#v:TO(TVO(k#|O(l#}O~O#w#gi#z#gi(d#gi!W#gi!X#gi~P%?SO_#xy!W#xy'm#xy'k#xy!T#xy!h#xyp#xy!Y#xy%b#xy!b#xy~P!7zOh;mOz)vO})wO(k)yO(l){O~OP#giY#gil#gi{#gi!f#gi!g#gi!i#gi!m#gi#h#gi#i#gi#j#gi#k#gi#l#gi#m#gi#n#gi#o#gi#p#gi#r#gi#t#gi#v#gi#w#gi#z#gi(T#gi(d#gi!W#gi!X#gi~P%AzO!g#wOP(SXY(SXh(SXl(SXz(SX{(SX}(SX!f(SX!i(SX!m(SX#h(SX#i(SX#j(SX#k(SX#l(SX#m(SX#n(SX#o(SX#p(SX#r(SX#t(SX#v(SX#w(SX#z(SX(T(SX(d(SX(k(SX(l(SX!W(SX!X(SX~O#z#{i!W#{i!X#{i~P#C^O#z!oi!X!oi~P$$zO!X6`O~O!W'[a!X'[a~P#C^O!b#uO(d'gO!W']a!h']a~O!W/VO!h(qi~O!W/VO!b#uO!h(qi~Oe$vq!W$vq#Y$vq#z$vq~P!0kO!T'_a!W'_a~P#,sO!b6gO~O!W/_O!T(ri~P#,sO!W/_O!T(ri~O!T6kO~O!b#uO#p6pO~Ol6qO!b#uO(d'gO~O!T6sO~Oe$xq!W$xq#Y$xq#z$xq~P!0kO_$jy!W$jy'm$jy'k$jy!T$jy!h$jyp$jy!Y$jy%b$jy!b$jy~P!7zO!b5kO~O!W4WO!Y(sa~O_#]y!W#]y'm#]y'k#]y!T#]y!h#]yp#]y!Y#]y%b#]y!b#]y~P!7zOY6xO~O`6zO'v+bO'xTO'{UO~O!W0bO!X(zi~O^7OO~O(W(tO!W'dX!X'dX~O!W4nO!X(wa~OjkO'v7VO~P.iO!X7YO~P%%QOm!nO}7ZO'xTO'{UO(W!mO(c!sO~O!Y0zO~O!Y0zO%b7]O~Oh7`O!Y0zO%b7]O~OY7eO!W'ga!X'ga~O!W1VO!X(xi~O!h7iO~O!h7jO~O!h7mO~O!h7mO~P%[O_7oO~O!b7pO~O!h7qO~O!W(ii!X(ii~P#C^O_%gO#Y7yO'm%gO~O!W(fy!h(fy_(fy'm(fy~P!7zO!W(`O!h(ey~O!Y'VO%b7|O~O#e$vqP$vqY$vq_$vql$vq{$vq!W$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq'm$vq(T$vq(d$vq!h$vq!T$vq'k$vq#Y$vqp$vq!Y$vq%b$vq!b$vq~P#,sO#e$xqP$xqY$xq_$xql$xq{$xq!W$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq'm$xq(T$xq(d$xq!h$xq!T$xq'k$xq#Y$xqp$xq!Y$xq%b$xq!b$xq~P#,sO!W'Ri!h'Ri~P!7zO#z#]q!W#]q!X#]q~P#C^Oz/yO{/yO}/zOPwaYwahwalwa!fwa!gwa!iwa!mwa#hwa#iwa#jwa#kwa#lwa#mwa#nwa#owa#pwa#rwa#twa#vwa#wwa#zwa(Twa(dwa(kwa(lwa!Wwa!Xwa~Oz)vO})wOP$maY$mah$mal$ma{$ma!f$ma!g$ma!i$ma!m$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#o$ma#p$ma#r$ma#t$ma#v$ma#w$ma#z$ma(T$ma(d$ma(k$ma(l$ma!W$ma!X$ma~Oz)vO})wOP$oaY$oah$oal$oa{$oa!f$oa!g$oa!i$oa!m$oa#h$oa#i$oa#j$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#r$oa#t$oa#v$oa#w$oa#z$oa(T$oa(d$oa(k$oa(l$oa!W$oa!X$oa~OP$}aY$}al$}a{$}a!f$}a!g$}a!i$}a!m$}a#h$}a#i$}a#j$}a#k$}a#l$}a#m$}a#n$}a#o$}a#p$}a#r$}a#t$}a#v$}a#w$}a#z$}a(T$}a(d$}a!W$}a!X$}a~P%AzO#z$iq!W$iq!X$iq~P#C^O#z$jq!W$jq!X$jq~P#C^O!X8WO~O#z8XO~P!0kO!b#uO!W']i!h']i~O!b#uO(d'gO!W']i!h']i~O!W/VO!h(qq~O!T'_i!W'_i~P#,sO!W/_O!T(rq~O!T8_O~P#,sO!T8_O~Oe(Ry!W(Ry~P!0kO!W'ba!Y'ba~P#,sO_%Uq!Y%Uq'm%Uq!W%Uq~P#,sOY8dO~O!W0bO!X(zq~O#Y8hO!W'da!X'da~O!W4nO!X(wi~P#C^OPZXYZXlZXzZX{ZX}ZX!TZX!WZX!fZX!gZX!iZX!mZX#YZX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX~O!b%SX#p%SX~P&3YO!Y0zO%b8lO~O'xTO'{UO(W8qO~O!W1VO!X(xq~O!h8tO~O!h8uO~O!h8vO~O!h8vO~P%[O#Y8yO!W#by!X#by~O!W#by!X#by~P#C^O!Y'VO%b9OO~O#z#xy!W#xy!X#xy~P#C^OP$viY$vil$vi{$vi!f$vi!g$vi!i$vi!m$vi#h$vi#i$vi#j$vi#k$vi#l$vi#m$vi#n$vi#o$vi#p$vi#r$vi#t$vi#v$vi#w$vi#z$vi(T$vi(d$vi!W$vi!X$vi~P%AzOz)vO})wO(l){OP%YiY%Yih%Yil%Yi{%Yi!f%Yi!g%Yi!i%Yi!m%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#o%Yi#p%Yi#r%Yi#t%Yi#v%Yi#w%Yi#z%Yi(T%Yi(d%Yi(k%Yi!W%Yi!X%Yi~Oz)vO})wOP%[iY%[ih%[il%[i{%[i!f%[i!g%[i!i%[i!m%[i#h%[i#i%[i#j%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#r%[i#t%[i#v%[i#w%[i#z%[i(T%[i(d%[i(k%[i(l%[i!W%[i!X%[i~O#z$jy!W$jy!X$jy~P#C^O#z#]y!W#]y!X#]y~P#C^O!b#uO!W']q!h']q~O!W/VO!h(qy~O!T'_q!W'_q~P#,sO!T9VO~P#,sO!W0bO!X(zy~O!W4nO!X(wq~O!Y0zO%b9^O~O!h9aO~O!Y'VO%b9fO~OP$vqY$vql$vq{$vq!f$vq!g$vq!i$vq!m$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#o$vq#p$vq#r$vq#t$vq#v$vq#w$vq#z$vq(T$vq(d$vq!W$vq!X$vq~P%AzOP$xqY$xql$xq{$xq!f$xq!g$xq!i$xq!m$xq#h$xq#i$xq#j$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#r$xq#t$xq#v$xq#w$xq#z$xq(T$xq(d$xq!W$xq!X$xq~P%AzOe%^!Z!W%^!Z#Y%^!Z#z%^!Z~P!0kO!W'dq!X'dq~P#C^O!W#b!Z!X#b!Z~P#C^O#e%^!ZP%^!ZY%^!Z_%^!Zl%^!Z{%^!Z!W%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z'm%^!Z(T%^!Z(d%^!Z!h%^!Z!T%^!Z'k%^!Z#Y%^!Zp%^!Z!Y%^!Z%b%^!Z!b%^!Z~P#,sOP%^!ZY%^!Zl%^!Z{%^!Z!f%^!Z!g%^!Z!i%^!Z!m%^!Z#h%^!Z#i%^!Z#j%^!Z#k%^!Z#l%^!Z#m%^!Z#n%^!Z#o%^!Z#p%^!Z#r%^!Z#t%^!Z#v%^!Z#w%^!Z#z%^!Z(T%^!Z(d%^!Z!W%^!Z!X%^!Z~P%AzOp(XX~P1qO'w!lO~P!*SO!TdX!WdX#YdX~P&3YOPZXYZXlZXzZX{ZX}ZX!WZX!WdX!fZX!gZX!iZX!mZX#YZX#YdX#edX#hZX#iZX#jZX#kZX#lZX#mZX#nZX#oZX#pZX#rZX#tZX#vZX#wZX#|ZX(TZX(dZX(kZX(lZX~O!bdX!hZX!hdX(ddX~P&HpOP9qOQ9qOb;bOc!iOjkOl9qOmkOnkOtkOv9qOx9qO}WO!RkO!SkO!YXO!d9tO!iZO!l9qO!m9qO!n9qO!p9uO!r9xO!u!hO$R!kO$VfO'v)UO'xTO'{UO(TVO(c[O(p;`O~O!W:VO!X$la~Oj%SOl$tOm$sOn$sOt%TOv%UOx:]O}${O!Y$|O!d;gO!i$xO#d:cO$R%YO$n:_O$p:aO$s%ZO'v(lO'xTO'{UO(P%RO(T$uO~O#q)]O~P&MfO!XZX!XdX~P&HpO#e9yO~O!b#uO#e9yO~O#Y:ZO~O#p:OO~O#Y:eO!W(iX!X(iX~O#Y:ZO!W(gX!X(gX~O#e:fO~Oe:hO~P!0kO#e:mO~O#e:nO~O!b#uO#e:oO~O!b#uO#e:fO~O#z:pO~P#C^O#e:qO~O#e:rO~O#e:sO~O#e:tO~O#e:uO~O#e:vO~O#z:wO~P!0kO#z:xO~P!0kO$V~!g!}#O#Q#R#U#c#d#o(p$n$p$s%V%a%b%c%j%l%o%p%r%t~'qR$V(p#i!S'o'w#jm#h#klz'p(W'p'v$X$Z$X~",
    goto: "$'X)OPPPP)PPP)SP)eP*t.xPPPP5`PP5vP;r>yP?^P?^PPP?^PAOP?^P?^P?^PASPPAXPArPFjPPPFnPPPPFnIoPPPIuJpPFnPMOPPPP! ^FnPPPFnPFnP!#lFnP!'Q!(S!(]P!)P!)T!)PPPPPP!,`!(SPP!,|!-vP!0jFnFn!0o!3y!8`!8`!<UPPP!<]FnPPPPPPPPPPP!?jP!@{PPFn!BYPFnPFnFnFnFnPFn!ClPP!FtP!IxP!I|!JW!J[!J[P!FqP!J`!J`P!MdP!MhFnFn!Mn#!q?^P?^P?^?^P##|?^?^#%x?^#(X?^#)}?^?^#*l#,j#,j#,n#,v#,j#-OP#,jP?^#-h?^#.q?^?^5`PPP#/}PPP#0h#0hP#0hP#1O#0hPP#1UP#0{P#0{#1i#0{#2T#2Z5])S#2^)SP#2e#2e#2eP)SP)SP)SP)SPP)SP#2k#2nP#2n)SP#2rP#2uP)SP)SP)SP)SP)SP)S)SPP#2{#3R#3^#3d#3j#3p#3v#4U#4[#4b#4l#4r#4|#5]#5c#6T#6g#6m#6s#7R#7h#8y#9X#9_#9e#9k#9q#9{#:R#:X#:c#:u#:{PPPPPPPPPP#;RPPPPPPP#;v#>}P#@^#@e#@mPPPP#D{#Gr#NZ#N^#Na$ Y$ ]$ `$ g$ oPP$ u$ y$!q$#p$#t$$YPP$$^$$d$$hP$$k$$o$$r$%h$&P$&h$&l$&o$&r$&x$&{$'P$'TR!{RoqOXst!Z#c%f&i&k&l&n,b,g1g1jY!uQ'V-S0z4uQ%lvQ%tyQ%{|Q&a!VS&}!e,zQ']!iS'c!r!xS*_$|*dQ+`%uQ+m%}Q,R&ZQ-Q'UQ-['^Q-d'dQ/p*fQ1U,SR:d9u%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|,_,b,g-W-`-n-t.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2w4r4|5^5_5b5u7Z7`7o7yS#p]9r!r)W$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ*o%VQ+e%wQ,T&^Q,[&fQ.X:[Q0W+WQ0[+YQ0g+fQ1^,YQ2k.UQ4`0bQ5T1VQ6R2oQ6X:]Q6z4aR8P6S&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;ct!nQ!r!u!x!y&}'U'V'c'd'e,z-Q-S-d0z4u4w$^$si#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mQ&O|Q&{!eS'R%b,}Q+e%wQ,T&^Q/{*sQ0g+fQ0l+lQ1],XQ1^,YQ4`0bQ4i0nQ5T1VQ5W1XQ5X1[Q6z4aQ6}4fQ7h5ZQ8g7OR8r7ernOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jR,V&b&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'X'i'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;b;c[#[WZ#V#Y'O'y!S%cm#g#h#k%^%a(S(^(_(`*z*{*},^,t-r-x-y-z-|1o2g2h5k5|Q%oxQ%syS%x|%}Q&U!TQ'Y!hQ'[!iQ(g#rS*R$x*VS+_%t%uQ+c%wQ+|&XQ,Q&ZS-Z']'^Q.W(hQ/Z*SQ0`+`Q0f+fQ0h+gQ0k+kQ1P+}S1T,R,SQ2X-[Q3g/VQ4_0bQ4c0eQ4h0mQ5S1UQ6d3hQ6y4aQ6|4eQ8c6xR9X8dv$zi#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i!S%qy!i!t%s%t%u&|'[']'^'b'l*^+_+`,w-Z-[-c/h0`2Q2X2`3zQ+X%oQ+r&RQ+u&SQ,P&ZQ.V(gQ1O+|U1S,Q,R,SQ2p.WQ4}1PS5R1T1UQ7d5S#O;d#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mg;e:X:Y:_:a:c:j:l:n:r:t:xW%Pi%R*l;`S&R!Q&`Q&S!RQ&T!SR+p&P$_%Oi#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mT)r$u)sV*p%V:[:]U'R!e%b,}S(u#y#zQ+j%zS.P(c(dQ0u+vQ4P/yR7S4n&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;c$i$`c#X#d%j%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.j.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ'P!eR1|,zv!nQ!e!r!u!x!y&}'U'V'c'd'e,z-Q-S-d0z4u4wS*^$|*dS/h*_*fQ/q*gQ0w+xQ3z/pR3}/snqOXst!Z#c%f&i&k&l&n,b,g1g1jQ&p!^Q'm!wS(i#t9yQ+]%rQ+z&UQ+{&WQ-X'ZQ-f'fS.](n:fS0O*x:oQ0^+^Q0y+yQ1n,iQ1p,jQ1x,uQ2V-YQ2Y-^S4U0P:uQ4Z0_S4^0a:vQ5m1zQ5q2WQ5v2_Q6w4[Q7t5oQ7u5rQ7x5wR8x7q$d$_c#X#d%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VS(f#o'`U*i$}(m3ZS+S%j.jQ2l0WQ6O2kQ8O6RR9P8P$d$^c#X#d%k%m'x(O(j(q(y(z({(|(})O)P)Q)R)S)T)V)Y)^)h+T+i,x-g-l-q-s.^.d.h.k.l.{/}1v1y2Z2b2v2{2|2}3O3P3Q3R3S3T3U3V3W3X3[3]3b4T4]5n5t5y6V6W6]6^7U7s7w8Q8U8V8{9Z9b9s;VS(e#o'`S(w#z$_S+R%j.jS.Q(d(fQ.m)XQ0T+SR2i.R&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cS#p]9rQ&k!XQ&l!YQ&n![Q&o!]R1f,eQ'W!hQ+U%oQ-V'YS.S(g+XQ2T-UW2m.V.W0V0XQ5p2UU5}2j2l2pS7{6O6QS8}7}8OS9d8|9PQ9l9eR9o9mU!vQ'V-ST4s0z4u!Q_OXZ`st!V!Z#c#g%^%f&`&b&i&k&l&n(`,b,g-y1g1j]!pQ!r'V-S0z4uT#p]9r%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yS(u#y#zS.P(c(d!s:|$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cY!tQ'V-S0z4uQ'b!rS'l!u!xS'n!y4wS-c'c'dQ-e'eR2`-dQ'k!tS([#f1aS-b'b'nQ/Y*RQ/f*^Q2a-eQ3l/ZS3u/g/qQ6c3gS6n3{3}Q8Z6dR8b6qQ#vbQ'j!tS(Z#f1aS(]#l*wQ*y%_Q+Z%pQ+a%vU-a'b'k'nQ-u([Q/X*RQ/e*^Q/k*aQ0]+[Q1Q,OS2^-b-eQ2f-}S3k/Y/ZS3t/f/qQ3w/jQ3y/lQ5P1RQ5x2aQ6b3gQ6f3lS6j3u3}Q6o3|Q7b5QS8Y6c6dQ8^6kQ8`6nQ8o7cQ9T8ZQ9U8_Q9W8bQ9`8pQ9h9VQ;P:zQ;[;TR;];UV!vQ'V-S%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yS#vz!j!r:y$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cR;P;b%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yQ%_j!S%py!i!t%s%t%u&|'[']'^'b'l*^+_+`,w-Z-[-c/h0`2Q2X2`3zS%vz!jQ+[%qQ,O&ZW1R,P,Q,R,SU5Q1S1T1US7c5R5SQ8p7d!r:z$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ;T;aR;U;b$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7yY#aWZ#V#Y'y!S%cm#g#h#k%^%a(S(^(_(`*z*{*},^,t-r-x-y-z-|1o2g2h5k5|Q,]&f!p:{$[$m)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cR;O'OS'S!e%bR2O,}%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|,_,b,g-W-`-n-t.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2w4r4|5^5_5b5u7Z7`7o7y!r)W$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cQ,[&fQ0W+WQ2k.UQ6R2oR8P6S!f$Uc#X%j'x(O(j(q)Q)R)S)T)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9s!T:Q)V)h,x.j1v1y2{3T3U3V3W3[3b5n6W6]6^7U7s8Q8U8V9Z9b;V!b$Wc#X%j'x(O(j(q)S)T)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9s!P:S)V)h,x.j1v1y2{3V3W3[3b5n6W6]6^7U7s8Q8U8V9Z9b;V!^$[c#X%j'x(O(j(q)Y)^+i-g-l-q-s.^.d.{/}2Z2b2v3X4T4]5t5y6V7w8{9sQ3f/Tz;c)V)h,x.j1v1y2{3[3b5n6W6]6^7U7s8Q8U8V9Z9b;VQ;h;jR;i;k&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cS$nh$oR3_.p'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.p.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cT$jf$pQ$hfS)a$k)eR)m$pT$if$pT)c$k)e'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%f%l%y&b&e&f&i&k&l&n&r&z'O'X'i'y'{(R(Y(n(r(v)j)u*x*|+W,_,b,g,s,v-W-`-n-t.U.b.i.p.q/z0P0a0}1_1`1b1d1g1j1l1{2]2c2o2w3^4p4r4|5^5_5b5l5u6S7Z7`7o7y8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;cT$nh$oQ$qhR)l$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%f%l%y&b&e&f&i&k&l&n&r&z'X'i'y'{(R(Y(n(r(v)u*x*|+W,_,b,g-W-`-n-t.U.b.i/z0P0a0}1_1`1b1d1g1j1l2]2c2o2w4r4|5^5_5b5u6S7Z7`7o7y!s;a$[$m'O)j,s,v.q1{3^4p5l8h8y9q9t9u9x9y9z9{9|9}:O:P:Q:R:S:T:U:V:Z:d:e:f:h:o:p:u:v;c#clOPXZst!Z!`!o#R#c#n#{$m%f&b&e&f&i&k&l&n&r&z'X(v)j*|+W,_,b,g-W.U.q/z0}1_1`1b1d1g1j1l2o3^4r4|5^5_5b6S7Z7`7ov$}i#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i#O(m#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mQ*t%ZQ.|)vg3Z:X:Y:_:a:c:j:l:n:r:t:xv$yi#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;iQ*W$zS*a$|*dQ*u%[Q/l*b#O;R#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mf;S:X:Y:_:a:c:j:l:n:r:t:xQ;W;dQ;X;eQ;Y;fR;Z;gv$}i#w%W%X%])z)|*U*j*k._/^/|3f4O8X;`;h;i#O(m#u$c$d$x${)q)w)}*[+V+Y+q+t.T/P/_/a0q0t0|2n3p3x4W4Y4{6P6g6p7]7|8l9O9^9f:^:`:b:i:k:m:q:s:w;l;mg3Z:X:Y:_:a:c:j:l:n:r:t:xnoOXst!Z#c%f&i&k&l&n,b,g1g1jQ*Z${Q,p&uQ,q&wR3o/_$^%Oi#u#w$c$d$x${%W%X%])q)w)z)|)}*U*[*j*k+V+Y+q+t.T._/P/^/_/a/|0q0t0|2n3f3p3x4O4W4Y4{6P6g6p7]7|8X8l9O9^9f:X:Y:^:_:`:a:b:c:i:j:k:l:m:n:q:r:s:t:w:x;`;h;i;l;mQ+s&SQ0s+uQ4l0rR7R4mT*c$|*dS*c$|*dT4t0z4uS/j*`4rT3|/r7ZQ+Z%pQ/k*aQ0]+[Q1Q,OQ5P1RQ7b5QQ8o7cR9`8pn)z$v(o*v/]/t/u2t3m4S6a6r9S;Q;^;_!Y:i(k)[*Q*Y.[.x.}/T/b0U0p0r2s3n3r4k4m6T6U6h6l6t6v8]8a9g;j;k]:j3Y6[8R9Q9R9pp)|$v(o*v/R/]/t/u2t3m4S6a6r9S;Q;^;_![:k(k)[*Q*Y.[.x.}/T/b0U0p0r2q2s3n3r4k4m6T6U6h6l6t6v8]8a9g;j;k_:l3Y6[8R8S9Q9R9prnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jQ&]!UR,_&frnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jR&]!UQ+w&TR0o+psnOXst!V!Z#c%f&`&i&k&l&n,b,g1g1jQ0{+|S4z1O1PU7[4x4y4}S8k7^7_S9[8j8mQ9i9]R9n9jQ&d!VR,W&`R5W1XS%x|%}R0h+gQ&i!WR,b&jR,h&oT1h,g1jR,l&pQ,k&pR1q,lQ'p!zR-h'pSsOtQ#cXT%is#cQ!}TR'r!}Q#QUR't#QQ)s$uR.y)sQ#TVR'v#TQ#WWU'|#W'}-oQ'}#XR-o(OQ,{'PR1},{Q.`(oR2u.`Q.c(qS2x.c2yR2y.dQ-S'VR2R-SY!rQ'V-S0z4uR'a!rS#^W%aU(T#^(U-pQ(U#_R-p(PQ-O'SR2P-Ot`OXst!V!Z#c%f&`&b&i&k&l&n,b,g1g1jS#gZ%^U#q`#g-yR-y(`Q(a#iQ-v(]W.O(a-v2d5zQ2d-wR5z2eQ)e$kR.r)eQ$ohR)k$oQ$bcU)Z$b-k:WQ-k9sR:W)hQ/W*RW3i/W3j6e8[U3j/X/Y/ZS6e3k3lR8[6f#o)x$v(k(o)[*Q*Y*q*r*v.Y.Z.[.x.}/R/S/T/]/b/t/u0U0p0r2q2r2s2t3Y3m3n3r4S4k4m6T6U6Y6Z6[6a6h6l6r6t6v8R8S8T8]8a9Q9R9S9g9p;Q;^;_;j;kQ/`*YU3q/`3s6iQ3s/bR6i3rQ*d$|R/n*dQ*m%QR/w*mQ4X0UR6u4XQ+O%dR0S+OQ4o0uS7T4o8iR8i7UQ+y&UR0x+yQ4u0zR7X4uQ1W,TS5U1W7fR7f5WQ0c+cW4b0c4d6{8eQ4d0fQ6{4cR8e6|Q+h%xR0i+hQ1j,gR5f1jYrOXst#cQ&m!ZQ+Q%fQ,a&iQ,c&kQ,d&lQ,f&nQ1e,bS1h,g1jR5e1gQ%hpQ&q!_Q&t!aQ&v!bQ&x!cQ'h!tQ+P%eQ+]%rQ+o&OQ,V&dQ,n&sW-_'b'j'k'nQ-f'fQ/m*cQ0^+^S1Z,W,ZQ1r,mQ1s,pQ1t,qQ2Y-^W2[-a-b-e-gQ4Z0_Q4g0lQ4j0pQ5O1QQ5Y1]Q5d1fU5s2Z2^2aQ5v2_Q6w4[Q7P4iQ7Q4kQ7W4tQ7a5PQ7g5XS7v5t5xQ7x5wQ8f6}Q8n7bQ8s7hQ8z7wQ9Y8gQ9_8oQ9c8{R9k9`Q%ryQ'Z!iQ'f!tU+^%s%t%uQ,u&|U-Y'[']'^S-^'b'lQ/d*^S0_+_+`Q1z,wS2W-Z-[Q2_-cQ3v/hQ4[0`Q5o2QQ5r2XQ5w2`R6m3zS$wi;`R*n%RU%Qi%R;`R/v*lQ$viS(k#u+YQ(o#wS)[$c$dQ*Q$xQ*Y${Q*q%WQ*r%XQ*v%]Q.Y:^Q.Z:`Q.[:bQ.x)qS.})w/PQ/R)zQ/S)|Q/T)}Q/]*UQ/b*[Q/t*jQ/u*kh0U+V.T0|2n4{6P7]7|8l9O9^9fQ0p+qQ0r+tQ2q:iQ2r:kQ2s:mQ2t._S3Y:X:YQ3m/^Q3n/_Q3r/aQ4S/|Q4k0qQ4m0tQ6T:qQ6U:sQ6Y:_Q6Z:aQ6[:cQ6a3fQ6h3pQ6l3xQ6r4OQ6t4WQ6v4YQ8R:nQ8S:jQ8T:lQ8]6gQ8a6pQ9Q:rQ9R:tQ9S8XQ9g:wQ9p:xQ;Q;`Q;^;hQ;_;iQ;j;lR;k;mnpOXst!Z#c%f&i&k&l&n,b,g1g1jQ!fPS#eZ#nQ&s!`U'_!o4r7ZQ'u#RQ(x#{Q)i$mS,Z&b&eQ,`&fQ,m&rQ,r&zQ-U'XQ.f(vQ.v)jQ0Q*|Q0X+WQ1c,_Q2U-WQ2l.UQ3a.qQ4Q/zQ4y0}Q5[1_Q5]1`Q5a1bQ5c1dQ5h1lQ6O2oQ6_3^Q7_4|Q7k5^Q7l5_Q7n5bQ8O6SQ8m7`R8w7o#WcOPXZst!Z!`!o#c#n#{%f&b&e&f&i&k&l&n&r&z'X(v*|+W,_,b,g-W.U/z0}1_1`1b1d1g1j1l2o4r4|5^5_5b6S7Z7`7oQ#XWQ#dYQ%juQ%kvS%mw!gS'x#V'{Q(O#YQ(j#tQ(q#xQ(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)R$WQ)S$XQ)T$YQ)V$[Q)Y$aQ)^$eW)h$m)j.q3^Q+T%lQ+i%yS,x'O1{Q-g'iS-l'y-nQ-q(RQ-s(YQ.^(nQ.d(rQ.h9qQ.j9tQ.k9uQ.l9xQ.{)uQ/}*xQ1v,sQ1y,vQ2Z-`Q2b-tQ2v.bQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S:QQ3T:RQ3U:SQ3V:TQ3W:UQ3X.iQ3[:ZQ3]:dQ3b:VQ4T0PQ4]0aQ5n:eQ5t2]Q5y2cQ6V2wQ6W:fQ6]:hQ6^:oQ7U4pQ7s5lQ7w5uQ8Q:pQ8U:uQ8V:vQ8{7yQ9Z8hQ9b8yQ9s#RR;V;cR#ZWR'Q!eY!tQ'V-S0z4uS&|!e,zQ'b!rS'l!u!xS'n!y4wS,w&}'US-c'c'dQ-e'eQ2Q-QR2`-dR(p#wR(s#xQ!fQT-R'V-S]!qQ!r'V-S0z4uQ#o]R'`9rT#jZ%^S#iZ%^S%dm,^U(]#g#h#kS-w(^(_Q-{(`Q0R*}Q2e-xU2f-y-z-|S5{2g2hR7z5|`#]W#V#Y%a'y(S*z-rr#fZm#g#h#k%^(^(_(`*}-x-y-z-|2g2h5|Q1a,^Q1w,tQ5j1oQ7r5kT:}'O*{T#`W%aS#_W%aS'z#V(SS(P#Y*zS,y'O*{T-m'y-rT'T!e%bQ$kfR)o$pT)d$k)eR3`.pT*T$x*VR*]${Q0V+VQ2j.TQ4x0|Q6Q2nQ7^4{Q7}6PQ8j7]Q8|7|Q9]8lQ9e9OQ9j9^R9m9fnqOXst!Z#c%f&i&k&l&n,b,g1g1jQ&c!VR,V&`tmOXst!U!V!Z#c%f&`&i&k&l&n,b,g1g1jR,^&fT%em,^R0v+vR,U&^Q%||R+n%}R+d%wT&g!W&jT&h!W&jT1i,g1j",
    nodeNames:
      ' ArithOp ArithOp LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem',
    maxTerm: 367,
    context: g2,
    nodeProps: [
      [
        'group',
        -26,
        7,
        15,
        17,
        63,
        200,
        204,
        208,
        209,
        211,
        214,
        217,
        227,
        229,
        235,
        237,
        239,
        241,
        244,
        250,
        256,
        258,
        260,
        262,
        264,
        266,
        267,
        'Statement',
        -32,
        11,
        12,
        26,
        29,
        30,
        36,
        46,
        49,
        50,
        52,
        57,
        65,
        73,
        77,
        79,
        81,
        82,
        104,
        105,
        114,
        115,
        132,
        135,
        137,
        138,
        139,
        140,
        142,
        143,
        163,
        164,
        166,
        'Expression',
        -23,
        25,
        27,
        31,
        35,
        37,
        39,
        167,
        169,
        171,
        172,
        174,
        175,
        176,
        178,
        179,
        180,
        182,
        183,
        184,
        194,
        196,
        198,
        199,
        'Type',
        -3,
        85,
        97,
        103,
        'ClassItem'
      ],
      [
        'openedBy',
        32,
        'InterpolationStart',
        51,
        '[',
        55,
        '{',
        70,
        '(',
        144,
        'JSXStartTag',
        156,
        'JSXStartTag JSXStartCloseTag'
      ],
      [
        'closedBy',
        34,
        'InterpolationEnd',
        45,
        ']',
        56,
        '}',
        71,
        ')',
        145,
        'JSXSelfCloseEndTag JSXEndTag',
        161,
        'JSXEndTag'
      ]
    ],
    propSources: [S2],
    skippedNodes: [0, 3, 4, 270],
    repeatNodeCount: 33,
    tokenData:
      "$Fl(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Nu!`!a$#a!a!b$(n!b!c$,m!c!}Er!}#O$-w#O#P$/R#P#Q$4j#Q#R$5t#R#SEr#S#T$7R#T#o$8]#o#p$<m#p#q$=c#q#r$>s#r#s$@P#s$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$I|Er$I|$I}$Df$I}$JO$Df$JO$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(n%d_$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$e&j'|!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'|!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$e&j'ypOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'ypOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$e&j'yp'|!b'o(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'z#S$e&j'p(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$e&j'yp'|!b'p(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$e&j!m$Ip'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#r$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#r$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'x$(n$e&j'|!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$e&j'|!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$e&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$`#t$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$`#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$`#t$e&j'|!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'|!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$`#t'|!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hh$e&j'yp'|!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__US$e&j'yp'|!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]US$e&j'|!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXUS$e&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSUSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWUS'|!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]US$e&j'ypOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWUS'ypOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYUS'yp'|!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$e&j(c!L^'yp'|!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$e&j'yp'|!b(W!LY'v&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$e&j'yp'|!b$X#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$e&j'yp'|!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$e&j#|$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfLva(l%<v$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$e&j#v$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b! c_'{$)`$e&j'ypOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b*Q!!i_$e&j'ypOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b)`!#mX$e&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h#t!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y#t!$oP;=`<%l!$Y)`!$uP;=`<%l!#h*Q!%R]$`#t$e&j'ypOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$f!&PZ'ypOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z$f!&yU$`#t'ypOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$f!'`P;=`<%l!%z*Q!'fP;=`<%l!!b(*Q!'t_!i(!b$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!hM|$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$e&j'yp'|!b'w#)d#k$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$e&j'yp'|!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$e&j'yp'|!bl&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!W&;l$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$e&j'yp'|!bz'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!VMt$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$e&j'yp'|!b#i$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$e&j'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$e&j'|!b!SSOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$e&j!SSOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$e&j!SSO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!SSOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!SS#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$e&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$e&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$e&j'|!b!SSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ'|!b!SSOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb'|!b!SSOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX'|!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$e&j'|!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$e&j'yp!SSOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$e&j'yp!SSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ'yp!SSOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb'yp!SSOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX'ypOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$e&j'ypOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$e&j'yp'|!b!SSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d]'yp'|!b!SSOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe'yp'|!b!SSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ'yp'|!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$e&j'yp'|!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$e&j'yp'|!b'q(;d!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$e&j'yp'|!bR(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$e&j'|!bR(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$e&jR(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSR(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW'|!bR(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$e&j'ypR(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW'ypR(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY'yp'|!bR(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$e&j#|$Id'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$U#t$e&j'yp'|!b!SSOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$e&j'yp'|!bm$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!b$b$e&j#z%<f'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I___l$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Jm^(P!*v!f'.r'yp'|!b$V)d(pSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Ki!Q!^*g!^!_#L_!_!`#NP!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KrX$g&j'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LhZ#l$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MZ!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MdX#|$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NYX#m$Id'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Qa#Y%?x$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!V!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!b_#e$Ih$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#paeBf#m$Id$b#|$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$u!`!a$&P!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%Q_#m$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&[a#l$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'a!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'l`#l$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(yc(d$Ip$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*U!P!^%Z!^!_*g!_!a%Z!a!b$+`!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*a_{'#p$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+k`$e&j#w$Id'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,x_!y!Ln$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.S_}(8n$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/WZ$e&jO!^$/y!^!_$0a!_#i$/y#i#j$0f#j#l$/y#l#m$2X#m#o$/y#o#p$0a#p;'S$/y;'S;=`$4d<%lO$/y(n$0QT]#S$e&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0fO]#S(n$0k[$e&jO!Q&c!Q![$1a![!^&c!_!c&c!c!i$1a!i#T&c#T#Z$1a#Z#o&c#o#p$3w#p;'S&c;'S;=`&w<%lO&c(n$1fZ$e&jO!Q&c!Q![$2X![!^&c!_!c&c!c!i$2X!i#T&c#T#Z$2X#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2^Z$e&jO!Q&c!Q![$3P![!^&c!_!c&c!c!i$3P!i#T&c#T#Z$3P#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3UZ$e&jO!Q&c!Q![$/y![!^&c!_!c&c!c!i$/y!i#T&c#T#Z$/y#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3zR!Q![$4T!c!i$4T#T#Z$4T#S$4WS!Q![$4T!c!i$4T#T#Z$4T#q#r$0a(n$4gP;=`<%l$/y!2r$4u_!T!+S$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$6P`#t$Id$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7^_$e&j'yp'|!b(T&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8lk$e&j'yp'|!b(W!LY'v&;d$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$8]uw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$8]![!^%Z!^!_*g!_!c%Z!c!}$8]!}#O%Z#O#P&c#P#R%Z#R#S$8]#S#T%Z#T#o$8]#o#p*g#p$g%Z$g;'S$8];'S;=`$<g<%lO$8]+d$:lk$e&j'yp'|!b$Z#tOY%ZYZ&cZr%Zrs&}st%Ztu$:auw%Zwx(rx}%Z}!O$:a!O!Q%Z!Q![$:a![!^%Z!^!_*g!_!c%Z!c!}$:a!}#O%Z#O#P&c#P#R%Z#R#S$:a#S#T%Z#T#o$:a#o#p*g#p$g%Z$g;'S$:a;'S;=`$<a<%lO$:a+d$<dP;=`<%l$:a(CS$<jP;=`<%l$8]!5p$<vX!Y!3l'yp'|!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$=na(k%<v$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+`#q;'S%Z;'S;=`+a<%lO%Z%#`$?Q_!X$I`p`$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@[_!nS$e&j'yp'|!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Al|$e&j'yp'|!b'o(;d(W!LY'v&;d$X#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AZ#BZ$ISEr$IS$I_$AZ$I_$JTEr$JT$JU$AZ$JU$KVEr$KV$KW$AZ$KW&FUEr&FU&FV$AZ&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AZ?HUOEr(CS$Dwk$e&j'yp'|!b'p(;d(W!LY'v&;d$X#tOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
    tokenizers: [
      b2,
      v2,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      y2,
      new Ua(
        "$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOr~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!P~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(V~~",
        141,
        328
      ),
      new Ua("j~RQYZXz{^~^O's~~aP!P!Qd~iO't~~", 25, 310)
    ],
    topRules: {
      Script: [0, 5],
      SingleExpression: [1, 268],
      SingleClassItem: [2, 269]
    },
    dialects: { jsx: 12842, ts: 12844 },
    dynamicPrecedences: { 67: 1, 77: 1, 79: 1, 164: 1, 192: 1 },
    specialized: [
      { term: 314, get: (n) => x2[n] || -1 },
      { term: 330, get: (n) => w2[n] || -1 },
      { term: 68, get: (n) => P2[n] || -1 }
    ],
    tokenPrec: 12868
  }),
  Jv = [
    ot('function ${name}(${params}) {\n	${}\n}', {
      label: 'function',
      detail: 'definition',
      type: 'keyword'
    }),
    ot('for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}', {
      label: 'for',
      detail: 'loop',
      type: 'keyword'
    }),
    ot('for (let ${name} of ${collection}) {\n	${}\n}', {
      label: 'for',
      detail: 'of loop',
      type: 'keyword'
    }),
    ot('do {\n	${}\n} while (${})', {
      label: 'do',
      detail: 'loop',
      type: 'keyword'
    }),
    ot('while (${}) {\n	${}\n}', {
      label: 'while',
      detail: 'loop',
      type: 'keyword'
    }),
    ot(
      `try {
	\${}
} catch (\${error}) {
	\${}
}`,
      { label: 'try', detail: '/ catch block', type: 'keyword' }
    ),
    ot('if (${}) {\n	${}\n}', { label: 'if', detail: 'block', type: 'keyword' }),
    ot(
      `if (\${}) {
	\${}
} else {
	\${}
}`,
      { label: 'if', detail: '/ else block', type: 'keyword' }
    ),
    ot(
      `class \${name} {
	constructor(\${params}) {
		\${}
	}
}`,
      { label: 'class', detail: 'definition', type: 'keyword' }
    ),
    ot('import {${names}} from "${module}"\n${}', {
      label: 'import',
      detail: 'named',
      type: 'keyword'
    }),
    ot('import ${name} from "${module}"\n${}', {
      label: 'import',
      detail: 'default',
      type: 'keyword'
    })
  ],
  $2 = Jv.concat([
    ot('interface ${name} {\n	${}\n}', {
      label: 'interface',
      detail: 'definition',
      type: 'keyword'
    }),
    ot('type ${name} = ${type}', {
      label: 'type',
      detail: 'definition',
      type: 'keyword'
    }),
    ot('enum ${name} {\n	${}\n}', {
      label: 'enum',
      detail: 'definition',
      type: 'keyword'
    })
  ]),
  HO = new xb(),
  eS = new Set([
    'Script',
    'Block',
    'FunctionExpression',
    'FunctionDeclaration',
    'ArrowFunction',
    'MethodDeclaration',
    'ForStatement'
  ])
function Ci(n) {
  return (e, t) => {
    let r = e.node.getChild('VariableDefinition')
    return r && t(r, n), !0
  }
}
const Q2 = ['FunctionDeclaration'],
  k2 = {
    FunctionDeclaration: Ci('function'),
    ClassDeclaration: Ci('class'),
    ClassExpression: () => !0,
    EnumDeclaration: Ci('constant'),
    TypeAliasDeclaration: Ci('type'),
    NamespaceDeclaration: Ci('namespace'),
    VariableDefinition(n, e) {
      n.matchContext(Q2) || e(n, 'variable')
    },
    TypeDefinition(n, e) {
      e(n, 'type')
    },
    __proto__: null
  }
function tS(n, e) {
  let t = HO.get(e)
  if (t) return t
  let r = [],
    i = !0
  function s(o, a) {
    let l = n.sliceString(o.from, o.to)
    r.push({ label: l, type: a })
  }
  return (
    e.cursor(Oe.IncludeAnonymous).iterate((o) => {
      if (i) i = !1
      else if (o.name) {
        let a = k2[o.name]
        if ((a && a(o, s)) || eS.has(o.name)) return !1
      } else if (o.to - o.from > 8192) {
        for (let a of tS(n, o.node)) r.push(a)
        return !1
      }
    }),
    HO.set(e, r),
    r
  )
}
const KO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,
  nS = [
    'TemplateString',
    'String',
    'RegExp',
    'LineComment',
    'BlockComment',
    'VariableDefinition',
    'TypeDefinition',
    'Label',
    'PropertyDefinition',
    'PropertyName',
    'PrivatePropertyDefinition',
    'PrivatePropertyName',
    '.',
    '?.'
  ]
function C2(n) {
  let e = ke(n.state).resolveInner(n.pos, -1)
  if (nS.indexOf(e.name) > -1) return null
  let t =
    e.name == 'VariableName' ||
    (e.to - e.from < 20 && KO.test(n.state.sliceDoc(e.from, e.to)))
  if (!t && !n.explicit) return null
  let r = []
  for (let i = e; i; i = i.parent)
    eS.has(i.name) && (r = r.concat(tS(n.state.doc, i)))
  return { options: r, from: t ? e.from : n.pos, validFor: KO }
}
const rn = Kr.define({
    name: 'javascript',
    parser: T2.configure({
      props: [
        xl.add({
          IfStatement: Wo({ except: /^\s*({|else\b)/ }),
          TryStatement: Wo({ except: /^\s*({|catch\b|finally\b)/ }),
          LabeledStatement: fR,
          SwitchBody: (n) => {
            let e = n.textAfter,
              t = /^\s*\}/.test(e),
              r = /^\s*(case|default)\b/.test(e)
            return n.baseIndent + (t ? 0 : r ? 1 : 2) * n.unit
          },
          Block: uR({ closing: '}' }),
          ArrowFunction: (n) => n.baseIndent + n.unit,
          'TemplateString BlockComment': () => null,
          'Statement Property': Wo({ except: /^{/ }),
          JSXElement(n) {
            let e = /^\s*<\//.test(n.textAfter)
            return n.lineIndent(n.node.from) + (e ? 0 : n.unit)
          },
          JSXEscape(n) {
            let e = /\s*\}/.test(n.textAfter)
            return n.lineIndent(n.node.from) + (e ? 0 : n.unit)
          },
          'JSXOpenTag JSXSelfClosingTag'(n) {
            return n.column(n.node.from) + n.unit
          }
        }),
        wl.add({
          'Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType':
            _b,
          BlockComment(n) {
            return { from: n.from + 2, to: n.to - 2 }
          }
        })
      ]
    }),
    languageData: {
      closeBrackets: { brackets: ['(', '[', '{', "'", '"', '`'] },
      commentTokens: { line: '//', block: { open: '/*', close: '*/' } },
      indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
      wordChars: '$'
    }
  }),
  rS = {
    test: (n) => /^JSX/.test(n.name),
    facet: $b({ commentTokens: { block: { open: '{/*', close: '*/}' } } })
  },
  iS = rn.configure({ dialect: 'ts' }, 'typescript'),
  sS = rn.configure({
    dialect: 'jsx',
    props: [Bf.add((n) => (n.isTop ? [rS] : void 0))]
  }),
  oS = rn.configure(
    { dialect: 'jsx ts', props: [Bf.add((n) => (n.isTop ? [rS] : void 0))] },
    'typescript'
  )
let aS = (n) => ({ label: n, type: 'keyword' })
const lS =
    'break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield'
      .split(' ')
      .map(aS),
  _2 = lS.concat(
    ['declare', 'implements', 'private', 'protected', 'public'].map(aS)
  )
function cS(n = {}) {
  let e = n.jsx ? (n.typescript ? oS : sS) : n.typescript ? iS : rn,
    t = n.typescript ? $2.concat(_2) : Jv.concat(lS)
  return new Uf(e, [
    rn.data.of({ autocomplete: CA(nS, Zv(t)) }),
    rn.data.of({ autocomplete: C2 }),
    n.jsx ? A2 : []
  ])
}
function R2(n) {
  for (;;) {
    if (
      n.name == 'JSXOpenTag' ||
      n.name == 'JSXSelfClosingTag' ||
      n.name == 'JSXFragmentTag'
    )
      return n
    if (n.name == 'JSXEscape' || !n.parent) return null
    n = n.parent
  }
}
function JO(n, e, t = n.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (
      r.name == 'JSXIdentifier' ||
      r.name == 'JSXBuiltin' ||
      r.name == 'JSXNamespacedName' ||
      r.name == 'JSXMemberExpression'
    )
      return n.sliceString(r.from, Math.min(r.to, t))
  return ''
}
const Z2 =
    typeof navigator == 'object' && /Android\b/.test(navigator.userAgent),
  A2 = j.inputHandler.of((n, e, t, r, i) => {
    if (
      (Z2 ? n.composing : n.compositionStarted) ||
      n.state.readOnly ||
      e != t ||
      (r != '>' && r != '/') ||
      !rn.isActiveAt(n.state, e, -1)
    )
      return !1
    let s = i(),
      { state: o } = s,
      a = o.changeByRange((l) => {
        var c
        let { head: u } = l,
          f = ke(o).resolveInner(u - 1, -1),
          p
        if (
          (f.name == 'JSXStartTag' && (f = f.parent),
          !(
            o.doc.sliceString(u - 1, u) != r ||
            (f.name == 'JSXAttributeValue' && f.to > u)
          ))
        ) {
          if (r == '>' && f.name == 'JSXFragmentTag')
            return { range: l, changes: { from: u, insert: '</>' } }
          if (r == '/' && f.name == 'JSXStartCloseTag') {
            let d = f.parent,
              O = d.parent
            if (
              O &&
              d.from == u - 2 &&
              ((p = JO(o.doc, O.firstChild, u)) ||
                ((c = O.firstChild) === null || c === void 0
                  ? void 0
                  : c.name) == 'JSXFragmentTag')
            ) {
              let g = `${p}>`
              return {
                range: C.cursor(u + g.length, -1),
                changes: { from: u, insert: g }
              }
            }
          } else if (r == '>') {
            let d = R2(f)
            if (
              d &&
              !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) &&
              (p = JO(o.doc, d, u))
            )
              return { range: l, changes: { from: u, insert: `</${p}>` } }
          }
        }
        return { range: l }
      })
    return a.changes.empty
      ? !1
      : (n.dispatch([
          s,
          o.update(a, { userEvent: 'input.complete', scrollIntoView: !0 })
        ]),
        !0)
  }),
  E2 = 54,
  D2 = 1,
  X2 = 55,
  Y2 = 2,
  I2 = 56,
  j2 = 3,
  em = 4,
  N2 = 5,
  qa = 6,
  uS = 7,
  fS = 8,
  hS = 9,
  pS = 10,
  M2 = 11,
  V2 = 12,
  W2 = 13,
  Pc = 57,
  L2 = 14,
  tm = 58,
  dS = 20,
  B2 = 22,
  OS = 23,
  U2 = 24,
  lf = 26,
  mS = 27,
  q2 = 28,
  z2 = 31,
  F2 = 34,
  G2 = 36,
  H2 = 37,
  K2 = 0,
  J2 = 1,
  eD = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    command: !0,
    embed: !0,
    frame: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0
  },
  tD = {
    dd: !0,
    li: !0,
    optgroup: !0,
    option: !0,
    p: !0,
    rp: !0,
    rt: !0,
    tbody: !0,
    td: !0,
    tfoot: !0,
    th: !0,
    tr: !0
  },
  nm = {
    dd: { dd: !0, dt: !0 },
    dt: { dd: !0, dt: !0 },
    li: { li: !0 },
    option: { option: !0, optgroup: !0 },
    optgroup: { optgroup: !0 },
    p: {
      address: !0,
      article: !0,
      aside: !0,
      blockquote: !0,
      dir: !0,
      div: !0,
      dl: !0,
      fieldset: !0,
      footer: !0,
      form: !0,
      h1: !0,
      h2: !0,
      h3: !0,
      h4: !0,
      h5: !0,
      h6: !0,
      header: !0,
      hgroup: !0,
      hr: !0,
      menu: !0,
      nav: !0,
      ol: !0,
      p: !0,
      pre: !0,
      section: !0,
      table: !0,
      ul: !0
    },
    rp: { rp: !0, rt: !0 },
    rt: { rp: !0, rt: !0 },
    tbody: { tbody: !0, tfoot: !0 },
    td: { td: !0, th: !0 },
    tfoot: { tbody: !0 },
    th: { td: !0, th: !0 },
    thead: { tbody: !0, tfoot: !0 },
    tr: { tr: !0 }
  }
function nD(n) {
  return (
    n == 45 ||
    n == 46 ||
    n == 58 ||
    (n >= 65 && n <= 90) ||
    n == 95 ||
    (n >= 97 && n <= 122) ||
    n >= 161
  )
}
function gS(n) {
  return n == 9 || n == 10 || n == 13 || n == 32
}
let rm = null,
  im = null,
  sm = 0
function cf(n, e) {
  let t = n.pos + e
  if (sm == t && im == n) return rm
  let r = n.peek(e)
  for (; gS(r); ) r = n.peek(++e)
  let i = ''
  for (; nD(r); ) (i += String.fromCharCode(r)), (r = n.peek(++e))
  return (
    (im = n),
    (sm = t),
    (rm = i ? i.toLowerCase() : r == rD || r == iD ? void 0 : null)
  )
}
const yS = 60,
  za = 62,
  uh = 47,
  rD = 63,
  iD = 33,
  sD = 45
function om(n, e) {
  ;(this.name = n), (this.parent = e), (this.hash = e ? e.hash : 0)
  for (let t = 0; t < n.length; t++)
    this.hash += (this.hash << 4) + n.charCodeAt(t) + (n.charCodeAt(t) << 8)
}
const oD = [qa, pS, uS, fS, hS],
  aD = new Hv({
    start: null,
    shift(n, e, t, r) {
      return oD.indexOf(e) > -1 ? new om(cf(r, 1) || '', n) : n
    },
    reduce(n, e) {
      return e == dS && n ? n.parent : n
    },
    reuse(n, e, t, r) {
      let i = e.type.id
      return i == qa || i == G2 ? new om(cf(r, 1) || '', n) : n
    },
    hash(n) {
      return n ? n.hash : 0
    },
    strict: !1
  }),
  lD = new cn(
    (n, e) => {
      if (n.next != yS) {
        n.next < 0 && e.context && n.acceptToken(Pc)
        return
      }
      n.advance()
      let t = n.next == uh
      t && n.advance()
      let r = cf(n, 0)
      if (r === void 0) return
      if (!r) return n.acceptToken(t ? L2 : qa)
      let i = e.context ? e.context.name : null
      if (t) {
        if (r == i) return n.acceptToken(M2)
        if (i && tD[i]) return n.acceptToken(Pc, -2)
        if (e.dialectEnabled(K2)) return n.acceptToken(V2)
        for (let s = e.context; s; s = s.parent) if (s.name == r) return
        n.acceptToken(W2)
      } else {
        if (r == 'script') return n.acceptToken(uS)
        if (r == 'style') return n.acceptToken(fS)
        if (r == 'textarea') return n.acceptToken(hS)
        if (eD.hasOwnProperty(r)) return n.acceptToken(pS)
        i && nm[i] && nm[i][r] ? n.acceptToken(Pc, -1) : n.acceptToken(qa)
      }
    },
    { contextual: !0 }
  ),
  cD = new cn((n) => {
    for (let e = 0, t = 0; ; t++) {
      if (n.next < 0) {
        t && n.acceptToken(tm)
        break
      }
      if (n.next == sD) e++
      else if (n.next == za && e >= 2) {
        t > 3 && n.acceptToken(tm, -2)
        break
      } else e = 0
      n.advance()
    }
  })
function uD(n) {
  for (; n; n = n.parent) if (n.name == 'svg' || n.name == 'math') return !0
  return !1
}
const fD = new cn((n, e) => {
  if (n.next == uh && n.peek(1) == za) {
    let t = e.dialectEnabled(J2) || uD(e.context)
    n.acceptToken(t ? N2 : em, 2)
  } else n.next == za && n.acceptToken(em, 1)
})
function fh(n, e, t) {
  let r = 2 + n.length
  return new cn((i) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (i.next < 0) {
        a && i.acceptToken(e)
        break
      }
      if (
        (s == 0 && i.next == yS) ||
        (s == 1 && i.next == uh) ||
        (s >= 2 && s < r && i.next == n.charCodeAt(s - 2))
      )
        s++, o++
      else if ((s == 2 || s == r) && gS(i.next)) o++
      else if (s == r && i.next == za) {
        a > o ? i.acceptToken(e, -o) : i.acceptToken(t, -(o - 2))
        break
      } else if ((i.next == 10 || i.next == 13) && a) {
        i.acceptToken(e, 1)
        break
      } else s = o = 0
      i.advance()
    }
  })
}
const hD = fh('script', E2, D2),
  pD = fh('style', X2, Y2),
  dD = fh('textarea', I2, j2),
  OD = vl({
    'Text RawText': m.content,
    'StartTag StartCloseTag SelfClosingEndTag EndTag': m.angleBracket,
    TagName: m.tagName,
    'MismatchedCloseTag/TagName': [m.tagName, m.invalid],
    AttributeName: m.attributeName,
    'AttributeValue UnquotedAttributeValue': m.attributeValue,
    Is: m.definitionOperator,
    'EntityReference CharacterReference': m.character,
    Comment: m.blockComment,
    ProcessingInst: m.processingInstruction,
    DoctypeDecl: m.documentMeta
  }),
  mD = ni.deserialize({
    version: 14,
    states:
      ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
    stateData:
      '+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~',
    goto: '%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp',
    nodeNames:
      ' StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl',
    maxTerm: 67,
    context: aD,
    nodeProps: [
      [
        'closedBy',
        -10,
        1,
        2,
        3,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        'EndTag',
        6,
        'EndTag SelfClosingEndTag',
        -4,
        21,
        30,
        33,
        36,
        'CloseTag'
      ],
      [
        'openedBy',
        4,
        'StartTag StartCloseTag',
        5,
        'StartTag',
        -4,
        29,
        32,
        35,
        37,
        'OpenTag'
      ],
      [
        'group',
        -9,
        14,
        17,
        18,
        19,
        20,
        39,
        40,
        41,
        42,
        'Entity',
        16,
        'Entity TextContent',
        -3,
        28,
        31,
        34,
        'TextContent Entity'
      ]
    ],
    propSources: [OD],
    skippedNodes: [0],
    repeatNodeCount: 9,
    tokenData:
      "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
    tokenizers: [hD, pD, dD, fD, lD, cD, 0, 1, 2, 3, 4, 5],
    topRules: { Document: [0, 15] },
    dialects: { noMatch: 0, selfClosing: 485 },
    tokenPrec: 487
  })
function bS(n, e) {
  let t = Object.create(null)
  for (let r of n.getChildren(OS)) {
    let i = r.getChild(U2),
      s = r.getChild(lf) || r.getChild(mS)
    i &&
      (t[e.read(i.from, i.to)] = s
        ? s.type.id == lf
          ? e.read(s.from + 1, s.to - 1)
          : e.read(s.from, s.to)
        : '')
  }
  return t
}
function am(n, e) {
  let t = n.getChild(B2)
  return t ? e.read(t.from, t.to) : ' '
}
function Tc(n, e, t) {
  let r
  for (let i of t)
    if (!i.attrs || i.attrs(r || (r = bS(n.node.parent.firstChild, e))))
      return { parser: i.parser }
  return null
}
function vS(n = [], e = []) {
  let t = [],
    r = [],
    i = [],
    s = []
  for (let a of n)
    (a.tag == 'script'
      ? t
      : a.tag == 'style'
        ? r
        : a.tag == 'textarea'
          ? i
          : s
    ).push(a)
  let o = e.length ? Object.create(null) : null
  for (let a of e) (o[a.name] || (o[a.name] = [])).push(a)
  return N_((a, l) => {
    let c = a.type.id
    if (c == q2) return Tc(a, l, t)
    if (c == z2) return Tc(a, l, r)
    if (c == F2) return Tc(a, l, i)
    if (c == dS && s.length) {
      let u = a.node,
        f = u.firstChild,
        p = f && am(f, l),
        d
      if (p) {
        for (let O of s)
          if (O.tag == p && (!O.attrs || O.attrs(d || (d = bS(u, l))))) {
            let g = u.lastChild
            return {
              parser: O.parser,
              overlay: [{ from: f.to, to: g.type.id == H2 ? g.from : u.to }]
            }
          }
      }
    }
    if (o && c == OS) {
      let u = a.node,
        f
      if ((f = u.firstChild)) {
        let p = o[l.read(f.from, f.to)]
        if (p)
          for (let d of p) {
            if (d.tagName && d.tagName != am(u.parent, l)) continue
            let O = u.lastChild
            if (O.type.id == lf) {
              let g = O.from + 1,
                b = O.lastChild,
                x = O.to - (b && b.isError ? 0 : 1)
              if (x > g)
                return { parser: d.parser, overlay: [{ from: g, to: x }] }
            } else if (O.type.id == mS)
              return { parser: d.parser, overlay: [{ from: O.from, to: O.to }] }
          }
      }
    }
    return null
  })
}
const gD = 96,
  lm = 1,
  yD = 97,
  bD = 98,
  cm = 2,
  SS = [
    9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,
    8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288
  ],
  vD = 58,
  SD = 40,
  xS = 95,
  xD = 91,
  Uo = 45,
  wD = 46,
  PD = 35,
  TD = 37,
  $D = 38,
  QD = 92,
  kD = 10
function Fa(n) {
  return (n >= 65 && n <= 90) || (n >= 97 && n <= 122) || n >= 161
}
function CD(n) {
  return n >= 48 && n <= 57
}
const _D = new cn((n, e) => {
    for (let t = !1, r = 0, i = 0; ; i++) {
      let { next: s } = n
      if (Fa(s) || s == Uo || s == xS || (t && CD(s)))
        !t && (s != Uo || i > 0) && (t = !0),
          r === i && s == Uo && r++,
          n.advance()
      else if (s == QD && n.peek(1) != kD)
        n.advance(), n.next > -1 && n.advance(), (t = !0)
      else {
        t && n.acceptToken(s == SD ? yD : r == 2 && e.canShift(cm) ? cm : bD)
        break
      }
    }
  }),
  RD = new cn((n) => {
    if (SS.includes(n.peek(-1))) {
      let { next: e } = n
      ;(Fa(e) ||
        e == xS ||
        e == PD ||
        e == wD ||
        e == xD ||
        e == vD ||
        e == Uo ||
        e == $D) &&
        n.acceptToken(gD)
    }
  }),
  ZD = new cn((n) => {
    if (!SS.includes(n.peek(-1))) {
      let { next: e } = n
      if ((e == TD && (n.advance(), n.acceptToken(lm)), Fa(e))) {
        do n.advance()
        while (Fa(n.next))
        n.acceptToken(lm)
      }
    }
  }),
  AD = vl({
    'AtKeyword import charset namespace keyframes media supports':
      m.definitionKeyword,
    'from to selector': m.keyword,
    NamespaceName: m.namespace,
    KeyframeName: m.labelName,
    KeyframeRangeName: m.operatorKeyword,
    TagName: m.tagName,
    ClassName: m.className,
    PseudoClassName: m.constant(m.className),
    IdName: m.labelName,
    'FeatureName PropertyName': m.propertyName,
    AttributeName: m.attributeName,
    NumberLiteral: m.number,
    KeywordQuery: m.keyword,
    UnaryQueryOp: m.operatorKeyword,
    'CallTag ValueName': m.atom,
    VariableName: m.variableName,
    Callee: m.operatorKeyword,
    Unit: m.unit,
    'UniversalSelector NestingSelector': m.definitionOperator,
    MatchOp: m.compareOperator,
    'ChildOp SiblingOp, LogicOp': m.logicOperator,
    BinOp: m.arithmeticOperator,
    Important: m.modifier,
    Comment: m.blockComment,
    ColorLiteral: m.color,
    'ParenthesizedContent StringLiteral': m.string,
    ':': m.punctuation,
    'PseudoOp #': m.derefOperator,
    '; ,': m.separator,
    '( )': m.paren,
    '[ ]': m.squareBracket,
    '{ }': m.brace
  }),
  ED = {
    __proto__: null,
    lang: 32,
    'nth-child': 32,
    'nth-last-child': 32,
    'nth-of-type': 32,
    'nth-last-of-type': 32,
    dir: 32,
    'host-context': 32,
    url: 60,
    'url-prefix': 60,
    domain: 60,
    regexp: 60,
    selector: 134
  },
  DD = {
    __proto__: null,
    '@import': 114,
    '@media': 138,
    '@charset': 142,
    '@namespace': 146,
    '@keyframes': 152,
    '@supports': 164
  },
  XD = { __proto__: null, not: 128, only: 128 },
  YD = ni.deserialize({
    version: 14,
    states:
      "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
    stateData:
      ':k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~',
    goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
    nodeNames:
      ' Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles',
    maxTerm: 114,
    nodeProps: [
      ['openedBy', 17, '(', 48, '{'],
      ['closedBy', 18, ')', 49, '}']
    ],
    propSources: [AD],
    skippedNodes: [0, 3, 85],
    repeatNodeCount: 10,
    tokenData:
      "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
    tokenizers: [
      RD,
      ZD,
      _D,
      1,
      2,
      3,
      4,
      new Ua('m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~', 28, 102)
    ],
    topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
    specialized: [
      { term: 97, get: (n) => ED[n] || -1 },
      { term: 56, get: (n) => DD[n] || -1 },
      { term: 98, get: (n) => XD[n] || -1 }
    ],
    tokenPrec: 1169
  })
let $c = null
function Qc() {
  if (!$c && typeof document == 'object' && document.body) {
    let { style: n } = document.body,
      e = [],
      t = new Set()
    for (let r in n)
      r != 'cssText' &&
        r != 'cssFloat' &&
        typeof n[r] == 'string' &&
        (/[A-Z]/.test(r) &&
          (r = r.replace(/[A-Z]/g, (i) => '-' + i.toLowerCase())),
        t.has(r) || (e.push(r), t.add(r)))
    $c = e.sort().map((r) => ({ type: 'property', label: r }))
  }
  return $c || []
}
const um = [
    'active',
    'after',
    'any-link',
    'autofill',
    'backdrop',
    'before',
    'checked',
    'cue',
    'default',
    'defined',
    'disabled',
    'empty',
    'enabled',
    'file-selector-button',
    'first',
    'first-child',
    'first-letter',
    'first-line',
    'first-of-type',
    'focus',
    'focus-visible',
    'focus-within',
    'fullscreen',
    'has',
    'host',
    'host-context',
    'hover',
    'in-range',
    'indeterminate',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'marker',
    'modal',
    'not',
    'nth-child',
    'nth-last-child',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'part',
    'placeholder',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'selection',
    'slotted',
    'target',
    'target-text',
    'valid',
    'visited',
    'where'
  ].map((n) => ({ type: 'class', label: n })),
  fm = [
    'above',
    'absolute',
    'activeborder',
    'additive',
    'activecaption',
    'after-white-space',
    'ahead',
    'alias',
    'all',
    'all-scroll',
    'alphabetic',
    'alternate',
    'always',
    'antialiased',
    'appworkspace',
    'asterisks',
    'attr',
    'auto',
    'auto-flow',
    'avoid',
    'avoid-column',
    'avoid-page',
    'avoid-region',
    'axis-pan',
    'background',
    'backwards',
    'baseline',
    'below',
    'bidi-override',
    'blink',
    'block',
    'block-axis',
    'bold',
    'bolder',
    'border',
    'border-box',
    'both',
    'bottom',
    'break',
    'break-all',
    'break-word',
    'bullets',
    'button',
    'button-bevel',
    'buttonface',
    'buttonhighlight',
    'buttonshadow',
    'buttontext',
    'calc',
    'capitalize',
    'caps-lock-indicator',
    'caption',
    'captiontext',
    'caret',
    'cell',
    'center',
    'checkbox',
    'circle',
    'cjk-decimal',
    'clear',
    'clip',
    'close-quote',
    'col-resize',
    'collapse',
    'color',
    'color-burn',
    'color-dodge',
    'column',
    'column-reverse',
    'compact',
    'condensed',
    'contain',
    'content',
    'contents',
    'content-box',
    'context-menu',
    'continuous',
    'copy',
    'counter',
    'counters',
    'cover',
    'crop',
    'cross',
    'crosshair',
    'currentcolor',
    'cursive',
    'cyclic',
    'darken',
    'dashed',
    'decimal',
    'decimal-leading-zero',
    'default',
    'default-button',
    'dense',
    'destination-atop',
    'destination-in',
    'destination-out',
    'destination-over',
    'difference',
    'disc',
    'discard',
    'disclosure-closed',
    'disclosure-open',
    'document',
    'dot-dash',
    'dot-dot-dash',
    'dotted',
    'double',
    'down',
    'e-resize',
    'ease',
    'ease-in',
    'ease-in-out',
    'ease-out',
    'element',
    'ellipse',
    'ellipsis',
    'embed',
    'end',
    'ethiopic-abegede-gez',
    'ethiopic-halehame-aa-er',
    'ethiopic-halehame-gez',
    'ew-resize',
    'exclusion',
    'expanded',
    'extends',
    'extra-condensed',
    'extra-expanded',
    'fantasy',
    'fast',
    'fill',
    'fill-box',
    'fixed',
    'flat',
    'flex',
    'flex-end',
    'flex-start',
    'footnotes',
    'forwards',
    'from',
    'geometricPrecision',
    'graytext',
    'grid',
    'groove',
    'hand',
    'hard-light',
    'help',
    'hidden',
    'hide',
    'higher',
    'highlight',
    'highlighttext',
    'horizontal',
    'hsl',
    'hsla',
    'hue',
    'icon',
    'ignore',
    'inactiveborder',
    'inactivecaption',
    'inactivecaptiontext',
    'infinite',
    'infobackground',
    'infotext',
    'inherit',
    'initial',
    'inline',
    'inline-axis',
    'inline-block',
    'inline-flex',
    'inline-grid',
    'inline-table',
    'inset',
    'inside',
    'intrinsic',
    'invert',
    'italic',
    'justify',
    'keep-all',
    'landscape',
    'large',
    'larger',
    'left',
    'level',
    'lighter',
    'lighten',
    'line-through',
    'linear',
    'linear-gradient',
    'lines',
    'list-item',
    'listbox',
    'listitem',
    'local',
    'logical',
    'loud',
    'lower',
    'lower-hexadecimal',
    'lower-latin',
    'lower-norwegian',
    'lowercase',
    'ltr',
    'luminosity',
    'manipulation',
    'match',
    'matrix',
    'matrix3d',
    'medium',
    'menu',
    'menutext',
    'message-box',
    'middle',
    'min-intrinsic',
    'mix',
    'monospace',
    'move',
    'multiple',
    'multiple_mask_images',
    'multiply',
    'n-resize',
    'narrower',
    'ne-resize',
    'nesw-resize',
    'no-close-quote',
    'no-drop',
    'no-open-quote',
    'no-repeat',
    'none',
    'normal',
    'not-allowed',
    'nowrap',
    'ns-resize',
    'numbers',
    'numeric',
    'nw-resize',
    'nwse-resize',
    'oblique',
    'opacity',
    'open-quote',
    'optimizeLegibility',
    'optimizeSpeed',
    'outset',
    'outside',
    'outside-shape',
    'overlay',
    'overline',
    'padding',
    'padding-box',
    'painted',
    'page',
    'paused',
    'perspective',
    'pinch-zoom',
    'plus-darker',
    'plus-lighter',
    'pointer',
    'polygon',
    'portrait',
    'pre',
    'pre-line',
    'pre-wrap',
    'preserve-3d',
    'progress',
    'push-button',
    'radial-gradient',
    'radio',
    'read-only',
    'read-write',
    'read-write-plaintext-only',
    'rectangle',
    'region',
    'relative',
    'repeat',
    'repeating-linear-gradient',
    'repeating-radial-gradient',
    'repeat-x',
    'repeat-y',
    'reset',
    'reverse',
    'rgb',
    'rgba',
    'ridge',
    'right',
    'rotate',
    'rotate3d',
    'rotateX',
    'rotateY',
    'rotateZ',
    'round',
    'row',
    'row-resize',
    'row-reverse',
    'rtl',
    'run-in',
    'running',
    's-resize',
    'sans-serif',
    'saturation',
    'scale',
    'scale3d',
    'scaleX',
    'scaleY',
    'scaleZ',
    'screen',
    'scroll',
    'scrollbar',
    'scroll-position',
    'se-resize',
    'self-start',
    'self-end',
    'semi-condensed',
    'semi-expanded',
    'separate',
    'serif',
    'show',
    'single',
    'skew',
    'skewX',
    'skewY',
    'skip-white-space',
    'slide',
    'slider-horizontal',
    'slider-vertical',
    'sliderthumb-horizontal',
    'sliderthumb-vertical',
    'slow',
    'small',
    'small-caps',
    'small-caption',
    'smaller',
    'soft-light',
    'solid',
    'source-atop',
    'source-in',
    'source-out',
    'source-over',
    'space',
    'space-around',
    'space-between',
    'space-evenly',
    'spell-out',
    'square',
    'start',
    'static',
    'status-bar',
    'stretch',
    'stroke',
    'stroke-box',
    'sub',
    'subpixel-antialiased',
    'svg_masks',
    'super',
    'sw-resize',
    'symbolic',
    'symbols',
    'system-ui',
    'table',
    'table-caption',
    'table-cell',
    'table-column',
    'table-column-group',
    'table-footer-group',
    'table-header-group',
    'table-row',
    'table-row-group',
    'text',
    'text-bottom',
    'text-top',
    'textarea',
    'textfield',
    'thick',
    'thin',
    'threeddarkshadow',
    'threedface',
    'threedhighlight',
    'threedlightshadow',
    'threedshadow',
    'to',
    'top',
    'transform',
    'translate',
    'translate3d',
    'translateX',
    'translateY',
    'translateZ',
    'transparent',
    'ultra-condensed',
    'ultra-expanded',
    'underline',
    'unidirectional-pan',
    'unset',
    'up',
    'upper-latin',
    'uppercase',
    'url',
    'var',
    'vertical',
    'vertical-text',
    'view-box',
    'visible',
    'visibleFill',
    'visiblePainted',
    'visibleStroke',
    'visual',
    'w-resize',
    'wait',
    'wave',
    'wider',
    'window',
    'windowframe',
    'windowtext',
    'words',
    'wrap',
    'wrap-reverse',
    'x-large',
    'x-small',
    'xor',
    'xx-large',
    'xx-small'
  ]
    .map((n) => ({ type: 'keyword', label: n }))
    .concat(
      [
        'aliceblue',
        'antiquewhite',
        'aqua',
        'aquamarine',
        'azure',
        'beige',
        'bisque',
        'black',
        'blanchedalmond',
        'blue',
        'blueviolet',
        'brown',
        'burlywood',
        'cadetblue',
        'chartreuse',
        'chocolate',
        'coral',
        'cornflowerblue',
        'cornsilk',
        'crimson',
        'cyan',
        'darkblue',
        'darkcyan',
        'darkgoldenrod',
        'darkgray',
        'darkgreen',
        'darkkhaki',
        'darkmagenta',
        'darkolivegreen',
        'darkorange',
        'darkorchid',
        'darkred',
        'darksalmon',
        'darkseagreen',
        'darkslateblue',
        'darkslategray',
        'darkturquoise',
        'darkviolet',
        'deeppink',
        'deepskyblue',
        'dimgray',
        'dodgerblue',
        'firebrick',
        'floralwhite',
        'forestgreen',
        'fuchsia',
        'gainsboro',
        'ghostwhite',
        'gold',
        'goldenrod',
        'gray',
        'grey',
        'green',
        'greenyellow',
        'honeydew',
        'hotpink',
        'indianred',
        'indigo',
        'ivory',
        'khaki',
        'lavender',
        'lavenderblush',
        'lawngreen',
        'lemonchiffon',
        'lightblue',
        'lightcoral',
        'lightcyan',
        'lightgoldenrodyellow',
        'lightgray',
        'lightgreen',
        'lightpink',
        'lightsalmon',
        'lightseagreen',
        'lightskyblue',
        'lightslategray',
        'lightsteelblue',
        'lightyellow',
        'lime',
        'limegreen',
        'linen',
        'magenta',
        'maroon',
        'mediumaquamarine',
        'mediumblue',
        'mediumorchid',
        'mediumpurple',
        'mediumseagreen',
        'mediumslateblue',
        'mediumspringgreen',
        'mediumturquoise',
        'mediumvioletred',
        'midnightblue',
        'mintcream',
        'mistyrose',
        'moccasin',
        'navajowhite',
        'navy',
        'oldlace',
        'olive',
        'olivedrab',
        'orange',
        'orangered',
        'orchid',
        'palegoldenrod',
        'palegreen',
        'paleturquoise',
        'palevioletred',
        'papayawhip',
        'peachpuff',
        'peru',
        'pink',
        'plum',
        'powderblue',
        'purple',
        'rebeccapurple',
        'red',
        'rosybrown',
        'royalblue',
        'saddlebrown',
        'salmon',
        'sandybrown',
        'seagreen',
        'seashell',
        'sienna',
        'silver',
        'skyblue',
        'slateblue',
        'slategray',
        'snow',
        'springgreen',
        'steelblue',
        'tan',
        'teal',
        'thistle',
        'tomato',
        'turquoise',
        'violet',
        'wheat',
        'white',
        'whitesmoke',
        'yellow',
        'yellowgreen'
      ].map((n) => ({ type: 'constant', label: n }))
    ),
  ID = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'b',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'figcaption',
    'figure',
    'footer',
    'form',
    'header',
    'hgroup',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'meter',
    'nav',
    'ol',
    'output',
    'p',
    'pre',
    'ruby',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'tr',
    'u',
    'ul'
  ].map((n) => ({ type: 'type', label: n })),
  kn = /^(\w[\w-]*|-\w[\w-]*|)$/,
  jD = /^-(-[\w-]*)?$/
function ND(n, e) {
  var t
  if (
    ((n.name == '(' || n.type.isError) && (n = n.parent || n),
    n.name != 'ArgList')
  )
    return !1
  let r = (t = n.parent) === null || t === void 0 ? void 0 : t.firstChild
  return (r == null ? void 0 : r.name) != 'Callee'
    ? !1
    : e.sliceString(r.from, r.to) == 'var'
}
const hm = new xb(),
  MD = ['Declaration']
function VD(n) {
  for (let e = n; ; ) {
    if (e.type.isTop) return e
    if (!(e = e.parent)) return n
  }
}
function wS(n, e, t) {
  if (e.to - e.from > 4096) {
    let r = hm.get(e)
    if (r) return r
    let i = [],
      s = new Set(),
      o = e.cursor(Oe.IncludeAnonymous)
    if (o.firstChild())
      do
        for (let a of wS(n, o.node, t))
          s.has(a.label) || (s.add(a.label), i.push(a))
      while (o.nextSibling())
    return hm.set(e, i), i
  } else {
    let r = [],
      i = new Set()
    return (
      e.cursor().iterate((s) => {
        var o
        if (
          t(s) &&
          s.matchContext(MD) &&
          ((o = s.node.nextSibling) === null || o === void 0
            ? void 0
            : o.name) == ':'
        ) {
          let a = n.sliceString(s.from, s.to)
          i.has(a) || (i.add(a), r.push({ label: a, type: 'variable' }))
        }
      }),
      r
    )
  }
}
const WD = (n) => (e) => {
    let { state: t, pos: r } = e,
      i = ke(t).resolveInner(r, -1),
      s =
        i.type.isError &&
        i.from == i.to - 1 &&
        t.doc.sliceString(i.from, i.to) == '-'
    if (
      i.name == 'PropertyName' ||
      ((s || i.name == 'TagName') &&
        /^(Block|Styles)$/.test(i.resolve(i.to).name))
    )
      return { from: i.from, options: Qc(), validFor: kn }
    if (i.name == 'ValueName')
      return { from: i.from, options: fm, validFor: kn }
    if (i.name == 'PseudoClassName')
      return { from: i.from, options: um, validFor: kn }
    if (n(i) || ((e.explicit || s) && ND(i, t.doc)))
      return {
        from: n(i) || s ? i.from : r,
        options: wS(t.doc, VD(i), n),
        validFor: jD
      }
    if (i.name == 'TagName') {
      for (let { parent: l } = i; l; l = l.parent)
        if (l.name == 'Block')
          return { from: i.from, options: Qc(), validFor: kn }
      return { from: i.from, options: ID, validFor: kn }
    }
    if (!e.explicit) return null
    let o = i.resolve(r),
      a = o.childBefore(r)
    return a && a.name == ':' && o.name == 'PseudoClassSelector'
      ? { from: r, options: um, validFor: kn }
      : (a && a.name == ':' && o.name == 'Declaration') || o.name == 'ArgList'
        ? { from: r, options: fm, validFor: kn }
        : o.name == 'Block' || o.name == 'Styles'
          ? { from: r, options: Qc(), validFor: kn }
          : null
  },
  LD = WD((n) => n.name == 'VariableName'),
  Ga = Kr.define({
    name: 'css',
    parser: YD.configure({
      props: [
        xl.add({ Declaration: Wo() }),
        wl.add({ 'Block KeyframeList': _b })
      ]
    }),
    languageData: {
      commentTokens: { block: { open: '/*', close: '*/' } },
      indentOnInput: /^\s*\}$/,
      wordChars: '-'
    }
  })
function BD() {
  return new Uf(Ga, Ga.data.of({ autocomplete: LD }))
}
const _i = ['_blank', '_self', '_top', '_parent'],
  kc = ['ascii', 'utf-8', 'utf-16', 'latin1', 'latin1'],
  Cc = ['get', 'post', 'put', 'delete'],
  _c = [
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain'
  ],
  pt = ['true', 'false'],
  F = {},
  UD = {
    a: {
      attrs: {
        href: null,
        ping: null,
        type: null,
        media: null,
        target: _i,
        hreflang: null
      }
    },
    abbr: F,
    address: F,
    area: {
      attrs: {
        alt: null,
        coords: null,
        href: null,
        target: null,
        ping: null,
        media: null,
        hreflang: null,
        type: null,
        shape: ['default', 'rect', 'circle', 'poly']
      }
    },
    article: F,
    aside: F,
    audio: {
      attrs: {
        src: null,
        mediagroup: null,
        crossorigin: ['anonymous', 'use-credentials'],
        preload: ['none', 'metadata', 'auto'],
        autoplay: ['autoplay'],
        loop: ['loop'],
        controls: ['controls']
      }
    },
    b: F,
    base: { attrs: { href: null, target: _i } },
    bdi: F,
    bdo: F,
    blockquote: { attrs: { cite: null } },
    body: F,
    br: F,
    button: {
      attrs: {
        form: null,
        formaction: null,
        name: null,
        value: null,
        autofocus: ['autofocus'],
        disabled: ['autofocus'],
        formenctype: _c,
        formmethod: Cc,
        formnovalidate: ['novalidate'],
        formtarget: _i,
        type: ['submit', 'reset', 'button']
      }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: F,
    center: F,
    cite: F,
    code: F,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ['command', 'checkbox', 'radio'],
        label: null,
        icon: null,
        radiogroup: null,
        command: null,
        title: null,
        disabled: ['disabled'],
        checked: ['checked']
      }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ['disabled'], multiple: ['multiple'] } },
    datalist: { attrs: { data: null } },
    dd: F,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ['open'] } },
    dfn: F,
    div: F,
    dl: F,
    dt: F,
    em: F,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ['disabled'], form: null, name: null } },
    figcaption: F,
    figure: F,
    footer: F,
    form: {
      attrs: {
        action: null,
        name: null,
        'accept-charset': kc,
        autocomplete: ['on', 'off'],
        enctype: _c,
        method: Cc,
        novalidate: ['novalidate'],
        target: _i
      }
    },
    h1: F,
    h2: F,
    h3: F,
    h4: F,
    h5: F,
    h6: F,
    head: {
      children: [
        'title',
        'base',
        'link',
        'style',
        'meta',
        'script',
        'noscript',
        'command'
      ]
    },
    header: F,
    hgroup: F,
    hr: F,
    html: { attrs: { manifest: null } },
    i: F,
    iframe: {
      attrs: {
        src: null,
        srcdoc: null,
        name: null,
        width: null,
        height: null,
        sandbox: [
          'allow-top-navigation',
          'allow-same-origin',
          'allow-forms',
          'allow-scripts'
        ],
        seamless: ['seamless']
      }
    },
    img: {
      attrs: {
        alt: null,
        src: null,
        ismap: null,
        usemap: null,
        width: null,
        height: null,
        crossorigin: ['anonymous', 'use-credentials']
      }
    },
    input: {
      attrs: {
        alt: null,
        dirname: null,
        form: null,
        formaction: null,
        height: null,
        list: null,
        max: null,
        maxlength: null,
        min: null,
        name: null,
        pattern: null,
        placeholder: null,
        size: null,
        src: null,
        step: null,
        value: null,
        width: null,
        accept: ['audio/*', 'video/*', 'image/*'],
        autocomplete: ['on', 'off'],
        autofocus: ['autofocus'],
        checked: ['checked'],
        disabled: ['disabled'],
        formenctype: _c,
        formmethod: Cc,
        formnovalidate: ['novalidate'],
        formtarget: _i,
        multiple: ['multiple'],
        readonly: ['readonly'],
        required: ['required'],
        type: [
          'hidden',
          'text',
          'search',
          'tel',
          'url',
          'email',
          'password',
          'datetime',
          'date',
          'month',
          'week',
          'time',
          'datetime-local',
          'number',
          'range',
          'color',
          'checkbox',
          'radio',
          'file',
          'submit',
          'image',
          'reset',
          'button'
        ]
      }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: F,
    keygen: {
      attrs: {
        challenge: null,
        form: null,
        name: null,
        autofocus: ['autofocus'],
        disabled: ['disabled'],
        keytype: ['RSA']
      }
    },
    label: { attrs: { for: null, form: null } },
    legend: F,
    li: { attrs: { value: null } },
    link: {
      attrs: {
        href: null,
        type: null,
        hreflang: null,
        media: null,
        sizes: ['all', '16x16', '16x16 32x32', '16x16 32x32 64x64']
      }
    },
    map: { attrs: { name: null } },
    mark: F,
    menu: { attrs: { label: null, type: ['list', 'context', 'toolbar'] } },
    meta: {
      attrs: {
        content: null,
        charset: kc,
        name: [
          'viewport',
          'application-name',
          'author',
          'description',
          'generator',
          'keywords'
        ],
        'http-equiv': [
          'content-language',
          'content-type',
          'default-style',
          'refresh'
        ]
      }
    },
    meter: {
      attrs: {
        value: null,
        min: null,
        low: null,
        high: null,
        max: null,
        optimum: null
      }
    },
    nav: F,
    noscript: F,
    object: {
      attrs: {
        data: null,
        type: null,
        name: null,
        usemap: null,
        form: null,
        width: null,
        height: null,
        typemustmatch: ['typemustmatch']
      }
    },
    ol: {
      attrs: {
        reversed: ['reversed'],
        start: null,
        type: ['1', 'a', 'A', 'i', 'I']
      },
      children: ['li', 'script', 'template', 'ul', 'ol']
    },
    optgroup: { attrs: { disabled: ['disabled'], label: null } },
    option: {
      attrs: {
        disabled: ['disabled'],
        label: null,
        selected: ['selected'],
        value: null
      }
    },
    output: { attrs: { for: null, form: null, name: null } },
    p: F,
    param: { attrs: { name: null, value: null } },
    pre: F,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: F,
    rt: F,
    ruby: F,
    samp: F,
    script: {
      attrs: {
        type: ['text/javascript'],
        src: null,
        async: ['async'],
        defer: ['defer'],
        charset: kc
      }
    },
    section: F,
    select: {
      attrs: {
        form: null,
        name: null,
        size: null,
        autofocus: ['autofocus'],
        disabled: ['disabled'],
        multiple: ['multiple']
      }
    },
    slot: { attrs: { name: null } },
    small: F,
    source: { attrs: { src: null, type: null, media: null } },
    span: F,
    strong: F,
    style: { attrs: { type: ['text/css'], media: null, scoped: null } },
    sub: F,
    summary: F,
    sup: F,
    table: F,
    tbody: F,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: F,
    textarea: {
      attrs: {
        dirname: null,
        form: null,
        maxlength: null,
        name: null,
        placeholder: null,
        rows: null,
        cols: null,
        autofocus: ['autofocus'],
        disabled: ['disabled'],
        readonly: ['readonly'],
        required: ['required'],
        wrap: ['soft', 'hard']
      }
    },
    tfoot: F,
    th: {
      attrs: {
        colspan: null,
        rowspan: null,
        headers: null,
        scope: ['row', 'col', 'rowgroup', 'colgroup']
      }
    },
    thead: F,
    time: { attrs: { datetime: null } },
    title: F,
    tr: F,
    track: {
      attrs: {
        src: null,
        label: null,
        default: null,
        kind: ['subtitles', 'captions', 'descriptions', 'chapters', 'metadata'],
        srclang: null
      }
    },
    ul: { children: ['li', 'script', 'template', 'ul', 'ol'] },
    var: F,
    video: {
      attrs: {
        src: null,
        poster: null,
        width: null,
        height: null,
        crossorigin: ['anonymous', 'use-credentials'],
        preload: ['auto', 'metadata', 'none'],
        autoplay: ['autoplay'],
        mediagroup: ['movie'],
        muted: ['muted'],
        controls: ['controls']
      }
    },
    wbr: F
  },
  PS = {
    accesskey: null,
    class: null,
    contenteditable: pt,
    contextmenu: null,
    dir: ['ltr', 'rtl', 'auto'],
    draggable: ['true', 'false', 'auto'],
    dropzone: ['copy', 'move', 'link', 'string:', 'file:'],
    hidden: ['hidden'],
    id: null,
    inert: ['inert'],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ['itemscope'],
    itemtype: null,
    lang: [
      'ar',
      'bn',
      'de',
      'en-GB',
      'en-US',
      'es',
      'fr',
      'hi',
      'id',
      'ja',
      'pa',
      'pt',
      'ru',
      'tr',
      'zh'
    ],
    spellcheck: pt,
    autocorrect: pt,
    autocapitalize: pt,
    style: null,
    tabindex: null,
    title: null,
    translate: ['yes', 'no'],
    rel: [
      'stylesheet',
      'alternate',
      'author',
      'bookmark',
      'help',
      'license',
      'next',
      'nofollow',
      'noreferrer',
      'prefetch',
      'prev',
      'search',
      'tag'
    ],
    role: 'alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer'.split(
      ' '
    ),
    'aria-activedescendant': null,
    'aria-atomic': pt,
    'aria-autocomplete': ['inline', 'list', 'both', 'none'],
    'aria-busy': pt,
    'aria-checked': ['true', 'false', 'mixed', 'undefined'],
    'aria-controls': null,
    'aria-describedby': null,
    'aria-disabled': pt,
    'aria-dropeffect': null,
    'aria-expanded': ['true', 'false', 'undefined'],
    'aria-flowto': null,
    'aria-grabbed': ['true', 'false', 'undefined'],
    'aria-haspopup': pt,
    'aria-hidden': pt,
    'aria-invalid': ['true', 'false', 'grammar', 'spelling'],
    'aria-label': null,
    'aria-labelledby': null,
    'aria-level': null,
    'aria-live': ['off', 'polite', 'assertive'],
    'aria-multiline': pt,
    'aria-multiselectable': pt,
    'aria-owns': null,
    'aria-posinset': null,
    'aria-pressed': ['true', 'false', 'mixed', 'undefined'],
    'aria-readonly': pt,
    'aria-relevant': null,
    'aria-required': pt,
    'aria-selected': ['true', 'false', 'undefined'],
    'aria-setsize': null,
    'aria-sort': ['ascending', 'descending', 'none', 'other'],
    'aria-valuemax': null,
    'aria-valuemin': null,
    'aria-valuenow': null,
    'aria-valuetext': null
  },
  TS =
    'beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload'
      .split(' ')
      .map((n) => 'on' + n)
for (let n of TS) PS[n] = null
class Ha {
  constructor(e, t) {
    ;(this.tags = Object.assign(Object.assign({}, UD), e)),
      (this.globalAttrs = Object.assign(Object.assign({}, PS), t)),
      (this.allTags = Object.keys(this.tags)),
      (this.globalAttrNames = Object.keys(this.globalAttrs))
  }
}
Ha.default = new Ha()
function ri(n, e, t = n.length) {
  if (!e) return ''
  let r = e.firstChild,
    i = r && r.getChild('TagName')
  return i ? n.sliceString(i.from, Math.min(i.to, t)) : ''
}
function ii(n, e = !1) {
  for (; n; n = n.parent)
    if (n.name == 'Element')
      if (e) e = !1
      else return n
  return null
}
function $S(n, e, t) {
  let r = t.tags[ri(n, ii(e))]
  return (r == null ? void 0 : r.children) || t.allTags
}
function hh(n, e) {
  let t = []
  for (let r = ii(e); r && !r.type.isTop; r = ii(r.parent)) {
    let i = ri(n, r)
    if (i && r.lastChild.name == 'CloseTag') break
    i &&
      t.indexOf(i) < 0 &&
      (e.name == 'EndTag' || e.from >= r.firstChild.to) &&
      t.push(i)
  }
  return t
}
const QS = /^[:\-\.\w\u00b7-\uffff]*$/
function pm(n, e, t, r, i) {
  let s = /\s*>/.test(n.sliceDoc(i, i + 5)) ? '' : '>',
    o = ii(t, !0)
  return {
    from: r,
    to: i,
    options: $S(n.doc, o, e)
      .map((a) => ({ label: a, type: 'type' }))
      .concat(
        hh(n.doc, t).map((a, l) => ({
          label: '/' + a,
          apply: '/' + a + s,
          type: 'type',
          boost: 99 - l
        }))
      ),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  }
}
function dm(n, e, t, r) {
  let i = /\s*>/.test(n.sliceDoc(r, r + 5)) ? '' : '>'
  return {
    from: t,
    to: r,
    options: hh(n.doc, e).map((s, o) => ({
      label: s,
      apply: s + i,
      type: 'type',
      boost: 99 - o
    })),
    validFor: QS
  }
}
function qD(n, e, t, r) {
  let i = [],
    s = 0
  for (let o of $S(n.doc, t, e)) i.push({ label: '<' + o, type: 'type' })
  for (let o of hh(n.doc, t))
    i.push({ label: '</' + o + '>', type: 'type', boost: 99 - s++ })
  return {
    from: r,
    to: r,
    options: i,
    validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
  }
}
function zD(n, e, t, r, i) {
  let s = ii(t),
    o = s ? e.tags[ri(n.doc, s)] : null,
    a = o && o.attrs ? Object.keys(o.attrs) : [],
    l =
      o && o.globalAttrs === !1
        ? a
        : a.length
          ? a.concat(e.globalAttrNames)
          : e.globalAttrNames
  return {
    from: r,
    to: i,
    options: l.map((c) => ({ label: c, type: 'property' })),
    validFor: QS
  }
}
function FD(n, e, t, r, i) {
  var s
  let o =
      (s = t.parent) === null || s === void 0
        ? void 0
        : s.getChild('AttributeName'),
    a = [],
    l
  if (o) {
    let c = n.sliceDoc(o.from, o.to),
      u = e.globalAttrs[c]
    if (!u) {
      let f = ii(t),
        p = f ? e.tags[ri(n.doc, f)] : null
      u = (p == null ? void 0 : p.attrs) && p.attrs[c]
    }
    if (u) {
      let f = n.sliceDoc(r, i).toLowerCase(),
        p = '"',
        d = '"'
      ;/^['"]/.test(f)
        ? ((l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/),
          (p = ''),
          (d = n.sliceDoc(i, i + 1) == f[0] ? '' : f[0]),
          (f = f.slice(1)),
          r++)
        : (l = /^[^\s<>='"]*$/)
      for (let O of u) a.push({ label: O, apply: p + O + d, type: 'constant' })
    }
  }
  return { from: r, to: i, options: a, validFor: l }
}
function GD(n, e) {
  let { state: t, pos: r } = e,
    i = ke(t).resolveInner(r, -1),
    s = i.resolve(r)
  for (let o = r, a; s == i && (a = i.childBefore(o)); ) {
    let l = a.lastChild
    if (!l || !l.type.isError || l.from < l.to) break
    ;(s = i = a), (o = l.from)
  }
  return i.name == 'TagName'
    ? i.parent && /CloseTag$/.test(i.parent.name)
      ? dm(t, i, i.from, r)
      : pm(t, n, i, i.from, r)
    : i.name == 'StartTag'
      ? pm(t, n, i, r, r)
      : i.name == 'StartCloseTag' || i.name == 'IncompleteCloseTag'
        ? dm(t, i, r, r)
        : (e.explicit && (i.name == 'OpenTag' || i.name == 'SelfClosingTag')) ||
            i.name == 'AttributeName'
          ? zD(t, n, i, i.name == 'AttributeName' ? i.from : r, r)
          : i.name == 'Is' ||
              i.name == 'AttributeValue' ||
              i.name == 'UnquotedAttributeValue'
            ? FD(t, n, i, i.name == 'Is' ? r : i.from, r)
            : e.explicit &&
                (s.name == 'Element' ||
                  s.name == 'Text' ||
                  s.name == 'Document')
              ? qD(t, n, i, r)
              : null
}
function HD(n) {
  let { extraTags: e, extraGlobalAttributes: t } = n,
    r = t || e ? new Ha(e, t) : Ha.default
  return (i) => GD(r, i)
}
const KD = rn.parser.configure({ top: 'SingleExpression' }),
  kS = [
    {
      tag: 'script',
      attrs: (n) => n.type == 'text/typescript' || n.lang == 'ts',
      parser: iS.parser
    },
    {
      tag: 'script',
      attrs: (n) => n.type == 'text/babel' || n.type == 'text/jsx',
      parser: sS.parser
    },
    {
      tag: 'script',
      attrs: (n) => n.type == 'text/typescript-jsx',
      parser: oS.parser
    },
    {
      tag: 'script',
      attrs: (n) => n.type == 'importmap' || n.type == 'speculationrules',
      parser: KD
    },
    {
      tag: 'script',
      attrs(n) {
        return (
          !n.type ||
          /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(
            n.type
          )
        )
      },
      parser: rn.parser
    },
    {
      tag: 'style',
      attrs(n) {
        return (
          (!n.lang || n.lang == 'css') &&
          (!n.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(n.type))
        )
      },
      parser: Ga.parser
    }
  ],
  CS = [
    { name: 'style', parser: Ga.parser.configure({ top: 'Styles' }) }
  ].concat(TS.map((n) => ({ name: n, parser: rn.parser }))),
  _S = Kr.define({
    name: 'html',
    parser: mD.configure({
      props: [
        xl.add({
          Element(n) {
            let e = /^(\s*)(<\/)?/.exec(n.textAfter)
            return n.node.to <= n.pos + e[0].length
              ? n.continue()
              : n.lineIndent(n.node.from) + (e[2] ? 0 : n.unit)
          },
          'OpenTag CloseTag SelfClosingTag'(n) {
            return n.column(n.node.from) + n.unit
          },
          Document(n) {
            if (n.pos + /\s*/.exec(n.textAfter)[0].length < n.node.to)
              return n.continue()
            let e = null,
              t
            for (let r = n.node; ; ) {
              let i = r.lastChild
              if (!i || i.name != 'Element' || i.to != r.to) break
              e = r = i
            }
            return e &&
              !(
                (t = e.lastChild) &&
                (t.name == 'CloseTag' || t.name == 'SelfClosingTag')
              )
              ? n.lineIndent(e.from) + n.unit
              : null
          }
        }),
        wl.add({
          Element(n) {
            let e = n.firstChild,
              t = n.lastChild
            return !e || e.name != 'OpenTag'
              ? null
              : { from: e.to, to: t.name == 'CloseTag' ? t.from : n.to }
          }
        }),
        Mb.add({ 'OpenTag CloseTag': (n) => n.getChild('TagName') })
      ]
    }),
    languageData: {
      commentTokens: { block: { open: '<!--', close: '-->' } },
      indentOnInput: /^\s*<\/\w+\W$/,
      wordChars: '-._'
    }
  }),
  qo = _S.configure({ wrap: vS(kS, CS) })
function JD(n = {}) {
  let e = '',
    t
  n.matchClosingTags === !1 && (e = 'noMatch'),
    n.selfClosingTags === !0 && (e = (e ? e + ' ' : '') + 'selfClosing'),
    ((n.nestedLanguages && n.nestedLanguages.length) ||
      (n.nestedAttributes && n.nestedAttributes.length)) &&
      (t = vS(
        (n.nestedLanguages || []).concat(kS),
        (n.nestedAttributes || []).concat(CS)
      ))
  let r = t
    ? _S.configure({ wrap: t, dialect: e })
    : e
      ? qo.configure({ dialect: e })
      : qo
  return new Uf(r, [
    qo.data.of({ autocomplete: HD(n) }),
    n.autoCloseTags !== !1 ? eX : [],
    cS().support,
    BD().support
  ])
}
const Om = new Set(
    'area base br col command embed frame hr img input keygen link meta param source track wbr menuitem'.split(
      ' '
    )
  ),
  eX = j.inputHandler.of((n, e, t, r, i) => {
    if (
      n.composing ||
      n.state.readOnly ||
      e != t ||
      (r != '>' && r != '/') ||
      !qo.isActiveAt(n.state, e, -1)
    )
      return !1
    let s = i(),
      { state: o } = s,
      a = o.changeByRange((l) => {
        var c, u, f
        let p = o.doc.sliceString(l.from - 1, l.to) == r,
          { head: d } = l,
          O = ke(o).resolveInner(d - 1, -1),
          g
        if (
          ((O.name == 'TagName' || O.name == 'StartTag') && (O = O.parent),
          p && r == '>' && O.name == 'OpenTag')
        ) {
          if (
            ((u =
              (c = O.parent) === null || c === void 0
                ? void 0
                : c.lastChild) === null || u === void 0
              ? void 0
              : u.name) != 'CloseTag' &&
            (g = ri(o.doc, O.parent, d)) &&
            !Om.has(g)
          ) {
            let b = d + (o.doc.sliceString(d, d + 1) === '>' ? 1 : 0),
              x = `</${g}>`
            return { range: l, changes: { from: d, to: b, insert: x } }
          }
        } else if (p && r == '/' && O.name == 'IncompleteCloseTag') {
          let b = O.parent
          if (
            O.from == d - 2 &&
            ((f = b.lastChild) === null || f === void 0 ? void 0 : f.name) !=
              'CloseTag' &&
            (g = ri(o.doc, b, d)) &&
            !Om.has(g)
          ) {
            let x = d + (o.doc.sliceString(d, d + 1) === '>' ? 1 : 0),
              w = `${g}>`
            return {
              range: C.cursor(d + w.length, -1),
              changes: { from: d, to: x, insert: w }
            }
          }
        }
        return { range: l }
      })
    return a.changes.empty
      ? !1
      : (n.dispatch([
          s,
          o.update(a, { userEvent: 'input.complete', scrollIntoView: !0 })
        ]),
        !0)
  })
var RS = (n) => {
    var { theme: e, settings: t = {}, styles: r = [] } = n,
      i = { '.cm-gutters': {} },
      s = {}
    t.background && (s.backgroundColor = t.background),
      t.backgroundImage && (s.backgroundImage = t.backgroundImage),
      t.foreground && (s.color = t.foreground),
      (t.background || t.foreground) && (i['&'] = s),
      t.fontFamily &&
        (i['&.cm-editor .cm-scroller'] = { fontFamily: t.fontFamily }),
      t.gutterBackground &&
        (i['.cm-gutters'].backgroundColor = t.gutterBackground),
      t.gutterForeground && (i['.cm-gutters'].color = t.gutterForeground),
      t.gutterBorder && (i['.cm-gutters'].borderRightColor = t.gutterBorder),
      t.caret &&
        ((i['.cm-content'] = { caretColor: t.caret }),
        (i['.cm-cursor, .cm-dropCursor'] = { borderLeftColor: t.caret }))
    var o = {}
    t.gutterActiveForeground && (o.color = t.gutterActiveForeground),
      t.lineHighlight &&
        ((i['.cm-activeLine'] = { backgroundColor: t.lineHighlight }),
        (o.backgroundColor = t.lineHighlight)),
      (i['.cm-activeLineGutter'] = o),
      t.selection &&
        (i[
          '&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection'
        ] = { background: t.selection + ' !important' }),
      t.selectionMatch &&
        (i['& .cm-selectionMatch'] = { backgroundColor: t.selectionMatch })
    var a = j.theme(i, { dark: e === 'dark' }),
      l = ai.define(r),
      c = [a, Gf(l)]
    return c
  },
  tX = {
    background: '#fff',
    foreground: '#24292e',
    selection: '#BBDFFF',
    selectionMatch: '#BBDFFF',
    gutterBackground: '#fff',
    gutterForeground: '#6e7781'
  },
  nX = (n) => {
    var { theme: e = 'light', settings: t = {}, styles: r = [] } = n || {}
    return RS({
      theme: e,
      settings: h._extends({}, tX, t),
      styles: [
        { tag: [m.standard(m.tagName), m.tagName], color: '#116329' },
        { tag: [m.comment, m.bracket], color: '#6a737d' },
        { tag: [m.className, m.propertyName], color: '#6f42c1' },
        {
          tag: [m.variableName, m.attributeName, m.number, m.operator],
          color: '#005cc5'
        },
        {
          tag: [m.keyword, m.typeName, m.typeOperator, m.typeName],
          color: '#d73a49'
        },
        { tag: [m.string, m.meta, m.regexp], color: '#032f62' },
        { tag: [m.name, m.quote], color: '#22863a' },
        { tag: [m.heading, m.strong], color: '#24292e', fontWeight: 'bold' },
        { tag: [m.emphasis], color: '#24292e', fontStyle: 'italic' },
        { tag: [m.deleted], color: '#b31d28', backgroundColor: 'ffeef0' },
        { tag: [m.atom, m.bool, m.special(m.variableName)], color: '#e36209' },
        { tag: [m.url, m.escape, m.regexp, m.link], color: '#032f62' },
        { tag: m.link, textDecoration: 'underline' },
        { tag: m.strikethrough, textDecoration: 'line-through' },
        { tag: m.invalid, color: '#cb2431' },
        ...r
      ]
    })
  },
  rX = nX(),
  iX = {
    background: '#0d1117',
    foreground: '#c9d1d9',
    caret: '#c9d1d9',
    selection: '#003d73',
    selectionMatch: '#003d73',
    lineHighlight: '#36334280'
  },
  sX = (n) => {
    var { theme: e = 'dark', settings: t = {}, styles: r = [] } = n || {}
    return RS({
      theme: e,
      settings: h._extends({}, iX, t),
      styles: [
        { tag: [m.standard(m.tagName), m.tagName], color: '#7ee787' },
        { tag: [m.comment, m.bracket], color: '#8b949e' },
        { tag: [m.className, m.propertyName], color: '#d2a8ff' },
        {
          tag: [m.variableName, m.attributeName, m.number, m.operator],
          color: '#79c0ff'
        },
        {
          tag: [m.keyword, m.typeName, m.typeOperator, m.typeName],
          color: '#ff7b72'
        },
        { tag: [m.string, m.meta, m.regexp], color: '#a5d6ff' },
        { tag: [m.name, m.quote], color: '#7ee787' },
        { tag: [m.heading, m.strong], color: '#d2a8ff', fontWeight: 'bold' },
        { tag: [m.emphasis], color: '#d2a8ff', fontStyle: 'italic' },
        { tag: [m.deleted], color: '#ffdcd7', backgroundColor: 'ffeef0' },
        { tag: [m.atom, m.bool, m.special(m.variableName)], color: '#ffab70' },
        { tag: m.link, textDecoration: 'underline' },
        { tag: m.strikethrough, textDecoration: 'line-through' },
        { tag: m.invalid, color: '#f97583' },
        ...r
      ]
    })
  }
sX()
function oX() {
  const n = { theme: rX, height: '450px' },
    { html: e, react: t, setGeneratedCode: r } = Oa()
  return h.jsxRuntimeExports.jsxs(hs, {
    children: [
      h.jsxRuntimeExports.jsx(Ur, {
        label: 'HTML / Bootstrap',
        children: h.jsxRuntimeExports.jsx(af, {
          ...n,
          value: e,
          extensions: [JD()],
          onChange: (i) => {
            r(i, 'html')
          }
        })
      }),
      h.jsxRuntimeExports.jsx(Ur, {
        label: 'React / Chakra',
        children: h.jsxRuntimeExports.jsx(af, {
          ...n,
          value: t,
          extensions: [cS({ jsx: !0 })],
          onChange: (i) => {
            r(i, 'react')
          }
        })
      })
    ]
  })
}
function aX() {
  const { setSelectedIndex: n } = Dg()
  return h.jsxRuntimeExports.jsxs(h.jsxRuntimeExports.Fragment, {
    children: [
      h.jsxRuntimeExports.jsx(jQ, {}),
      h.jsxRuntimeExports.jsxs('div', {
        className: 'slds-tabs_scoped__content-container',
        children: [
          h.jsxRuntimeExports.jsxs('div', {
            className: 'slds-grid slds-grid_align-spread slds-m-bottom_large',
            children: [
              h.jsxRuntimeExports.jsx('div', {
                className: 'slds-col',
                children: h.jsxRuntimeExports.jsx(lt, {
                  className: 'slds-button_outline-icon',
                  onClick: () => n(0),
                  assistiveText: { icon: 'back' },
                  iconCategory: 'utility',
                  iconName: 'back',
                  iconVariant: 'border',
                  variant: 'icon'
                })
              }),
              h.jsxRuntimeExports.jsx('div', {
                className: 'slds-col',
                children: h.jsxRuntimeExports.jsx(lt, {
                  type: 'button',
                  label: 'Download Files',
                  variant: 'outline-brand',
                  iconCategory: 'utility',
                  iconName: 'download',
                  iconPosition: 'left'
                })
              })
            ]
          }),
          h.jsxRuntimeExports.jsx('div', {
            className: 'slds-border_bottom slds-m-bottom_large',
            children: h.jsxRuntimeExports.jsx(oX, {})
          }),
          h.jsxRuntimeExports.jsxs('div', {
            className: 'slds-grid slds-grid_align-spread',
            children: [
              h.jsxRuntimeExports.jsx('div', { className: 'slds-col' }),
              h.jsxRuntimeExports.jsxs('div', {
                className: 'slds-col',
                children: [
                  h.jsxRuntimeExports.jsx(lt, {
                    assistiveText: { icon: 'Like' },
                    iconCategory: 'utility',
                    iconName: 'like',
                    iconVariant: 'border',
                    variant: 'icon'
                  }),
                  h.jsxRuntimeExports.jsx(lt, {
                    assistiveText: { icon: 'Dislike' },
                    iconCategory: 'utility',
                    iconName: 'dislike',
                    iconVariant: 'border',
                    variant: 'icon'
                  })
                ]
              })
            ]
          })
        ]
      })
    ]
  })
}
function mm(n) {
  return h.jsxRuntimeExports.jsxs('span', {
    children: [
      h.jsxRuntimeExports.jsx(Ie, {
        style: { marginRight: '4px' },
        assistiveText: { label: n.label },
        category: 'utility',
        name: n.icon,
        size: 'x-small'
      }),
      n.label
    ]
  })
}
function lX({ assetUrl: n }) {
  const { selectedIndex: e, setSelectedIndex: t } = Dg(),
    r = n + '/assets/icons'
  return h.jsxRuntimeExports.jsx(Ja, {
    iconPath: r,
    children: h.jsxRuntimeExports.jsxs(hs, {
      selectedIndex: e,
      onSelect: t,
      variant: 'scoped',
      children: [
        h.jsxRuntimeExports.jsx(Ur, {
          label: h.jsxRuntimeExports.jsx(mm, {
            label: 'Instructions',
            icon: 'sparkles'
          }),
          children: h.jsxRuntimeExports.jsx(mQ, {})
        }),
        h.jsxRuntimeExports.jsx(Ur, {
          label: h.jsxRuntimeExports.jsx(mm, {
            label: 'Created Components',
            icon: 'favorite'
          }),
          children: h.jsxRuntimeExports.jsx(aX, {})
        })
      ]
    })
  })
}
class cX {
  constructor(e) {
    Qn(this, 'subscribableEvents', ['sfcc:ready'])
    Qn(this, 'emittableEvents', ['sfcc:value'])
    Qn(this, 'render')
    Qn(this, 'getValue')
    Qn(this, 'setValue')
    Qn(this, 'listeners', {
      'sfcc:ready': () => {
        window.subscribe('sfcc:ready', (e) => {
          const { config: t, value: r } = e,
            { assetUrl: i } = t
          this.setValue(r), this.render({ assetUrl: i })
        })
      }
    })
    Qn(this, 'emitters', {
      'sfcc:value': () => {
        window.emit({ type: 'sfcc:value', payload: this.getValue() })
      }
    })
    ;(this.render = e.render),
      (this.getValue = e.getValue),
      (this.setValue = e.setValue)
  }
  subscribe(e) {
    this.listeners[e] || console.error('Invalid event', e), this.listeners[e]()
  }
  emit(e) {
    this.emitters[e] || console.error('Invalid event', e)
    const t = this.emitters[e]
    t()
  }
}
const uX = (n) => {
    const e = 'EinsteinAssistedComponentEditor',
      t = document.getElementById(e) ?? document.createElement('div')
    t.id || ((t.id = e), document.body.appendChild(t)),
      h.client.createRoot(t).render(
        h.jsxRuntimeExports.jsx(h.React.StrictMode, {
          children: h.jsxRuntimeExports.jsx(lX, { assetUrl: n.assetUrl })
        })
      )
  },
  ph = new cX({
    render: uX,
    getValue: () => {
      const { componentName: n, prompt: e } = zi.getState(),
        { html: t, react: r } = Oa.getState()
      return { componentName: n, prompt: e, code: { html: t, react: r } }
    },
    setValue: (n) => {
      n &&
        (zi.setState({ componentName: n.componentName, prompt: n.prompt }),
        Oa.setState({ html: n.code.html, react: n.code.react }))
    }
  })
ph.subscribe('sfcc:ready')
zi.subscribe(() => ph.emit('sfcc:value'))
Oa.subscribe(() => ph.emit('sfcc:value'))
